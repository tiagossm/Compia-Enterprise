===FILE: supabase/functions/api/action-plans-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";
import { addXP } from "./gamification-routes.ts";

const actionPlansRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/action-plans');

// Get all action items across all inspections with optional organization filter
actionPlansRoutes.get("/all", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const organizationId = c.req.query("organization_id");
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    let query = `
      SELECT ai.*, 

             i.title as inspection_title,
             i.location as inspection_location,
             i.company_name as inspection_company,
             i.created_by as inspection_created_by,
             coalesce(i.organization_id, ai.organization_id) as final_organization_id,
             u.name as created_by_name,
             u_assigned.name as assigned_to_name,
             o.name as organization_name
      FROM action_items ai
      LEFT JOIN inspections i ON ai.inspection_id = i.id
      LEFT JOIN users u ON ai.created_by = u.id
      LEFT JOIN users u_assigned ON ai.assigned_to = u_assigned.id
      LEFT JOIN organizations o ON coalesce(i.organization_id, ai.organization_id) = o.id
    `;

    const params: any[] = [];
    const whereConditions: string[] = [];

    // Type filter
    const type = c.req.query("type");
    if (type && type !== 'all') {
      whereConditions.push("ai.type = ?");
      params.push(type);
    }

    // Organization filter logic (using COALESCE to fallback to direct org_id)
    if (organizationId && organizationId !== 'all') {
      whereConditions.push("coalesce(i.organization_id, ai.organization_id) = ?");
      params.push(parseInt(organizationId));
    }

    // Role-based access control
    if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {
      // System admin sees all
    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN) {
      if (userProfile.managed_organization_id) {
        whereConditions.push(`(
          coalesce(i.organization_id, ai.organization_id) = ? OR 
          coalesce(i.organization_id, ai.organization_id) IN (
            SELECT id FROM organizations WHERE parent_organization_id = ?
          )
        )`);
        params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
      }
    } else {
      // Regular users: Created by me OR Assigned to me OR Org visible
      whereConditions.push(`(ai.created_by = ? OR ai.assigned_to = ? OR coalesce(i.organization_id, ai.organization_id) = ?)`);
      params.push(user.id, user.id, userProfile?.organization_id);
    }

    if (whereConditions.length > 0) {
      query += " WHERE " + whereConditions.join(" AND ");
    }

    query += " ORDER BY ai.created_at DESC";

    console.log('[ACTION_PLANS] Executing query:', query);
    console.log('[ACTION_PLANS] Params:', params);

    const actionItems = await env.DB.prepare(query).bind(...params).all();

    return c.json({
      action_items: actionItems.results || [],
      total: (actionItems.results || []).length
    });

  } catch (error: any) {
    console.error('Error fetching all action items:', error);
    return c.json({
      error: "Failed to fetch action items",
      details: error.message,
      stack: error.stack
    }, 500);
  }
});

// Get action items by inspection ID
actionPlansRoutes.get("/inspection/:inspectionId", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("inspectionId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Verify access to inspection
    const inspection = await env.DB.prepare(`
      SELECT i.*, u.name as created_by_name
      FROM inspections i
      LEFT JOIN users u ON i.created_by = u.id
      WHERE i.id = ?
    `).bind(inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "Inspection not found" }, 404);
    }

    // Check access permissions
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    const hasAccess = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
      userProfile?.role === 'sys_admin' ||
      inspection.created_by === user.id ||
      inspection.organization_id === userProfile?.organization_id ||
      (userProfile?.role === USER_ROLES.ORG_ADMIN &&
        (inspection.organization_id === userProfile.managed_organization_id ||
          await env.DB.prepare(`
                         SELECT 1 FROM organizations 
                         WHERE id = ? AND parent_organization_id = ?
                       `).bind(inspection.organization_id, userProfile.managed_organization_id).first()));

    if (!hasAccess) {
      return c.json({ error: "Access denied" }, 403);
    }

    // Get action items for this inspection
    const actionItems = await env.DB.prepare(`
      SELECT ai.*, ii.category as item_category, ii.item_description
      FROM action_items ai
      LEFT JOIN inspection_items ii ON ai.inspection_item_id = ii.id
      WHERE ai.inspection_id = ?
      ORDER BY ai.created_at DESC
    `).bind(inspectionId).all();

    return c.json({
      inspection,
      action_items: actionItems.results || []
    });

  } catch (error) {
    console.error('Error fetching inspection action items:', error);
    return c.json({ error: "Failed to fetch action items" }, 500);
  }
});

// Helper to create Google Calendar Event
async function createGoogleCalendarEvent(token: string, title: string, description: string, date: string): Promise<string | null> {
  try {
    const response = await fetch('https://www.googleapis.com/calendar/v3/calendars/primary/events', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        summary: title,
        description: description || 'Tarefa criada via Compia',
        start: { date: date }, // All-day event
        end: { date: date }
      })
    });

    if (!response.ok) {
      console.error('Failed to create Google Calendar event:', await response.text());
      return null;
    }

    const data = await response.json();
    return data.id;
  } catch (e) {
    console.error('Error creating Google Calendar event:', e);
    return null;
  }
}

// Create new action item
actionPlansRoutes.post("/", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const {
      title,
      type = 'manual_task',
      description,
      priority = 'media',
      status = 'pending',
      when_deadline,
      assignee_id,
      google_token // Token passed from frontend
    } = body;

    if (!title) {
      return c.json({ error: "Title is required" }, 400);
    }

    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    let organizationId = userProfile?.organization_id;
    if (userProfile?.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {
      organizationId = userProfile.managed_organization_id;
    }

    // Google Calendar Sync
    let google_event_id: string | null = null;
    if (google_token && when_deadline) {
      // Format date/time if needed. Assuming when_deadline is YYYY-MM-DD.
      // If type is inspection_order, maybe prefix title?
      const eventTitle = type === 'inspection_order' ? `[InspeÃ§Ã£o] ${title}` : title;
      google_event_id = await createGoogleCalendarEvent(google_token, eventTitle, description || '', when_deadline);
    }

    const result = await env.DB.prepare(`
        INSERT INTO action_items (
            title, 
            type, 
            description, 
            priority, 
            status, 
            when_deadline, 
            created_by, 
            organization_id, 
            assigned_to,
            source,
            google_event_id,
            created_at,
            updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'user', ?, NOW(), NOW()) 
        RETURNING *
    `).bind(
      title,
      type,
      description || null,
      priority,
      status,
      when_deadline || null,
      user.id,
      organizationId,
      assignee_id || null,
      google_event_id
    ).first();

    return c.json({ success: true, action_item: result }, 201);

  } catch (error) {
    console.error('Error creating action item:', error);
    return c.json({ error: "Failed to create action item" }, 500);
  }
});

// Update action item status
actionPlansRoutes.put("/:id/status", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const actionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { status } = body;

    if (!['pending', 'in_progress', 'completed'].includes(status)) {
      return c.json({ error: "Invalid status" }, 400);
    }

    // Get action item for permission check
    const actionItem = await env.DB.prepare(`
      SELECT ai.*, i.created_by as inspection_created_by, coalesce(i.organization_id, ai.organization_id) as final_organization_id
      FROM action_items ai
      LEFT JOIN inspections i ON ai.inspection_id = i.id
      WHERE ai.id = ?
    `).bind(actionId).first() as any;

    if (!actionItem) {
      return c.json({ error: "Action item not found" }, 404);
    }

    // Check permissions
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    const hasAccess = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
      userProfile?.role === 'sys_admin' ||
      actionItem.created_by === user.id ||
      actionItem.inspection_created_by === user.id ||
      actionItem.assigned_to === user.id ||
      actionItem.final_organization_id === userProfile?.organization_id ||
      (userProfile?.role === USER_ROLES.ORG_ADMIN &&
        (actionItem.final_organization_id === userProfile.managed_organization_id ||
          await env.DB.prepare(`
                         SELECT 1 FROM organizations 
                         WHERE id = ? AND parent_organization_id = ?
                       `).bind(actionItem.final_organization_id, userProfile.managed_organization_id).first()));

    if (!hasAccess) {
      return c.json({ error: "Access denied" }, 403);
    }

    // Update status
    await env.DB.prepare(`
      UPDATE action_items 
      SET status = ?, updated_at = NOW()
      WHERE id = ?
    `).bind(status, actionId).run();

    // Gamification: Award XP if completed
    if (status === 'completed') {
      try {
        // Basic logic: 20 XP for completion.
        // Future: Check deadlin for bonus.
        await addXP(user.id, 20, env.DB);
      } catch (xpError) {
        console.error("Error awarding XP:", xpError);
      }
    }

    return c.json({ message: "Status updated successfully" });

  } catch (error) {
    console.error('Error updating action item status:', error);
    return c.json({ error: "Failed to update status" }, 500);
  }
});

// Get action items statistics
actionPlansRoutes.get("/stats", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const organizationId = c.req.query("organization_id");
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    let query = `
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN ai.status = 'pending' THEN 1 ELSE 0 END) as pending,
        SUM(CASE WHEN ai.status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
        SUM(CASE WHEN ai.status = 'completed' THEN 1 ELSE 0 END) as completed,
        SUM(CASE WHEN ai.priority = 'alta' AND ai.status != 'completed' THEN 1 ELSE 0 END) as high_priority,
        SUM(CASE WHEN ai.when_deadline < date('now') AND ai.status != 'completed' THEN 1 ELSE 0 END) as overdue
      FROM action_items ai
      LEFT JOIN inspections i ON ai.inspection_id = i.id
    `;

    const params: any[] = [];
    const whereConditions: string[] = [];

    // Organization filter
    if (organizationId && organizationId !== 'all') {
      whereConditions.push("coalesce(i.organization_id, ai.organization_id) = ?");
      params.push(parseInt(organizationId));
    }

    // Role-based access control
    if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {
      // System admin sees all stats
    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN) {
      if (userProfile.managed_organization_id) {
        whereConditions.push(`(
          coalesce(i.organization_id, ai.organization_id) = ? OR 
          coalesce(i.organization_id, ai.organization_id) IN (
            SELECT id FROM organizations WHERE parent_organization_id = ?
          )
        )`);
        params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
      }
    } else {
      whereConditions.push(`(ai.created_by = ? OR ai.assigned_to = ? OR coalesce(i.organization_id, ai.organization_id) = ?)`);
      params.push(user.id, user.id, userProfile?.organization_id);
    }

    if (whereConditions.length > 0) {
      query += " WHERE " + whereConditions.join(" AND ");
    }

    const stats = await env.DB.prepare(query).bind(...params).first() as any;

    return c.json({
      stats: {
        total: stats?.total || 0,
        pending: stats?.pending || 0,
        in_progress: stats?.in_progress || 0,
        completed: stats?.completed || 0,
        high_priority: stats?.high_priority || 0,
        overdue: stats?.overdue || 0
      }
    });

  } catch (error) {
    console.error('Error fetching action items stats:', error);
    return c.json({ error: "Failed to fetch stats" }, 500);
  }
});

// Delete action item
actionPlansRoutes.delete("/:id", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const actionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get action item with inspection details for permission check
    const actionItem = await env.DB.prepare(`
      SELECT ai.*, i.created_by as inspection_created_by, coalesce(i.organization_id, ai.organization_id) as final_organization_id
      FROM action_items ai
      LEFT JOIN inspections i ON ai.inspection_id = i.id
      WHERE ai.id = ?
    `).bind(actionId).first() as any;

    if (!actionItem) {
      return c.json({ error: "Action item not found" }, 404);
    }

    // Check permissions
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    const hasAccess = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
      userProfile?.role === 'sys_admin' ||
      actionItem.created_by === user.id ||
      actionItem.inspection_created_by === user.id ||
      actionItem.final_organization_id === userProfile?.organization_id ||
      (userProfile?.role === USER_ROLES.ORG_ADMIN &&
        (actionItem.final_organization_id === userProfile.managed_organization_id ||
          await env.DB.prepare(`
                         SELECT 1 FROM organizations 
                         WHERE id = ? AND parent_organization_id = ?
                       `).bind(actionItem.final_organization_id, userProfile.managed_organization_id).first()));

    if (!hasAccess) {
      return c.json({ error: "Access denied" }, 403);
    }

    // Delete action item
    await env.DB.prepare("DELETE FROM action_items WHERE id = ?").bind(actionId).run();

    return c.json({
      success: true,
      message: "Action item deleted successfully"
    });

  } catch (error) {
    console.error('Error deleting action item:', error);
    return c.json({ error: "Failed to delete action item" }, 500);
  }
});

export default actionPlansRoutes;

===END_FILE===
===FILE: supabase/functions/api/admin-approval-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware as authMiddleware } from './tenant-auth-middleware.ts';
import { logActivity } from './audit-logger.ts';

/**
 * Rotas de administraÃ§Ã£o para AprovaÃ§Ã£o de UsuÃ¡rios
 * @security System Admin tem acesso total
 * @security Org Admin pode aprovar usuÃ¡rios da sua organizaÃ§Ã£o
 */
const adminApprovalRoutes = new Hono<{ Bindings: Env; Variables: { user: any; tenantContext: any } }>().basePath('/api/admin');

/**
 * Helper: Verificar se usuÃ¡rio Ã© SysAdmin
 */
function isSysAdmin(role: string): boolean {
    const sysAdminRoles = ['system_admin', 'sys_admin', 'admin'];
    return sysAdminRoles.includes(role?.toLowerCase() || '');
}

/**
 * Helper: Verificar se usuÃ¡rio Ã© OrgAdmin
 */
function isOrgAdmin(role: string): boolean {
    const orgAdminRoles = ['org_admin', 'admin_org', 'organization_admin'];
    return orgAdminRoles.includes(role?.toLowerCase() || '');
}

/**
 * Helper: Verificar se usuÃ¡rio pode aprovar (SysAdmin OU OrgAdmin)
 */
function canApproveUsers(role: string): boolean {
    return isSysAdmin(role) || isOrgAdmin(role);
}

/**
 * Listar usuÃ¡rios pendentes
 * GET /api/admin/pending-users
 */
adminApprovalRoutes.get("/pending-users", async (c) => {
    const env = c.env;
    const user = c.get("user");

    console.log("[ADMIN-APPROVAL] GET /pending-users - User:", user?.email, "Role:", user?.role);

    // Verificar autenticaÃ§Ã£o
    if (!user) {
        console.log("[ADMIN-APPROVAL] No user found in context");
        return c.json({ error: "unauthorized", message: "AutenticaÃ§Ã£o necessÃ¡ria" }, 401);
    }

    // Verificar se pode aprovar (SysAdmin OU OrgAdmin)
    if (!canApproveUsers(user.role)) {
        console.log("[ADMIN-APPROVAL] User cannot approve:", user.role);
        return c.json({ error: "forbidden", message: "Apenas administradores podem acessar" }, 403);
    }

    try {
        const pendingUsers = await env.DB.prepare(`
      SELECT id, email, name, role, organization_id, created_at 
      FROM users 
      WHERE approval_status = 'pending'
      ORDER BY created_at DESC
    `).all();

        return c.json({
            success: true,
            data: pendingUsers.results || []
        });
    } catch (error) {
        console.error('[ADMIN-APPROVAL] Erro ao listar pendentes:', error);
        return c.json({ error: "Erro ao buscar usuÃ¡rios pendentes" }, 500);
    }
});

/**
 * Aprovar usuÃ¡rio
 * POST /api/admin/users/:id/approve
 */
adminApprovalRoutes.post("/users/:id/approve", async (c) => {
    const env = c.env;
    const targetUserId = c.req.param("id");
    const user = c.get("user");

    console.log("[ADMIN-APPROVAL] POST /users/:id/approve");
    console.log("[ADMIN-APPROVAL] Target User ID:", targetUserId);
    console.log("[ADMIN-APPROVAL] Current User:", JSON.stringify(user));

    // Verificar autenticaÃ§Ã£o
    if (!user) {
        console.log("[ADMIN-APPROVAL] FALHA: Nenhum usuÃ¡rio no contexto");
        return c.json({ error: "unauthorized", message: "AutenticaÃ§Ã£o necessÃ¡ria" }, 401);
    }

    // SysAdmin e OrgAdmin podem aprovar
    if (!canApproveUsers(user.role)) {
        console.log("[ADMIN-APPROVAL] FALHA: UsuÃ¡rio nÃ£o pode aprovar. Role:", user.role);
        return c.json({ error: "forbidden", message: "Apenas administradores podem aprovar" }, 403);
    }

    console.log("[ADMIN-APPROVAL] SUCESSO: UsuÃ¡rio autorizado");

    try {
        const result = await env.DB.prepare(`
      UPDATE users 
      SET 
        approval_status = 'approved',
        approved_by = ?,
        approved_at = NOW(),
        updated_at = NOW()
      WHERE id = ?
    `).bind(user.id, targetUserId).run();

        if (result.meta.changes === 0) {
            return c.json({ error: "UsuÃ¡rio nÃ£o encontrado" }, 404);
        }

        // NOTIFICAÃ‡ÃƒO: Avisar usuÃ¡rio que foi aprovado
        try {
            await env.DB.prepare(`
                INSERT INTO notifications (user_id, title, message, type, link) 
                VALUES (?, 'Conta Aprovada!', 'Seu cadastro foi aprovado. Bem-vindo ao sistema!', 'success', '/dashboard')
            `).bind(targetUserId).run();
        } catch (notifError) {
            console.error("Falha ao notificar usuÃ¡rio aprovado:", notifError);
        }

        // TRIGGER EMAIL: Send approval email
        try {
            // First fetch the approved user's details to get email/name
            const targetUser = await env.DB.prepare("SELECT email, name FROM users WHERE id = ?").bind(targetUserId).first();

            const supabaseUrl = Deno.env.get('SUPABASE_URL');
            const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY');

            if (targetUser && supabaseUrl && supabaseAnonKey) {
                fetch(`${supabaseUrl}/functions/v1/email-worker`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${supabaseAnonKey}`
                    },
                    body: JSON.stringify({
                        to: targetUser.email,
                        type: 'approval',
                        data: {
                            name: targetUser.name
                        }
                    })
                }).catch(err => console.error("Failed to trigger approved email:", err));
            }

            // Log de Auditoria
            await logActivity(env, {
                userId: user.id,
                orgId: user.organization_id || null, // Quem aprovou
                actionType: 'USER_APPROVED',
                actionDescription: `Aprovou o usuÃ¡rio ${targetUser?.name || 'ID ' + targetUserId} (${targetUser?.email})`,
                targetType: 'USER',
                targetId: targetUserId,
                metadata: {
                    approved_user_email: targetUser?.email,
                    approved_user_name: targetUser?.name
                },
                req: c.req
            });

        } catch (emailErr) {
            console.error("Error triggering approved email:", emailErr);
        }

        console.log("[ADMIN-APPROVAL] UsuÃ¡rio aprovado com sucesso:", targetUserId);

        return c.json({
            success: true,
            message: "UsuÃ¡rio aprovado com sucesso"
        });

    } catch (error) {
        console.error('[ADMIN-APPROVAL] Erro ao aprovar usuÃ¡rio:', error);
        return c.json({ error: "Erro ao realizar aprovaÃ§Ã£o" }, 500);
    }
});

/**
 * Rejeitar usuÃ¡rio
 * POST /api/admin/users/:id/reject
 */
adminApprovalRoutes.post("/users/:id/reject", async (c) => {
    const env = c.env;
    const targetUserId = c.req.param("id");
    const user = c.get("user");
    const body = await c.req.json().catch(() => ({}));
    const reason = body.reason || null;

    console.log("[ADMIN-APPROVAL] POST /users/:id/reject");
    console.log("[ADMIN-APPROVAL] Target User ID:", targetUserId);
    console.log("[ADMIN-APPROVAL] Current User:", JSON.stringify(user));

    // Verificar autenticaÃ§Ã£o
    if (!user) {
        return c.json({ error: "unauthorized", message: "AutenticaÃ§Ã£o necessÃ¡ria" }, 401);
    }

    // SysAdmin e OrgAdmin podem rejeitar
    if (!canApproveUsers(user.role)) {
        return c.json({ error: "forbidden", message: "Apenas administradores podem rejeitar" }, 403);
    }

    try {
        const result = await env.DB.prepare(`
      UPDATE users 
      SET 
        approval_status = 'rejected',
        approved_by = ?, 
        rejection_reason = ?,
        updated_at = NOW()
      WHERE id = ?
    `).bind(user.id, reason, targetUserId).run();

        if (result.meta.changes === 0) {
            return c.json({ error: "UsuÃ¡rio nÃ£o encontrado" }, 404);
        }

        return c.json({
            success: true,
            message: "UsuÃ¡rio rejeitado com sucesso"
        });

    } catch (error) {
        console.error('[ADMIN-APPROVAL] Erro ao rejeitar usuÃ¡rio:', error);
        return c.json({ error: "Erro ao rejeitar usuÃ¡rio" }, 500);
    }
});

export default adminApprovalRoutes;
===END_FILE===
===FILE: supabase/functions/api/admin-debug-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware as authMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";

type Env = {
  DB: any;
};

const adminDebugRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();
const isProduction = Deno.env.get('ENVIRONMENT') === 'production';

// Admin bypass endpoint para verificar dados de produÃ§Ã£o (SYSTEM_ADMIN only)
adminDebugRoutes.get("/debug/data-check", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (isProduction) {
    return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
  }

  try {
    // Get user profile - MUST be SYSTEM_ADMIN
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile || userProfile.role !== USER_ROLES.SYSTEM_ADMIN) {
      return c.json({ error: "Only SYSTEM_ADMIN can access debug data" }, 403);
    }

    console.log(`[DEBUG-DATA] SYSTEM_ADMIN ${user.email} fazendo verificaÃ§Ã£o de dados`);

    // Verificar todos os dados sem filtros
    const [
      totalInspections,
      totalUsers,
      totalOrganizations,
      totalTemplates,
      recentInspections,
      userDetails,
      organizationDetails
    ] = await Promise.all([
      env.DB.prepare("SELECT COUNT(*) as count FROM inspections").first(),
      env.DB.prepare("SELECT COUNT(*) as count FROM users").first(),
      env.DB.prepare("SELECT COUNT(*) as count FROM organizations").first(),
      env.DB.prepare("SELECT COUNT(*) as count FROM checklist_templates").first(),
      env.DB.prepare("SELECT id, title, status, created_by, organization_id, created_at FROM inspections ORDER BY created_at DESC LIMIT 3").all(),
      env.DB.prepare("SELECT id, email, role, organization_id, is_active FROM users ORDER BY created_at DESC LIMIT 3").all(),
      env.DB.prepare("SELECT id, name, type, is_active FROM organizations ORDER BY created_at DESC LIMIT 3").all()
    ]);

    const debugData = {
      timestamp: new Date().toISOString(),
      checked_by: user.email,
      environment: "development",
      database_counts: {
        inspections: (totalInspections as any)?.count || 0,
        users: (totalUsers as any)?.count || 0,
        organizations: (totalOrganizations as any)?.count || 0,
        checklist_templates: (totalTemplates as any)?.count || 0
      },
      sample_data: {
        recent_inspections: recentInspections.results || [],
        users: userDetails.results || [],
        organizations: organizationDetails.results || []
      },
      sync_status: {
        has_production_data: (totalInspections as any)?.count > 0,
        has_users: (totalUsers as any)?.count > 0,
        has_organizations: (totalOrganizations as any)?.count > 0,
        has_templates: (totalTemplates as any)?.count > 0
      }
    };

    console.log(`[DEBUG-DATA] Dados encontrados:`, debugData.database_counts);

    return c.json(debugData);

  } catch (error) {
    console.error('[DEBUG-DATA] Erro na verificaÃ§Ã£o de dados:', error);
    return c.json({ error: "Failed to check debug data" }, 500);
  }
});

// Endpoint para forÃ§ar resincronizaÃ§Ã£o (SYSTEM_ADMIN only)
adminDebugRoutes.post("/debug/force-resync", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (isProduction) {
    return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
  }

  try {
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile || userProfile.role !== USER_ROLES.SYSTEM_ADMIN) {
      return c.json({ error: "Only SYSTEM_ADMIN can force resync" }, 403);
    }

    console.log(`[FORCE-RESYNC] SYSTEM_ADMIN ${user.email} forÃ§ando resincronizaÃ§Ã£o`);

    // Verificar se o usuÃ¡rio atual tem permissÃµes corretas
    if (userProfile.role !== USER_ROLES.SYSTEM_ADMIN) {
      // ForÃ§ar upgrade para SYSTEM_ADMIN se for o usuÃ¡rio criador do sistema
      if (user.email === 'eng.tiagosm@gmail.com') {
        await env.DB.prepare(`
          UPDATE users 
          SET role = ?, can_manage_users = ?, can_create_organizations = ?, updated_at = NOW()
          WHERE id = ?
        `).bind(USER_ROLES.SYSTEM_ADMIN, 1, 1, user.id).run();

        console.log(`[FORCE-RESYNC] UsuÃ¡rio ${user.email} promovido para SYSTEM_ADMIN`);
      }
    }

    // Verificar integridade dos dados
    const dataCheck = await env.DB.prepare(`
      SELECT 
        (SELECT COUNT(*) FROM inspections) as inspections_count,
        (SELECT COUNT(*) FROM users WHERE role = 'system_admin') as admin_count,
        (SELECT COUNT(*) FROM organizations) as org_count
    `).first() as any;

    const resyncStatus = {
      timestamp: new Date().toISOString(),
      performed_by: user.email,
      before_resync: dataCheck,
      actions_taken: [
        "VerificaÃ§Ã£o de permissÃµes do usuÃ¡rio",
        "ValidaÃ§Ã£o de integridade dos dados",
        "ConfirmaÃ§Ã£o de sincronizaÃ§Ã£o ativa"
      ],
      sync_confirmed: true
    };

    console.log(`[FORCE-RESYNC] Status da resincronizaÃ§Ã£o:`, resyncStatus);

    return c.json({
      message: "ResincronizaÃ§Ã£o forÃ§ada concluÃ­da com sucesso",
      status: resyncStatus
    });

  } catch (error) {
    console.error('[FORCE-RESYNC] Erro na resincronizaÃ§Ã£o forÃ§ada:', error);
    return c.json({ error: "Failed to force resync" }, 500);
  }
});

// Import all data endpoint (SYSTEM_ADMIN only)
adminDebugRoutes.post("/import-all-data", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (isProduction) {
    return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
  }

  try {
    // Get user profile - MUST be SYSTEM_ADMIN
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile || userProfile.role !== USER_ROLES.SYSTEM_ADMIN) {
      return c.json({ error: "Only SYSTEM_ADMIN can import data" }, 403);
    }

    const importData = await c.req.json();

    if (!importData.data || !importData.total_counts) {
      return c.json({ error: "Invalid import data format" }, 400);
    }

    console.log(`[IMPORT-ALL] SYSTEM_ADMIN ${user.email} importing production data`);
    console.log(`[IMPORT-ALL] Counts to import:`, importData.total_counts);

    // Clear existing development data (except current user)
    console.log(`[IMPORT-ALL] Clearing existing development data...`);
    await env.DB.batch([
      env.DB.prepare("DELETE FROM inspection_media"),
      env.DB.prepare("DELETE FROM action_items"),
      env.DB.prepare("DELETE FROM inspection_items"),
      env.DB.prepare("DELETE FROM inspections"),
      env.DB.prepare("DELETE FROM checklist_fields"),
      env.DB.prepare("DELETE FROM checklist_templates WHERE created_by_user_id != ?").bind(user.id),
      env.DB.prepare("DELETE FROM organizations WHERE id != (SELECT organization_id FROM users WHERE id = ?)").bind(user.id),
      env.DB.prepare("DELETE FROM users WHERE id != ?").bind(user.id)
    ]);

    const importedCounts = {
      organizations: 0,
      users: 0,
      checklist_templates: 0,
      checklist_fields: 0,
      inspections: 0,
      inspection_items: 0,
      action_items: 0,
      inspection_media: 0
    };

    // Import organizations
    console.log(`[IMPORT-ALL] Importing ${importData.data.organizations?.length || 0} organizations...`);
    if (importData.data.organizations) {
      for (const org of importData.data.organizations) {
        try {
          await env.DB.prepare(`
            INSERT INTO organizations (
              id, name, type, description, logo_url, contact_email, contact_phone, 
              address, is_active, parent_organization_id, organization_level, 
              subscription_status, subscription_plan, max_users, max_subsidiaries,
              cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao,
              natureza_juridica, data_abertura, capital_social, porte_empresa,
              situacao_cadastral, numero_funcionarios, setor_industria, subsetor_industria,
              certificacoes_seguranca, data_ultima_auditoria, nivel_risco,
              contato_seguranca_nome, contato_seguranca_email, contato_seguranca_telefone,
              historico_incidentes, observacoes_compliance, website, faturamento_anual,
              created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).bind(
            org.id, org.name, org.type || 'company', org.description, org.logo_url, org.contact_email, org.contact_phone,
            org.address, org.is_active !== false ? 1 : 0, org.parent_organization_id, org.organization_level || 'company',
            org.subscription_status || 'active', org.subscription_plan || 'basic', org.max_users || 50, org.max_subsidiaries || 0,
            org.cnpj, org.razao_social, org.nome_fantasia, org.cnae_principal, org.cnae_descricao,
            org.natureza_juridica, org.data_abertura, org.capital_social, org.porte_empresa,
            org.situacao_cadastral, org.numero_funcionarios, org.setor_industria, org.subsetor_industria,
            org.certificacoes_seguranca, org.data_ultima_auditoria, org.nivel_risco || 'medio',
            org.contato_seguranca_nome, org.contato_seguranca_email, org.contato_seguranca_telefone,
            org.historico_incidentes, org.observacoes_compliance, org.website, org.faturamento_anual,
            org.created_at, org.updated_at
          ).run();
          importedCounts.organizations++;
        } catch (error) {
          console.error(`[IMPORT-ALL] Error importing organization ${org.id}:`, error);
        }
      }
    }

    // Import users (except current system admin)
    console.log(`[IMPORT-ALL] Importing ${importData.data.users?.length || 0} users...`);
    if (importData.data.users) {
      for (const userData of importData.data.users) {
        if (userData.id === user.id) continue; // Skip current user

        try {
          await env.DB.prepare(`
            INSERT INTO users (
              id, email, name, role, organization_id, phone, avatar_url, is_active,
              last_login_at, can_manage_users, can_create_organizations, managed_organization_id,
              invitation_token, invited_by, invitation_expires_at, password_hash,
              email_verified_at, profile_completed, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).bind(
            userData.id, userData.email, userData.name, userData.role, userData.organization_id,
            userData.phone, userData.avatar_url, userData.is_active !== false ? 1 : 0,
            userData.last_login_at, userData.can_manage_users || 0, userData.can_create_organizations || 0,
            userData.managed_organization_id, userData.invitation_token, userData.invited_by,
            userData.invitation_expires_at, userData.password_hash, userData.email_verified_at,
            userData.profile_completed || 0, userData.created_at, userData.updated_at
          ).run();
          importedCounts.users++;
        } catch (error) {
          console.error(`[IMPORT-ALL] Error importing user ${userData.id}:`, error);
        }
      }
    }

    // Import checklist templates
    console.log(`[IMPORT-ALL] Importing ${importData.data.checklist_templates?.length || 0} templates...`);
    if (importData.data.checklist_templates) {
      for (const template of importData.data.checklist_templates) {
        try {
          await env.DB.prepare(`
            INSERT INTO checklist_templates (
              id, name, description, category, created_by, is_public, created_by_user_id,
              organization_id, parent_category_id, category_path, is_category_folder,
              folder_color, folder_icon, display_order, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).bind(
            template.id, template.name, template.description, template.category, template.created_by,
            template.is_public || 0, template.created_by_user_id, template.organization_id,
            template.parent_category_id, template.category_path, template.is_category_folder || 0,
            template.folder_color || '#3B82F6', template.folder_icon || 'folder', template.display_order || 0,
            template.created_at, template.updated_at
          ).run();
          importedCounts.checklist_templates++;
        } catch (error) {
          console.error(`[IMPORT-ALL] Error importing template ${template.id}:`, error);
        }
      }
    }

    // Import checklist fields
    console.log(`[IMPORT-ALL] Importing ${importData.data.checklist_fields?.length || 0} fields...`);
    if (importData.data.checklist_fields) {
      for (const field of importData.data.checklist_fields) {
        try {
          await env.DB.prepare(`
            INSERT INTO checklist_fields (
              id, template_id, field_name, field_type, is_required, options, order_index,
              created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).bind(
            field.id, field.template_id, field.field_name, field.field_type,
            field.is_required || 0, field.options, field.order_index || 0,
            field.created_at, field.updated_at
          ).run();
          importedCounts.checklist_fields++;
        } catch (error) {
          console.error(`[IMPORT-ALL] Error importing field ${field.id}:`, error);
        }
      }
    }

    // Import inspections
    console.log(`[IMPORT-ALL] Importing ${importData.data.inspections?.length || 0} inspections...`);
    if (importData.data.inspections) {
      for (const inspection of importData.data.inspections) {
        try {
          await env.DB.prepare(`
            INSERT INTO inspections (
              id, title, description, location, inspector_name, inspector_email, status,
              priority, scheduled_date, completed_date, company_name, cep, address,
              latitude, longitude, action_plan, action_plan_type, inspector_signature,
              responsible_signature, created_by, organization_id, ai_assistant_id,
              responsible_name, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).bind(
            inspection.id, inspection.title, inspection.description, inspection.location,
            inspection.inspector_name, inspection.inspector_email, inspection.status,
            inspection.priority, inspection.scheduled_date, inspection.completed_date,
            inspection.company_name, inspection.cep, inspection.address, inspection.latitude,
            inspection.longitude, inspection.action_plan, inspection.action_plan_type,
            inspection.inspector_signature, inspection.responsible_signature, inspection.created_by,
            inspection.organization_id, inspection.ai_assistant_id, inspection.responsible_name,
            inspection.created_at, inspection.updated_at
          ).run();
          importedCounts.inspections++;
        } catch (error) {
          console.error(`[IMPORT-ALL] Error importing inspection ${inspection.id}:`, error);
        }
      }
    }

    // Import inspection items
    console.log(`[IMPORT-ALL] Importing ${importData.data.inspection_items?.length || 0} inspection items...`);
    if (importData.data.inspection_items) {
      for (const item of importData.data.inspection_items) {
        try {
          await env.DB.prepare(`
            INSERT INTO inspection_items (
              id, inspection_id, category, item_description, is_compliant, observations,
              photo_url, template_id, field_responses, ai_action_plan, ai_pre_analysis,
              created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).bind(
            item.id, item.inspection_id, item.category, item.item_description,
            item.is_compliant, item.observations, item.photo_url, item.template_id,
            item.field_responses, item.ai_action_plan, item.ai_pre_analysis,
            item.created_at, item.updated_at
          ).run();
          importedCounts.inspection_items++;
        } catch (error) {
          console.error(`[IMPORT-ALL] Error importing inspection item ${item.id}:`, error);
        }
      }
    }

    // Import action items
    console.log(`[IMPORT-ALL] Importing ${importData.data.action_items?.length || 0} action items...`);
    if (importData.data.action_items) {
      for (const action of importData.data.action_items) {
        try {
          await env.DB.prepare(`
            INSERT INTO action_items (
              id, inspection_id, inspection_item_id, title, what_description, where_location,
              why_reason, how_method, who_responsible, when_deadline, how_much_cost,
              status, priority, is_ai_generated, assigned_to, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).bind(
            action.id, action.inspection_id, action.inspection_item_id, action.title,
            action.what_description, action.where_location, action.why_reason, action.how_method,
            action.who_responsible, action.when_deadline, action.how_much_cost, action.status,
            action.priority, action.is_ai_generated || 0, action.assigned_to,
            action.created_at, action.updated_at
          ).run();
          importedCounts.action_items++;
        } catch (error) {
          console.error(`[IMPORT-ALL] Error importing action item ${action.id}:`, error);
        }
      }
    }

    // Import inspection media
    console.log(`[IMPORT-ALL] Importing ${importData.data.inspection_media?.length || 0} media files...`);
    if (importData.data.inspection_media) {
      for (const media of importData.data.inspection_media) {
        try {
          await env.DB.prepare(`
            INSERT INTO inspection_media (
              id, inspection_id, inspection_item_id, media_type, file_name, file_url,
              file_size, mime_type, description, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).bind(
            media.id, media.inspection_id, media.inspection_item_id, media.media_type,
            media.file_name, media.file_url, media.file_size, media.mime_type,
            media.description, media.created_at, media.updated_at
          ).run();
          importedCounts.inspection_media++;
        } catch (error) {
          console.error(`[IMPORT-ALL] Error importing media ${media.id}:`, error);
        }
      }
    }

    console.log(`[IMPORT-ALL] Import completed:`, importedCounts);

    return c.json({
      message: "Production data imported successfully",
      imported_counts: importedCounts,
      timestamp: new Date().toISOString(),
      imported_by: user.email
    });

  } catch (error) {
    console.error('[IMPORT-ALL] Error importing data:', error);
    return c.json({
      error: "Failed to import data",
      details: error instanceof Error ? error.message : String(error)
    }, 500);
  }
});

export default adminDebugRoutes;

===END_FILE===
===FILE: supabase/functions/api/ai-assistant-routes.ts===
import { Hono } from 'hono';
import { tenantAuthMiddleware } from './tenant-auth-middleware.ts';
import { incrementAiUsage } from './ai-usage-tracker.ts';

const aiAssistant = new Hono<{ Bindings: Env; Variables: { user: any } }>()
    .basePath('/api/ai-assistant');

// System context for the AI assistant
const SYSTEM_CONTEXT = `VocÃª Ã© o COMPIA AI, o assistente inteligente do sistema COMPIA - uma plataforma de gestÃ£o de inspeÃ§Ãµes de seguranÃ§a do trabalho.

SUAS PRINCIPAIS FUNÃ‡Ã•ES:
1. Converter dados de texto em formato CSV para importaÃ§Ã£o de checklists
2. Responder dÃºvidas sobre como usar o sistema COMPIA
3. Ajudar com anÃ¡lise de conformidade e boas prÃ¡ticas

SOBRE O SISTEMA COMPIA:
- Sistema de gestÃ£o de inspeÃ§Ãµes de seguranÃ§a do trabalho
- Permite criar inspeÃ§Ãµes com checklists personalizados
- Suporta anÃ¡lise de conformidade (Conforme, NÃ£o Conforme, N/A)
- Integra IA para anÃ¡lise de fotos e Ã¡udios
- Gera relatÃ³rios em PDF
- Suporta mÃºltiplas organizaÃ§Ãµes e usuÃ¡rios

FORMATO CSV PARA CHECKLISTS (MUITO IMPORTANTE):
A primeira linha DEVE ser o cabeÃ§alho: campo,tipo,obrigatorio,opcoes
Exemplo completo:
\`\`\`csv
campo,tipo,obrigatorio,opcoes
Nome do FuncionÃ¡rio,text,true,
Data da InspeÃ§Ã£o,date,true,
EPIs Adequados,boolean,true,
CondiÃ§Ã£o do Extintor,select,true,Bom|Regular|Ruim
NÃ­vel de Risco,rating,false,
\`\`\`

TIPOS DE CAMPO DISPONÃVEIS:
- text: Texto Curto (nome, identificador)
- textarea: Texto Longo (observaÃ§Ãµes detalhadas)
- boolean: Conforme/NÃ£o Conforme (Sim ou NÃ£o)
- number: NÃºmero
- date: Data
- time: Hora
- select: Lista Suspensa (requer opÃ§Ãµes separadas por |)
- radio: Escolha Ãšnica (requer opÃ§Ãµes separadas por |)
- multiselect: MÃºltipla Escolha (requer opÃ§Ãµes separadas por |)
- checkbox: Caixa de SeleÃ§Ã£o
- rating: AvaliaÃ§Ã£o (1-5)
- file: Upload de Arquivo

REGRAS DE FORMATO:
1. Colunas: campo,tipo,obrigatorio,opcoes (exatamente nesta ordem)
2. ObrigatÃ³rio: use "true" ou "false" (sem aspas no CSV)
3. OpÃ§Ãµes: apenas para select, radio ou multiselect - separe com pipe (|). Ex: "Bom|Regular|Ruim"
4. Campos sem opÃ§Ãµes: deixe a coluna opcoes vazia

COMO IMPORTAR CHECKLIST:
1. VÃ¡ para Checklists > Templates
2. Clique no template desejado
3. Clique em "Importar CSV"
4. Cole ou carregue o arquivo CSV
5. Confirme a importaÃ§Ã£o

ANÃLISE DE CONFORMIDADE:
- Boolean: Sim = Conforme, NÃ£o = NÃ£o Conforme (automÃ¡tico)
- Rating: â‰¥4 = Conforme (automÃ¡tico)
- Text/Arquivo: Manual (inspetor avalia)
- Date/Time: NÃ£o se aplica

Sempre responda em portuguÃªs do Brasil de forma clara e objetiva.
Se o usuÃ¡rio pedir para converter dados, SEMPRE gere o CSV completo no formato correto com o cabeÃ§alho "campo,tipo,obrigatorio,opcoes".
`;

aiAssistant.post('/chat', tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get('user');

    if (!user) {
        return c.json({ error: 'UsuÃ¡rio nÃ£o autenticado' }, 401);
    }

    try {
        const { message, history = [] } = await c.req.json();

        if (!message || typeof message !== 'string') {
            return c.json({ error: 'Mensagem invÃ¡lida' }, 400);
        }

        const openaiApiKey = env.OPENAI_API_KEY || Deno.env.get('OPENAI_API_KEY');
        if (!openaiApiKey) {
            return c.json({ error: 'OpenAI API key nÃ£o configurada' }, 500);
        }

        // Build messages array
        const messages = [
            { role: 'system', content: SYSTEM_CONTEXT },
            ...history.slice(-8).map((m: any) => ({
                role: m.role,
                content: m.content
            })),
            { role: 'user', content: message }
        ];

        // Call OpenAI
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${openaiApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'gpt-4o-mini',
                messages,
                max_tokens: 1500,
                temperature: 0.7,
            }),
        });

        if (!response.ok) {
            const errorData = await response.json();
            console.error('OpenAI error:', errorData);
            return c.json({ error: 'Erro ao processar mensagem' }, 500);
        }

        const data = await response.json();
        const reply = data.choices?.[0]?.message?.content || 'Desculpe, nÃ£o consegui processar sua solicitaÃ§Ã£o.';

        // Generate contextual suggestions based on the message
        const suggestions = generateSuggestions(message, reply);

        // Track usage
        try {
            const userId = user.id || (user as any).sub;
            await incrementAiUsage(env.DB, userId, 'ai-assistant-chat', 'gpt-4o-mini');
        } catch (err) {
            console.error('[AI-ASSISTANT] Failed to track usage:', err);
        }

        return c.json({
            reply,
            suggestions,
        });
    } catch (error) {
        console.error('AI Assistant error:', error);
        return c.json({ error: 'Erro interno do servidor' }, 500);
    }
});

function generateSuggestions(userMessage: string, aiReply: string): string[] {
    const suggestions: string[] = [];
    const lowerMessage = userMessage.toLowerCase();
    const lowerReply = aiReply.toLowerCase();

    // CSV-related suggestions
    if (lowerReply.includes('csv') || lowerReply.includes('field_name')) {
        suggestions.push('Como importo esse CSV?');
        suggestions.push('Adicionar mais campos');
    }

    // Inspection-related suggestions
    if (lowerMessage.includes('inspeÃ§Ã£o') || lowerMessage.includes('inspecao')) {
        suggestions.push('Como adicionar fotos?');
        suggestions.push('O que Ã© anÃ¡lise de conformidade?');
    }

    // Checklist-related suggestions
    if (lowerMessage.includes('checklist') || lowerMessage.includes('template')) {
        suggestions.push('Tipos de campo disponÃ­veis');
        suggestions.push('Como duplicar um template?');
    }

    // Conformidade suggestions
    if (lowerMessage.includes('conformidade') || lowerMessage.includes('conforme')) {
        suggestions.push('Como funciona o cÃ¡lculo automÃ¡tico?');
        suggestions.push('Posso desativar a conformidade?');
    }

    // Limit to 3 suggestions
    return suggestions.slice(0, 3);
}

export default aiAssistant;
===END_FILE===
===FILE: supabase/functions/api/ai-assistants-routes.ts===
import { Hono } from 'hono';
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";


type Env = {
  DB: any;
  OPENAI_API_KEY?: string;
};

type Variables = {
  user: any;
};

const aiAssistantsRoutes = new Hono<{ Bindings: Env; Variables: Variables }>().basePath('/api/ai-assistants');

// Get all AI assistants
// Get all AI assistants
aiAssistantsRoutes.get('/', async (c) => {
  try {
    const env = c.env;

    // Check DB availability
    if (!env.DB) {
      console.error('[AI-ASSISTANTS] DB connection not initialized');
      return c.json({
        success: false,
        error: 'Database connection error',
        assistants: [],
        total_count: 0
      }, 500);
    }

    const assistants = await env.DB.prepare(`
      SELECT * FROM ai_assistants 
      WHERE is_active = TRUE 
      ORDER BY created_at DESC
    `).all();

    return c.json({
      success: true,
      assistants: assistants.results || [],
      total_count: (assistants.results || []).length
    });
  } catch (error) {
    console.error('[AI-ASSISTANTS] Error fetching assistants:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    const errorStack = error instanceof Error ? error.stack : '';

    return c.json({
      success: false,
      error: 'Erro ao buscar assistentes de IA',
      details: errorMessage,
      stack: errorStack,
      assistants: [],
      total_count: 0
    }, 500);
  }
});

// Get single AI assistant
aiAssistantsRoutes.get('/:id', async (c) => {
  const env = c.env;
  const assistantId = parseInt(c.req.param('id'));

  try {
    const assistant = await env.DB.prepare(`
      SELECT * FROM ai_assistants 
      WHERE id = ? AND is_active = true
    `).bind(assistantId).first();

    if (!assistant) {
      return c.json({
        success: false,
        error: 'Assistente nÃ£o encontrado'
      }, 404);
    }

    return c.json({
      success: true,
      assistant
    });
  } catch (error) {
    console.error('Error fetching AI assistant:', error);
    return c.json({
      success: false,
      error: 'Erro ao buscar assistente de IA'
    }, 500);
  }
});

// Create AI assistant (admin only)
aiAssistantsRoutes.post('/', tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get('user');

  if (!user) {
    return c.json({ error: 'User not found' }, 401);
  }

  try {
    const body = await c.req.json();
    const { name, description, specialization, instructions } = body;

    if (!name || !specialization || !instructions) {
      return c.json({
        success: false,
        error: 'Nome, especializaÃ§Ã£o e instruÃ§Ãµes sÃ£o obrigatÃ³rios'
      }, 400);
    }

    const result = await env.DB.prepare(`
      INSERT INTO ai_assistants (
        name, description, specialization, instructions, is_active,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, NOW(), NOW())
    `).bind(
      name,
      description || null,
      specialization,
      instructions,
      true
    ).run();

    return c.json({
      success: true,
      id: result.meta.last_row_id,
      message: 'Assistente de IA criado com sucesso'
    });
  } catch (error) {
    console.error('Error creating AI assistant:', error);
    return c.json({
      success: false,
      error: 'Erro ao criar assistente de IA'
    }, 500);
  }
});

// Update AI assistant (admin only)
aiAssistantsRoutes.put('/:id', tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get('user');
  const assistantId = parseInt(c.req.param('id'));

  if (!user) {
    return c.json({ error: 'User not found' }, 401);
  }

  try {
    const body = await c.req.json();

    const updateFields = [];
    const updateValues = [];

    const allowedFields = ['name', 'description', 'specialization', 'instructions', 'is_active'];

    for (const field of allowedFields) {
      if (body[field] !== undefined) {
        updateFields.push(`${field} = ?`);
        updateValues.push(body[field]);
      }
    }

    if (updateFields.length === 0) {
      return c.json({
        success: false,
        error: 'Nenhum campo para atualizar'
      }, 400);
    }

    updateFields.push('updated_at = datetime(\'now\')');

    await env.DB.prepare(`
      UPDATE ai_assistants 
      SET ${updateFields.join(', ')}
      WHERE id = ?
    `).bind(...updateValues, assistantId).run();

    return c.json({
      success: true,
      message: 'Assistente de IA atualizado com sucesso'
    });
  } catch (error) {
    console.error('Error updating AI assistant:', error);
    return c.json({
      success: false,
      error: 'Erro ao atualizar assistente de IA'
    }, 500);
  }
});

// Seed AI assistants - popula assistentes especialistas
aiAssistantsRoutes.post('/seed', async (c) => {
  const env = c.env;

  try {
    // Verificar se jÃ¡ existem assistentes
    const existing = await env.DB.prepare("SELECT COUNT(*) as count FROM ai_assistants").first() as any;

    if (existing?.count > 0) {
      // Deletar existentes e recriar
      await env.DB.prepare("DELETE FROM ai_assistants").run();
    }

    const aiAssistants = [
      {
        name: 'Especialista NR-35 Altura',
        description: 'Especialista em trabalho em altura, anÃ¡lise de riscos de queda e conformidade com NR-35',
        specialization: 'Trabalho em Altura - NR-35',
        instructions: 'VocÃª Ã© um especialista em seguranÃ§a para trabalho em altura. Analise evidÃªncias focando em: sistemas de ancoragem, EPIs de altura (cinturÃ£o, trava-quedas), condiÃ§Ãµes de acesso, sinalizaÃ§Ã£o de Ã¡reas elevadas, treinamento dos trabalhadores.'
      },
      {
        name: 'Especialista NR-10 Eletricidade',
        description: 'Especialista em instalaÃ§Ãµes elÃ©tricas, anÃ¡lise de riscos elÃ©tricos e conformidade com NR-10',
        specialization: 'SeguranÃ§a ElÃ©trica - NR-10',
        instructions: 'VocÃª Ã© um especialista em seguranÃ§a elÃ©trica. Analise evidÃªncias focando em: painÃ©is elÃ©tricos, aterramento, bloqueio/etiquetagem, EPIs isolantes, sinalizaÃ§Ã£o de risco elÃ©trico, condiÃ§Ãµes de instalaÃ§Ãµes.'
      },
      {
        name: 'Especialista NR-12 MÃ¡quinas',
        description: 'Especialista em seguranÃ§a de mÃ¡quinas e equipamentos conforme NR-12',
        specialization: 'MÃ¡quinas e Equipamentos - NR-12',
        instructions: 'VocÃª Ã© um especialista em seguranÃ§a de mÃ¡quinas. Analise evidÃªncias focando em: proteÃ§Ãµes fÃ­sicas, sistemas de parada de emergÃªncia, sinalizaÃ§Ã£o de pontos de risco, condiÃ§Ãµes de manutenÃ§Ã£o, procedimentos operacionais.'
      },
      {
        name: 'Especialista EPIs',
        description: 'Especialista em Equipamentos de ProteÃ§Ã£o Individual e conformidade com NR-6',
        specialization: 'EPIs - NR-6',
        instructions: 'VocÃª Ã© um especialista em EPIs. Analise evidÃªncias focando em: uso correto de EPIs, condiÃ§Ã£o de conservaÃ§Ã£o, adequaÃ§Ã£o ao risco, CA vÃ¡lido, armazenamento, treinamento de uso.'
      },
      {
        name: 'Especialista Ergonomia',
        description: 'Especialista em ergonomia e anÃ¡lise de postos de trabalho conforme NR-17',
        specialization: 'Ergonomia - NR-17',
        instructions: 'VocÃª Ã© um especialista em ergonomia. Analise evidÃªncias focando em: posturas de trabalho, mobiliÃ¡rio, iluminaÃ§Ã£o, organizaÃ§Ã£o do posto de trabalho, movimentos repetitivos, levantamento de cargas.'
      },
      {
        name: 'Especialista IncÃªndio',
        description: 'Especialista em prevenÃ§Ã£o e combate a incÃªndio conforme NR-23',
        specialization: 'PrevenÃ§Ã£o de IncÃªndio - NR-23',
        instructions: 'VocÃª Ã© um especialista em seguranÃ§a contra incÃªndio. Analise evidÃªncias focando em: extintores, sinalizaÃ§Ã£o de emergÃªncia, rotas de fuga, hidrantes, brigada de incÃªndio, materiais inflamÃ¡veis.'
      },
      {
        name: 'Especialista Riscos Psicossociais',
        description: 'Especialista em identificaÃ§Ã£o de fatores de risco psicossocial no ambiente de trabalho e geraÃ§Ã£o de planos de aÃ§Ã£o preventivos',
        specialization: 'Riscos Psicossociais Ocupacionais',
        instructions: `VocÃª Ã© um especialista em SeguranÃ§a e SaÃºde do Trabalho focado em RISCOS PSICOSSOCIAIS OCUPACIONAIS.

SEU PAPEL: Identificar fatores de risco psicossocial no AMBIENTE DE TRABALHO e gerar AÃ‡Ã•ES PREVENTIVAS/CORRETIVAS. NÃƒO faÃ§a diagnÃ³sticos clÃ­nicos.

FATORES DE RISCO A ANALISAR:
1. ORGANIZAÃ‡ÃƒO: Sobrecarga, ritmo excessivo, metas inatingÃ­veis
2. RELAÃ‡Ã•ES: Conflitos, assÃ©dio moral, falta de suporte
3. CONTEÃšDO: Monotonia, falta de autonomia, baixo reconhecimento
4. AMBIENTE: RuÃ­do, temperatura, iluminaÃ§Ã£o
5. TRABALHO-VIDA: Dificuldade de conciliaÃ§Ã£o

ANÃLISE DE ÃUDIO: Tom de voz, hesitaÃ§Ãµes, palavras-chave de estresse.

GERE AÃ‡Ã•ES 5W2H: ReorganizaÃ§Ã£o de processos, treinamentos, canais de escuta.`
      }
    ];

    for (const assistant of aiAssistants) {
      await env.DB.prepare(`
        INSERT INTO ai_assistants (name, description, specialization, instructions, is_active, created_at, updated_at)
        VALUES (?, ?, ?, ?, true, NOW(), NOW())
      `).bind(assistant.name, assistant.description, assistant.specialization, assistant.instructions).run();
    }

    return c.json({
      success: true,
      message: `${aiAssistants.length} assistentes de IA criados com sucesso`,
      count: aiAssistants.length
    });
  } catch (error) {
    console.error('Error seeding AI assistants:', error);
    return c.json({
      success: false,
      error: 'Erro ao popular assistentes de IA'
    }, 500);
  }
});

export default aiAssistantsRoutes;


===END_FILE===
===FILE: supabase/functions/api/ai-prompts.ts===
/**
 * AI Prompts Collection
 * Centralizes system instructions for different AI agents (personas).
 */

/**
 * Prompt for Pre-Analysis (Auditor Persona)
 */
export const getPreAnalysisPrompt = (
    fieldName: string,
    status: string,
    location: string,
    mediaContext: string,
    userPrompt?: string
) => `Auditor de SeguranÃ§a (Multimodal).
CONTEXTO:
- Item: ${fieldName}
- Status: ${status}
- Local: ${location}
${mediaContext}
${userPrompt ? `Pedido: ${userPrompt}` : ''}

INSTRUÃ‡ÃƒO: Analise todas as mÃ­dias (Ãudio, Imagem, PDF) e forneÃ§a APENAS a conclusÃ£o tÃ©cnica consolidada.
- NÃƒO use prefixos como "SÃ­ntese:", "Ãudio:", "Visual:", "ConclusÃ£o:".
- Integre as evidÃªncias visualmente e auditivamente no texto de forma fluida (ex: "A imagem confirma X, e o Ã¡udio relata Y").
- Seja direto, tÃ©cnico e aponte divergÃªncias na conformidade se houver.
- Responda em texto corrido (1 ou 2 parÃ¡grafos).`;

/**
 * Prompt for Action Plan Generation (Engineer Persona)
 */
export const getActionPlanPrompt = (
    companyName: string,
    location: string,
    inspectionTitle: string,
    fieldName: string,
    responseValue: string,
    comment: string,
    complianceStatus: string,
    preAnalysis: string,
    riskLevel: string
) => `Atue como um Engenheiro de SeguranÃ§a do Trabalho SÃªnior.
Analise o contexto abaixo e GERE UM PLANO DE AÃ‡ÃƒO 5W2H TÃ‰CNICO E DETALHADO.

CONTEXTO DA INSPEÃ‡ÃƒO:
- Empresa: ${companyName}
- Local/Setor: ${location}
- Item Inspecionado: ${inspectionTitle} > ${fieldName}
- Resposta do Inspetor: ${responseValue}
- ComentÃ¡rio/ObservaÃ§Ã£o do Inspetor: ${comment}
- Status da Conformidade: ${complianceStatus}
- AnÃ¡lise PrÃ©via (EvidÃªncias): ${preAnalysis}
- NÃ­vel de Risco Identificado: ${riskLevel}

DIRETRIZES PARA GERAÃ‡ÃƒO:
1. Se o status for "NÃƒO CONFORME", vocÃª **DEVE** gerar um plano de aÃ§Ã£o (\`requires_action: true\`).
2. Se houver riscos graves descritos na anÃ¡lise prÃ©via, gere um plano de aÃ§Ã£o.
3. O plano deve ser prÃ¡tico, tÃ©cnico e focado na resoluÃ§Ã£o da nÃ£o conformidade.
4. "how_much" (Custo) deve ser uma estimativa realista ou "A cotar".

Responda APENAS em JSON no seguinte formato:
{
  "requires_action": true/false,
  "what": "AÃ§Ã£o corretiva detalhada (O que fazer)",
  "why": "Motivo tÃ©cnico/Norma Regulamentadora (Por que fazer)",
  "where": "Local especÃ­fico da intervenÃ§Ã£o",
  "when": "Prazo sugerido (Imediato / X dias)",
  "who": "Cargo responsÃ¡vel (Ex: ManutenÃ§Ã£o, SESMT)",
  "how": "Procedimento da correÃ§Ã£o",
  "how_much": "Estimativa de custo/recurso",
  "priority": "baixa/media/alta/critica",
  "justification": "Breve justificativa tÃ©cnica"
}`;

/**
 * System Message for Action Plan (Engineer Persona)
 */
export const SYSTEM_PROMPT_ACTION_PLAN = 'VocÃª Ã© um especialista em seguranÃ§a do trabalho. Gere um plano de aÃ§Ã£o 5W2H detalhado e prÃ¡tico em formato JSON.';

/**
 * System Message for Field Response (Technical Specialist Persona)
 */
export const SYSTEM_PROMPT_FIELD_RESPONSE = 'VocÃª Ã© um especialista em seguranÃ§a do trabalho especializado em anÃ¡lise multimodal avanÃ§ada. Sua funÃ§Ã£o Ã© analisar imagens, Ã¡udios, vÃ­deos e contexto para gerar respostas tÃ©cnicas precisas e detalhadas baseadas em evidÃªncias reais. SEMPRE descreva especificamente o que observa nas imagens em relaÃ§Ã£o Ã  seguranÃ§a do trabalho. Para Ã¡udios, identifique ruÃ­dos, comunicaÃ§Ãµes verbais e, se for assistente psicossocial, analise tom de voz, sinais de estresse, ansiedade ou bem-estar emocional. Seja tÃ©cnico, detalhado e especÃ­fico sobre as evidÃªncias analisadas.';
===END_FILE===
===FILE: supabase/functions/api/ai-rate-limit.ts===
/**
 * AI Rate Limiting Middleware and Utility Functions
 * 
 * ResponsÃ¡vel por:
 * - Verificar limite de uso de IA por organizaÃ§Ã£o
 * - Incrementar contador apÃ³s uso
 * - Logar uso para auditoria e billing
 * - Resetar contador mensalmente
 */

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import type { Context, Next } from 'hono';

interface AIUsageResult {
    allowed: boolean;
    currentUsage: number;
    limit: number;
    remaining: number;
    resetDate: string;
    percentUsed: number;
}

interface LogAIUsageParams {
    organizationId: string;
    userId: string;
    featureType: 'analysis' | 'action_plan' | 'transcription' | 'chat';
    modelUsed: string;
    inputTokens?: number;
    outputTokens?: number;
    costUsd?: number;
    responseTimeMs?: number;
    status?: 'success' | 'error' | 'timeout';
    errorMessage?: string;
    inspectionId?: string;
}

/**
 * Verifica se a organizaÃ§Ã£o ainda tem uso de IA disponÃ­vel
 * Retorna informaÃ§Ãµes sobre o uso atual
 */
export async function checkAIUsage(
    supabaseAdmin: ReturnType<typeof createClient>,
    organizationId: string
): Promise<AIUsageResult & {
    alert_50_sent: boolean;
    alert_80_sent: boolean;
    alert_100_sent: boolean;
}> {
    // Buscar dados da organizaÃ§Ã£o
    const { data: org, error } = await supabaseAdmin
        .from('organizations')
        .select('ai_usage_count, ai_limit, ai_reset_date, subscription_tier, alert_50_sent, alert_80_sent, alert_100_sent')
        .eq('id', organizationId)
        .single();

    if (error || !org) {
        console.error('Error fetching organization AI usage:', error);
        return {
            allowed: false,
            currentUsage: 0,
            limit: 0,
            remaining: 0,
            resetDate: '',
            percentUsed: 100,
            alert_50_sent: false,
            alert_80_sent: false,
            alert_100_sent: false
        };
    }

    // Verificar se precisa resetar (novo mÃªs)
    const today = new Date();
    const resetDate = new Date(org.ai_reset_date);

    if (today >= resetDate) {
        // Resetar contador e atualizar data de reset
        const nextReset = new Date(today.getFullYear(), today.getMonth() + 1, 1);

        await supabaseAdmin
            .from('organizations')
            .update({
                ai_usage_count: 0,
                ai_reset_date: nextReset.toISOString().split('T')[0],
                alert_50_sent: false, // Reset alerts
                alert_80_sent: false,
                alert_100_sent: false
            })
            .eq('id', organizationId);

        org.ai_usage_count = 0;
        org.ai_reset_date = nextReset.toISOString().split('T')[0];
        org.alert_50_sent = false;
        org.alert_80_sent = false;
        org.alert_100_sent = false;
    }

    const currentUsage = org.ai_usage_count || 0;
    const limit = org.ai_limit || 100;
    const remaining = Math.max(0, limit - currentUsage);
    const percentUsed = Math.round((currentUsage / limit) * 100);

    return {
        allowed: currentUsage < limit,
        currentUsage,
        limit,
        remaining,
        resetDate: org.ai_reset_date,
        percentUsed,
        alert_50_sent: org.alert_50_sent || false,
        alert_80_sent: org.alert_80_sent || false,
        alert_100_sent: org.alert_100_sent || false,
    };
}

/**
 * Incrementa o contador de uso de IA da organizaÃ§Ã£o
 * Deve ser chamado APÃ“S uso bem-sucedido da IA
 */
export async function incrementAIUsage(
    supabaseAdmin: ReturnType<typeof createClient>,
    organizationId: string
): Promise<boolean> {
    const { error } = await supabaseAdmin.rpc('increment_ai_usage', {
        org_id: organizationId,
    });

    // Se a funÃ§Ã£o RPC nÃ£o existir, fazer update direto
    if (error && error.code === 'PGRST202') {
        const { error: updateError } = await supabaseAdmin
            .from('organizations')
            .update({
                ai_usage_count: supabaseAdmin.rpc('coalesce', {
                    value1: 'ai_usage_count + 1',
                    value2: 1
                }),
            })
            .eq('id', organizationId);

        // Fallback: update direto com SQL
        if (updateError) {
            // Buscar valor atual e incrementar
            const { data: org } = await supabaseAdmin
                .from('organizations')
                .select('ai_usage_count')
                .eq('id', organizationId)
                .single();

            await supabaseAdmin
                .from('organizations')
                .update({ ai_usage_count: (org?.ai_usage_count || 0) + 1 })
                .eq('id', organizationId);
        }
    }

    return !error;
}

/**
 * Loga o uso de IA para auditoria e billing
 */
export async function logAIUsage(
    supabaseAdmin: ReturnType<typeof createClient>,
    params: LogAIUsageParams
): Promise<void> {
    try {
        await supabaseAdmin.from('ai_usage_log').insert({
            organization_id: params.organizationId,
            user_id: params.userId,
            inspection_id: params.inspectionId,
            feature_type: params.featureType,
            model_used: params.modelUsed,
            input_tokens: params.inputTokens || 0,
            output_tokens: params.outputTokens || 0,
            cost_usd: params.costUsd || 0,
            response_time_ms: params.responseTimeMs || 0,
            status: params.status || 'success',
            error_message: params.errorMessage,
        });
    } catch (error) {
        console.error('Error logging AI usage:', error);
        // NÃ£o falhar por causa do log
    }
}

/**
 * Verifica e incrementa uso de IA em uma Ãºnica operaÃ§Ã£o
 * Retorna se a operaÃ§Ã£o Ã© permitida
 */
export async function checkAndIncrementAIUsage(
    supabaseAdmin: ReturnType<typeof createClient>,
    organizationId: string,
    userId: string,
    featureType: LogAIUsageParams['featureType'] = 'analysis'
): Promise<{ allowed: boolean; usage: AIUsageResult }> {
    const usage = await checkAIUsage(supabaseAdmin, organizationId);

    if (!usage.allowed) {
        // Logar tentativa bloqueada
        await logAIUsage(supabaseAdmin, {
            organizationId,
            userId,
            featureType,
            modelUsed: 'blocked',
            status: 'error',
            errorMessage: 'Limite de uso de IA atingido',
        });
    }

    return { allowed: usage.allowed, usage };
}

/**
 * Busca configuraÃ§Ãµes do sistema
 */
export async function getSystemSettings(
    supabaseAdmin: ReturnType<typeof createClient>
): Promise<{
    aiEnabled: boolean;
    aiPrimaryProvider: string;
    aiBackupProvider: string;
    aiFallbackEnabled: boolean;
    gamificationEnabled: boolean;
}> {
    const { data, error } = await supabaseAdmin
        .from('system_settings')
        .select('*')
        .eq('id', 'global')
        .single();

    if (error || !data) {
        // Retornar defaults
        return {
            aiEnabled: true,
            aiPrimaryProvider: 'gemini',
            aiBackupProvider: 'openai',
            aiFallbackEnabled: true,
            gamificationEnabled: true,
        };
    }

    return {
        aiEnabled: data.ai_enabled ?? true,
        aiPrimaryProvider: data.ai_primary_provider ?? 'gemini',
        aiBackupProvider: data.ai_backup_provider ?? 'openai',
        aiFallbackEnabled: data.ai_fallback_enabled ?? true,
        gamificationEnabled: data.gamification_enabled ?? true,
    };
}

/**
 * Middleware de rate limiting para rotas de IA
 * Adiciona informaÃ§Ãµes de uso ao contexto
 */
export function aiRateLimitMiddleware(featureType: LogAIUsageParams['featureType'] = 'analysis') {
    return async (c: Context, next: Next) => {
        const user = c.get('user');

        if (!user) {
            return c.json({ error: 'UsuÃ¡rio nÃ£o autenticado' }, 401);
        }

        const organizationId = user.organization_id;

        if (!organizationId) {
            return c.json({ error: 'UsuÃ¡rio nÃ£o associado a uma organizaÃ§Ã£o' }, 400);
        }

        // Criar cliente Supabase admin
        const supabaseUrl = c.env?.SUPABASE_URL || Deno.env.get('SUPABASE_URL');
        const supabaseKey = c.env?.SUPABASE_SERVICE_ROLE_KEY || Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

        if (!supabaseUrl || !supabaseKey) {
            console.error('Supabase credentials not configured');
            return next(); // Continuar sem rate limiting se nÃ£o configurado
        }

        const supabaseAdmin = createClient(supabaseUrl, supabaseKey);

        // Verificar configuraÃ§Ãµes do sistema
        const settings = await getSystemSettings(supabaseAdmin);

        if (!settings.aiEnabled) {
            return c.json({
                error: 'ServiÃ§o de IA temporariamente desabilitado pelo administrador',
                code: 'AI_DISABLED'
            }, 503);
        }

        // Verificar uso
        const { allowed, usage } = await checkAndIncrementAIUsage(
            supabaseAdmin,
            organizationId,
            user.id,
            featureType
        );

        // Adicionar informaÃ§Ãµes ao contexto
        c.set('aiUsage', usage);
        c.set('supabaseAdmin', supabaseAdmin);
        c.set('systemSettings', settings);

        if (!allowed) {
            return c.json({
                error: 'Limite de anÃ¡lises de IA atingido para este mÃªs',
                code: 'AI_LIMIT_REACHED',
                usage: {
                    current: usage.currentUsage,
                    limit: usage.limit,
                    resetDate: usage.resetDate,
                },
                upgrade: {
                    message: 'FaÃ§a upgrade do seu plano para mais anÃ¡lises',
                    url: '/settings/subscription',
                }
            }, 429);
        }

        // Adicionar headers de rate limit na resposta
        await next();

        // ApÃ³s a resposta, adicionar headers
        c.header('X-RateLimit-Limit', usage.limit.toString());
        c.header('X-RateLimit-Remaining', usage.remaining.toString());
        c.header('X-RateLimit-Reset', usage.resetDate);
    };
}

async function sendAlertEmail(
    organizationId: string,
    threshold: number,
    currentUsage: number,
    limit: number
) {
    console.log(`[ALERT] Organization ${organizationId} reached ${threshold}% usage (${currentUsage}/${limit})`);
    // TODO: Implement actual email sending via SendGrid/Resend
    // Example: fetch('https://api.resend.com/emails', ...)
}

/**
 * ApÃ³s uso bem-sucedido de IA, finaliza o log e incrementa contador
 */
export async function finalizeAIUsage(
    supabaseAdmin: ReturnType<typeof createClient>,
    organizationId: string,
    params: Omit<LogAIUsageParams, 'organizationId'>
): Promise<void> {
    // Incrementar contador
    await incrementAIUsage(supabaseAdmin, organizationId);

    // Check for alerts
    try {
        const usageData = await checkAIUsage(supabaseAdmin, organizationId);
        const { percentUsed, alert_50_sent, alert_80_sent, alert_100_sent } = usageData;

        let alertToSend = 0;
        let startCondition = false;

        if (percentUsed >= 100 && !alert_100_sent) {
            alertToSend = 100;
        } else if (percentUsed >= 80 && !alert_80_sent) {
            alertToSend = 80;
        } else if (percentUsed >= 50 && !alert_50_sent) {
            alertToSend = 50;
        }

        if (alertToSend > 0) {
            await sendAlertEmail(organizationId, alertToSend, usageData.currentUsage, usageData.limit);

            // Update flag
            const updateData: any = {};
            if (alertToSend === 50) updateData.alert_50_sent = true;
            if (alertToSend === 80) updateData.alert_80_sent = true;
            if (alertToSend === 100) updateData.alert_100_sent = true;

            await supabaseAdmin
                .from('organizations')
                .update(updateData)
                .eq('id', organizationId);
        }
    } catch (e) {
        console.error('Error checking usage alerts:', e);
    }

    // Logar uso
    await logAIUsage(supabaseAdmin, {
        ...params,
        organizationId,
    });
}
===END_FILE===
===FILE: supabase/functions/api/ai-service.ts===
/**
 * AI Service Module - Gemini Primary with OpenAI Fallback
 * 
 * ResponsÃ¡vel por:
 * - Tentar Gemini primeiro (mais barato)
 * - Fazer fallback para OpenAI se Gemini falhar
 * - Logar qual provider foi utilizado
 */

interface AICompletionOptions {
    systemPrompt: string;
    userPrompt: string;
    maxTokens?: number;
    temperature?: number;
    timeoutMs?: number;
    images?: Array<{
        data: string; // Base64
        mimeType: string;
    }>;
}

interface AICompletionResult {
    success: boolean;
    content: string;
    provider: 'gemini' | 'openai';
    model: string;
    error?: string;
    fallbackUsed?: boolean;
    totalTokens?: number;
}

/**
 * Chama a API do Gemini (Google AI)
 */
async function callGemini(
    apiKey: string,
    options: AICompletionOptions
): Promise<{ success: boolean; content?: string; error?: string; totalTokens?: number }> {
    const { systemPrompt, userPrompt, maxTokens = 1500, temperature = 0.3, timeoutMs = 60000, images } = options;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

    try {
        const parts: any[] = [{ text: `${systemPrompt}\n\n${userPrompt}` }];

        if (images && images.length > 0) {
            images.forEach(img => {
                parts.push({
                    inlineData: {
                        mimeType: img.mimeType,
                        data: img.data
                    }
                });
            });
        }

        const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`,
            {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [
                        {
                            role: 'user',
                            parts: parts
                        }
                    ],
                    generationConfig: {
                        temperature: temperature,
                        maxOutputTokens: maxTokens,
                        responseMimeType: 'application/json'
                    },
                    safetySettings: [
                        { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                        { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                        { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                        { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                    ]
                }),
                signal: controller.signal
            }
        );

        clearTimeout(timeoutId);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('[AI-SERVICE] Gemini API Error:', response.status, errorText);
            return { success: false, error: `Gemini error ${response.status}: ${errorText}` };
        }

        const data = await response.json();

        // Extract content from Gemini response
        const content = data.candidates?.[0]?.content?.parts?.[0]?.text;

        if (!content) {
            return { success: false, error: 'Gemini returned empty response' };
        }

        // Extract usage
        const totalTokens = data.usageMetadata?.totalTokenCount || 0;

        console.log('[AI-SERVICE] Gemini success, content length:', content.length, 'Tokens:', totalTokens);
        return { success: true, content, totalTokens };

    } catch (error: any) {
        clearTimeout(timeoutId);

        if (error.name === 'AbortError') {
            return { success: false, error: 'Gemini request timed out' };
        }

        console.error('[AI-SERVICE] Gemini exception:', error.message);
        return { success: false, error: error.message };
    }
}

/**
 * Chama a API do OpenAI
 */
async function callOpenAI(
    apiKey: string,
    options: AICompletionOptions
): Promise<{ success: boolean; content?: string; error?: string; totalTokens?: number }> {
    const { systemPrompt, userPrompt, maxTokens = 1500, temperature = 0.3, timeoutMs = 60000, images } = options;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

    try {
        const messages: any[] = [
            { role: 'system', content: systemPrompt }
        ];

        if (images && images.length > 0) {
            const contentParts: any[] = [{ type: 'text', text: userPrompt }];

            images.forEach(img => {
                contentParts.push({
                    type: 'image_url',
                    image_url: {
                        url: `data:${img.mimeType};base64,${img.data}`
                    }
                });
            });

            messages.push({ role: 'user', content: contentParts });
        } else {
            messages.push({ role: 'user', content: userPrompt });
        }

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'gpt-4o-mini',
                messages: messages,
                max_tokens: maxTokens,
                temperature: temperature
            }),
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('[AI-SERVICE] OpenAI API Error:', response.status, errorText);
            return { success: false, error: `OpenAI error ${response.status}: ${errorText}` };
        }

        const data = await response.json();
        const content = data.choices?.[0]?.message?.content;

        if (!content) {
            return { success: false, error: 'OpenAI returned empty response' };
        }

        const totalTokens = data.usage?.total_tokens || 0;

        console.log('[AI-SERVICE] OpenAI success, content length:', content.length, 'Tokens:', totalTokens);
        return { success: true, content, totalTokens };

    } catch (error: any) {
        clearTimeout(timeoutId);

        if (error.name === 'AbortError') {
            return { success: false, error: 'OpenAI request timed out' };
        }

        console.error('[AI-SERVICE] OpenAI exception:', error.message);
        return { success: false, error: error.message };
    }
}

/**
 * FunÃ§Ã£o principal: tenta Gemini primeiro, depois OpenAI como fallback
 */
export async function generateAICompletion(
    geminiKey: string | undefined,
    openaiKey: string | undefined,
    options: AICompletionOptions,
    preferences: {
        preferredProvider: 'gemini' | 'openai';
        fallbackEnabled: boolean;
    } = { preferredProvider: 'gemini', fallbackEnabled: true }
): Promise<AICompletionResult> {

    const { preferredProvider, fallbackEnabled } = preferences;
    const providerOrder = preferredProvider === 'openai'
        ? ['openai', 'gemini']
        : ['gemini', 'openai'];

    console.log(`[AI-SERVICE] Config: Primary=${preferredProvider}, Fallback=${fallbackEnabled ? 'ON' : 'OFF'}`);

    for (const provider of providerOrder) {
        // Skip secondary provider if fallback is disabled and we are on the second iteration
        if (!fallbackEnabled && provider !== preferredProvider) {
            console.log(`[AI-SERVICE] Fallback disabled, skipping ${provider}`);
            continue;
        }

        if (provider === 'gemini') {
            if (geminiKey && geminiKey.trim()) {
                console.log('[AI-SERVICE] Tentando Gemini...');
                const result = await callGemini(geminiKey.trim(), options);

                if (result.success && result.content) {
                    return {
                        success: true,
                        content: result.content,
                        provider: 'gemini',
                        model: 'gemini-1.5-flash',
                        fallbackUsed: provider !== preferredProvider,
                        totalTokens: result.totalTokens
                    };
                }
                console.log('[AI-SERVICE] Gemini falhou:', result.error);
            } else {
                console.log('[AI-SERVICE] Gemini Key ausente ou invÃ¡lida.');
            }
        }

        if (provider === 'openai') {
            if (openaiKey && openaiKey.trim()) {
                console.log('[AI-SERVICE] Tentando OpenAI...');
                const result = await callOpenAI(openaiKey.trim(), options);

                if (result.success && result.content) {
                    return {
                        success: true,
                        content: result.content,
                        provider: 'openai',
                        model: 'gpt-4o-mini',
                        fallbackUsed: provider !== preferredProvider,
                        totalTokens: result.totalTokens
                    };
                }
                console.log('[AI-SERVICE] OpenAI falhou:', result.error);
            } else {
                console.log('[AI-SERVICE] OpenAI Key ausente ou invÃ¡lida.');
            }
        }
    }

    // Se chegou aqui, ambos falharam ou nÃ£o estavam configurados adequadamente
    return {
        success: false,
        content: '',
        provider: 'openai', // Default for error reporting
        model: 'none',
        error: 'Falha em todos os provedores configurados ou chaves ausentes.'
    };
}

/**
 * Verifica status dos providers de IA
 */
export async function checkAIProvidersStatus(
    geminiKey: string | undefined,
    openaiKey: string | undefined
): Promise<{ gemini: 'available' | 'unavailable' | 'error'; openai: 'available' | 'unavailable' | 'error' }> {
    const status = {
        gemini: 'unavailable' as 'available' | 'unavailable' | 'error',
        openai: 'unavailable' as 'available' | 'unavailable' | 'error'
    };

    // Quick health check for Gemini
    if (geminiKey) {
        try {
            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models?key=${geminiKey}`,
                { method: 'GET' }
            );
            status.gemini = response.ok ? 'available' : 'error';
        } catch {
            status.gemini = 'error';
        }
    }

    // Quick health check for OpenAI
    if (openaiKey) {
        try {
            const response = await fetch('https://api.openai.com/v1/models', {
                method: 'GET',
                headers: { 'Authorization': `Bearer ${openaiKey}` }
            });
            status.openai = response.ok ? 'available' : 'error';
        } catch {
            status.openai = 'error';
        }
    }

    return status;
}
===END_FILE===
===FILE: supabase/functions/api/ai-usage-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";

const aiUsageRoutes = new Hono<{ Bindings: any }>();

// GET /api/organizations/:orgId/ai-usage/logs
aiUsageRoutes.get('/:orgId/logs', tenantAuthMiddleware, async (c) => {
    const orgId = c.req.param('orgId');
    const { page = '1', limit = '20', start_date, end_date, feature_type, user_id } = c.req.query();

    // Permission check (must be org_admin or sys_admin)
    const user = c.get('user');
    // Basic check: user.organization_id == orgId OR user.role == sys_admin
    // (Middleware already handles basic tenant, but let's be safe if we want strict admin only)

    try {
        const offset = (parseInt(page) - 1) * parseInt(limit);
        const params: any[] = [orgId];
        let query = `
            SELECT l.*, u.email as user_email
            FROM ai_usage_log l
            LEFT JOIN users u ON l.user_id = u.id
            WHERE l.organization_id = ?
        `;

        if (start_date) {
            query += ` AND l.created_at >= ?`;
            params.push(start_date);
        }
        if (end_date) {
            query += ` AND l.created_at <= ?`;
            params.push(end_date);
        }
        if (feature_type) {
            query += ` AND l.feature_type = ?`;
            params.push(feature_type);
        }
        if (user_id) {
            query += ` AND l.user_id = ?`;
            params.push(user_id);
        }

        const countQuery = `SELECT COUNT(*) as total FROM (${query}) as sub`;
        // @ts-ignore
        const totalResult = await c.env.DB.prepare(countQuery).bind(...params).first();

        query += ` ORDER BY l.created_at DESC LIMIT ? OFFSET ?`;
        params.push(parseInt(limit), offset);

        // @ts-ignore
        const results = await c.env.DB.prepare(query).bind(...params).all();

        return c.json({
            logs: results.results || [],
            pagination: {
                total: totalResult?.total || 0,
                page: parseInt(page),
                limit: parseInt(limit),
                pages: Math.ceil((totalResult?.total || 0) / parseInt(limit))
            }
        });
    } catch (e: any) {
        console.error("Error fetching AI logs:", e);
        return c.json({ error: e.message }, 500);
    }
});

// GET /api/organizations/:orgId/ai-usage/export
aiUsageRoutes.get('/:orgId/export', tenantAuthMiddleware, async (c) => {
    const orgId = c.req.param('orgId');
    const { start_date, end_date } = c.req.query();

    try {
        const params: any[] = [orgId];
        let query = `
            SELECT l.created_at, u.email, l.feature_type, l.model_used, l.status
            FROM ai_usage_log l
            LEFT JOIN users u ON l.user_id = u.id
            WHERE l.organization_id = ?
        `;

        if (start_date) {
            query += ` AND l.created_at >= ?`;
            params.push(start_date);
        }
        if (end_date) {
            query += ` AND l.created_at <= ?`;
            params.push(end_date);
        }
        query += ` ORDER BY l.created_at DESC LIMIT 1000`; // Limit export size

        // @ts-ignore
        const results = await c.env.DB.prepare(query).bind(...params).all();
        const logs = results.results || [];

        // Generate CSV
        const header = "Data/Hora,UsuÃ¡rio,Funcionalidade,Modelo,Status\n";
        const rows = logs.map((l: any) =>
            `${l.created_at},${l.email || 'N/A'},${l.feature_type},${l.model_used},${l.status}`
        ).join("\n");

        return c.text(header + rows, 200, {
            'Content-Type': 'text/csv',
            'Content-Disposition': `attachment; filename="ai_usage_report_${orgId}.csv"`
        });

    } catch (e: any) {
        console.error("Error exporting AI logs:", e);
        return c.json({ error: e.message }, 500);
    }
});

export { aiUsageRoutes };
===END_FILE===
===FILE: supabase/functions/api/ai-usage-tracker.ts===

/**
 * Shared helper for AI Usage Increment across all routes.
 * Centralizes logic for updating organization usage counts and logging events.
 */
export async function incrementAiUsage(
    db: any,
    userId: string,
    featureType: string,
    modelUsed: string,
    tokenCount: number = 0 // Default to 0 if not provided
): Promise<{ success: boolean; debug_org_id?: number | null; error?: string }> {
    try {
        // Safe userId extraction
        if (!userId) {
            console.error('[AI-USAGE-HELPER] No userId provided');
            return { success: false, error: 'no_user_id' };
        }

        console.log(`[AI-USAGE-HELPER] Incrementing for user: ${userId}, Feature: ${featureType}, Tokens: ${tokenCount}`);

        // Get User's Organization
        const userProfile = await db.prepare(
            "SELECT organization_id FROM users WHERE id = ?"
        ).bind(userId).first() as { organization_id?: number };

        if (!userProfile?.organization_id) {
            console.error('[AI-USAGE-HELPER] Organization ID not found for user:', userId);
            return { success: false, debug_org_id: null, error: 'org_not_found' };
        }

        const orgId = userProfile.organization_id;

        // Update Counter
        await db.prepare(
            "UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?"
        ).bind(orgId).run();

        // Insert Log
        try {
            await db.prepare(`
                INSERT INTO ai_usage_logs (organization_id, user_id, feature_type, model_used, total_tokens, status, created_at)
                VALUES (?, ?, ?, ?, ?, 'success', ?)
            `).bind(orgId, userId, featureType, modelUsed, tokenCount, new Date().toISOString()).run();
        } catch (logErr) {
            console.warn('[AI-USAGE-HELPER] Log insertion failed (non-critical):', logErr);
            // Non-critical, but we log it.
        }

        return { success: true, debug_org_id: orgId, _trace: 'fixed-syntax' };

    } catch (err: any) {
        console.error('[AI-USAGE-HELPER] Critical failure:', err);
        return { success: false, error: err.message };
    }
}
===END_FILE===
===FILE: supabase/functions/api/asaas-service.ts===

export interface AsaasCustomer {
    id: string;
    name: string;
    email: string;
    cpfCnpj: string;
    phone?: string;
    mobilePhone?: string;
    address?: string;
    addressNumber?: string;
    complement?: string;
    province?: string;
    postalCode?: string;
}

export interface AsaasSubscription {
    id: string;
    customer: string;
    value: number;
    nextDueDate: string;
    cycle: 'MONTHLY' | 'YEARLY';
    description?: string;
    billingType: 'BOLETO' | 'CREDIT_CARD' | 'PIX' | 'UNDEFINED';
    status: 'ACTIVE' | 'EXPIRED';
}

export class AsaasService {
    private apiKey: string;
    private apiUrl: string;

    constructor() {
        this.apiKey = Deno.env.get('ASAAS_API_KEY') || '';
        // Default to Sandbox if not specified, explicitly check for 'production' value
        // Support both naming conventions (EN/PT)
        const mode = Deno.env.get('ASAAS_MODE') || Deno.env.get('MODO_ASAAS');
        this.apiUrl = mode === 'production'
            ? 'https://api.asaas.com/v3'
            : 'https://sandbox.asaas.com/api/v3';

        if (!this.apiKey) {
            console.warn('[AsaasService] ASAAS_API_KEY not found in environment variables.');
        } else {
            console.log(`[AsaasService] Initialized. Mode: ${mode || 'default(sandbox)'}. Key Length: ${this.apiKey.length}. Target: ${this.apiUrl}`);
            console.log(`[AsaasService] Key Prefix: ${this.apiKey.substring(0, 4)}...`);
        }
    }

    private async request(endpoint: string, method: string = 'GET', body?: any) {
        const url = `${this.apiUrl}${endpoint}`;
        const headers = {
            'Content-Type': 'application/json',
            'access_token': this.apiKey
        };

        const options: RequestInit = {
            method,
            headers
        };

        if (body) {
            options.body = JSON.stringify(body);
        }

        console.log(`[AsaasService] ${method} ${url}`);

        try {
            const response = await fetch(url, options);

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`[AsaasService] Error ${response.status}: ${errorText}`);
                throw new Error(`Asaas API Error: ${response.status} on ${url} - ${errorText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('[AsaasService] Request failed:', error);
            throw error;
        }
    }

    /**
     * Create or Update a customer in Asaas
     * First checks if customer exists by email/cpfCnpj to avoid duplicates
     */
    async createOrUpdateCustomer(data: Partial<AsaasCustomer>): Promise<AsaasCustomer> {
        // 1. Try to find by CPF/CNPJ
        if (data.cpfCnpj) {
            const search = await this.request(`/customers?cpfCnpj=${data.cpfCnpj}`);
            if (search.data && search.data.length > 0) {
                return search.data[0];
            }
        }

        // 2. Try to find by Email
        if (data.email) {
            const search = await this.request(`/customers?email=${data.email}`);
            if (search.data && search.data.length > 0) {
                return search.data[0];
            }
        }

        // 3. Create new customer
        return await this.request('/customers', 'POST', data);
    }

    /**
     * Create a new Subscription
     */
    async createSubscription(data: {
        customer: string;
        billingType: 'BOLETO' | 'CREDIT_CARD' | 'PIX' | 'UNDEFINED';
        value: number;
        nextDueDate: string;
        cycle: 'MONTHLY' | 'YEARLY';
        description?: string;
        externalReference?: string;
    }): Promise<AsaasSubscription> {
        return await this.request('/subscriptions', 'POST', data);
    }

    /**
     * Update an existing subscription (Upgrade/Downgrade)
     */
    async updateSubscription(subscriptionId: string, data: {
        value?: number;
        nextDueDate?: string;
        cycle?: 'MONTHLY' | 'YEARLY';
        billingType?: string;
        description?: string;
        updatePendingPayments?: boolean; // If true, updates pending invoices
    }): Promise<AsaasSubscription> {
        // Note: Asaas API might require specific handling for value updates vs cycle updates
        return await this.request(`/subscriptions/${subscriptionId}`, 'POST', data);
    }

    /**
     * Get Subscription details
     */
    async getSubscription(subscriptionId: string): Promise<AsaasSubscription> {
        return await this.request(`/subscriptions/${subscriptionId}`);
    }

    /**
     * Get Payments (Invoices) for a Subscription
     */
    async getSubscriptionPayments(subscriptionId: string) {
        return await this.request(`/payments?subscription=${subscriptionId}`);
    }

    /**
     * Generate a One-Time Payment Link (for Pay-as-you-go Credits)
     */
    async createPaymentLink(data: {
        name: string;
        description: string;
        value: number;
        dueDateLimitDays?: number; // Days until link expires
        billingType: 'BOLETO' | 'CREDIT_CARD' | 'PIX' | 'UNDEFINED';
        chargeType: 'DETACHED'; // One-time charge
    }) {
        return await this.request('/paymentLinks', 'POST', data);
    }
    /**
     * Get PIX QR Code and Copy & Paste string for a payment
     */
    async getPixQrCode(paymentId: string): Promise<{ encodedImage: string; payload: string; expirationDate: string }> {
        return await this.request(`/payments/${paymentId}/pixQrCode`);
    }
}
===END_FILE===
===FILE: supabase/functions/api/asaas-webhook.ts===
import { Hono } from "hono";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";

const asaasWebhookRoutes = new Hono();

// Define Asaas event types
type AsaasEventType =
    | 'PAYMENT_CONFIRMED'
    | 'PAYMENT_RECEIVED'
    | 'PAYMENT_OVERDUE'
    | 'PAYMENT_DELETED'
    | 'PAYMENT_UPDATED'
    | 'PAYMENT_REFUNDED'
    | 'SUBSCRIPTION_DELETED'
    | 'SUBSCRIPTION_UPDATED';

interface AsaasWebhookPayload {
    id: string; // Event ID
    event: AsaasEventType;
    payment?: {
        id: string;
        customer: string;
        subscription?: string;
        value: number;
        status: string;
        dueDate: string;
        confirmedDate?: string;
    };
    subscription?: {
        id: string;
        customer: string;
        status: string;
    };
}

// ============================================================================
// POST /webhooks/asaas - Main Asaas webhook handler
// ============================================================================
asaasWebhookRoutes.post("/", async (c) => {
    // 1. Initialize Supabase Admin Client
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabaseAdmin = createClient(supabaseUrl, supabaseKey);

    // 2. Authentication (Optional but recommended)
    const webhookToken = c.req.header('asaas-access-token');
    const expectedToken = Deno.env.get('ASAAS_WEBHOOK_TOKEN');

    if (expectedToken && webhookToken !== expectedToken) {
        console.warn("[ASAAS-WEBHOOK] Invalid webhook token received");
        return c.json({ error: "Unauthorized" }, 401);
    }

    let payload: AsaasWebhookPayload;

    try {
        payload = await c.req.json();
    } catch (err) {
        console.error("[ASAAS-WEBHOOK] Failed to parse JSON payload:", err);
        return c.json({ error: "Invalid JSON payload" }, 400);
    }

    console.log(`[ASAAS-WEBHOOK] Received event: ${payload.event}, id: ${payload.id}`);

    // 3. Idempotency Check
    const { data: existingEvent } = await supabaseAdmin
        .from('webhook_events')
        .select('id')
        .eq('gateway', 'asaas')
        .eq('external_event_id', payload.id)
        .maybeSingle();

    if (existingEvent) {
        console.log(`[ASAAS-WEBHOOK] Event ${payload.id} already processed, skipping`);
        return c.json({ status: "already_processed" });
    }

    // 4. Process Event
    try {
        switch (payload.event) {
            case 'PAYMENT_CONFIRMED':
            case 'PAYMENT_RECEIVED':
                await handlePaymentConfirmed(supabaseAdmin, payload);
                break;

            case 'PAYMENT_OVERDUE':
                await handlePaymentOverdue(supabaseAdmin, payload);
                break;

            case 'PAYMENT_REFUNDED':
                await handlePaymentRefunded(supabaseAdmin, payload);
                break;

            case 'SUBSCRIPTION_DELETED':
                await handleSubscriptionDeleted(supabaseAdmin, payload);
                break;

            default:
                console.log(`[ASAAS-WEBHOOK] Unhandled event type: ${payload.event}`);
        }

        // 5. Log Success
        await supabaseAdmin.from('webhook_events').insert({
            gateway: 'asaas',
            external_event_id: payload.id,
            event_type: payload.event,
            payload: payload,
            status: 'processed',
            processed_at: new Date().toISOString()
        });

        console.log(`[ASAAS-WEBHOOK] Successfully processed event ${payload.id}`);
        return c.json({ status: "processed" });

    } catch (err: any) {
        console.error(`[ASAAS-WEBHOOK] Error processing event ${payload.id}:`, err);

        // Log Failure
        await supabaseAdmin.from('webhook_events').insert({
            gateway: 'asaas',
            external_event_id: payload.id,
            event_type: payload.event,
            payload: payload,
            status: 'failed',
            error_message: err.message,
            processed_at: new Date().toISOString()
        });

        return c.json({ error: "Processing failed", details: err.message }, 500);
    }
});

// ============================================================================
// Event Handlers
// ============================================================================

async function handlePaymentConfirmed(supabase: any, payload: AsaasWebhookPayload) {
    if (!payload.payment) return;

    const { id: paymentId, subscription: subscriptionId, confirmedDate } = payload.payment;

    console.log(`[ASAAS-WEBHOOK] Processing PAYMENT_CONFIRMED: ${paymentId}`);

    const paidAt = confirmedDate ? new Date(confirmedDate).toISOString() : new Date().toISOString();

    // 1. Update Invoice
    const { error: invoiceError } = await supabase
        .from('invoices')
        .update({
            status: 'paid',
            paid_at: paidAt
        })
        .eq('gateway_invoice_id', paymentId);

    if (invoiceError) console.error("Error updating invoice:", invoiceError);
    else console.log(`[ASAAS-WEBHOOK] Invoice ${paymentId} marked as paid`);

    // 2. Update Subscription & Organization (if applicable)
    if (subscriptionId) {
        // Update Subscription
        const { data: subData, error: subError } = await supabase
            .from('subscriptions')
            .update({
                status: 'active',
                updated_at: new Date().toISOString()
            })
            .eq('gateway_subscription_id', subscriptionId)
            .select('organization_id')
            .single();

        if (subError) {
            console.error("Error updating subscription:", subError);
        } else if (subData?.organization_id) {
            console.log(`[ASAAS-WEBHOOK] Subscription ${subscriptionId} active. Updating Org...`);

            // Sync Org Status
            const { error: orgError } = await supabase
                .from('organizations')
                .update({
                    subscription_status: 'active',
                    updated_at: new Date().toISOString()
                })
                .eq('id', subData.organization_id);

            if (orgError) console.error("Error updating organization:", orgError);
            else console.log(`[ASAAS-WEBHOOK] Organization ${subData.organization_id} activated.`);
        }
    }
}

async function handlePaymentOverdue(supabase: any, payload: AsaasWebhookPayload) {
    if (!payload.payment) return;
    const { id: paymentId, subscription: subscriptionId, value } = payload.payment;

    console.log(`[ASAAS-WEBHOOK] Processing PAYMENT_OVERDUE: ${paymentId}`);

    // Update Invoice
    const { data: invoiceData } = await supabase
        .from('invoices')
        .update({ status: 'overdue' })
        .eq('gateway_invoice_id', paymentId)
        .select('organization_id')
        .single();

    // Update Subscription (if active)
    if (subscriptionId) {
        await supabase
            .from('subscriptions')
            .update({ status: 'past_due' })
            .eq('gateway_subscription_id', subscriptionId)
            .eq('status', 'active');
    }

    // CRM Lead Logic (Simplified)
    if (invoiceData?.organization_id) {
        // Fetch Org Info
        const { data: org } = await supabase
            .from('organizations')
            .select('name, contact_email, contact_phone')
            .eq('id', invoiceData.organization_id)
            .single();

        if (org) {
            // Check existing churn lead
            const { data: existingLead } = await supabase
                .from('leads')
                .select('id')
                .eq('company_name', org.name)
                .eq('deal_type', 'churn_recovery')
                .not('status', 'in', '("won","lost")')
                .maybeSingle();

            if (!existingLead) {
                console.log(`[ASAAS-WEBHOOK] Creating Churn Recovery Lead for ${org.name}`);
                await supabase.from('leads').insert({
                    company_name: org.name,
                    contact_name: 'Contato Financeiro',
                    email: org.contact_email,
                    phone: org.contact_phone,
                    status: 'new',
                    source: 'billing_failure',
                    notes: `ALERTA FINANCEIRO: Fatura em atraso (ID: ${paymentId}). Valor: R$ ${value.toFixed(2)}.`,
                    deal_value: value,
                    probability: 90,
                    deal_type: 'churn_recovery'
                });
            }
        }
    }
}

async function handlePaymentRefunded(supabase: any, payload: AsaasWebhookPayload) {
    if (!payload.payment) return;
    const { id: paymentId } = payload.payment;

    console.log(`[ASAAS-WEBHOOK] Processing PAYMENT_REFUNDED: ${paymentId}`);

    await supabase
        .from('invoices')
        .update({ status: 'refunded' })
        .eq('gateway_invoice_id', paymentId);
}

async function handleSubscriptionDeleted(supabase: any, payload: AsaasWebhookPayload) {
    const subscriptionId = payload.subscription?.id || payload.payment?.subscription;
    if (!subscriptionId) return;

    console.log(`[ASAAS-WEBHOOK] Processing SUBSCRIPTION_DELETED: ${subscriptionId}`);

    await supabase
        .from('subscriptions')
        .update({
            status: 'canceled',
            canceled_at: new Date().toISOString()
        })
        .eq('gateway_subscription_id', subscriptionId);
}

// Health check
asaasWebhookRoutes.get("/", (c) => {
    return c.json({
        status: "ok",
        message: "Asaas webhook endpoint ready (Supabase Native)",
        supported_events: [
            "PAYMENT_CONFIRMED",
            "PAYMENT_RECEIVED",
            "PAYMENT_OVERDUE",
            "PAYMENT_REFUNDED",
            "SUBSCRIPTION_DELETED"
        ]
    });
});

export default asaasWebhookRoutes;
===END_FILE===
===FILE: supabase/functions/api/audit-logger.ts===
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";

export async function logActivity(env: any, params: {
    userId: string | number,
    orgId: string | number | null,
    actionType: string,
    actionDescription: string,
    targetType: string,
    targetId: string | number | null,
    metadata?: any,
    req?: any
}) {
    try {
        const ip = params.req?.header('cf-connecting-ip') || params.req?.header('x-forwarded-for') || 'unknown';
        const ua = params.req?.header('user-agent') || 'unknown';

        // Ensure metadata is stringified if object
        const metadataStr = params.metadata ?
            (typeof params.metadata === 'string' ? params.metadata : JSON.stringify(params.metadata))
            : null;

        // Initialize Supabase Client
        // Ensure env contains necessary keys
        const supabaseUrl = env.SUPABASE_URL;
        const supabaseKey = env.SUPABASE_SERVICE_ROLE_KEY || env.SUPABASE_ANON_KEY;

        if (!supabaseUrl || !supabaseKey) {
            console.error('[AUDIT-LOG] Missing Supabase credentials in env');
            return;
        }

        const supabase = createClient(supabaseUrl, supabaseKey);

        const { error } = await supabase.from('activity_log').insert({
            user_id: params.userId,
            organization_id: params.orgId,
            action_type: params.actionType,
            action_description: params.actionDescription,
            target_type: params.targetType,
            target_id: String(params.targetId),
            metadata: metadataStr,
            ip_address: ip,
            user_agent: ua
            // created_at is handled by DB default
        });

        if (error) {
            console.error('[AUDIT-LOG] Insert error:', error);
        } else {
            console.log(`[AUDIT-LOG] Logged ${params.actionType} for ${params.targetType}:${params.targetId}`);
        }

    } catch (e) {
        console.error('[AUDIT-LOG] Failed to log activity:', e);
    }
}
===END_FILE===
===FILE: supabase/functions/api/audit-routes.ts===
import { Hono } from 'hono';
import { tenantAuthMiddleware as authMiddleware } from './tenant-auth-middleware.ts';


type Env = {
    DB: any;
    [key: string]: any;
};

const auditRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/audit');

// Middleware to ensure user has access to audit logs (System Admin or Org Admin)
const requireAuditAccess = async (c: any, next: any) => {
    const user = c.get('user');
    const role = user?.role || user?.profile?.role;
    console.log(`[AUDIT] Auth check - User: ${user?.email}, Role: ${role}`);

    if (!role || !['system_admin', 'sys_admin', 'org_admin', 'organization_admin'].includes(role)) {
        return c.json({ error: `Acesso negado. Role '${role}' nÃ£o autorizada.` }, 403);
    }
    await next();
};



// GET /api/audit/logs - List audit logs with filters
auditRoutes.get('/logs', authMiddleware, requireAuditAccess, async (c) => {
    const env = c.env;
    const user = c.get('user');
    const userRole = user?.role || user?.profile?.role;
    const userOrgId = user?.organization_id || user?.profile?.organization_id;

    // Parse query parameters for filters
    const url = new URL(c.req.url);
    const page = parseInt(url.searchParams.get('page') || '1');
    const limit = Math.min(parseInt(url.searchParams.get('limit') || '50'), 100);
    const offset = (page - 1) * limit;

    // Filters
    const startDate = url.searchParams.get('start_date');
    const endDate = url.searchParams.get('end_date');
    const actionType = url.searchParams.get('action_type');
    const targetType = url.searchParams.get('target_type');
    const userId = url.searchParams.get('user_id');
    const organizationIdQuery = url.searchParams.get('organization_id');
    const search = url.searchParams.get('search');

    try {
        // Build dynamic query with filters
        let whereConditions: string[] = [];
        let params: any[] = [];
        // paramIndex removed - wrapper handles sequential ? automatically

        // Security: If org_admin, force filter by their organization_id
        if (['org_admin', 'organization_admin'].includes(userRole)) {
            if (!userOrgId) {
                return c.json({ error: 'UsuÃ¡rio sem organizaÃ§Ã£o vinculada' }, 400);
            }
            whereConditions.push('al.organization_id = ?');
            params.push(userOrgId);
        } else if (organizationIdQuery) {
            // If system admin and supplied organization_id filter
            whereConditions.push('al.organization_id = ?');
            params.push(parseInt(organizationIdQuery));
        }

        if (startDate) {
            whereConditions.push('al.created_at >= ?');
            params.push(startDate);
        }
        if (endDate) {
            whereConditions.push('al.created_at <= ?');
            params.push(endDate + 'T23:59:59Z');
        }
        if (actionType) {
            whereConditions.push('al.action_type = ?');
            params.push(actionType);
        }
        if (targetType) {
            whereConditions.push('al.target_type = ?');
            params.push(targetType);
        }
        if (userId) {
            whereConditions.push('al.user_id = ?');
            params.push(userId);
        }
        if (search) {
            whereConditions.push('(al.action_description LIKE ? OR al.target_id LIKE ?)');
            params.push(`%${search}%`);
            params.push(`%${search}%`);
        }

        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';

        // Get total count
        const countQuery = `SELECT COUNT(*) as total FROM activity_log al ${whereClause}`;
        const countResult = await env.DB.prepare(countQuery).bind(...params).first() as any;
        const total = countResult?.total || 0;

        // Get logs with user info
        const logsQuery = `
      SELECT 
        al.id,
        al.user_id,
        al.organization_id,
        al.action_type,
        al.action_description,
        al.target_type,
        al.target_id,
        al.metadata,
        al.created_at,
        u.email as user_email,
        u.name as user_name,
        o.name as organization_name
      FROM activity_log al
      LEFT JOIN users u ON al.user_id = u.id
      LEFT JOIN organizations o ON al.organization_id = o.id
      ${whereClause}
      ORDER BY al.created_at DESC
      LIMIT ${limit} OFFSET ${offset}
    `;

        const logs = await env.DB.prepare(logsQuery).bind(...params).all();

        return c.json({
            logs: logs.results || [],
            pagination: {
                page,
                limit,
                total,
                totalPages: Math.ceil(total / limit)
            }
        });
    } catch (error) {
        console.error('Error fetching audit logs:', error);
        return c.json({ error: 'Erro ao buscar logs de auditoria' }, 500);
    }
});

// GET /api/audit/logs/:id - Get single log detail
auditRoutes.get('/logs/:id', authMiddleware, requireAuditAccess, async (c) => {
    const env = c.env;
    const user = c.get('user');
    const userRole = user?.role || user?.profile?.role;
    const userOrgId = user?.organization_id || user?.profile?.organization_id;
    const logId = parseInt(c.req.param('id'));

    try {
        let query = `
      SELECT 
        al.*,
        u.email as user_email,
        u.name as user_name,
        o.name as organization_name
      FROM activity_log al
      LEFT JOIN users u ON al.user_id = u.id
      LEFT JOIN organizations o ON al.organization_id = o.id
      WHERE al.id = ?
    `;

        const params = [logId];

        if (['org_admin', 'organization_admin'].includes(userRole)) {
            query += ' AND al.organization_id = ?';
            params.push(userOrgId);
        }

        const log = await env.DB.prepare(query).bind(...params).first();

        if (!log) {
            return c.json({ error: 'Log nÃ£o encontrado ou acesso nÃ£o autorizado' }, 404);
        }

        return c.json({ log });
    } catch (error) {
        console.error('Error fetching audit log:', error);
        return c.json({ error: 'Erro ao buscar log de auditoria' }, 500);
    }
});

// GET /api/audit/stats - Get audit statistics
auditRoutes.get('/stats', authMiddleware, requireAuditAccess, async (c) => {
    const env = c.env;
    const user = c.get('user');
    const userRole = user?.role || user?.profile?.role;
    const userOrgId = user?.organization_id || user?.profile?.organization_id;

    const url = new URL(c.req.url);
    const days = parseInt(url.searchParams.get('days') || '30');

    try {
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - days);
        const startDateStr = startDate.toISOString();

        let orgFilter = '';
        let orgFilterTop = ''; // For queries where aliases might differ or direct modification is needed
        let params: any[] = [startDateStr];

        if (['org_admin', 'organization_admin'].includes(userRole)) {
            orgFilter = 'AND organization_id = ?';
            orgFilterTop = 'AND al.organization_id = ?';
            params.push(userOrgId);
        }

        // Total events in period
        const totalResult = await env.DB.prepare(`
      SELECT COUNT(*) as total FROM activity_log WHERE created_at >= ? ${orgFilter}
    `).bind(...params).first() as any;

        // Events by action type
        const byActionType = await env.DB.prepare(`
      SELECT action_type, COUNT(*) as count 
      FROM activity_log 
      WHERE created_at >= ? ${orgFilter}
      GROUP BY action_type 
      ORDER BY count DESC
    `).bind(...params).all();

        // Events by target type
        const byTargetType = await env.DB.prepare(`
      SELECT target_type, COUNT(*) as count 
      FROM activity_log 
      WHERE created_at >= ? AND target_type IS NOT NULL ${orgFilter}
      GROUP BY target_type 
      ORDER BY count DESC
    `).bind(...params).all();

        // Top users by activity
        const topUsersParams = [startDateStr];
        if (['org_admin', 'organization_admin'].includes(userRole)) {
            topUsersParams.push(userOrgId);
        }

        const topUsers = await env.DB.prepare(`
      SELECT 
        al.user_id,
        u.name as user_name,
        u.email as user_email,
        COUNT(*) as activity_count
      FROM activity_log al
      LEFT JOIN users u ON al.user_id = u.id
      WHERE al.created_at >= ? AND al.user_id IS NOT NULL ${orgFilterTop}
      GROUP BY al.user_id, u.name, u.email
      ORDER BY activity_count DESC
      LIMIT 10
    `).bind(...topUsersParams).all();

        // Daily activity for chart
        const dailyActivity = await env.DB.prepare(`
      SELECT 
        DATE(created_at) as date,
        COUNT(*) as count
      FROM activity_log
      WHERE created_at >= ? ${orgFilter}
      GROUP BY DATE(created_at)
      ORDER BY date ASC
    `).bind(...params).all();

        // Security events
        const securityEvents = await env.DB.prepare(`
      SELECT COUNT(*) as count
      FROM activity_log
      WHERE created_at >= ? 
      AND (action_type LIKE '%FAILED%' OR action_type LIKE '%DENIED%' OR action_type LIKE '%UNAUTHORIZED%')
      ${orgFilter}
    `).bind(...params).first() as any;

        return c.json({
            period: { days, start_date: startDateStr },
            total_events: totalResult?.total || 0,
            by_action_type: byActionType.results || [],
            by_target_type: byTargetType.results || [],
            top_users: topUsers.results || [],
            daily_activity: dailyActivity.results || [],
            security_alerts: securityEvents?.count || 0
        });
    } catch (error) {
        console.error('Error fetching audit stats:', error);
        return c.json({ error: 'Erro ao buscar estatÃ­sticas de auditoria' }, 500);
    }
});

// GET /api/audit/export - Export logs as CSV
auditRoutes.get('/export', authMiddleware, requireAuditAccess, async (c) => {
    const env = c.env;
    const user = c.get('user');
    const userRole = user?.role || user?.profile?.role;
    const userOrgId = user?.organization_id || user?.profile?.organization_id;

    const url = new URL(c.req.url);
    const startDate = url.searchParams.get('start_date');
    const endDate = url.searchParams.get('end_date');

    try {
        let whereConditions: string[] = [];
        const params: any[] = [];
        // paramIndex removed

        if (['org_admin', 'organization_admin'].includes(userRole)) {
            whereConditions.push('al.organization_id = ?');
            params.push(userOrgId);
        }

        if (startDate) {
            whereConditions.push('al.created_at >= ?');
            params.push(startDate);
        }
        if (endDate) {
            whereConditions.push('al.created_at <= ?');
            params.push(endDate + 'T23:59:59Z');
        }

        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';

        const logs = await env.DB.prepare(`
      SELECT 
        al.id,
        al.created_at,
        u.email as user_email,
        u.name as user_name,
        al.action_type,
        al.action_description,
        al.target_type,
        al.target_id,
        o.name as organization_name
      FROM activity_log al
      LEFT JOIN users u ON al.user_id = u.id
      LEFT JOIN organizations o ON al.organization_id = o.id
      ${whereClause}
      ORDER BY al.created_at DESC
      LIMIT 10000
    `).bind(...params).all();

        // Build CSV
        const headers = ['ID', 'Data/Hora', 'UsuÃ¡rio', 'Email', 'AÃ§Ã£o', 'DescriÃ§Ã£o', 'Tipo Recurso', 'ID Recurso', 'OrganizaÃ§Ã£o'];
        const rows = (logs.results || []).map((log: any) => [
            log.id,
            log.created_at,
            log.user_name || '',
            log.user_email || '',
            log.action_type || '',
            (log.action_description || '').replace(/"/g, '""'),
            log.target_type || '',
            log.target_id || '',
            log.organization_name || ''
        ].map(val => `"${val}"`).join(','));

        const csv = [headers.join(','), ...rows].join('\n');

        return new Response(csv, {
            headers: {
                'Content-Type': 'text/csv; charset=utf-8',
                'Content-Disposition': `attachment; filename="audit_logs_${new Date().toISOString().split('T')[0]}.csv"`
            }
        });
    } catch (error) {
        console.error('Error exporting audit logs:', error);
        return c.json({ error: 'Erro ao exportar logs de auditoria' }, 500);
    }
});

// GET /api/audit/action-types - Get distinct action types for filter dropdown
auditRoutes.get('/action-types', authMiddleware, requireAuditAccess, async (c) => {
    const env = c.env;
    const user = c.get('user');
    const userRole = user?.role || user?.profile?.role;
    const userOrgId = user?.organization_id || user?.profile?.organization_id;

    try {
        let query = 'SELECT DISTINCT action_type FROM activity_log WHERE action_type IS NOT NULL';
        const params: any[] = [];

        if (['org_admin', 'organization_admin'].includes(userRole)) {
            query += ' AND organization_id = ?';
            params.push(userOrgId);
        }

        query += ' ORDER BY action_type';

        const result = await env.DB.prepare(query).bind(...params).all();

        return c.json({ action_types: (result.results || []).map((r: any) => r.action_type) });
    } catch (error) {
        console.error('Error fetching action types:', error);
        return c.json({ error: 'Erro ao buscar tipos de aÃ§Ã£o' }, 500);
    }
});

// GET /api/audit/target-types - Get distinct target types for filter dropdown
auditRoutes.get('/target-types', authMiddleware, requireAuditAccess, async (c) => {
    const env = c.env;
    const user = c.get('user');
    const userRole = user?.role || user?.profile?.role;
    const userOrgId = user?.organization_id || user?.profile?.organization_id;

    try {
        let query = 'SELECT DISTINCT target_type FROM activity_log WHERE target_type IS NOT NULL';
        const params: any[] = [];

        if (['org_admin', 'organization_admin'].includes(userRole)) {
            query += ' AND organization_id = ?';
            params.push(userOrgId);
        }

        query += ' ORDER BY target_type';

        const result = await env.DB.prepare(query).bind(...params).all();

        return c.json({ target_types: (result.results || []).map((r: any) => r.target_type) });
    } catch (error) {
        console.error('Error fetching target types:', error);
        return c.json({ error: 'Erro ao buscar tipos de recurso' }, 500);
    }
});

export { auditRoutes };
===END_FILE===
===FILE: supabase/functions/api/auth-routes.ts===
import { Hono } from "hono";
import { setCookie, deleteCookie, getCookie } from "hono/cookie";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { requireProtectedSysAdmin } from "./rbac-middleware.ts";


const authRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/auth');
console.log('[AUTH-ROUTES] Auth routes module loaded, typeof:', typeof authRoutes);

// Helper para hash de senha SEGURO usando PBKDF2 (recomendado para senhas)
// PBKDF2 Ã© lento por design, dificultando ataques de forÃ§a bruta
const PBKDF2_ITERATIONS = 100000;
const SALT_LENGTH = 16;

async function hashPassword(password: string, existingSalt?: string): Promise<string> {
    const encoder = new TextEncoder();

    // Gerar salt ou usar existente (para verificaÃ§Ã£o)
    let salt: Uint8Array;
    if (existingSalt) {
        salt = new Uint8Array(existingSalt.match(/.{2}/g)!.map(byte => parseInt(byte, 16)));
    } else {
        salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
    }

    // Importar senha como chave
    const keyMaterial = await crypto.subtle.importKey(
        'raw',
        encoder.encode(password),
        'PBKDF2',
        false,
        ['deriveBits']
    );

    // Derivar hash com PBKDF2
    const hashBuffer = await crypto.subtle.deriveBits(
        {
            name: 'PBKDF2',
            salt: salt,
            iterations: PBKDF2_ITERATIONS,
            hash: 'SHA-256'
        },
        keyMaterial,
        256
    );

    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const saltHex = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('');
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

    // Formato: salt$hash (permite extrair salt para verificaÃ§Ã£o)
    return `${saltHex}$${hashHex}`;
}

// FunÃ§Ã£o para verificar senha contra hash armazenado
async function verifyPassword(password: string, storedHash: string): Promise<boolean> {
    // Hash antigo (SHA-256 puro) nÃ£o tem '$'
    if (!storedHash.includes('$')) {
        // Compatibilidade: verificar com SHA-256 legado
        const msgBuffer = new TextEncoder().encode(password);
        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const legacyHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return legacyHash === storedHash;
    }

    // Hash novo (PBKDF2): extrair salt e verificar
    const [salt] = storedHash.split('$');
    const newHash = await hashPassword(password, salt);
    return newHash === storedHash;
}

// Debug endpoint to check permissions
authRoutes.get("/debug-permissions", tenantAuthMiddleware, requireProtectedSysAdmin(), (c) => {
    if (Deno.env.get('ENVIRONMENT') === 'production') {
        return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
    }

    const tenantContext = c.get("tenantContext");
    const user = c.get("user");
    return c.json({
        user_id: user?.id,
        role: user?.role,
        tenant_context: tenantContext
    });
});

// Get current user details - supports both Supabase auth and session cookie
authRoutes.get("/me", tenantAuthMiddleware, async (c) => {
    const env = c.env;

    // 1. Try Supabase auth user first (for Google login)
    let user = c.get('user');

    // 2. If no Supabase user, check session cookie (for email/password login)
    // SEGURANÃ‡A: dev-session sÃ³ Ã© aceito em ambiente de desenvolvimento
    // Fail Secure: Assume produÃ§Ã£o (false) a menos que explicitamente 'development'
    const isDevelopment = Deno.env.get('ENVIRONMENT') === 'development';

    if (!user) {
        const sessionToken = getCookie(c, 'mocha-session-token');
        if (sessionToken && sessionToken.startsWith('dev-session-') && isDevelopment) {
            const userId = sessionToken.replace('dev-session-', '');
            // Validate session by looking up user in DB
            const dbUser = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(userId).first();
            if (dbUser) {
                user = { id: dbUser.id, email: dbUser.email };
            }
        } else if (sessionToken && sessionToken.startsWith('dev-session-') && !isDevelopment) {
            console.warn('[AUTH-ROUTES] BLOQUEADO: Tentativa de usar dev-session em produÃ§Ã£o');
        }
    }

    if (!user) {
        return c.json({ user: null }); // Return null user instead of 401 for session checks
    }

    try {
        // Fetch full user details from DB to get role/name
        let dbUser = await env.DB.prepare("SELECT * FROM users WHERE id = ? OR email = ?").bind(user.id, user.email).first();

        if (!dbUser && user?.email) {
            const userName = (user as any).user_metadata?.full_name || (user as any).user_metadata?.name || user.email?.split('@')[0] || 'User';
            try {
                await env.DB.prepare(`
                    INSERT INTO users (id, email, name, role, is_active, approval_status, created_at, updated_at, avatar_url)
                    VALUES (?, ?, ?, 'inspector', true, 'pending', NOW(), NOW(), ?)
                `).bind(user.id, user.email, userName, (user as any).user_metadata?.avatar_url || (user as any).user_metadata?.picture || null).run();
                dbUser = await env.DB.prepare("SELECT * FROM users WHERE id = ? OR email = ?").bind(user.id, user.email).first();
            } catch (insertError) {
                console.error('[AUTH-ME] Auto-create user failed:', insertError);
            }
        }

        if (!dbUser) {
            return c.json({ user: null });
        }


        // VERIFICAÃ‡ÃƒO CRÃTICA: Bloquear APENAS usuÃ¡rios rejeitados
        if (dbUser.approval_status === 'rejected') {
            return c.json({
                error: "Conta recusada",
                message: "Sua solicitaÃ§Ã£o de cadastro foi recusada.",
                code: "APPROVAL_REJECTED",
                approval_status: "rejected",
                user: null
            }, 403);
        }

        // Build profile object as expected by frontend
        const profile = {
            // ... existing profile build ...

            id: dbUser.id,
            email: dbUser.email,
            name: dbUser.name,
            role: dbUser.role,
            organization_id: dbUser.organization_id,
            can_manage_users: dbUser.can_manage_users,
            can_create_organizations: dbUser.can_create_organizations,
            is_active: dbUser.is_active,
            managed_organization_id: dbUser.managed_organization_id,
            avatar_url: dbUser.avatar_url,
            created_at: dbUser.created_at,
            updated_at: dbUser.updated_at,
            profile_completed: true,
            approval_status: dbUser.approval_status
        };

        // Helper to extract Google Data
        let googleUserData = null;
        console.log('[AUTH-ME] User object keys:', user ? Object.keys(user) : 'null');
        console.log('[AUTH-ME] User metadata:', user ? (user as any).user_metadata : 'null');

        if (user && (user as any).user_metadata) {
            const meta = (user as any).user_metadata;
            console.log('[AUTH-ME] Meta keys:', Object.keys(meta));
            if (meta.picture || meta.avatar_url) {
                googleUserData = {
                    picture: meta.picture || meta.avatar_url,
                    name: meta.full_name || meta.name
                };
                console.log('[AUTH-ME] Extracted google_user_data:', googleUserData);

                // NOVO: Persistir avatar_url na tabela users se ainda nÃ£o existir
                if (!dbUser.avatar_url && googleUserData.picture) {
                    try {
                        await env.DB.prepare(`
                            UPDATE users SET avatar_url = ?, updated_at = NOW() WHERE id = ?
                        `).bind(googleUserData.picture, dbUser.id).run();
                        console.log('[AUTH-ME] Avatar URL persistido para usuÃ¡rio:', dbUser.id);
                    } catch (avatarErr) {
                        console.error('[AUTH-ME] Erro ao persistir avatar:', avatarErr);
                    }
                }
            }
        } else if ((user as any).google_user_data) {
            // Fallback if attached by middleware (though middleware might not run here)
            googleUserData = (user as any).google_user_data;
        }

        // Fetch accessible organizations
        // SYS_ADMIN gets ALL organizations, others get only their assigned ones
        let accessibleOrganizations: any[] = [];
        try {
            const isSysAdmin = ['sys_admin', 'system_admin', 'admin'].includes(dbUser.role?.toLowerCase());

            if (isSysAdmin) {
                // System Admin: Get ALL active organizations
                accessibleOrganizations = await env.DB.prepare(`
                    SELECT o.id, o.name, o.type, o.organization_level, 'sys_admin' as role, false as is_primary
                    FROM organizations o
                    WHERE o.is_active = true
                    ORDER BY o.name ASC
                `).all().then((res: any) => res.results || []);
                console.log(`[AUTH-ME] SysAdmin ${dbUser.email} has access to ${accessibleOrganizations.length} organizations`);
            } else {
                // Regular users: Get only assigned organizations
                accessibleOrganizations = await env.DB.prepare(`
                    SELECT o.id, o.name, o.type, o.organization_level, uo.role, uo.is_primary
                    FROM organizations o
                    JOIN user_organizations uo ON o.id = uo.organization_id
                    WHERE uo.user_id = ? AND o.is_active = true
                `).bind(dbUser.id).all().then((res: any) => res.results || []);
            }
        } catch (e) {
            console.error('[AUTH-ME] Error fetching user organizations:', e);
        }

        return c.json({
            success: true,
            user: {
                id: dbUser.id,
                email: dbUser.email,
                name: dbUser.name,
                role: dbUser.role,
                approval_status: dbUser.approval_status,
                profile: profile, // Frontend expects user.profile.role
                google_user_data: googleUserData, // Pass Verified Google Data
                organizations: accessibleOrganizations // N-to-N Orgs list
            }
        });
    } catch (error) {
        console.error('Error fetching user /me:', error);
        return c.json({ error: "Server error" }, 500);
    }
});

// Registro de usuÃ¡rio
authRoutes.post("/register", async (c) => {
    const env = c.env;

    try {
        const { email, password, name, organization_name, role, subscription_plan } = await c.req.json();

        if (!email || !password || !name) {
            return c.json({ error: "Email, senha e nome sÃ£o obrigatÃ³rios" }, 400);
        }

        // Database initialization removed (migrated to Postgres)

        // Verificar se usuÃ¡rio jÃ¡ existe
        const existingUser = await env.DB.prepare("SELECT id FROM users WHERE email = ?").bind(email).first();

        if (existingUser) {
            return c.json({ error: "Email jÃ¡ cadastrado" }, 409);
        }

        // Criar ID Ãºnico
        const userId = crypto.randomUUID();
        const passwordHash = await hashPassword(password);

        // Verificar se Ã© o usuÃ¡rio Admin de Bootstrap
        const isBootstrapAdmin = email === 'eng.tiagosm@gmail.com';

        // Definir Role Inicial
        let initialRole = role || 'inspector';

        // Se estiver criando organizaÃ§Ã£o, forÃ§a ser Admin da Org
        if (organization_name) {
            initialRole = 'org_admin';
        }

        // SanitizaÃ§Ã£o de seguranÃ§a: Impedir criaÃ§Ã£o direta de SysAdmin via API
        if (initialRole === 'sys_admin' || initialRole === 'system_admin') {
            if (isBootstrapAdmin) {
                initialRole = 'sys_admin'; // Permitido apenas para o e-mail mestre
            } else {
                initialRole = 'org_admin'; // Downgrade seguro
            }
        }

        // Definir Status: SEMPRE pendente, exceto o bootstrap admin
        const initialStatus = isBootstrapAdmin ? 'approved' : 'pending';

        // 1. Criar usuÃ¡rio (Agora com role dinÃ¢mico e status forÃ§ado)
        await env.DB.prepare(`
          INSERT INTO users (id, email, name, role, approval_status, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, NOW(), NOW())
        `).bind(userId, email, name, initialRole, initialStatus).run();

        // 2. Criar credenciais
        await env.DB.prepare(`
          INSERT INTO user_credentials (user_id, password_hash, created_at, updated_at)
          VALUES (?, ?, NOW(), NOW())
        `).bind(userId, passwordHash).run();

        // 3. Se forneceu nome da organizaÃ§Ã£o, criar e vincular
        if (organization_name) {

            // Determine Plan and Status
            const plan = subscription_plan || 'basic';
            const subStatus = (plan === 'pro' || plan === 'enterprise') ? 'pending_payment' : 'active';


            const orgResult = await env.DB.prepare(`
                INSERT INTO organizations (name, type, subscription_plan, subscription_status, created_at, updated_at)
                VALUES (?, 'company', ?, ?, NOW(), NOW())
            `).bind(organization_name, plan, subStatus).run();

            const orgId = orgResult.meta.last_row_id;

            // Vincular usuÃ¡rio Ã  organizaÃ§Ã£o criada
            await env.DB.prepare(`
                UPDATE users 
                SET organization_id = ?, can_manage_users = true, can_create_organizations = true
                WHERE id = ?
            `).bind(orgId, userId).run();
        }

        // NOTIFICAÃ‡ÃƒO: Avisar SysAdmins sobre novo cadastro urgente
        try {
            const sysAdmins = await env.DB.prepare("SELECT id FROM users WHERE role IN ('sys_admin', 'system_admin')").all();
            if (sysAdmins && sysAdmins.results) {
                const notifications = sysAdmins.results.map((admin: any) => ({
                    user_id: admin.id,
                    title: "Novo Cadastro Pendente",
                    message: `O usuÃ¡rio ${name} (${email}) se cadastrou e aguarda aprovaÃ§Ã£o.`,
                    type: "info",
                    link: "/users"
                }));

                // Bulk insert or loop
                for (const notif of notifications) {
                    await env.DB.prepare(`
                        INSERT INTO notifications (user_id, title, message, type, link) VALUES (?, ?, ?, ?, ?)
                    `).bind(notif.user_id, notif.title, notif.message, notif.type, notif.link).run();
                }
            }
        } catch (notifError) {
            console.error("Falha ao criar notificaÃ§Ã£o para admins:", notifError);
            // Non-blocking error
        }

        // TRIGGER EMAIL: Send welcome email (Pending Approval)
        try {
            const supabaseUrl = Deno.env.get('SUPABASE_URL');
            const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY');

            if (supabaseUrl && supabaseAnonKey) {
                fetch(`${supabaseUrl}/functions/v1/send-email`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${supabaseAnonKey}`
                    },
                    body: JSON.stringify({
                        type: 'welcome_pending',
                        payload: { email, name }
                    })
                }).catch(err => console.error("Failed to trigger welcome email:", err));
            }
        } catch (emailErr) {
            console.error("Error triggering welcome email:", emailErr);
        }

        // AUTO-LOGIN: Set session cookie immediately
        // SEGURANÃ‡A: Gerar token de sessÃ£o com UUID criptogrÃ¡fico
        const sessionToken = crypto.randomUUID();

        // SEGURANÃ‡A: Armazenar sessÃ£o no banco
        try {
            await env.DB.prepare(`
                INSERT INTO user_sessions (id, user_id, token, created_at, expires_at)
                VALUES (?, ?, ?, NOW(), NOW() + INTERVAL '7 days')
            `).bind(crypto.randomUUID(), userId, sessionToken).run();
        } catch (sessionErr) {
            console.warn('[AUTH] Warn saving session:', sessionErr);
        }

        // SEGURANÃ‡A: Cookie secure dinÃ¢mico
        const isProduction = Deno.env.get('ENVIRONMENT') !== 'development';

        setCookie(c, "mocha-session-token", sessionToken, {
            httpOnly: true,
            path: "/",
            sameSite: "Lax",
            secure: isProduction,
            maxAge: 60 * 60 * 24 * 7 // 7 dias
        });

        return c.json({
            success: true,
            message: "Conta criada com sucesso. Redirecionando...",
            requires_approval: true, // Still true, but we allow access to limited areas
            user: {
                id: userId,
                email,
                name,
                role: initialRole,
                approval_status: initialStatus
            }
        }, 201);

    } catch (error) {
        console.error('Erro no registro:', error);
        return c.json({ error: "Erro ao criar conta" }, 500);
    }
});

// Login
authRoutes.post("/login", async (c) => {
    const env = c.env;

    try {
        const { email, password } = await c.req.json();

        if (!email || !password) {
            return c.json({ error: "Email e senha sÃ£o obrigatÃ³rios" }, 400);
        }

        // initializeDatabase(env) removed

        // Buscar usuÃ¡rio e verificar status de aprovaÃ§Ã£o
        const user = await env.DB.prepare("SELECT * FROM users WHERE email = ?").bind(email).first();

        if (!user) {
            return c.json({ error: "Credenciais invÃ¡lidas" }, 401);
        }

        // VERIFICAÃ‡ÃƒO DE APROVAÃ‡ÃƒO
        // VERIFICAÃ‡ÃƒO DE APROVAÃ‡ÃƒO
        if (user.approval_status === 'rejected') {
            return c.json({
                error: "Conta recusada",
                message: "Sua solicitaÃ§Ã£o de cadastro foi recusada.",
                code: "APPROVAL_REJECTED"
            }, 403);
        }

        // Verificar senha
        const credentials = await env.DB.prepare("SELECT password_hash FROM user_credentials WHERE user_id = ?").bind(user.id).first();

        if (!credentials) {
            // UsuÃ¡rio existe mas sem senha (login social?)
            return c.json({ error: "Este usuÃ¡rio deve fazer login via Google" }, 401);
        }

        // Verificar senha (suporta hash novo PBKDF2 e legado SHA-256)
        const isValidPassword = await verifyPassword(password, credentials.password_hash as string);

        if (!isValidPassword) {
            return c.json({ error: "Credenciais invÃ¡lidas" }, 401);
        }


        // Login sucesso
        // Atualizar last_login
        await env.DB.prepare("UPDATE user_credentials SET last_login_at = NOW() WHERE user_id = ?").bind(user.id).run();

        // SEGURANÃ‡A: Gerar token de sessÃ£o com UUID criptogrÃ¡fico (nÃ£o previsÃ­vel)
        const sessionToken = crypto.randomUUID();

        // SEGURANÃ‡A: Armazenar sessÃ£o no banco para validaÃ§Ã£o futura
        try {
            await env.DB.prepare(`
                INSERT INTO user_sessions (id, user_id, token, created_at, expires_at)
                VALUES (?, ?, ?, NOW(), NOW() + INTERVAL '7 days')
            `).bind(crypto.randomUUID(), user.id, sessionToken).run();
        } catch (sessionErr) {
            console.warn('[AUTH] NÃ£o foi possÃ­vel salvar sessÃ£o no banco (tabela pode nÃ£o existir):', sessionErr);
        }

        // SEGURANÃ‡A: Cookie secure dinÃ¢mico baseado no ambiente
        const isProduction = Deno.env.get('ENVIRONMENT') !== 'development';

        setCookie(c, "mocha-session-token", sessionToken, {
            httpOnly: true,
            path: "/",
            sameSite: "Lax",
            secure: isProduction, // true em produÃ§Ã£o, false em dev
            maxAge: 60 * 60 * 24 * 7 // 7 dias
        });

        return c.json({
            success: true,
            user: {
                id: user.id,
                email: user.email,
                name: user.name,
                role: user.role
            }
        });

    } catch (error) {
        console.error('Erro no login:', error);
        return c.json({ error: "Erro ao realizar login" }, 500);
    }
});

// Logout
authRoutes.post("/logout", async (c) => {
    deleteCookie(c, "mocha-session-token");
    return c.json({ success: true });
});

// Forgot Password - Gera token e envia email
authRoutes.post("/forgot-password", async (c) => {
    const env = c.env;
    try {
        const { email } = await c.req.json();
        if (!email) {
            return c.json({ error: "Email Ã© obrigatÃ³rio" }, 400);
        }

        // 1. Verificar se usuÃ¡rio existe
        const user = await env.DB.prepare("SELECT id, name, email FROM users WHERE email = ?").bind(email).first();

        // SeguranÃ§a: Retornar sucesso mesmo se nÃ£o existir para evitar enumeraÃ§Ã£o de usuÃ¡rios
        // Mas logar internamente para debug
        if (!user) {
            console.log(`[AUTH-RESET] SolicitaÃ§Ã£o de reset para email inexistente: ${email}`);
            return c.json({ success: true, message: "Se o email estiver cadastrado, vocÃª receberÃ¡ um link de recuperaÃ§Ã£o." });
        }

        // 2. Gerar Token Ãºnico e Hash
        const token = crypto.randomUUID();
        // NÃ£o precisamos de hash complexo aqui, pois o token Ã© curto vida (1h) e random
        // Mas se quisessemos mais seguranÃ§a, poderiamos hashear. Por simplicidade e performance, guardamos direto.
        // O token Ã© o "segredo" enviado por email.

        // 3. Salvar token no banco
        // 3. Salvar token no banco
        // Definir validade de 1 hora explicitamente
        await env.DB.prepare(`
            INSERT INTO password_reset_tokens (user_id, token, expires_at)
            VALUES (?, ?, NOW() + INTERVAL '1 hour')
        `).bind(user.id, token).run();


        // 4. Enviar Email
        const supabaseUrl = Deno.env.get('SUPABASE_URL');
        const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY');
        const resetUrl = `https://compia.tech/reset-password?token=${token}`;

        if (supabaseUrl && supabaseAnonKey) {
            c.executionCtx.waitUntil(
                fetch(`${supabaseUrl}/functions/v1/email-worker`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${supabaseAnonKey}`
                    },
                    body: JSON.stringify({
                        to: user.email,
                        type: 'reset_password',
                        data: {
                            name: user.name,
                            resetUrl: resetUrl
                        }
                    })
                }).then(res => {
                    if (!res.ok) console.error("[AUTH-RESET] Falha ao enviar email do worker:", res.status);
                }).catch(err => console.error("[AUTH-RESET] Erro ao chamar email-worker:", err))
            );
        }

        return c.json({ success: true, message: "Se o email estiver cadastrado, vocÃª receberÃ¡ um link de recuperaÃ§Ã£o." });

    } catch (error) {
        console.error('Erro em forgot-password:', error);
        return c.json({ error: "Erro interno ao processar solicitaÃ§Ã£o" }, 500);
    }
});

// Reset Password - Valida token e atualiza senha
authRoutes.post("/reset-password", async (c) => {
    const env = c.env;
    try {
        const { token, newPassword } = await c.req.json();

        if (!token || !newPassword) {
            return c.json({ error: "Token e nova senha sÃ£o obrigatÃ³rios" }, 400);
        }

        // 1. Validar Token
        const tokenRecord = await env.DB.prepare(`
            SELECT * FROM password_reset_tokens 
            WHERE token = ? AND used = FALSE AND expires_at > NOW()
        `).bind(token).first();

        if (!tokenRecord) {
            return c.json({ error: "Token invÃ¡lido ou expirado" }, 400);
        }

        // 2. Hash da nova senha
        const newPasswordHash = await hashPassword(newPassword);

        // 3. Atualizar Credenciais
        await env.DB.prepare("UPDATE user_credentials SET password_hash = ?, updated_at = NOW() WHERE user_id = ?")
            .bind(newPasswordHash, tokenRecord.user_id).run();

        // 4. Marcar token como usado
        await env.DB.prepare("UPDATE password_reset_tokens SET used = TRUE WHERE id = ?")
            .bind(tokenRecord.id).run();

        // 5. Opcional: Invalidar sessÃµes antigas?
        // Por seguranÃ§a, seria bom, mas pode ser agressivo. Vamos manter logado quem estÃ¡ logado, 
        // mas quem esqueceu a senha provavelmente nÃ£o estÃ¡ logado.

        return c.json({ success: true, message: "Senha atualizada com sucesso" });

    } catch (error) {
        console.error('Erro em reset-password:', error);
        return c.json({ error: "Erro ao redefinir senha" }, 500);
    }
});

export default authRoutes;

===END_FILE===
===FILE: supabase/functions/api/auto-organize-folders.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";

const autoOrganizeRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();

// FunÃ§Ã£o para extrair categoria/NR do nome do checklist
function extractFolderName(templateName: string, category?: string): string | null {
    // Se categoria jÃ¡ existe, usar ela
    if (category && category.trim() !== '') {
        return category.trim();
    }

    // PadrÃµes comuns de NRs no nome
    const nrPatterns = [
        /^(NR[-\s]?\d{2})/i,           // NR-06, NR 06, NR06
        /^(NR[-\s]?\d{2}[-\s]?[A-Z]?)/i, // NR-12-A, NR 35 A
        /\((NR[-\s]?\d{2})\)/i,        // (NR-06)
    ];

    for (const pattern of nrPatterns) {
        const match = templateName.match(pattern);
        if (match) {
            // Normalizar formato: "NR-XX"
            const nr = match[1].replace(/\s+/g, '-').toUpperCase();
            return nr;
        }
    }

    // Se nÃ£o encontrou NR, tentar extrair primeira parte antes de " - "
    const parts = templateName.split(' - ');
    if (parts.length > 1 && parts[0].length < 50) {
        return parts[0].trim();
    }

    return null;
}

// FunÃ§Ã£o para gerar slug Ãºnico
function generateSlug(name: string, existing: string[] = []): string {
    let baseSlug = name
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '') // Remove acentos
        .replace(/[^a-z0-9]/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');

    let slug = baseSlug;
    let counter = 1;

    while (existing.includes(slug)) {
        slug = `${baseSlug}-${counter}`;
        counter++;
    }

    return slug;
}

// Endpoint para organizar automaticamente um template em pasta
autoOrganizeRoutes.post("/auto-organize/:templateId", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const templateId = c.req.param("templateId");

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        // Buscar perfil do usuÃ¡rio
        let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
        if (!userProfile && (user as any).profile) {
            userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
        }

        if (!userProfile?.organization_id) {
            return c.json({ error: "UsuÃ¡rio nÃ£o possui organizaÃ§Ã£o" }, 403);
        }

        // Buscar template
        const template = await env.DB.prepare(`
      SELECT id, name, category, folder_id, organization_id
      FROM checklist_templates 
      WHERE id = ? AND organization_id = ?
    `).bind(templateId, userProfile.organization_id).first() as any;

        if (!template) {
            return c.json({ error: "Template nÃ£o encontrado" }, 404);
        }

        // Se jÃ¡ estÃ¡ em uma pasta, nÃ£o fazer nada
        if (template.folder_id) {
            return c.json({
                message: "Template jÃ¡ estÃ¡ organizado em pasta",
                folder_id: template.folder_id
            });
        }

        // Extrair nome da pasta
        const folderName = extractFolderName(template.name, template.category);

        if (!folderName) {
            return c.json({
                message: "NÃ£o foi possÃ­vel determinar pasta automaticamente",
                organized: false
            });
        }

        // Verificar se pasta jÃ¡ existe
        let folder = await env.DB.prepare(`
      SELECT id FROM checklist_folders 
      WHERE organization_id = ? AND name = ? AND parent_id IS NULL
    `).bind(userProfile.organization_id, folderName).first() as any;

        let folderId: string;

        if (!folder) {
            // Criar nova pasta
            const existingSlugs = await env.DB.prepare(`
        SELECT slug FROM checklist_folders 
        WHERE organization_id = ? AND parent_id IS NULL
      `).bind(userProfile.organization_id).all();

            const slugs = existingSlugs.results.map((r: any) => r.slug);
            const slug = generateSlug(folderName, slugs);
            const path = `/${slug}`;

            const result = await env.DB.prepare(`
        INSERT INTO checklist_folders (
          organization_id, parent_id, name, slug, path, description,
          color, icon, display_order, created_at, updated_at
        ) VALUES (?, NULL, ?, ?, ?, ?, '#3B82F6', 'folder', 0, NOW(), NOW())
      `).bind(
                userProfile.organization_id,
                folderName,
                slug,
                path,
                `Pasta criada automaticamente para ${folderName}`
            ).run();

            folderId = result.meta.last_row_id as string;
        } else {
            folderId = folder.id;
        }

        // Mover template para a pasta
        await env.DB.prepare(`
      UPDATE checklist_templates 
      SET folder_id = ?, updated_at = NOW()
      WHERE id = ?
    `).bind(folderId, templateId).run();

        return c.json({
            message: "Template organizado automaticamente",
            folder_name: folderName,
            folder_id: folderId,
            organized: true
        });

    } catch (error) {
        console.error('Error auto-organizing template:', error);
        return c.json({ error: "Failed to auto-organize template" }, 500);
    }
});

// Endpoint para organizar TODOS os templates nÃ£o organizados
autoOrganizeRoutes.post("/auto-organize-all", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        // Buscar perfil do usuÃ¡rio
        let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
        if (!userProfile && (user as any).profile) {
            userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
        }

        if (!userProfile?.organization_id) {
            return c.json({ error: "UsuÃ¡rio nÃ£o possui organizaÃ§Ã£o" }, 403);
        }

        // Buscar todos os templates sem pasta
        const templates = await env.DB.prepare(`
      SELECT id, name, category
      FROM checklist_templates 
      WHERE organization_id = ? AND folder_id IS NULL AND is_category_folder = false
    `).bind(userProfile.organization_id).all();

        let organized = 0;
        let skipped = 0;
        const foldersCreated: Set<string> = new Set();

        for (const template of templates.results as any[]) {
            const folderName = extractFolderName(template.name, template.category);

            if (!folderName) {
                skipped++;
                continue;
            }

            // Verificar se pasta jÃ¡ existe
            let folder = await env.DB.prepare(`
        SELECT id FROM checklist_folders 
        WHERE organization_id = ? AND name = ? AND parent_id IS NULL
      `).bind(userProfile.organization_id, folderName).first() as any;

            let folderId: string;

            if (!folder) {
                // Criar nova pasta
                const existingSlugs = await env.DB.prepare(`
          SELECT slug FROM checklist_folders 
          WHERE organization_id = ? AND parent_id IS NULL
        `).bind(userProfile.organization_id).all();

                const slugs = existingSlugs.results.map((r: any) => r.slug);
                const slug = generateSlug(folderName, slugs);
                const path = `/${slug}`;

                const result = await env.DB.prepare(`
          INSERT INTO checklist_folders (
            organization_id, parent_id, name, slug, path, description,
            color, icon, display_order, created_at, updated_at
          ) VALUES (?, NULL, ?, ?, ?, ?, '#3B82F6', 'folder', 0, NOW(), NOW())
        `).bind(
                    userProfile.organization_id,
                    folderName,
                    slug,
                    path,
                    `Pasta criada automaticamente para ${folderName}`
                ).run();

                folderId = result.meta.last_row_id as string;
                foldersCreated.add(folderName);
            } else {
                folderId = folder.id;
            }

            // Mover template para a pasta
            await env.DB.prepare(`
        UPDATE checklist_templates 
        SET folder_id = ?, updated_at = NOW()
        WHERE id = ?
      `).bind(folderId, template.id).run();

            organized++;
        }

        return c.json({
            message: "OrganizaÃ§Ã£o automÃ¡tica concluÃ­da",
            templates_organized: organized,
            templates_skipped: skipped,
            folders_created: foldersCreated.size,
            folder_names: Array.from(foldersCreated)
        });

    } catch (error) {
        console.error('Error auto-organizing all templates:', error);
        return c.json({ error: "Failed to auto-organize templates" }, 500);
    }
});

export default autoOrganizeRoutes;

===END_FILE===
===FILE: supabase/functions/api/autosuggest-routes.ts===
import { Hono } from 'hono';
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";

const autosuggest = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/autosuggest');

type Env = {
  DB: any;
};

// Companies autosuggest - now returns recent companies when search is empty
autosuggest.get("/companies", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const search = c.req.query("search") || "";

  try {
    const user = c.get("user");
    if (!user) {
      return c.json({ suggestions: [] });
    }

    // Get user profile to check organization access
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    const isSystemAdmin = userProfile?.role === 'system_admin' || userProfile?.role === 'sys_admin' || userProfile?.role === 'admin';

    let companies;

    if (isSystemAdmin) {
      // System admin can see all organizations
      if (search.trim()) {
        // With search term - filter by name
        companies = await env.DB.prepare(`
          SELECT DISTINCT 
            COALESCE(o.nome_fantasia, o.name) as value, 
            COALESCE(o.nome_fantasia, o.name) as label, 
            o.contact_email as email,
            o.address,
            o.id as org_id
          FROM organizations o
          WHERE (COALESCE(o.nome_fantasia, o.name) LIKE ? OR o.razao_social LIKE ?)
            AND o.is_active = true
          ORDER BY COALESCE(o.nome_fantasia, o.name) 
          LIMIT 10
        `).bind(`%${search}%`, `%${search}%`).all();
      } else {
        // No search term - return all active companies ordered by name
        companies = await env.DB.prepare(`
          SELECT DISTINCT 
            COALESCE(o.nome_fantasia, o.name) as value, 
            COALESCE(o.nome_fantasia, o.name) as label, 
            o.contact_email as email,
            o.address,
            o.id as org_id
          FROM organizations o
          WHERE o.is_active = true
          ORDER BY COALESCE(o.nome_fantasia, o.name) 
          LIMIT 10
        `).all();
      }
    } else {
      // Non-admin users: get organizations from user_organizations table
      if (search.trim()) {
        companies = await env.DB.prepare(`
          SELECT DISTINCT 
            COALESCE(o.nome_fantasia, o.name) as value, 
            COALESCE(o.nome_fantasia, o.name) as label, 
            o.contact_email as email,
            o.address,
            o.id as org_id
          FROM organizations o
          INNER JOIN user_organizations uo ON uo.organization_id = o.id
          WHERE uo.user_id = ?
            AND uo.is_active = true
            AND o.is_active = true
            AND (COALESCE(o.nome_fantasia, o.name) LIKE ? OR o.razao_social LIKE ?)
          ORDER BY COALESCE(o.nome_fantasia, o.name) 
          LIMIT 10
        `).bind(user.id, `%${search}%`, `%${search}%`).all();
      } else {
        // No search - return all companies user has access to
        companies = await env.DB.prepare(`
          SELECT DISTINCT 
            COALESCE(o.nome_fantasia, o.name) as value, 
            COALESCE(o.nome_fantasia, o.name) as label, 
            o.contact_email as email,
            o.address,
            o.id as org_id
          FROM organizations o
          INNER JOIN user_organizations uo ON uo.organization_id = o.id
          WHERE uo.user_id = ?
            AND uo.is_active = true
            AND o.is_active = true
          ORDER BY COALESCE(o.nome_fantasia, o.name) 
          LIMIT 10
        `).bind(user.id).all();
      }

      // If no results from user_organizations, try user's primary organization
      if ((!companies.results || companies.results.length === 0) && userProfile?.organization_id) {
        companies = await env.DB.prepare(`
          SELECT DISTINCT 
            COALESCE(o.nome_fantasia, o.name) as value, 
            COALESCE(o.nome_fantasia, o.name) as label, 
            o.contact_email as email,
            o.address,
            o.id as org_id
          FROM organizations o
          WHERE o.id = ?
            OR o.parent_organization_id = ?
          ORDER BY COALESCE(o.nome_fantasia, o.name) 
          LIMIT 10
        `).bind(userProfile.organization_id, userProfile.organization_id).all();
      }
    }

    const results = (companies.results || []).slice(0, 10);
    console.log('[AUTOSUGGEST] Companies results:', JSON.stringify(results));

    return c.json({
      suggestions: results
    });
  } catch (error) {
    console.error('Error fetching company suggestions:', error);
    return c.json({ suggestions: [] });
  }
});


// Inspector suggestions
autosuggest.get('/inspectors', tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const search = c.req.query('search') || '';

  try {
    const user = c.get("user");
    if (!user) {
      return c.json({ suggestions: [] });
    }

    // First search in registered users (high priority)
    const userResults = await env.DB.prepare(
      `SELECT 
              name as value, 
              name as label, 
              email,
              100 as priority
       FROM users 
       WHERE (name LIKE ? OR email LIKE ?) 
         AND name IS NOT NULL AND name != '' 
         AND is_active = true
         AND (role = 'inspector' OR role = 'manager' OR role = 'admin' OR role = 'org_admin')
       ORDER BY name ASC
       LIMIT 8`
    )
      .bind(`%${search}%`, `%${search}%`)
      .all();

    // Then search in inspection data (lower priority)
    const inspectionResults = await env.DB.prepare(
      `SELECT DISTINCT 
              inspector_name as value, 
              inspector_name as label, 
              inspector_email as email, 
              COUNT(*) as usage_count,
              50 as priority
       FROM inspections 
       WHERE (inspector_name LIKE ? OR inspector_email LIKE ?)
         AND inspector_name IS NOT NULL AND inspector_name != ''
       GROUP BY inspector_name, inspector_email
       ORDER BY usage_count DESC, inspector_name ASC
       LIMIT 5`
    )
      .bind(`%${search}%`, `%${search}%`)
      .all();

    // Combine and remove duplicates
    const allSuggestions = [
      ...(userResults.results || []),
      ...(inspectionResults.results || [])
    ];

    const uniqueSuggestions = allSuggestions.reduce((acc: any[], current: any) => {
      const exists = acc.find((item: any) =>
        (item.value && current.value && item.value.toLowerCase() === current.value.toLowerCase()) ||
        (item.email && current.email && item.email.toLowerCase() === current.email.toLowerCase())
      );
      if (!exists && current.value) {
        acc.push({
          value: current.value,
          label: current.label,
          email: current.email,
          priority: current.priority
        });
      }
      return acc;
    }, [] as any[]);

    // Sort by priority and name
    uniqueSuggestions.sort((a, b) => {
      if (a.priority !== b.priority) {
        return b.priority - a.priority;
      }
      return a.value.localeCompare(b.value);
    });

    return c.json({
      suggestions: uniqueSuggestions.slice(0, 10)
    });
  } catch (error) {
    console.error('Error fetching inspector suggestions:', error);
    return c.json({ suggestions: [] });
  }
});

// Responsible person suggestions
autosuggest.get('/responsibles', tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const search = c.req.query('search') || '';

  try {
    const user = c.get("user");
    if (!user) {
      return c.json({ suggestions: [] });
    }

    // Search in registered users (high priority)
    const userResults = await env.DB.prepare(
      `SELECT 
              name as value, 
              name as label, 
              email,
              100 as priority
       FROM users 
       WHERE (name LIKE ? OR email LIKE ?) 
         AND name IS NOT NULL AND name != ''
         AND is_active = true
       ORDER BY name ASC
       LIMIT 8`
    )
      .bind(`%${search}%`, `%${search}%`)
      .all();

    // Search from existing inspections (lower priority)
    const inspectionResults = await env.DB.prepare(
      `SELECT DISTINCT 
              responsible_name as value, 
              responsible_name as label, 
              responsible_email as email,
              COUNT(*) as usage_count,
              50 as priority
       FROM inspections 
       WHERE (responsible_name LIKE ? OR responsible_email LIKE ?)
         AND responsible_name IS NOT NULL AND responsible_name != ''
       GROUP BY responsible_name, responsible_email
       ORDER BY usage_count DESC, responsible_name ASC
       LIMIT 6`
    )
      .bind(`%${search}%`, `%${search}%`)
      .all();

    // Combine results, prioritizing registered users
    const allSuggestions = [
      ...(userResults.results || []),
      ...(inspectionResults.results || [])
    ];

    // Remove duplicates
    const uniqueSuggestions = allSuggestions.reduce((acc: any[], current: any) => {
      const exists = acc.find((item: any) =>
        (item.value && current.value && item.value.toLowerCase() === current.value.toLowerCase()) ||
        (item.email && current.email && item.email.toLowerCase() === current.email.toLowerCase())
      );
      if (!exists && current.value) {
        acc.push({
          value: current.value,
          label: current.label,
          email: current.email,
          priority: current.priority
        });
      }
      return acc;
    }, [] as any[]);

    // Sort by priority and name
    uniqueSuggestions.sort((a, b) => {
      if (a.priority !== b.priority) {
        return b.priority - a.priority;
      }
      return a.value.localeCompare(b.value);
    });

    return c.json({
      suggestions: uniqueSuggestions.slice(0, 10)
    });
  } catch (error) {
    console.error('Error fetching responsible suggestions:', error);
    return c.json({ suggestions: [] });
  }
});

// Locations suggestions
autosuggest.get('/locations', tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const search = c.req.query('search') || '';

  try {
    const user = c.get("user");
    if (!user) {
      return c.json({ suggestions: [] });
    }

    const results = await env.DB.prepare(
      `SELECT DISTINCT location as value, location as label, COUNT(*) as usage_count
       FROM inspections 
       WHERE location LIKE ? AND location IS NOT NULL AND location != ''
       GROUP BY location
       ORDER BY usage_count DESC, location ASC
       LIMIT 10`
    )
      .bind(`%${search}%`)
      .all();

    return c.json({
      suggestions: (results.results || []).map((item: any) => ({
        value: item.value,
        label: item.label
      }))
    });
  } catch (error) {
    console.error('Error fetching location suggestions:', error);
    return c.json({ suggestions: [] });
  }
});

// Title suggestions for inspections
autosuggest.get('/inspection-titles', tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const search = c.req.query('search') || '';

  try {
    const user = c.get("user");
    if (!user) {
      return c.json({ suggestions: [] });
    }

    // Search existing titles
    const existingTitles = await env.DB.prepare(
      `SELECT DISTINCT title as value, title as label, COUNT(*) as usage_count
       FROM inspections 
       WHERE title LIKE ? AND title IS NOT NULL AND title != ''
       GROUP BY title
       ORDER BY usage_count DESC, title ASC
       LIMIT 8`
    )
      .bind(`%${search}%`)
      .all();

    // Add default suggestions based on common inspection types
    const defaultSuggestions = [
      'InspeÃ§Ã£o de Equipamentos de ProteÃ§Ã£o Individual (EPI)',
      'InspeÃ§Ã£o de SeguranÃ§a em Altura',
      'InspeÃ§Ã£o de Equipamentos de ProteÃ§Ã£o Coletiva (EPC)',
      'InspeÃ§Ã£o de MÃ¡quinas e Equipamentos',
      'InspeÃ§Ã£o de InstalaÃ§Ãµes ElÃ©tricas',
      'InspeÃ§Ã£o de Ambiente de Trabalho',
      'InspeÃ§Ã£o de SinalizaÃ§Ã£o de SeguranÃ§a',
      'InspeÃ§Ã£o de Ergonomia e Postura',
      'InspeÃ§Ã£o de PrevenÃ§Ã£o Contra IncÃªndio',
      'InspeÃ§Ã£o de Produtos QuÃ­micos e FISPQ'
    ].filter(suggestion =>
      search === '' || suggestion.toLowerCase().includes(search.toLowerCase())
    ).slice(0, 5).map(suggestion => ({
      value: suggestion,
      label: suggestion,
      usage_count: 0,
      is_default: true
    }));

    const allSuggestions = [
      ...(existingTitles.results || []),
      ...defaultSuggestions
    ];

    // Remove duplicates
    const uniqueSuggestions = allSuggestions.reduce((acc: any[], current: any) => {
      const exists = acc.find((item: any) =>
        item.value.toLowerCase() === current.value.toLowerCase()
      );
      if (!exists) {
        acc.push(current);
      }
      return acc;
    }, [] as any[]);

    return c.json({
      suggestions: uniqueSuggestions.slice(0, 10)
    });
  } catch (error) {
    console.error('Error fetching title suggestions:', error);
    return c.json({ suggestions: [] });
  }
});

// Description suggestions for inspections
autosuggest.get('/inspection-descriptions', tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const search = c.req.query('search') || '';

  try {
    const user = c.get("user");
    if (!user) {
      return c.json({ suggestions: [] });
    }

    // Search existing descriptions
    const existingDescriptions = await env.DB.prepare(
      `SELECT DISTINCT description as value, description as label, COUNT(*) as usage_count
       FROM inspections 
       WHERE description LIKE ? AND description IS NOT NULL AND description != '' AND LENGTH(description) > 10
       GROUP BY description
       ORDER BY usage_count DESC, description ASC
       LIMIT 6`
    )
      .bind(`%${search}%`)
      .all();

    // Add default suggestions based on common descriptions
    const defaultSuggestions = [
      'VerificaÃ§Ã£o de conformidade com as normas regulamentadoras de seguranÃ§a do trabalho',
      'AvaliaÃ§Ã£o dos equipamentos de proteÃ§Ã£o individual e coletiva disponÃ­veis',
      'InspeÃ§Ã£o das condiÃ§Ãµes gerais de seguranÃ§a e higiene do ambiente de trabalho',
      'VerificaÃ§Ã£o do cumprimento dos procedimentos de seguranÃ§a estabelecidos',
      'AvaliaÃ§Ã£o dos riscos ocupacionais e medidas de controle implementadas',
      'InspeÃ§Ã£o preventiva para identificaÃ§Ã£o de potenciais riscos Ã  seguranÃ§a',
      'VerificaÃ§Ã£o da adequaÃ§Ã£o das instalaÃ§Ãµes Ã s normas de seguranÃ§a vigentes',
      'AvaliaÃ§Ã£o da eficÃ¡cia dos treinamentos de seguranÃ§a ministrados'
    ].filter(suggestion =>
      search === '' || suggestion.toLowerCase().includes(search.toLowerCase())
    ).slice(0, 4).map(suggestion => ({
      value: suggestion,
      label: suggestion,
      usage_count: 0,
      is_default: true
    }));

    const allSuggestions = [
      ...(existingDescriptions.results || []),
      ...defaultSuggestions
    ];

    // Remove duplicates
    const uniqueSuggestions = allSuggestions.reduce((acc: any[], current: any) => {
      const exists = acc.find((item: any) =>
        item.value && current.value &&
        item.value.toLowerCase().trim() === current.value.toLowerCase().trim()
      );
      if (!exists && current.value) {
        acc.push({
          value: current.value,
          label: current.label,
          usage_count: current.usage_count || 0,
          is_default: current.is_default || false
        });
      }
      return acc;
    }, [] as any[]);

    return c.json({
      suggestions: uniqueSuggestions.slice(0, 8)
    });
  } catch (error) {
    console.error('Error fetching description suggestions:', error);
    return c.json({ suggestions: [] });
  }
});

export default autosuggest;

===END_FILE===
===FILE: supabase/functions/api/calendar-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { requireProtectedSysAdmin } from "./rbac-middleware.ts";
import { ExtendedMochaUser, USER_ROLES } from "./user-types.ts";

type Env = {
    DB: any;
};

const getDatabase = (env: any) => env.DB;

/**
 * Chronos Lei 2: VerificaÃ§Ã£o de conflito de agendamento e Lei 5: Respeito a HorÃ¡rios/Feriados
 * Retorna eventos que conflitam com o perÃ­odo solicitado ou violaÃ§Ãµes de regras
 */
async function checkConflict(
    db: any,
    orgId: string,
    startTime: string,
    endTime: string,
    participantEmail?: string,
    excludeEventId?: string | number
): Promise<{ hasConflict: boolean; conflictingEvents: any[]; violationType?: 'overlap' | 'business_hours' | 'holiday' }> {
    try {
        // 1. Verificar ConfiguraÃ§Ãµes da Agenda (Feriados e HorÃ¡rio Comercial)
        try {
            // Tentar buscar configuraÃ§Ãµes (pode nÃ£o existir se a tabela ainda nÃ£o foi criada/populada)
            const settings = await db.prepare("SELECT * FROM calendar_settings WHERE organization_id = ?").bind(orgId).first() as any;

            if (settings) {
                const holidays = JSON.parse(settings.holidays || '[]');
                const businessHours = JSON.parse(settings.business_hours || '{}');
                const timezone = settings.timezone || 'UTC';

                const start = new Date(startTime);
                const end = new Date(endTime);

                // Verificar Feriados
                const startStr = start.toISOString().split('T')[0];
                const holiday = holidays.find((h: any) => h.date === startStr);

                if (holiday) {
                    return {
                        hasConflict: true,
                        conflictingEvents: [{
                            id: 'holiday',
                            title: `Feriado: ${holiday.name}`,
                            start_time: `${startStr}T00:00:00Z`,
                            end_time: `${startStr}T23:59:59Z`,
                            event_type: 'block'
                        }],
                        violationType: 'holiday'
                    };
                }

                // Verificar HorÃ¡rio Comercial (apenas se configurado)
                if (businessHours.start && businessHours.end) {
                    // Converter para minutos para facilitar comparaÃ§Ã£o
                    const getMinutes = (timeStr: string) => {
                        const [h, m] = timeStr.split(':').map(Number);
                        return h * 60 + m;
                    };

                    // Extrair hora do evento (assumindo que start_time estÃ¡ em UTC, precisaria converter para timezone da org,
                    // mas por simplificaÃ§Ã£o aqui vamos extrair UTC hours se timezone for UTC-3 aprox ou usar lib de data se tiver
                    // Como nÃ£o temos date-fns aqui, vamos fazer uma verificaÃ§Ã£o simples:
                    // Se o evento comeÃ§a antes de businessHours.start ou termina depois de businessHours.end (em UTC ajustado)

                    // TODO: Melhorar suporte a timezone real no backend. Por enquanto, focado em conflitos de OVERLAP.
                }
            }
        } catch (e) {
            // Log warning instead of silently swallowing
            console.warn('[Chronos] Calendar settings check skipped:', e);
        }

        // 2. Verificar conflitos em calendar_events
        let query = `
            SELECT id, title, start_time, end_time, event_type
            FROM calendar_events
            WHERE organization_id = ?
              AND start_time < ?
              AND end_time > ?
        `;
        const params: any[] = [orgId, endTime, startTime];

        // Excluir o prÃ³prio evento (para ediÃ§Ãµes)
        if (excludeEventId && !String(excludeEventId).startsWith('inspection-')) {
            query += ` AND id != ?`;
            params.push(excludeEventId);
        }

        // Filtrar por participante se fornecido
        if (participantEmail) {
            query += ` AND (participants::text LIKE ? OR created_by IN (SELECT id FROM users WHERE email = ?))`;
            params.push(`%"${participantEmail}"%`, participantEmail);
        }

        query += ` LIMIT 5`;

        const calendarConflicts = await db.prepare(query).bind(...params).all();
        const conflicts = calendarConflicts.results || [];

        // Verificar conflitos em inspections tambÃ©m
        if (participantEmail) {
            let inspectionQuery = `
                SELECT id, title as project_name, scheduled_date, status
                FROM inspections
                WHERE organization_id = ?
                  AND inspector_email = ?
                  AND scheduled_date IS NOT NULL
                  AND scheduled_date >= ?
                  AND scheduled_date < ?
                  AND status NOT IN ('cancelled', 'completed')
            `;
            const inspParams: any[] = [orgId, participantEmail, startTime, endTime];

            // Excluir prÃ³pria inspeÃ§Ã£o
            if (excludeEventId && String(excludeEventId).startsWith('inspection-')) {
                const realId = String(excludeEventId).replace('inspection-', '');
                inspectionQuery += ` AND id != ?`;
                inspParams.push(realId);
            }

            inspectionQuery += ` LIMIT 5`;

            const inspectionConflicts = await db.prepare(inspectionQuery).bind(...inspParams).all();
            if (inspectionConflicts.results) {
                conflicts.push(...inspectionConflicts.results.map((i: any) => ({
                    id: `inspection-${i.id}`,
                    title: i.project_name?.startsWith('InspeÃ§Ã£o:') ? i.project_name : `InspeÃ§Ã£o: ${i.project_name}`,
                    start_time: i.scheduled_date,
                    end_time: new Date(new Date(i.scheduled_date).getTime() + 60 * 60 * 1000).toISOString(),
                    event_type: 'inspection'
                })));
            }
        }

        return {
            hasConflict: conflicts.length > 0,
            conflictingEvents: conflicts
        };
    } catch (error) {
        console.error('[Chronos] Error checking conflict:', error);
        // Em caso de erro, nÃ£o bloquear - apenas logar
        return { hasConflict: false, conflictingEvents: [] };
    }
}

const app = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/calendar');

// ROTA TEMPORÃRIA PARA TESTE DE PERFORMANCE (seed)
app.get('/seed-test', tenantAuthMiddleware, async (c) => {
    const user = c.get('user') as ExtendedMochaUser;
    const db = getDatabase(c.env);

    const userProfile = await db.prepare("SELECT organization_id, managed_organization_id, email FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile) return c.json({ error: "User not found" }, 404);

    const orgId = userProfile.managed_organization_id || userProfile.organization_id;
    const email = userProfile.email;

    // Inserir 50 eventos
    const statements = [];
    const baseDate = new Date(); // Hoje

    for (let i = 0; i < 50; i++) {
        const dayOffset = Math.floor(i / 5); // 5 eventos por dia
        const hourOffset = (i % 5) + 8; // ComeÃ§a as 8h

        const startTime = new Date(baseDate);
        startTime.setDate(baseDate.getDate() + dayOffset);
        startTime.setHours(hourOffset, 0, 0, 0);

        const endTime = new Date(startTime);
        endTime.setHours(hourOffset + 1, 0, 0, 0);

        statements.push(db.prepare(`
            INSERT INTO calendar_events (
                organization_id, title, description, start_time, end_time, 
                event_type, created_by, participants, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
        `).bind(
            orgId,
            `Teste Performance ${i + 1}`,
            `Evento gerado automaticamente para teste de carga #${i + 1}`,
            startTime.toISOString(),
            endTime.toISOString(),
            i % 2 === 0 ? 'meeting' : 'focus',
            user.id,
            JSON.stringify([email])
        ));
    }

    await db.batch(statements);
    return c.json({ message: "50 eventos criados com sucesso", orgId });
});

// List events (Integrated with Inspections and Action Plans)
app.get('/', tenantAuthMiddleware, async (c) => {
    try {
        const user = c.get('user') as ExtendedMochaUser;
        const db = getDatabase(c.env);

        const startDate = c.req.query('start_date');
        const endDate = c.req.query('end_date');

        // Get user profile to know which organization to fetch for
        const userProfile = await db.prepare("SELECT organization_id, managed_organization_id, role, email FROM users WHERE id = ?").bind(user.id).first() as any;

        if (!userProfile) {
            return c.json({ error: "User profile not found" }, 404);
        }

        const orgId = userProfile.managed_organization_id || userProfile.organization_id;
        // User email for participation check
        const userEmail = userProfile.email || user.email;

        if (!orgId) {
            return c.json({ error: "User is not associated with any organization" }, 400);
        }

        const events = [];

        // 1. Fetch Calendar Events (Rich Manual Events)
        try {
            // Check for Org OR Participation
            // Note: participants is stored as stringified JSON array in TEXT column usually
            // We use LIKE for partial match as simple workaround. proper JSONB would be better.
            let query = `
          SELECT * FROM calendar_events 
          WHERE (organization_id = ? OR participants::text LIKE ?)
        `;
            const params: any[] = [orgId, `%"${userEmail}"%`];

            if (startDate) {
                query += ` AND end_time >= ?`;
                params.push(startDate);
            }

            if (endDate) {
                query += ` AND start_time <= ?`;
                params.push(endDate);
            }

            const calendarEvents = await db.prepare(query).bind(...params).all();

            if (calendarEvents.results) {
                events.push(...calendarEvents.results.map((e: any) => ({
                    ...e,
                    source: 'calendar',
                    readonly: e.organization_id !== orgId, // Readonly if not my org (simplified)
                    participants: typeof e.participants === 'string' ? JSON.parse(e.participants) : (e.participants || []),
                    accepted_by: typeof e.accepted_by === 'string' ? JSON.parse(e.accepted_by) : (e.accepted_by || []),
                    declined_by: typeof e.declined_by === 'string' ? JSON.parse(e.declined_by) : (e.declined_by || []),
                    scope_items: typeof e.scope_items === 'string' ? JSON.parse(e.scope_items) : (e.scope_items || []),
                    attachments: typeof e.attachments === 'string' ? JSON.parse(e.attachments) : (e.attachments || []),
                    // Preserve new fields
                    location: e.location,
                    meeting_link: e.meeting_link,
                    google_event_id: e.google_event_id,
                    notification_body: e.notification_body
                })));
            }
        } catch (e: any) {
            console.error('[CALENDAR_DEBUG] Error fetching calendar_events:', e);
            throw new Error(`Failed to fetch calendar_events: ${e.message}`);
        }

        // 2. Fetch Inspections (System)
        try {
            // Fetch Org Inspections OR Assigned Inspections
            let inspectionQuery = `
                SELECT id, title as project_name, scheduled_date, status, 'InspeÃ§Ã£o PrÃ¡tica' as inspection_type, 
                       company_name, client_id, address, location, organization_id, inspector_email, accepted_by, declined_by,
                       cep, logradouro, numero, complemento, bairro, cidade, uf
                FROM inspections
                WHERE (organization_id = ? OR inspector_email = ?) 
                AND scheduled_date IS NOT NULL
            `;
            const inspectionParams: any[] = [orgId, userEmail];

            if (startDate) {
                inspectionQuery += ` AND scheduled_date >= ?`;
                inspectionParams.push(startDate);
            }
            if (endDate) {
                inspectionQuery += ` AND scheduled_date <= ?`;
                inspectionParams.push(endDate);
            }

            const inspections = await db.prepare(inspectionQuery).bind(...inspectionParams).all();
            if (inspections.results) {
                events.push(...inspections.results.map((i: any) => ({
                    id: `inspection-${i.id}`, // Virtual ID
                    original_id: i.id,
                    title: i.project_name?.startsWith('InspeÃ§Ã£o:') ? i.project_name : `InspeÃ§Ã£o: ${i.project_name}`,
                    description: `Status: ${i.status}`,
                    start_time: i.scheduled_date,
                    end_time: new Date(new Date(i.scheduled_date).getTime() + 60 * 60 * 1000).toISOString(), // Assume 1h
                    event_type: 'inspection',
                    source: 'inspection',
                    readonly: i.organization_id !== orgId, // Readonly if not my org
                    status: i.status === 'completed' ? 'completed' : 'scheduled',
                    company_name: i.company_name,
                    client_id: i.client_id,
                    location: i.location || i.address,
                    // Granular Address Mapping for EventModal
                    cep: i.cep,
                    logradouro: i.logradouro,
                    numero: i.numero,
                    complemento: i.complemento,
                    bairro: i.bairro,
                    cidade: i.cidade,
                    uf: i.uf,
                    participants: i.inspector_email ? [i.inspector_email] : [],
                    accepted_by: typeof i.accepted_by === 'string' ? JSON.parse(i.accepted_by) : (i.accepted_by || []),
                    declined_by: typeof i.declined_by === 'string' ? JSON.parse(i.declined_by) : (i.declined_by || [])
                })));
            }
        } catch (e: any) {
            console.error('[CALENDAR_DEBUG] Error fetching inspections:', e);
            throw new Error(`Failed to fetch inspections: ${e.message}`);
        }

        // 3. Fetch Action Plans (System)
        try {
            let actionPlanQuery = `
                SELECT id, description, due_date, status, priority
                FROM action_plans
                WHERE organization_id = ? AND due_date IS NOT NULL
            `;
            const actionParams: any[] = [orgId];

            if (startDate) {
                actionPlanQuery += ` AND due_date >= ?`;
                actionParams.push(startDate);
            }
            if (endDate) {
                actionPlanQuery += ` AND due_date <= ?`;
                actionParams.push(endDate);
            }

            const actionPlans = await db.prepare(actionPlanQuery).bind(...actionParams).all();
            if (actionPlans.results) {
                events.push(...actionPlans.results.map((a: any) => ({
                    id: `action-${a.id}`, // Virtual ID
                    original_id: a.id,
                    title: `Plano de AÃ§Ã£o: ${a.description.substring(0, 30)}...`,
                    description: `Prioridade: ${a.priority}. Status: ${a.status}`,
                    start_time: a.due_date,
                    end_time: a.due_date, // Deadline is a point in time
                    event_type: 'blocking', // Blocking/Deadline type
                    source: 'action_plan',
                    readonly: true,
                    status: a.status === 'completed' ? 'completed' : 'scheduled'
                })));
            }
        } catch (e: any) {
            console.error('[CALENDAR_DEBUG] Error fetching action_plans:', e);
            // If action_plans doesn't exist, ignore it for now to not block calendar
            // throw new Error(`Failed to fetch action_plans: ${e.message}`);
        }

        // Sort by start_time
        events.sort((a, b) => new Date(a.start_time).getTime() - new Date(b.start_time).getTime());

        return c.json(events);

    } catch (error) {
        console.error('Error fetching calendar events FULL:', error);
        if (error instanceof Error) {
            console.error('Stack:', error.stack);
            console.error('Message:', error.message);
        }
        return c.json({ error: 'Erro ao buscar eventos do calendÃ¡rio', details: String(error) }, 500);
    }
});

// Create event (Rich + Integration Hooks + Inspection Automation)
app.post('/', tenantAuthMiddleware, async (c) => {
    try {
        const user = c.get('user') as ExtendedMochaUser;
        const db = getDatabase(c.env);
        const body = await c.req.json();

        const {
            title,
            description,
            start_time,
            end_time,
            event_type,
            metadata,
            // New Rich Fields
            participants,
            scope_items,
            attachments,
            location,
            meeting_link,
            notification_body,
            // Integration Flags
            create_meet,
            notify_email,
            // Inspection Specifics
            template_id,
            company_name, // or client_id
            client_id
        } = body;

        // Validation
        if (!title || !start_time || !end_time || !event_type) {
            return c.json({ error: "Campos obrigatÃ³rios: title, start_time, end_time, event_type" }, 400);
        }

        // Get user profile
        const userProfile = await db.prepare("SELECT organization_id, managed_organization_id, role, name, email FROM users WHERE id = ?").bind(user.id).first() as any;

        if (!userProfile) {
            return c.json({ error: "User profile not found" }, 404);
        }

        const orgId = userProfile.managed_organization_id || userProfile.organization_id;

        if (!orgId) {
            return c.json({ error: "User is not associated with any organization" }, 400);
        }

        // --- CHRONOS LEI 2: VerificaÃ§Ã£o de conflito ---
        // Determinar o email do participante principal para verificaÃ§Ã£o
        const primaryParticipant = participants && participants.length > 0
            ? (typeof participants[0] === 'string' ? participants[0] : participants[0].email)
            : userProfile.email;

        // Verificar se forÃ§a a criaÃ§Ã£o mesmo com conflito
        const forceCreate = body.force_conflict === true;

        if (!forceCreate) {
            const conflictCheck = await checkConflict(
                db,
                orgId,
                start_time,
                end_time,
                primaryParticipant
            );

            if (conflictCheck.hasConflict) {
                return c.json({
                    error: "Conflito de horÃ¡rio detectado",
                    conflict: true,
                    conflicting_events: conflictCheck.conflictingEvents,
                    message: "JÃ¡ existe um evento neste horÃ¡rio. Envie force_conflict=true para criar mesmo assim."
                }, 409);
            }
        }

        // --- INSPECTION CREATION LOGIC ---
        if (event_type === 'inspection') {
            console.log('[Calendar] Creating Inspection explicitly:', title);

            // Extract primary inspector from participants or use current user
            let inspectorName = userProfile.name;
            let inspectorEmail = userProfile.email;

            if (participants && participants.length > 0) {
                const first = participants[0];
                if (typeof first === 'string') {
                    // It's an email string
                    inspectorEmail = first;
                    // Try to find name if possible, otherwise use email as name or keep default? 
                    // Ideally we should lookup the user, but for now let's use the email prefix or keep generic if we can't find it.
                    // Actually, if we are assigning someone else, we might not have their name readily available in the body.
                    // Let's rely on the email.
                    inspectorName = first.split('@')[0];
                } else if (first.email) {
                    inspectorEmail = first.email;
                    inspectorName = first.name || first.email.split('@')[0];
                }
            }

            const inspectionQuery = `
                INSERT INTO inspections (
                    organization_id, created_by, title, scheduled_date, 
                    status, 
                    participants, location, company_name, client_id, template_id,
                    inspector_name, inspector_email,
                    description,
                    cep, logradouro, numero, complemento, bairro, cidade, uf
                ) VALUES (
                    ?, ?, ?, ?, 
                    'scheduled',
                    ?, ?, ?, ?, ?,
                    ?, ?,
                    ?,
                    ?, ?, ?, ?, ?, ?, ?
                ) RETURNING *
            `;

            // Use template_id if provided, otherwise null (Deferred Configuration)
            const resolvedTemplateId = template_id || null;

            // Extract detailed address fields from body
            const { cep, logradouro, numero, complemento, bairro, cidade, uf } = body;

            const inspectionResult = await db.prepare(inspectionQuery).bind(
                orgId, user.id, title, start_time,
                JSON.stringify(participants || []), location || '', company_name || '', client_id || null, resolvedTemplateId,
                inspectorName, inspectorEmail,
                description ? `${description} (Agendado por: ${userProfile.name})` : `Agendado via Agenda por: ${userProfile.name}`,
                cep || null, logradouro || null, numero || null, complemento || null, bairro || null, cidade || null, uf || null
            ).first();

            // Log Activity
            await db.prepare(`
                INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
                VALUES(?, ?, ?, ?, ?, ?, NOW())
            `).bind(
                user.id, orgId, 'inspection_scheduled',
                `Agendou inspeÃ§Ã£o: ${title}`, 'inspection', inspectionResult.id.toString()
            ).run();

            // Create initial history record
            await db.prepare(`
                INSERT INTO inspection_status_history (inspection_id, status_from, status_to, changed_by, created_at)
                VALUES (?, NULL, 'scheduled', ?, NOW())
            `).bind(inspectionResult.id, user.id).run();

            return c.json({ ...inspectionResult, id: `inspection-${inspectionResult.id}`, original_id: inspectionResult.id, source: 'inspection', integration_status: 'created_inspection' });
        }

        // --- STANDARD CALENDAR EVENT ---

        // Integration Logic Placeholder (Google Meet, etc)
        // For V1, we just save the request.

        // Insert
        const query = `
            INSERT INTO calendar_events (
                organization_id, created_by, title, description, 
                start_time, end_time, event_type, metadata,
                participants, scope_items, attachments, 
                location, meeting_link, notification_body,
                company_name, client_id
            ) VALUES (
                ?, ?, ?, ?, ?, ?, ?, ?,
                ?, ?, ?, ?, ?, ?,
                ?, ?
            ) RETURNING *
        `;

        const result = await db.prepare(query).bind(
            orgId, user.id, title, description || null,
            start_time, end_time, event_type, JSON.stringify(metadata || {}),
            JSON.stringify(participants || []),
            JSON.stringify(scope_items || []),
            JSON.stringify(attachments || []),
            location || null,
            meeting_link || null,
            notification_body || null,
            company_name || null,
            client_id || null
        ).first();

        // Log Activity
        await db.prepare(`
        INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
        VALUES(?, ?, ?, ?, ?, ?, NOW())
    `).bind(
            user.id, orgId, 'event_created',
            `Criou evento: ${title}`, 'calendar_event', result.id.toString()
        ).run();

        return c.json({ ...result, integration_status: 'ok' });

    } catch (error) {
        console.error('Error creating calendar event:', error);
        return c.json({ error: 'Erro ao criar evento' }, 500);
    }
});

// Update event
app.put('/:id', tenantAuthMiddleware, async (c) => {
    try {
        const user = c.get('user') as ExtendedMochaUser;
        const db = getDatabase(c.env);
        const eventId = c.req.param('id');
        const body = await c.req.json();

        // Get user profile first as we need orgId for both branches
        const userProfile = await db.prepare("SELECT organization_id, managed_organization_id, role FROM users WHERE id = ?").bind(user.id).first() as any;
        if (!userProfile) return c.json({ error: "User profile not found" }, 404);

        const orgId = userProfile.managed_organization_id || userProfile.organization_id;

        // --- CHRONOS LEI 2: VerificaÃ§Ã£o de conflito na ediÃ§Ã£o ---
        const { start_time, end_time, participants, force_conflict } = body;

        if (start_time && end_time && !force_conflict) {
            const primaryParticipant = participants && participants.length > 0
                ? (typeof participants[0] === 'string' ? participants[0] : participants[0].email)
                : userProfile.email;

            const conflictCheck = await checkConflict(
                db,
                orgId,
                start_time,
                end_time,
                primaryParticipant,
                eventId // Excluir o prÃ³prio evento
            );

            if (conflictCheck.hasConflict) {
                return c.json({
                    error: "Conflito de horÃ¡rio detectado",
                    conflict: true,
                    conflicting_events: conflictCheck.conflictingEvents,
                    message: "JÃ¡ existe um evento neste horÃ¡rio. Envie force_conflict=true para atualizar mesmo assim."
                }, 409);
            }
        }

        // Check if it's a virtual inspection ID
        if (eventId.startsWith('inspection-')) {
            const realId = eventId.replace('inspection-', '');

            // Map fields back to inspection columns
            const { title, start_time, company_name, client_id, description, location, participants, cep, logradouro, numero, bairro, cidade, uf, complemento } = body;

            const updates = [];
            const values = [];

            if (title) { updates.push('title = ?'); values.push(title); }
            if (start_time) { updates.push('scheduled_date = ?'); values.push(start_time); }
            if (company_name) { updates.push('company_name = ?'); values.push(company_name); }
            if (client_id) { updates.push('client_id = ?'); values.push(client_id); }
            if (description !== undefined) { updates.push('description = ?'); values.push(description); }
            if (location !== undefined) { updates.push('address = ?'); values.push(location); }

            // Detailed address fields
            if (cep !== undefined) { updates.push('cep = ?'); values.push(cep); }
            if (logradouro !== undefined) { updates.push('logradouro = ?'); values.push(logradouro); }
            if (numero !== undefined) { updates.push('numero = ?'); values.push(numero); }
            if (bairro !== undefined) { updates.push('bairro = ?'); values.push(bairro); }
            if (cidade !== undefined) { updates.push('cidade = ?'); values.push(cidade); }
            if (uf !== undefined) { updates.push('uf = ?'); values.push(uf); }
            if (complemento !== undefined) { updates.push('complemento = ?'); values.push(complemento); }

            // Handle participants and inspector_email for inspections
            if (participants) {
                updates.push('participants = ?');
                values.push(JSON.stringify(participants));

                // Also update inspector_email if participants list is not empty
                if (participants.length > 0) {
                    // Participant is usually just an email string in this context based on frontend
                    const firstParticipant = participants[0];
                    // If it's an object use email property, otherwise use string
                    const email = typeof firstParticipant === 'string' ? firstParticipant : firstParticipant.email;
                    if (email) {
                        updates.push('inspector_email = ?');
                        values.push(email);
                    }
                }
            }

            if (updates.length > 0) {
                updates.push("updated_at = NOW()");
                const query = `
                    UPDATE inspections 
                    SET ${updates.join(', ')} 
                    WHERE id = ? AND organization_id = ?
                    RETURNING *
                 `;
                // Add realId and orgId to values
                const result = await db.prepare(query).bind(...values, realId, orgId).first();

                if (!result) return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);

                return c.json({
                    ...result,
                    id: `inspection-${result.id}`,
                    start_time: result.scheduled_date,
                    end_time: result.scheduled_date, // End time is same as start for inspections unless we add duration
                    event_type: 'inspection',
                    source: 'inspection',
                    location: result.address
                });
            }
            return c.json({ message: "Nada para atualizar" });
        }

        // Standard Calendar Event Update

        // Allowed fields to update
        const allowedFields = [
            'title', 'description', 'start_time', 'end_time', 'event_type', 'status', 'metadata',
            'participants', 'scope_items', 'attachments', 'location', 'meeting_link', 'notification_body',
            'company_name', 'client_id'
        ];
        const updates = [];
        const values = [];

        for (const field of allowedFields) {
            if (body[field] !== undefined) {
                updates.push(`${field} = ?`);
                if (['metadata', 'participants', 'scope_items', 'attachments'].includes(field)) {
                    values.push(JSON.stringify(body[field]));
                } else {
                    values.push(body[field]);
                }
            }
        }

        if (updates.length === 0) {
            return c.json({ message: "Nada para atualizar" }, 200);
        }

        updates.push("updated_at = NOW()");

        const query = `
            UPDATE calendar_events 
            SET ${updates.join(', ')} 
            WHERE id = ? AND organization_id = ?
            RETURNING *
        `;

        const result = await db.prepare(query).bind(...values, eventId, orgId).first();

        if (!result) {
            return c.json({ error: "Evento nÃ£o encontrado ou permissÃ£o negada" }, 404);
        }

        return c.json(result);

    } catch (error) {
        console.error('Error updating calendar event:', error);
        return c.json({ error: 'Erro ao atualizar evento' }, 500);
    }
});

// Delete event
app.delete('/:id', tenantAuthMiddleware, async (c) => {
    try {
        const user = c.get('user') as ExtendedMochaUser;
        const db = getDatabase(c.env);
        const eventId = c.req.param('id');

        const userProfile = await db.prepare("SELECT organization_id, managed_organization_id, role FROM users WHERE id = ?").bind(user.id).first() as any;
        const orgId = userProfile.managed_organization_id || userProfile.organization_id;

        // Check for inspection ID
        if (eventId.startsWith('inspection-')) {
            const realId = eventId.replace('inspection-', '');
            const result = await db.prepare(`
                DELETE FROM inspections
                WHERE id = ? AND organization_id = ?
                RETURNING id
            `).bind(realId, orgId).first();

            if (!result) return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
            return c.json({ message: "InspeÃ§Ã£o excluÃ­da" });
        }

        const result = await db.prepare(`
            DELETE FROM calendar_events 
            WHERE id = ? AND organization_id = ?
            RETURNING id
        `).bind(eventId, orgId).first();

        if (!result) {
            return c.json({ error: "Evento nÃ£o encontrado ou permissÃ£o negada" }, 404);
        }

        return c.json({ message: "Evento excluÃ­do com sucesso" });

    } catch (error) {
        console.error('Error deleting calendar event:', error);
        return c.json({ error: 'Erro ao excluir evento' }, 500);
    }
});

// Debug route to diagnose 500 errors
app.get('/debug', tenantAuthMiddleware, requireProtectedSysAdmin(), async (c) => {
    if (Deno.env.get('ENVIRONMENT') === 'production') {
        return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
    }

    try {
        const db = getDatabase(c.env);
        let orgId = c.req.query('org_id');

        // If no orgId provided, try to find the first one
        if (!orgId) {
            const firstOrg = await db.prepare("SELECT id FROM organizations LIMIT 1").first();
            if (firstOrg) {
                orgId = firstOrg.id;
            }
        }

        if (!orgId) return c.json({ error: 'No Org ID found and no organization in DB' });

        const report: any = { orgId, checks: {} };

        // Check 1: Calendar Events
        try {
            await db.prepare("SELECT * FROM calendar_events WHERE organization_id = ? LIMIT 1").bind(orgId).all();
            report.checks.calendar_events = 'OK';
        } catch (e: any) {
            report.checks.calendar_events = `FAILED: ${e.message}`;
        }

        // Check 2: Inspections (Corrected Schema)
        try {
            await db.prepare("SELECT id, title, scheduled_date, status FROM inspections WHERE organization_id = ? LIMIT 1").bind(orgId).all();
            report.checks.inspections = 'OK';
        } catch (e: any) {
            report.checks.inspections = `FAILED: ${e.message}`;
        }

        // Check 3: Action Plans
        try {
            await db.prepare("SELECT id, description, due_date, status, priority FROM action_plans WHERE organization_id = ? LIMIT 1").bind(orgId).all();
            report.checks.action_plans = 'OK';
        } catch (e: any) {
            report.checks.action_plans = `FAILED: ${e.message}`;
        }

        return c.json(report);

    } catch (error: any) {
        return c.json({
            error: error.message,
            ...(Deno.env.get('ENVIRONMENT') === 'production' ? {} : { stack: error.stack })
        });
    }
});

// RSVP to event
app.post('/:id/respond', tenantAuthMiddleware, async (c) => {
    try {
        const user = c.get('user') as ExtendedMochaUser;
        const db = getDatabase(c.env);
        const eventId = c.req.param('id');
        const { status } = await c.req.json(); // 'accepted' | 'declined'

        if (!['accepted', 'declined'].includes(status)) {
            return c.json({ error: 'Status invÃ¡lido' }, 400);
        }

        const userProfile = await db.prepare("SELECT organization_id, managed_organization_id, role, email, name FROM users WHERE id = ?").bind(user.id).first() as any;
        const orgId = userProfile.managed_organization_id || userProfile.organization_id;

        const respondent = {
            id: user.id,
            email: userProfile.email,
            name: userProfile.name,
            responded_at: new Date().toISOString()
        };

        // Helper to update lists
        const updateLists = (currentAccepted: any[], currentDeclined: any[], newStatus: string) => {
            // Remove from both first
            const newAccepted = currentAccepted.filter((u: any) => (typeof u === 'string' ? u : u.email) !== userProfile.email);
            const newDeclined = currentDeclined.filter((u: any) => (typeof u === 'string' ? u : u.email) !== userProfile.email);

            if (newStatus === 'accepted') {
                newAccepted.push(respondent);
            } else {
                newDeclined.push(respondent);
            }
            return { newAccepted, newDeclined };
        };

        // Check for inspection
        if (eventId.startsWith('inspection-')) {
            const realId = eventId.replace('inspection-', '');
            const current = await db.prepare("SELECT accepted_by, declined_by FROM inspections WHERE id = ? AND organization_id = ?").bind(realId, orgId).first();

            if (!current) return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);

            const curAccepted = typeof current.accepted_by === 'string' ? JSON.parse(current.accepted_by) : (current.accepted_by || []);
            const curDeclined = typeof current.declined_by === 'string' ? JSON.parse(current.declined_by) : (current.declined_by || []);

            const { newAccepted, newDeclined } = updateLists(curAccepted, curDeclined, status);

            await db.prepare(`
                UPDATE inspections 
                SET accepted_by = ?, declined_by = ?, updated_at = NOW()
                WHERE id = ?
            `).bind(JSON.stringify(newAccepted), JSON.stringify(newDeclined), realId).run();

            return c.json({ message: "Resposta registrada" });
        }

        // Standard Event
        const current = await db.prepare("SELECT accepted_by, declined_by FROM calendar_events WHERE id = ? AND organization_id = ?").bind(eventId, orgId).first();

        if (!current) return c.json({ error: "Evento nÃ£o encontrado" }, 404);

        const curAccepted = typeof current.accepted_by === 'string' ? JSON.parse(current.accepted_by) : (current.accepted_by || []);
        const curDeclined = typeof current.declined_by === 'string' ? JSON.parse(current.declined_by) : (current.declined_by || []);

        const { newAccepted, newDeclined } = updateLists(curAccepted, curDeclined, status);

        await db.prepare(`
            UPDATE calendar_events 
            SET accepted_by = ?, declined_by = ?, updated_at = NOW()
            WHERE id = ?
        `).bind(JSON.stringify(newAccepted), JSON.stringify(newDeclined), eventId).run();

        return c.json({ message: "Resposta registrada" });

    } catch (error) {
        console.error('Error responding to event:', error);
        return c.json({ error: 'Erro ao responder evento' }, 500);
    }
});

export default app;


===END_FILE===
===FILE: supabase/functions/api/calendar-settings-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { ExtendedMochaUser, USER_ROLES } from "./user-types.ts";

type Env = {
    DB: any;
};

const getDatabase = (env: any) => env.DB;

const app = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/calendar-settings');

// Ensure table exists helper
async function ensureTableExists(db: any) {
    await db.prepare(`
    CREATE TABLE IF NOT EXISTS calendar_settings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        organization_id INTEGER NOT NULL UNIQUE,
        business_hours TEXT DEFAULT '{"start": "08:00", "end": "18:00", "days": [1,2,3,4,5]}',
        holidays TEXT DEFAULT '[]',
        timezone TEXT DEFAULT 'America/Sao_Paulo',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );
  `).run();

    // Index on organization_id for performance
    try {
        await db.prepare(`CREATE INDEX IF NOT EXISTS idx_calendar_settings_org ON calendar_settings(organization_id)`).run();
    } catch (e) {
        // Ignore if index creation fails (might be duplicate name error but IF NOT EXISTS handles most)
    }
}

// Get Settings
app.get('/', tenantAuthMiddleware, async (c) => {
    try {
        const user = c.get('user') as ExtendedMochaUser;
        const db = getDatabase(c.env);

        // Ensure table exists on first access
        await ensureTableExists(db);

        // Get user profile
        const userProfile = await db.prepare("SELECT organization_id, managed_organization_id FROM users WHERE id = ?").bind(user.id).first() as any;
        if (!userProfile) return c.json({ error: "User not found" }, 404);

        const orgId = userProfile.managed_organization_id || userProfile.organization_id;

        const settings = await db.prepare("SELECT * FROM calendar_settings WHERE organization_id = ?").bind(orgId).first() as any;

        if (!settings) {
            // Return defaults if no settings exist
            return c.json({
                organization_id: orgId,
                business_hours: { start: "08:00", end: "18:00", days: [1, 2, 3, 4, 5] },
                holidays: [],
                timezone: 'America/Sao_Paulo'
            });
        }

        return c.json({
            ...settings,
            business_hours: JSON.parse(settings.business_hours || '{}'),
            holidays: JSON.parse(settings.holidays || '[]')
        });

    } catch (error) {
        console.error('Error fetching calendar settings:', error);
        return c.json({ error: 'Erro ao buscar configuraÃ§Ãµes' }, 500);
    }
});

// Update Settings
app.put('/', tenantAuthMiddleware, async (c) => {
    try {
        const user = c.get('user') as ExtendedMochaUser;
        const db = getDatabase(c.env);

        // Ensure table permissions
        // Only Org Admin or System Admin should update settings
        const userProfile = await db.prepare("SELECT organization_id, managed_organization_id, role FROM users WHERE id = ?").bind(user.id).first() as any;

        if (!userProfile) return c.json({ error: "User not found" }, 404);

        const orgId = userProfile.managed_organization_id || userProfile.organization_id;

        if (userProfile.role !== USER_ROLES.ORG_ADMIN && userProfile.role !== USER_ROLES.SYSTEM_ADMIN && userProfile.role !== 'sys_admin') {
            // Allow update if user manages this org
            if (!userProfile.managed_organization_id || userProfile.managed_organization_id !== orgId) {
                return c.json({ error: "PermissÃ£o negada. Apenas administradores podem alterar configuraÃ§Ãµes." }, 403);
            }
        }

        await ensureTableExists(db);

        const body = await c.req.json();
        const { business_hours, holidays, timezone } = body;

        // Upsert logic
        const existing = await db.prepare("SELECT id FROM calendar_settings WHERE organization_id = ?").bind(orgId).first();

        if (existing) {
            await db.prepare(`
                UPDATE calendar_settings 
                SET business_hours = ?, holidays = ?, timezone = ?, updated_at = datetime('now')
                WHERE organization_id = ?
            `).bind(
                JSON.stringify(business_hours),
                JSON.stringify(holidays),
                timezone,
                orgId
            ).run();
        } else {
            await db.prepare(`
                INSERT INTO calendar_settings (organization_id, business_hours, holidays, timezone)
                VALUES (?, ?, ?, ?)
            `).bind(
                orgId,
                JSON.stringify(business_hours),
                JSON.stringify(holidays),
                timezone
            ).run();
        }

        return c.json({ message: "ConfiguraÃ§Ãµes atualizadas com sucesso" });

    } catch (error) {
        console.error('Error updating calendar settings:', error);
        return c.json({ error: 'Erro ao atualizar configuraÃ§Ãµes' }, 500);
    }
});

export default app;
===END_FILE===
===FILE: supabase/functions/api/calendar-upload-routes.ts===

import { Hono } from "hono";
import { tenantAuthMiddleware as authMiddleware } from "./tenant-auth-middleware.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const calendarUploadRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/calendar-upload');

type Env = {
    DB: any;
    SUPABASE_URL: string;
    SUPABASE_SERVICE_ROLE_KEY: string;
};

// File size limits in bytes (same as media-routes)
const FILE_SIZE_LIMITS = {
    image: 10 * 1024 * 1024,      // 10 MB
    video: 100 * 1024 * 1024,     // 100 MB
    audio: 20 * 1024 * 1024,      // 20 MB
    document: 50 * 1024 * 1024    // 50 MB
};

calendarUploadRoutes.post("/upload", authMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        const body = await c.req.json();
        const {
            file_name,
            file_data,
            file_size,
            mime_type
        } = body;

        // Determine media type for validation
        let mediaType = 'document';
        if (mime_type.startsWith('image/')) mediaType = 'image';
        else if (mime_type.startsWith('video/')) mediaType = 'video';
        else if (mime_type.startsWith('audio/')) mediaType = 'audio';

        // Validate size
        const limit = FILE_SIZE_LIMITS[mediaType as keyof typeof FILE_SIZE_LIMITS];
        if (file_size > limit) {
            return c.json({ error: `Arquivo muito grande. Limite: ${limit / 1024 / 1024}MB` }, 400);
        }

        const supabaseUrl = env.SUPABASE_URL;
        const supabaseServiceKey = env.SUPABASE_SERVICE_ROLE_KEY;

        if (!supabaseUrl || !supabaseServiceKey) {
            return c.json({ error: "Storage not configured" }, 500);
        }

        const supabase = createClient(supabaseUrl, supabaseServiceKey);

        // Convert base64 to binary
        const base64Data = file_data.split(',')[1];
        const binaryData = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));

        // Generate unique path
        const timestamp = Date.now();
        const sanitizedFileName = file_name.replace(/[^a-zA-Z0-9.-]/g, '_');
        const filePath = `calendar_uploads/${user.organization_id}/${timestamp}_${sanitizedFileName}`;

        // Upload to 'inspection-media' bucket (reusing existing bucket)
        const { data: uploadData, error: uploadError } = await supabase.storage
            .from('inspection-media')
            .upload(filePath, binaryData, {
                contentType: mime_type,
                upsert: false
            });

        if (uploadError) {
            console.error('Supabase Storage error:', uploadError);
            throw new Error(uploadError.message);
        }

        // Get public URL
        const { data: urlData } = supabase.storage
            .from('inspection-media')
            .getPublicUrl(filePath);

        return c.json({
            success: true,
            file_url: urlData.publicUrl,
            file_name: file_name
        });

    } catch (error) {
        console.error('Error uploading calendar attachment:', error);
        return c.json({
            error: "Erro ao fazer upload",
            details: error instanceof Error ? error.message : "Erro desconhecido"
        }, 500);
    }
});

export default calendarUploadRoutes;
===END_FILE===
===FILE: supabase/functions/api/cep-routes.ts===
import { Hono } from "hono";

const cepRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();

// Helper function to perform CEP lookup with proper error handling
const performCepLookup = async (cepInput: string) => {
  try {
    if (!cepInput) {
      return {
        success: false,
        error: "CEP Ã© obrigatÃ³rio",
        status: 400
      };
    }

    // Clean CEP (remove dots, dashes, spaces)
    const cleanCep = cepInput.replace(/[-.\s]/g, '');

    // Validate CEP format (8 digits)
    if (!/^\d{8}$/.test(cleanCep)) {
      return {
        success: false,
        error: "CEP deve conter 8 dÃ­gitos numÃ©ricos",
        status: 400
      };
    }

    // Call external CEP API (using ViaCEP)
    const apiUrl = `https://viacep.com.br/ws/${cleanCep}/json/`;

    const response = await globalThis.fetch(apiUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; InspectionApp/1.0)',
      }
    });

    if (!response.ok) {
      if (response.status === 429) {
        return {
          success: false,
          error: "Muitas consultas. Tente novamente em alguns minutos.",
          status: 429
        };
      }
      return {
        success: false,
        error: `Erro na consulta externa: ${response.status}`,
        status: 502
      };
    }

    const cepData = await response.json() as any;

    if (cepData.erro) {
      return {
        success: false,
        error: "CEP nÃ£o encontrado",
        status: 404
      };
    }

    // Transform data to match our address format
    const addressData = {
      cep: cepData.cep,
      address: `${cepData.logradouro}${cepData.complemento ? ', ' + cepData.complemento : ''}, ${cepData.bairro}, ${cepData.localidade}/${cepData.uf}`,
      logradouro: cepData.logradouro,
      complemento: cepData.complemento,
      bairro: cepData.bairro,
      localidade: cepData.localidade,
      uf: cepData.uf,
      ibge: cepData.ibge,
      gia: cepData.gia,
      ddd: cepData.ddd,
      siafi: cepData.siafi
    };

    return {
      success: true,
      data: addressData,
      status: 200
    };

  } catch (error) {
    console.error('CEP lookup error:', error);
    return {
      success: false,
      error: "Erro interno ao consultar CEP",
      details: error instanceof Error ? error.message : "Erro desconhecido",
      status: 500
    };
  }
};

// CEP lookup endpoint with path parameter
cepRoutes.get("/:cep", async (c) => {
  // Set proper JSON content type header
  c.header('Content-Type', 'application/json');

  const cep = c.req.param("cep");
  const result = await performCepLookup(cep);

  if (result.success && result.data) {
    return c.json({
      success: true,
      data: result.data,
      address: result.data.address
    }, 200);
  } else {
    return c.json({
      error: result.error,
      details: result.details
    }, result.status as any);
  }
});

export default cepRoutes;

===END_FILE===
===FILE: supabase/functions/api/checklist-folders-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";
import { requireScopes, SCOPES, createAuthErrorResponse, isSystemAdmin } from "./rbac-middleware.ts";
import { logActivity } from "./audit-logger.ts";

type Env = {
  DB: any;
};

const checklistFoldersRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/checklist');

// FunÃ§Ã£o para gerar slug Ãºnico
function generateSlug(name: string, existing: string[] = []): string {
  let baseSlug = name
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remove acentos
    .replace(/[^a-z0-9]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');

  let slug = baseSlug;
  let counter = 1;

  while (existing.includes(slug)) {
    slug = `${baseSlug}-${counter}`;
    counter++;
  }

  return slug;
}

// FunÃ§Ã£o para construir path baseado na hierarquia (com proteÃ§Ã£o contra ciclos)
async function buildFolderPath(db: any, folderId: string): Promise<string> {
  const pathParts: string[] = [];
  let currentId: string | null = folderId;
  let depth = 0;
  const maxDepth = 20; // ProteÃ§Ã£o contra loops infinitos

  while (currentId && depth < maxDepth) {
    const folder = await db.prepare("SELECT slug, parent_id FROM checklist_folders WHERE id = ?")
      .bind(currentId).first() as any;

    if (!folder) break;

    pathParts.unshift(folder.slug);

    // Check for self-reference (basic cycle prevention)
    if (folder.parent_id === currentId) break;

    currentId = folder.parent_id;
    depth++;
  }

  return '/' + pathParts.join('/');
}

// MigraÃ§Ã£o segura de categorias existentes para pastas
checklistFoldersRoutes.post("/migrate-categories", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Buscar perfil do usuÃ¡rio
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Verificar permissÃµes - admins ou gestores da organizaÃ§Ã£o
    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'admin';
    const isOrgAdmin = userProfile?.role === USER_ROLES.ORG_ADMIN || userProfile?.role === USER_ROLES.MANAGER;

    if (!isSysAdmin && (!isOrgAdmin || !userProfile?.organization_id)) {
      return c.json({ error: "Insufficient permissions for migration" }, 403);
    }

    let query = `
      SELECT DISTINCT organization_id 
      FROM checklist_templates 
      WHERE organization_id IS NOT NULL AND folder_id IS NULL
    `;
    let params: any[] = [];

    // Se nÃ£o for sysadmin, restringir Ã  prÃ³pria organizaÃ§Ã£o
    if (!isSysAdmin && userProfile?.organization_id) {
      query += " AND organization_id = ?";
      params.push(userProfile.organization_id);
    }

    // Buscar organizaÃ§Ãµes para migrar
    const organizations = await env.DB.prepare(query).bind(...params).all();

    let totalMigrated = 0;
    const migrationDetails: any[] = [];

    for (const org of organizations.results) {
      const orgId = (org as any).organization_id;

      // Buscar categorias Ãºnicas nesta organizaÃ§Ã£o
      const categories = await env.DB.prepare(`
        SELECT DISTINCT category 
        FROM checklist_templates 
        WHERE organization_id = ? AND folder_id IS NULL AND is_category_folder = false
      `).bind(orgId).all();

      let orgMigrated = 0;

      for (const cat of categories.results) {
        const categoryName = (cat as any).category;

        if (!categoryName || categoryName.trim() === '') continue;

        // Verificar se pasta jÃ¡ existe
        const existingFolder = await env.DB.prepare(`
          SELECT id FROM checklist_folders 
          WHERE organization_id = ? AND name = ? AND parent_id IS NULL
        `).bind(orgId, categoryName).first() as any;

        let folderId: string;

        if (existingFolder) {
          folderId = existingFolder.id;
        } else {
          // Criar nova pasta para esta categoria
          const existingSlugs = await env.DB.prepare(`
            SELECT slug FROM checklist_folders WHERE organization_id = ? AND parent_id IS NULL
          `).bind(orgId).all();

          const slugs = existingSlugs.results.map((r: any) => r.slug);
          const slug = generateSlug(categoryName, slugs);
          const path = `/${slug}`;

          const result = await env.DB.prepare(`
            INSERT INTO checklist_folders (
              organization_id, parent_id, name, slug, path, description,
              color, icon, display_order, created_at, updated_at
            ) VALUES (?, NULL, ?, ?, ?, ?, '#3B82F6', 'folder', 0, NOW(), NOW())
          `).bind(
            orgId,
            categoryName,
            slug,
            path,
            `Pasta criada automaticamente da categoria: ${categoryName}`
          ).run();

          folderId = result.meta.last_row_id as string;
        }

        // Migrar templates desta categoria para a pasta
        const updateResult = await env.DB.prepare(`
          UPDATE checklist_templates 
          SET folder_id = ?, updated_at = NOW()
          WHERE organization_id = ? AND category = ? AND folder_id IS NULL AND is_category_folder = false
        `).bind(folderId, orgId, categoryName).run();

        orgMigrated += updateResult.meta.changes || 0;
      }

      if (orgMigrated > 0) {
        migrationDetails.push({
          organization_id: orgId,
          templates_migrated: orgMigrated
        });
        totalMigrated += orgMigrated;
      }
    }

    // Log da migraÃ§Ã£o
    await env.DB.prepare(`
      INSERT INTO migrations_log (migration_type, details, items_migrated, created_at)
      VALUES ('category_to_folder', ?, ?, NOW())
    `).bind(
      JSON.stringify({
        organizations_migrated: migrationDetails.length,
        details: migrationDetails,
        total_templates: totalMigrated
      }),
      totalMigrated
    ).run();

    // Global Log Activity
    await logActivity(env, {
      userId: user.id,
      orgId: userProfile?.organization_id || null,
      actionType: 'MIGRATE',
      actionDescription: `Checklist Categories Migrated to Folders`,
      targetType: 'SYSTEM',
      targetId: null,
      metadata: { organizations_migrated: migrationDetails.length, total_templates: totalMigrated },
      req: c.req
    });

    return c.json(safeJson({
      success: true,
      message: `MigraÃ§Ã£o concluÃ­da com sucesso`,
      organizations_migrated: migrationDetails.length,
      templates_migrated: totalMigrated,
      details: migrationDetails
    }));

  } catch (error) {
    console.error('Error in category migration:', error);
    return c.json({
      error: "Failed to migrate categories",
      details: error instanceof Error ? error.message : "Unknown error"
    }, 500);
  }
});

// Helper to handle BigInt serialization
// Helper to handle BigInt serialization - ROBUST RECURSIVE
const safeJson = (data: any): any => {
  if (data === null || data === undefined) return data;
  if (typeof data === 'bigint') return data.toString();
  if (Array.isArray(data)) return data.map(safeJson);
  if (typeof data === 'object') {
    return Object.fromEntries(
      Object.entries(data).map(([key, value]) => [key, safeJson(value)])
    );
  }
  return data;
};

// Listar pastas com contadores (requires checklist:folders:read scope)
checklistFoldersRoutes.get("/folders", tenantAuthMiddleware, requireScopes(SCOPES.CHECKLIST_FOLDERS_READ), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  let userProfile: any = null;

  try {
    // Buscar perfil do usuÃ¡rio
    userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }
    const rawParent = c.req.query('parent_id');
    const parentId = (rawParent === undefined || rawParent === null || rawParent === '' || rawParent === 'null' || rawParent === 'undefined') ? null : rawParent;

    if (!userProfile?.organization_id) {
      return c.json(createAuthErrorResponse('forbidden', 'UsuÃ¡rio nÃ£o possui organizaÃ§Ã£o associada', [SCOPES.CHECKLIST_FOLDERS_READ]), 403);
    }

    let whereClause = "WHERE (f.organization_id = ? OR f.organization_id IS NULL)";
    let params: any[] = [userProfile?.organization_id || null];

    if (parentId === null) {
      whereClause += " AND f.parent_id IS NULL";
    } else {
      whereClause += " AND f.parent_id = ?";
      params.push(parentId);
    }

    // Buscar pastas com contadores
    const folders = await env.DB.prepare(`
      SELECT 
        f.*,
        COUNT(DISTINCT cf.id) as subfolder_count,
        COUNT(DISTINCT ct.id) as template_count
      FROM checklist_folders f
      LEFT JOIN checklist_folders cf ON cf.parent_id = f.id
      LEFT JOIN checklist_templates ct ON ct.folder_id = f.id AND ct.is_category_folder = false
      ${whereClause}
      GROUP BY f.id
      ORDER BY f.display_order ASC, f.name ASC
    `).bind(...params).all();

    return c.json(safeJson({
      folders: folders.results || [],
      parent_id: parentId
    }));

  } catch (error) {
    console.error('Error fetching folders:', error);
    return c.json({
      error: error instanceof Error ? error.message : "Failed to fetch folders",
      details: error instanceof Error ? error.stack : undefined,
      cause: (error as any)?.cause,
      user_id: user?.id,
      org_id: userProfile?.organization_id
    }, 500);
  }
});

// Obter Ã¡rvore de pastas (leve para breadcrumbs)
checklistFoldersRoutes.get("/tree", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Buscar perfil do usuÃ¡rio
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Buscar todas as pastas da organizaÃ§Ã£o com contadores
    const folders = await env.DB.prepare(`
      SELECT 
        f.id, f.parent_id, f.name, f.slug, f.path, f.color, f.icon, f.display_order,
        COUNT(DISTINCT cf.id) as subfolder_count,
        COUNT(DISTINCT ct.id) as template_count
      FROM checklist_folders f
      LEFT JOIN checklist_folders cf ON cf.parent_id = f.id
      LEFT JOIN checklist_templates ct ON ct.folder_id = f.id AND (ct.is_category_folder = false OR ct.is_category_folder IS NULL)
      WHERE (f.organization_id = ? OR f.organization_id IS NULL)
      GROUP BY f.id
      ORDER BY f.display_order ASC, f.name ASC
    `).bind(userProfile?.organization_id || null).all();

    // Construir Ã¡rvore hierÃ¡rquica (limitada a 3 nÃ­veis por performance)
    function buildTree(parentId: string | null = null, currentDepth = 0): any[] {
      if (currentDepth >= 3) return [];

      return (folders.results as any[])
        .filter(f => f.parent_id === parentId)
        .map(folder => ({
          ...folder,
          children: buildTree(folder.id, currentDepth + 1)
        }));
    }

    const tree = buildTree();

    return c.json({ tree });

  } catch (error) {
    console.error('Error fetching folder tree:', error);
    return c.json({ error: error instanceof Error ? error.message : "Failed to fetch folder tree" }, 500);
  }
});



// Get folder path/breadcrumb
checklistFoldersRoutes.get("/folders/:id/path", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const folderId = c.req.param("id");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Buscar perfil do usuÃ¡rio
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Build path from root to this folder
    const path: any[] = [];
    let currentId: string | null = folderId;
    let depth = 0;
    const maxDepth = 20; // ProteÃ§Ã£o contra loops

    while (currentId && depth < maxDepth) {
      const folder = await env.DB.prepare(`
        SELECT id, name, slug, parent_id, color, icon 
        FROM checklist_folders 
        WHERE id = ? AND organization_id = ?
      `).bind(currentId, userProfile?.organization_id || null).first() as any;

      if (!folder) break;

      path.unshift(folder); // Add to beginning to build path from root

      if (folder.parent_id === currentId) break; // Cycle check

      currentId = folder.parent_id;
      depth++;
    }

    return c.json({ path });

  } catch (error) {
    console.error('Error fetching folder path:', error);
    return c.json({ error: "Failed to fetch folder path" }, 500);
  }
});

// Criar nova pasta (requires checklist:folders:write scope)
checklistFoldersRoutes.post("/folders", tenantAuthMiddleware, requireScopes(SCOPES.CHECKLIST_FOLDERS_WRITE), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    let { name, description, parent_id, color, icon } = body;

    // Normalize parent_id
    if (parent_id === 'null' || parent_id === '' || parent_id === 0) parent_id = null;

    if (!name || name.trim() === '') {
      return c.json({ error: "Nome da pasta Ã© obrigatÃ³rio" }, 400);
    }

    // Buscar perfil do usuÃ¡rio
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    if (!userProfile?.organization_id) {
      return c.json(createAuthErrorResponse('forbidden', 'UsuÃ¡rio nÃ£o possui organizaÃ§Ã£o associada', [SCOPES.CHECKLIST_FOLDERS_WRITE]), 403);
    }

    // Verificar se pasta pai existe (se especificada e nÃ£o null)
    if (parent_id) {
      const parentFolder = await env.DB.prepare(`
        SELECT id FROM checklist_folders 
        WHERE id = ? AND organization_id = ?
      `).bind(parent_id, userProfile?.organization_id || null).first();

      if (!parentFolder) {
        return c.json({ error: "Pasta pai nÃ£o encontrada" }, 404);
      }
    }

    // Gerar slug Ãºnico (SAFE SQL)
    const slugQuery = parent_id
      ? `SELECT slug FROM checklist_folders WHERE organization_id = ? AND parent_id = ?`
      : `SELECT slug FROM checklist_folders WHERE organization_id = ? AND parent_id IS NULL`;

    const slugParams = parent_id
      ? [userProfile?.organization_id || null, parent_id]
      : [userProfile?.organization_id || null];

    const existingSlugs = await env.DB.prepare(slugQuery).bind(...slugParams).all();

    const slugs = existingSlugs.results.map((r: any) => r.slug);
    const slug = generateSlug(name, slugs);

    // Criar pasta
    const result = await env.DB.prepare(`
      INSERT INTO checklist_folders (
        organization_id, parent_id, name, slug, path, description,
        color, icon, display_order, created_at, updated_at
      ) VALUES (?, ?, ?, ?, '', ?, ?, ?, 0, NOW(), NOW())
    `).bind(
      userProfile?.organization_id,
      parent_id || null,
      name.trim(),
      slug,
      description?.trim() || null,
      color || '#3B82F6',
      icon || 'folder'
    ).run();

    const folderId = result.meta.last_row_id as string;

    // Construir e atualizar o path
    const path = await buildFolderPath(env.DB, folderId);
    await env.DB.prepare("UPDATE checklist_folders SET path = ? WHERE id = ?")
      .bind(path, folderId).run();

    // Log Creation
    await logActivity(env, {
      userId: user.id,
      orgId: userProfile?.organization_id,
      actionType: 'CREATE',
      actionDescription: `Checklist Folder Created: ${name}`,
      targetType: 'CHECKLIST_FOLDER',
      targetId: folderId,
      metadata: { name, slug, path },
      req: c.req
    });

    return c.json({
      id: folderId,
      message: "Pasta criada com sucesso",
      slug,
      path
    });

  } catch (error) {
    console.error('Error creating folder:', error);
    return c.json({ error: "Failed to create folder" }, 500);
  }
});

// Atualizar pasta (renomear/mover) (requires checklist:folders:write scope)
checklistFoldersRoutes.patch("/folders/:id", tenantAuthMiddleware, requireScopes(SCOPES.CHECKLIST_FOLDERS_WRITE), async (c) => {
  const env = c.env;
  const user = c.get("user");
  const folderId = c.req.param("id");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    let { name, description, parent_id, color, icon } = body;

    // Normalize parent_id
    if (parent_id === 'null' || parent_id === '' || parent_id === 0) parent_id = null;

    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Verificar se pasta existe
    const folder = await env.DB.prepare(`
      SELECT * FROM checklist_folders 
      WHERE id = ? AND organization_id = ?
    `).bind(folderId, userProfile?.organization_id || null).first() as any;

    if (!folder) {
      return c.json({ error: "Pasta nÃ£o encontrada" }, 404);
    }

    // VerificaÃ§Ã£o de permissÃµes jÃ¡ foi feita pelo middleware RBAC

    // Verificar se novo pai nÃ£o cria ciclo
    if (parent_id && parent_id !== folder.parent_id) {
      let currentParent = parent_id;
      let depth = 0;
      const MAX_DEPTH = 50; // Safety limit

      while (currentParent && depth < MAX_DEPTH) {
        if (currentParent === folderId) {
          return c.json({ error: "NÃ£o Ã© possÃ­vel mover pasta para dentro de si mesma" }, 400);
        }

        const parentFolder = await env.DB.prepare("SELECT parent_id FROM checklist_folders WHERE id = ?")
          .bind(currentParent).first() as any;

        if (!parentFolder) break;
        currentParent = parentFolder.parent_id;
        depth++;
      }
    }

    let newSlug = folder.slug;

    // Se nome mudou, gerar novo slug (SAFE SQL)
    if (name && name.trim() !== folder.name) {
      const slugQuery = parent_id
        ? `SELECT slug FROM checklist_folders WHERE organization_id = ? AND parent_id = ? AND id != ?`
        : `SELECT slug FROM checklist_folders WHERE organization_id = ? AND parent_id IS NULL AND id != ?`;

      const slugParams = parent_id
        ? [userProfile?.organization_id || null, parent_id, folderId]
        : [userProfile?.organization_id || null, folderId];

      const existingSlugs = await env.DB.prepare(slugQuery).bind(...slugParams).all();

      const slugs = existingSlugs.results.map((r: any) => r.slug);
      newSlug = generateSlug(name.trim(), slugs);
    }

    // Atualizar pasta
    await env.DB.prepare(`
      UPDATE checklist_folders SET 
        name = COALESCE(?, name),
        description = COALESCE(?, description),
        parent_id = COALESCE(?, parent_id),
        slug = ?,
        color = COALESCE(?, color),
        icon = COALESCE(?, icon),
        updated_at = NOW()
      WHERE id = ?
    `).bind(
      name?.trim(),
      description?.trim(),
      parent_id,
      newSlug,
      color,
      icon,
      folderId
    ).run();

    // Reconstruir paths se houve mudanÃ§a de nome ou pai
    if ((name && name.trim() !== folder.name) || (parent_id !== folder.parent_id)) {
      await updateFolderPaths(env.DB, folderId);
    }

    return c.json({ message: "Pasta atualizada com sucesso" });

    // Log Update (Async)
    logActivity(env, {
      userId: user.id,
      orgId: userProfile?.organization_id,
      actionType: 'UPDATE',
      actionDescription: `Checklist Folder Updated: ${name || folder.name}`,
      targetType: 'CHECKLIST_FOLDER',
      targetId: folderId,
      metadata: { name, description, parent_id },
      req: c.req
    });

  } catch (error) {
    console.error('Error updating folder:', error);
    return c.json({ error: "Failed to update folder" }, 500);
  }
});

// FunÃ§Ã£o auxiliar para atualizar paths em cascata
async function updateFolderPaths(db: any, folderId: string) {
  // Atualizar path da pasta atual
  const newPath = await buildFolderPath(db, folderId);
  await db.prepare("UPDATE checklist_folders SET path = ? WHERE id = ?")
    .bind(newPath, folderId).run();

  // Atualizar subpastas recursivamente
  const children = await db.prepare("SELECT id FROM checklist_folders WHERE parent_id = ?")
    .bind(folderId).all();

  for (const child of children.results) {
    await updateFolderPaths(db, (child as any).id);
  }
}

// Excluir pasta (requires checklist:folders:delete scope)
checklistFoldersRoutes.delete("/folders/:id", tenantAuthMiddleware, requireScopes(SCOPES.CHECKLIST_FOLDERS_DELETE), async (c) => {
  const env = c.env;
  const user = c.get("user");
  const folderId = c.req.param("id");
  const strategy = c.req.query('strategy') || 'block';

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Verificar se pasta existe
    const folder = await env.DB.prepare(`
      SELECT * FROM checklist_folders 
      WHERE id = ? AND organization_id = ?
    `).bind(folderId, userProfile?.organization_id || null).first() as any;

    if (!folder) {
      return c.json({ error: "Pasta nÃ£o encontrada" }, 404);
    }

    // Verificar permissÃµes para cascade (apenas system admin)
    if (strategy === 'cascade' && !isSystemAdmin(userProfile?.role)) {
      return c.json(createAuthErrorResponse('forbidden', 'Apenas administradores de sistema podem usar exclusÃ£o em cascata', [SCOPES.SYSTEM_ADMIN]), 403);
    }

    // Verificar conteÃºdo da pasta
    const subfolders = await env.DB.prepare("SELECT COUNT(*) as count FROM checklist_folders WHERE parent_id = ?")
      .bind(folderId).first() as any;
    const templates = await env.DB.prepare("SELECT COUNT(*) as count FROM checklist_templates WHERE folder_id = ?")
      .bind(folderId).first() as any;

    const hasContent = (subfolders?.count || 0) > 0 || (templates?.count || 0) > 0;

    if (strategy === 'block' && hasContent) {
      return c.json({
        error: "Pasta contÃ©m itens. Use estratÃ©gia 'merge' ou 'cascade' para proceder",
        subfolders: subfolders?.count || 0,
        templates: templates?.count || 0
      }, 400);
    }

    if (strategy === 'merge') {
      // Mover conteÃºdo para pasta pai
      await env.DB.prepare("UPDATE checklist_folders SET parent_id = ? WHERE parent_id = ?")
        .bind(folder.parent_id, folderId).run();
      await env.DB.prepare("UPDATE checklist_templates SET folder_id = ? WHERE folder_id = ?")
        .bind(folder.parent_id, folderId).run();

      // Atualizar paths das subpastas movidas
      const movedFolders = await env.DB.prepare("SELECT id FROM checklist_folders WHERE parent_id = ?")
        .bind(folder.parent_id).all();
      for (const moved of movedFolders.results) {
        await updateFolderPaths(env.DB, (moved as any).id);
      }
    } else if (strategy === 'cascade') {
      // Excluir recursivamente (apenas system_admin)
      await deleteFolder(env.DB, folderId);
    }

    // Excluir a pasta
    await env.DB.prepare("DELETE FROM checklist_folders WHERE id = ?").bind(folderId).run();

    return c.json({ message: "Pasta excluÃ­da com sucesso" });

    // Log Deletion (Async)
    logActivity(env, {
      userId: user.id,
      orgId: userProfile?.organization_id,
      actionType: 'DELETE',
      actionDescription: `Checklist Folder Deleted: ${folder.name}`,
      targetType: 'CHECKLIST_FOLDER',
      targetId: folderId,
      metadata: { name: folder.name, strategy },
      req: c.req
    });

  } catch (error) {
    console.error('Error deleting folder:', error);
    return c.json({ error: "Failed to delete folder" }, 500);
  }
});

// FunÃ§Ã£o auxiliar para exclusÃ£o em cascata
async function deleteFolder(db: any, folderId: string) {
  // Excluir subpastas recursivamente
  const subfolders = await db.prepare("SELECT id FROM checklist_folders WHERE parent_id = ?")
    .bind(folderId).all();

  for (const subfolder of subfolders.results) {
    await deleteFolder(db, (subfolder as any).id);
  }

  // Excluir templates da pasta
  await db.prepare("DELETE FROM checklist_templates WHERE folder_id = ?").bind(folderId).run();

  // Excluir pasta
  await db.prepare("DELETE FROM checklist_folders WHERE id = ?").bind(folderId).run();
}

// Mover itens em lote (requires checklist:folders:write scope)
checklistFoldersRoutes.post("/folders/:id/move-items", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const targetFolderId = c.req.param("id");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { templateIds = [], folderIds = [] } = body;

    // Buscar perfil do usuÃ¡rio
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Verificar se pasta destino existe (pode ser null para raiz)
    if (targetFolderId && targetFolderId !== 'null' && targetFolderId !== 'undefined') {
      const targetFolder = await env.DB.prepare(`
        SELECT id FROM checklist_folders 
        WHERE id = ? AND (organization_id = ? OR organization_id IS NULL)
      `).bind(targetFolderId, userProfile?.organization_id || null).first();

      if (!targetFolder) {
        return c.json({
          error: `Pasta destino nÃ£o encontrada. ID: ${targetFolderId}, Org: ${userProfile?.organization_id}`
        }, 404);
      }
    }

    const finalTargetId = (targetFolderId === 'null') ? null : targetFolderId;
    let movedCount = 0;

    const isAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
      userProfile?.role === 'sys_admin' ||
      userProfile?.role === 'admin';

    // Mover templates
    if (templateIds.length > 0) {
      for (const templateId of templateIds) {
        if (isAdmin) {
          const result = await env.DB.prepare(`
            UPDATE checklist_templates 
            SET folder_id = ?, updated_at = NOW()
            WHERE id = ? AND organization_id = ?
          `).bind(finalTargetId, templateId, userProfile?.organization_id || null).run();

          movedCount += result.meta.changes || 0;
        } else {
          const result = await env.DB.prepare(`
            INSERT INTO user_checklist_layout (
              user_id, checklist_template_id, folder_id, display_order, created_at, updated_at
            ) VALUES (?, ?, ?, 0, NOW(), NOW())
            ON CONFLICT (user_id, checklist_template_id)
            DO UPDATE SET folder_id = EXCLUDED.folder_id, updated_at = NOW()
          `).bind(user.id, templateId, finalTargetId).run();

          movedCount += result.meta.changes || 0;
        }
      }
    }

    // Mover pastas (somente system admin). Para outros, ignorar silently.
    if (folderIds.length > 0) {
      if (isAdmin) {
        for (const folderId of folderIds) {
          // Verificar se nÃ£o estÃ¡ tentando mover para dentro de si mesma
          if (finalTargetId) {
            let currentParent = finalTargetId;
            let isCycle = false;

            while (currentParent && !isCycle) {
              if (currentParent === folderId) {
                isCycle = true;
                break;
              }

              const parent = await env.DB.prepare("SELECT parent_id FROM checklist_folders WHERE id = ?")
                .bind(currentParent).first() as any;
              currentParent = parent?.parent_id;
            }

            if (isCycle) {
              continue; // Pular esta pasta para evitar ciclo
            }
          }

          const result = await env.DB.prepare(`
            UPDATE checklist_folders 
            SET parent_id = ?, updated_at = NOW()
            WHERE id = ? AND organization_id = ?
          `).bind(finalTargetId, folderId, userProfile?.organization_id || null).run();

          if (result.meta.changes && result.meta.changes > 0) {
            // Atualizar paths em cascata
            await updateFolderPaths(env.DB, folderId);
            movedCount += result.meta.changes;
          }
        }
      }
    }

    return c.json({
      message: `${movedCount} itens movidos com sucesso`,
      moved_count: movedCount,
      mode: isAdmin ? 'global' : 'user_layout'
    });

  } catch (error) {
    console.error('Error moving items:', error);
    return c.json({ error: "Failed to move items" }, 500);
  }
});

export default checklistFoldersRoutes;

===END_FILE===
===FILE: supabase/functions/api/checklist-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";
import { logActivity } from "./audit-logger.ts";
import { aiRateLimitMiddleware, finalizeAIUsage } from "./ai-rate-limit.ts";
import { generateAICompletion } from "./ai-service.ts";
import { incrementAiUsage } from "./ai-usage-tracker.ts";

type Env = {
  DB: any;
  OPENAI_API_KEY?: string;
  [key: string]: any;
};

// Helper to handle BigInt serialization
// Helper to handle BigInt serialization - ROBUST RECURSIVE
const safeJson = (data: any): any => {
  if (data === null || data === undefined) return data;
  if (typeof data === 'bigint') return data.toString();
  if (Array.isArray(data)) return data.map(safeJson);
  if (typeof data === 'object') {
    return Object.fromEntries(
      Object.entries(data).map(([key, value]) => [key, safeJson(value)])
    );
  }
  return data;
};

const checklistRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/checklist');

// List all checklist templates - ENHANCED ADMIN VISIBILITY
// List all checklist templates - ENHANCED ADMIN VISIBILITY
checklistRoutes.get("/templates", tenantAuthMiddleware, async (c) => {
  // Reuse the same logic - copy paste or function extraction would be better but for now replacing content
  // Actually, I can just mount the same handler if I extracted it, but for this tool I need to careful.
  // I will just change the existing route to be /templates OR keep both if I want backward compatibility.
  // Given this is a new app phase, let's just CHANGE it to /templates as it is cleaner, 
  // BUT wait, looking at the code I see "/checklist-templates". I should probably just change that line to "/templates" 
  // since "checklist" is already in the prefix from index.ts.
  // So URL will be /api/checklist/templates. Perfect.
  return handleListTemplates(c);
});

checklistRoutes.get("/checklist-templates", tenantAuthMiddleware, async (c) => {
  return handleListTemplates(c);
});

async function handleListTemplates(c: any) {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  // Verificar se o banco de dados estÃ¡ disponÃ­vel
  if (!env?.DB) {
    return c.json({ error: "Database nÃ£o disponÃ­vel", templates: [] }, 503);
  }

  try {
    // STAGE 1: Fetch User Profile
    let userProfile: any = null;
    try {
      userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first();
      if (!userProfile && (user as any).profile) {
        userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
      }
    } catch (userErr: any) {
      console.error('[TEMPLATES] User Fetch Error:', userErr);
      // Fail open or return error? Let's return error to debug
      throw new Error(`User Fetch Error: ${userErr.message} (binding user.id: ${user.id})`);
    }

    console.log(`[TEMPLATES] [PROD] Usuario ${user.email} role: ${userProfile?.role} org: ${userProfile?.organization_id}`);

    // STAGE 2: Fetch Templates
    // SIMPLIFIED QUERY: Removed JOINs to rule out performance issues
    let query = `
      SELECT ct.*,
        COALESCE(ul.folder_id, ct.folder_id) as effective_folder_id,
        COALESCE(ul.display_order, ct.display_order) as effective_display_order
      FROM checklist_templates ct
      LEFT JOIN user_checklist_layout ul
        ON ul.checklist_template_id = ct.id AND ul.user_id = ?
    `;
    let params: any[] = [user.id];
    let whereClause = ["(ct.is_category_folder = false OR ct.is_category_folder IS NULL)"];

    // ADMIN SYSTEM TEM ACESSO IRRESTRITO A TUDO
    if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'admin') {
      // ...
    } else {
      // ...
      let conditions = ["ct.is_public = true", "ct.created_by_user_id = ?"];
      params.push(user.id);

      if (userProfile?.organization_id) {
        conditions.push("ct.organization_id = ?");
        params.push(userProfile.organization_id);
      } else {
        conditions.push("ct.organization_id IS NULL");
      }
      whereClause.push(`(${conditions.join(" OR ")})`);
    }

    // Filter by folder_id - ROBUST NORMALIZATION
    const rawFolderId = c.req.query("folder_id");
    const folderId = (rawFolderId === undefined || rawFolderId === null || rawFolderId === '' || rawFolderId === 'null' || rawFolderId === 'undefined') ? null : rawFolderId;

    if (folderId && folderId !== null) {
      whereClause.push("COALESCE(ul.folder_id, ct.folder_id) = ?");
      params.push(folderId);
    } else if (folderId === null) {
      whereClause.push("COALESCE(ul.folder_id, ct.folder_id) IS NULL");
    }

    if (whereClause.length > 0) {
      query += " WHERE " + whereClause.join(" AND ");
    }

    query += " ORDER BY COALESCE(ul.display_order, ct.display_order) ASC, ct.created_at DESC";

    console.log(`[TEMPLATES] [DEBUG] Query: ${query}`);
    console.log(`[TEMPLATES] [DEBUG] Params: ${JSON.stringify(params)}`);
    if (params.length > 1) {
      console.log(`[TEMPLATES] [DEBUG] OrgID Type: ${typeof params[1]} Value: ${params[1]}`);
    }

    const startTime = Date.now();
    // Using .all() directly on the prepared statement
    const result = await env.DB.prepare(query).bind(...params).all();
    console.log(`[TEMPLATES] [DEBUG] DB Exec Time: ${Date.now() - startTime}ms`);

    const templates = result.results || [];

    // Manually calculate field_count (if critical, otherwise remove or fetch separately)
    // For now returning 0 to fix stability
    const templatesWithCounts = templates.map((t: any) => ({
      ...t,
      folder_id: t.effective_folder_id ?? t.folder_id,
      display_order: t.effective_display_order ?? t.display_order,
      field_count: 0, // Placeholder to avoid JOIN
      is_folder: t.is_category_folder
    }));

    console.log(`[TEMPLATES] [PROD] Found ${templates.length} templates. Serializing...`);

    const jsonStart = Date.now();
    const response = c.json(safeJson({ templates: templatesWithCounts }));
    console.log(`[TEMPLATES] [DEBUG] JSON Serialize Time: ${Date.now() - jsonStart}ms`);

    return response;

  } catch (error) {
    console.error('[TEMPLATES] [FATAL ERROR] Fetching templates:', error);
    return c.json({
      error: error instanceof Error ? error.message : "Failed to fetch templates",
      details: error instanceof Error ? error.stack : undefined,
      user_id: user?.id,
      timestamp: new Date().toISOString()
    }, 500);
  }
}

// Get specific checklist template with fields
checklistRoutes.get("/checklist-templates/:id", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const templateId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get template
    const template = await env.DB.prepare("SELECT * FROM checklist_templates WHERE id = ?").bind(templateId).first() as any;

    if (!template) {
      return c.json({ error: "Template not found" }, 404);
    }

    // Check access permissions
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }
    const canAccess = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
      template.is_public ||
      template.created_by_user_id === user.id ||
      template.organization_id === userProfile?.organization_id;

    if (!canAccess) {
      return c.json({ error: "Access denied" }, 403);
    }

    // Get fields
    const fields = await env.DB.prepare(`
      SELECT * FROM checklist_fields 
      WHERE template_id = ? 
      ORDER BY order_index ASC
    `).bind(templateId).all();

    return c.json({
      template,
      fields: fields.results || []
    });
  } catch (error) {
    console.error('Error fetching template:', error);
    return c.json({ error: "Failed to fetch template" }, 500);
  }
});

// Create checklist template
checklistRoutes.post("/checklist-templates", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { name, description, category, is_public, parent_category_id, folder_id } = body;

    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    const result = await env.DB.prepare(`
      INSERT INTO checklist_templates (
        name, description, category, created_by, created_by_user_id, 
        organization_id, is_public, parent_category_id, folder_id,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW()) RETURNING id
    `).bind(
      name,
      description || null,
      category,
      user.google_user_data?.name || user.email,
      user.id,
      userProfile?.organization_id || null,
      is_public || false,
      parent_category_id || null,
      folder_id || null
    ).run();

    const newTemplateId = result.meta.last_row_id;

    // Log Activity
    await logActivity(env, {
      userId: user.id,
      orgId: userProfile?.organization_id || null,
      actionType: 'CREATE',
      actionDescription: `Checklist Template Created: ${name}`,
      targetType: 'CHECKLIST_TEMPLATE',
      targetId: newTemplateId,
      metadata: { name, category, is_public },
      req: c.req
    });

    return c.json({
      id: newTemplateId,
      message: "Template created successfully"
    });
  } catch (error) {
    console.error('Error creating template:', error);
    return c.json({ error: "Failed to create template" }, 500);
  }
});

// Create checklist field
checklistRoutes.post("/checklist-fields", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    console.log('[CHECKLIST_FIELDS] Received body:', JSON.stringify(body));
    const { template_id, field_name, field_type, is_required, options, order_index } = body;

    if (!template_id || !field_name || !field_type) {
      return c.json({ error: "Missing required fields" }, 400);
    }

    // Verify template ownership/access
    const template = await env.DB.prepare("SELECT * FROM checklist_templates WHERE id = ?").bind(template_id).first() as any;

    if (!template) {
      return c.json({ error: "Template not found" }, 404);
    }

    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Check permissions
    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
      userProfile?.role === 'sys_admin' ||
      userProfile?.role === 'admin';

    if (!isSysAdmin) {
      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {
        return c.json({ error: "Insufficient permissions" }, 403);
      }
    }

    const result = await env.DB.prepare(`
      INSERT INTO checklist_fields (
        template_id, field_name, field_type, is_required, options, order_index,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW()) RETURNING id
    `).bind(
      template_id,
      field_name,
      field_type,
      is_required ? 1 : 0,
      options || null,
      order_index || 0
    ).run();

    return c.json({
      id: result.meta.last_row_id,
      message: "Field created successfully"
    });
  } catch (error) {
    console.error('Error creating field:', error);
    return c.json({ error: "Failed to create field" }, 500);
  }
});

// Update checklist template
checklistRoutes.put("/checklist-templates/:id", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const templateId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { name, description, category, is_public, folder_id } = body;

    // Check template ownership
    const template = await env.DB.prepare("SELECT * FROM checklist_templates WHERE id = ?").bind(templateId).first() as any;

    if (!template) {
      return c.json({ error: "Template not found" }, 404);
    }

    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Check permissions - SYS_ADMIN TEM ACESSO TOTAL
    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
      userProfile?.role === 'sys_admin' ||
      userProfile?.role === 'admin';

    if (!isSysAdmin) {
      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {
        return c.json({ error: "Insufficient permissions" }, 403);
      }
    }

    await env.DB.prepare(`
      UPDATE checklist_templates 
      SET name = ?, description = ?, category = ?, is_public = ?, folder_id = ?, updated_at = NOW()
      WHERE id = ?
    `).bind(name, description, category, is_public, folder_id || null, templateId).run();

    // Log update
    await logActivity(env, {
      userId: user.id,
      orgId: template.organization_id, // Use template org
      actionType: 'UPDATE',
      actionDescription: `Checklist Template Updated: ${name || template.name}`,
      targetType: 'CHECKLIST_TEMPLATE',
      targetId: templateId,
      metadata: { name, category, is_public },
      req: c.req
    });

    return c.json({ message: "Template updated successfully" });
  } catch (error) {
    console.error('Error updating template:', error);
    return c.json({ error: "Failed to update template" }, 500);
  }
});

// Delete checklist template
checklistRoutes.delete("/checklist-templates/:id", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const templateId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Check template ownership
    const template = await env.DB.prepare("SELECT * FROM checklist_templates WHERE id = ?").bind(templateId).first() as any;

    if (!template) {
      return c.json({ error: "Template not found" }, 404);
    }

    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Check permissions - SYS_ADMIN TEM ACESSO TOTAL
    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
      userProfile?.role === 'sys_admin' ||
      userProfile?.role === 'admin';

    if (!isSysAdmin) {
      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {
        return c.json({ error: "Insufficient permissions" }, 403);
      }
    }

    // Delete fields first
    await env.DB.prepare("DELETE FROM checklist_fields WHERE template_id = ?").bind(templateId).run();

    // Delete template
    await env.DB.prepare("DELETE FROM checklist_templates WHERE id = ?").bind(templateId).run();

    // Log deletion
    await logActivity(env, {
      userId: user.id,
      orgId: template.organization_id,
      actionType: 'DELETE',
      actionDescription: `Checklist Template Deleted: ${template.name}`,
      targetType: 'CHECKLIST_TEMPLATE',
      targetId: templateId,
      metadata: { name: template.name, category: template.category },
      req: c.req
    });

    return c.json({ message: "Template deleted successfully" });
  } catch (error) {
    console.error('Error deleting template:', error);
    return c.json({ error: "Failed to delete template" }, 500);
  }
});

// Duplicate checklist template
checklistRoutes.post("/checklist-templates/:id/duplicate", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const templateId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get original template
    const originalTemplate = await env.DB.prepare("SELECT * FROM checklist_templates WHERE id = ?").bind(templateId).first() as any;

    if (!originalTemplate) {
      return c.json({ error: "Template not found" }, 404);
    }

    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Create duplicate template
    const newName = `${originalTemplate.name} - CÃ³pia`;
    const result = await env.DB.prepare(`
      INSERT INTO checklist_templates (
        name, description, category, created_by, created_by_user_id, 
        organization_id, is_public, parent_category_id,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
    `).bind(
      newName,
      originalTemplate.description,
      originalTemplate.category,
      user.google_user_data?.name || user.email,
      user.id,
      userProfile?.organization_id || null,
      false, // Copies are private by default
      originalTemplate.parent_category_id
    ).run();

    const newTemplateId = result.meta.last_row_id as number;

    // OPTIMIZATION: Batch Insert (fix N+1 query)
    // Fetch fields first
    const fields = await env.DB.prepare("SELECT * FROM checklist_fields WHERE template_id = ?").bind(templateId).all();
    const fieldResults = fields.results || [];
    if (fieldResults.length > 0) {
      const nowIso = new Date().toISOString();

      let insertQuery = `
        INSERT INTO checklist_fields (
          template_id, field_name, field_type, is_required, options, order_index,
          created_at, updated_at
        ) VALUES 
      `;
      const insertParams: any[] = [];
      const placeholders: string[] = [];

      for (const field of fieldResults) {
        placeholders.push('(?, ?, ?, ?, ?, ?, ?, ?)');
        insertParams.push(
          newTemplateId,
          (field as any).field_name,
          (field as any).field_type,
          (field as any).is_required,
          (field as any).options,
          (field as any).order_index,
          nowIso,
          nowIso
        );
      }

      insertQuery += placeholders.join(', ');
      await env.DB.prepare(insertQuery).bind(...insertParams).run();
      console.log(`[DUPLICATE] Batch inserted ${fieldResults.length} fields for template ${newTemplateId}`);
    }

    return c.json({
      id: newTemplateId,
      message: "Template duplicated successfully"
    });
  } catch (error) {
    console.error('Error duplicating template:', error);
    return c.json({ error: "Failed to duplicate template" }, 500);
  }
});

// Share checklist template
checklistRoutes.put("/checklist-templates/:id/share", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const templateId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { visibility, shared_with } = body;

    // Check template ownership
    const template = await env.DB.prepare("SELECT * FROM checklist_templates WHERE id = ?").bind(templateId).first() as any;

    if (!template) {
      return c.json({ error: "Template not found" }, 404);
    }

    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Check permissions - only owner, org admins, or sys admins can share
    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
      userProfile?.role === 'sys_admin' ||
      userProfile?.role === 'admin';

    if (!isSysAdmin) {
      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {
        return c.json({ error: "Insufficient permissions" }, 403);
      }
    }

    // Validate visibility
    const validVisibilities = ['private', 'public', 'shared'];
    if (!validVisibilities.includes(visibility)) {
      return c.json({ error: "Invalid visibility value" }, 400);
    }

    // Update is_public based on visibility
    const isPublic = visibility === 'public';
    const sharedWithJson = visibility === 'shared' && shared_with ? JSON.stringify(shared_with) : null;

    await env.DB.prepare(`
      UPDATE checklist_templates 
      SET visibility = ?, is_public = ?, shared_with = ?, updated_at = NOW()
      WHERE id = ?
    `).bind(visibility, isPublic, sharedWithJson, templateId).run();

    // Log sharing
    await logActivity(env, {
      userId: user.id,
      orgId: template.organization_id,
      actionType: 'SHARE',
      actionDescription: `Checklist Template Shared: ${template.name}`,
      targetType: 'CHECKLIST_TEMPLATE',
      targetId: templateId,
      metadata: { visibility, is_public: isPublic },
      req: c.req
    });

    return c.json({ message: "Sharing settings updated successfully" });
  } catch (error) {
    console.error('Error updating share settings:', error);
    return c.json({ error: "Failed to update share settings" }, 500);
  }
});

// Generate AI checklist - simple version with enhanced error handling
// Includes rate limiting to track usage per organization
checklistRoutes.post("/checklist-templates/generate-ai-simple", tenantAuthMiddleware, aiRateLimitMiddleware('analysis'), async (c) => {
  const env = c.env;
  const user = c.get("user");

  console.log('[AI-CHECKLIST] Prompt Generation Route Hit - VERSION 2.2 (Stable - Fallback Active)');

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    console.log('[AI-CHECKLIST] Iniciando geraÃ§Ã£o de checklist...');

    const body = await c.req.json();
    const { industry, location_type, template_name, category, num_questions, specific_requirements, detail_level, regulation } = body;

    console.log('[AI-CHECKLIST] ParÃ¢metros recebidos:', {
      industry, location_type, template_name, category, num_questions
    });

    // Validate required fields
    if (!industry || !location_type || !template_name || !category) {
      return c.json({
        success: false,
        error: "Campos obrigatÃ³rios: setor, tipo de local, nome do template e categoria"
      }, 400);
    }

    // Check API keys
    const openAiKey = env?.OPENAI_API_KEY || Deno.env.get('OPENAI_API_KEY');
    const geminiKey = env?.GEMINI_API_KEY || Deno.env.get('GEMINI_API_KEY');

    if (!openAiKey && !geminiKey) {
      console.error('[AI-CHECKLIST] Nenhuma chave de API (OpenAI ou Gemini) configurada');
      return c.json({
        success: false,
        error: "IA nÃ£o configurada no sistema. Contate o suporte."
      }, 500);
    }

    console.log('[AI-CHECKLIST] Iniciando chamada para AI Service (Gemini/OpenAI)...');

    // Limit questions to prevent timeouts
    const limitedQuestions = Math.min(num_questions || 10, 15);

    // Construct context based on detail level
    let detailContext = "";
    switch (detail_level) {
      case 'basico':
        detailContext = "Crie perguntas simples e diretas (Sim/NÃ£o). Foque no essencial.";
        break;
      case 'avancado':
        detailContext = "Crie perguntas detalhadas e tÃ©cnicas. Inclua campos para mediÃ§Ãµes ou observaÃ§Ãµes especÃ­ficas onde aplicÃ¡vel.";
        break;
      case 'intermediario':
      default:
        detailContext = "Equilibre perguntas diretas com algumas que exijam observaÃ§Ã£o.";
    }

    // Construct regulation context
    const regulationContext = regulation && regulation !== 'Nenhuma norma especÃ­fica'
      ? `Baseie as perguntas estritamente na norma ${regulation}. Cite o item da norma se possÃ­vel.`
      : "Baseie-se nas melhores prÃ¡ticas de seguranÃ§a do trabalho.";

    // Create optimized AI prompt
    const prompt = `Crie um checklist de seguranÃ§a com ${limitedQuestions} perguntas para:
- Setor: ${industry}
- Local: ${location_type}
- Nome: ${template_name}
- Categoria: ${category}
${specific_requirements ? `- Requisitos: ${specific_requirements}` : ''}
- NÃ­vel de Detalhe: ${detail_level} (${detailContext})
- Norma/RegulamentaÃ§Ã£o: ${regulationContext}

Retorne APENAS JSON vÃ¡lido nesta estrutura exata:
{
  "template": {
    "name": "${template_name}",
    "description": "Checklist de seguranÃ§a para ${industry} - ${location_type}. Baseado em: ${regulation || 'Melhores prÃ¡ticas'}",
    "category": "${category}",
    "is_public": false
  },
  "fields": [
    {
      "field_name": "Pergunta sobre seguranÃ§a",
      "field_type": "boolean",
      "is_required": true,
      "options": "",
      "order_index": 0
    }
  ]
}

IMPORTANTE:
- Exatamente ${limitedQuestions} campos no array fields
- Use field_type: "boolean", "text", "textarea", "select", "rating", "date" ou "file"
- Para "select", use options: ["Conforme", "NÃ£o Conforme", "N/A"]
- Foque em itens prÃ¡ticos de seguranÃ§a
- Se o nÃ­vel for avanÃ§ado, vocÃª pode usar "text" para observaÃ§Ãµes obrigatÃ³rias em pontos crÃ­ticos
- Use "file" para solicitar evidÃªncias fotogrÃ¡ficas quando necessÃ¡rio`;

    // Fetch system settings for AI preferences
    let preferredProvider: 'gemini' | 'openai' = 'gemini';
    let fallbackEnabled = true;

    try {
      const settings = await env.DB.prepare("SELECT ai_primary_provider, ai_fallback_enabled FROM system_settings WHERE id = 'global'").first() as any;
      if (settings) {
        if (settings.ai_primary_provider === 'openai') preferredProvider = 'openai';
        // default is gemini if null or 'gemini'

        if (settings.ai_fallback_enabled === false || settings.ai_fallback_enabled === 0) {
          fallbackEnabled = false;
        }
      }
    } catch (err) {
      console.warn('[AI-CHECKLIST] Failed to fetch settings, using defaults:', err);
    }

    // Call AI Service with fallback
    const aiResult = await generateAICompletion(geminiKey, openAiKey, {
      systemPrompt: 'VocÃª Ã© um especialista em seguranÃ§a do trabalho. Responda SEMPRE com JSON vÃ¡lido, sem markdown ou texto adicional. Seja conciso e prÃ¡tico.',
      userPrompt: prompt,
      maxTokens: Math.min(1500, limitedQuestions * 100),
      temperature: 0.3,
      timeoutMs: 60000
    }, { preferredProvider, fallbackEnabled });

    if (!aiResult.success) {
      console.error('[AI-CHECKLIST] Erro na geraÃ§Ã£o IA:', aiResult.error);
      return c.json({
        success: false,
        error: aiResult.error || "Erro ao gerar checklist com IA."
      }, 500);
    }

    const content = aiResult.content;

    // Log which provider was used
    console.log(`[AI-CHECKLIST] Sucesso via ${aiResult.provider} (${aiResult.model}). Fallback usado: ${aiResult.fallbackUsed}`);

    // Parse AI response with robust error handling
    let aiData;
    try {
      // Try direct JSON parse first
      aiData = JSON.parse(content);
    } catch (parseError) {
      console.log('[AI-CHECKLIST] Direct parse failed, trying to extract JSON...');

      // Try to extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          aiData = JSON.parse(jsonMatch[0]);
        } catch (extractError) {
          console.error('[AI-CHECKLIST] JSON extraction failed:', extractError);
          return c.json({
            success: false,
            error: "IA retornou formato invÃ¡lido. Tente novamente com menos perguntas."
          }, 500);
        }
      } else {
        console.error('[AI-CHECKLIST] No JSON found in response');
        return c.json({
          success: false,
          error: "IA nÃ£o retornou dados vÃ¡lidos. Tente reformular a solicitaÃ§Ã£o."
        }, 500);
      }
    }

    // Validate AI response structure
    if (!aiData || typeof aiData !== 'object') {
      console.error('[AI-CHECKLIST] Invalid AI data structure:', typeof aiData);
      return c.json({
        success: false,
        error: "Estrutura de dados invÃ¡lida da IA"
      }, 500);
    }

    if (!aiData.template || !aiData.fields || !Array.isArray(aiData.fields)) {
      console.error('[AI-CHECKLIST] Missing required fields in AI response');
      return c.json({
        success: false,
        error: "IA nÃ£o retornou template completo. Tente novamente."
      }, 500);
    }

    if (aiData.fields.length === 0) {
      console.error('[AI-CHECKLIST] Empty fields array');
      return c.json({
        success: false,
        error: "IA nÃ£o gerou campos para o checklist. Tente com parÃ¢metros diferentes."
      }, 500);
    }

    console.log(`[AI-CHECKLIST] Successfully generated ${aiData.fields.length} fields`);

    // Clean up and validate the fields
    const cleanFields = aiData.fields
      .filter((field: any) => field && typeof field === 'object' && field.field_name)
      .map((field: any, index: number) => {
        // Ensure valid field_type
        const validTypes = ['boolean', 'text', 'textarea', 'select', 'multiselect', 'radio', 'rating', 'file'];
        const fieldType = validTypes.includes(field.field_type) ? field.field_type : 'boolean';

        // Process options for select/radio fields
        let processedOptions = '';
        if ((fieldType === 'select' || fieldType === 'radio') && field.options) {
          try {
            if (typeof field.options === 'string' && field.options.startsWith('[')) {
              const parsed = JSON.parse(field.options);
              processedOptions = JSON.stringify(Array.isArray(parsed) ? parsed : ['Conforme', 'NÃ£o Conforme', 'N/A']);
            } else if (Array.isArray(field.options)) {
              processedOptions = JSON.stringify(field.options);
            } else {
              processedOptions = JSON.stringify(['Conforme', 'NÃ£o Conforme', 'N/A']);
            }
          } catch (error) {
            processedOptions = JSON.stringify(['Conforme', 'NÃ£o Conforme', 'N/A']);
          }
        }

        return {
          field_name: String(field.field_name).trim().substring(0, 200),
          field_type: fieldType,
          is_required: Boolean(field.is_required),
          options: processedOptions,
          order_index: index
        };
      })
      .slice(0, limitedQuestions); // Ensure we don't exceed the limit

    if (cleanFields.length === 0) {
      console.error('[AI-CHECKLIST] No valid fields after cleaning');
      return c.json({
        success: false,
        error: "IA nÃ£o gerou campos vÃ¡lidos. Tente com parÃ¢metros diferentes."
      }, 500);
    }

    // Ensure template has valid structure
    const cleanTemplate = {
      name: String(aiData.template.name || template_name).trim().substring(0, 200),
      description: String(aiData.template.description || `Checklist de seguranÃ§a para ${industry} - ${location_type}`).trim().substring(0, 500),
      category: String(aiData.template.category || category).trim().substring(0, 100),
      is_public: Boolean(aiData.template.is_public || false)
    };

    console.log('[AI-CHECKLIST] Checklist gerado com sucesso');

    // Increment AI usage count for the organization using shared helper
    let usageIncremented = false;
    try {
      const userId = user.id || (user as any).sub;
      const usageResult = await incrementAiUsage(
        env.DB,
        userId,
        'checklist-generation',
        aiResult.model,
        aiResult.totalTokens
      );
      usageIncremented = usageResult.success;
    } catch (usageError) {
      console.error('[AI-CHECKLIST] Failed to update usage:', usageError);
      // Don't fail the request if usage tracking fails
    }

    return c.json({
      success: true,
      template: cleanTemplate,
      fields: cleanFields,
      meta: {
        generated_at: new Date().toISOString(),
        requested_questions: num_questions,
        delivered_questions: cleanFields.length,
        usage_incremented: usageIncremented
      }
    });

  } catch (error) {
    console.error('[AI-CHECKLIST] Erro geral:', error);

    // Handle specific error types
    if (error instanceof Error) {
      if (error.name === 'AbortError') {
        return c.json({
          success: false,
          error: "Timeout na geraÃ§Ã£o. Tente com menos perguntas (5-8)."
        }, 408);
      } else if (error.message.includes('fetch')) {
        return c.json({
          success: false,
          error: "Erro de conexÃ£o com a IA. Verifique sua internet e tente novamente."
        }, 502);
      }
    }

    return c.json({
      success: false,
      error: error instanceof Error ? error.message : "Erro interno do servidor"
    }, 500);
  }
});

// Generate AI CSV - Universal Importer Route
checklistRoutes.post("/checklist-templates/generate-ai-csv", tenantAuthMiddleware, aiRateLimitMiddleware('analysis'), async (c) => {
  const env = c.env;
  const user = c.get("user");

  console.log('[AI-CSV] CSV Generation Route Hit');

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { text, images, context } = body;

    // Check API keys
    const openAiKey = env?.OPENAI_API_KEY || Deno.env.get('OPENAI_API_KEY');
    const geminiKey = env?.GEMINI_API_KEY || Deno.env.get('GEMINI_API_KEY');

    if (!openAiKey && !geminiKey) {
      return c.json({
        success: false,
        error: "IA nÃ£o configurada no sistema."
      }, 500);
    }

    // SYSTEM PROMPT FOR CSV
    const systemPrompt = \`VocÃª Ã© um especialista em SeguranÃ§a do Trabalho e estruturaÃ§Ã£o de dados.
SUA TAREFA: Analisar o input (texto, imagem ou planilha) e converter para um CHECKLIST no formato CSV padrÃ£o do sistema.

FORMATO CSV OBRIGATÃ“RIO (CabeÃ§alho + Dados):
campo,tipo,obrigatorio,opcoes
"Nome do Item","text","true",
"CondiÃ§Ã£o","select","true","Conforme|NÃ£o Conforme|N/A"

REGRAS DE TIPOS DE CAMPO:
- "text": Para nomes, localizaÃ§Ãµes, identificadores.
- "textarea": Para observaÃ§Ãµes ou descriÃ§Ãµes (use para campos abertos).
- "boolean": Para perguntas de Sim/NÃ£o ou Conforme/NÃ£o Conforme simples.
- "select": Para listas. AS OPÃ‡Ã•ES DEVEM SER SEPARADAS POR PIPE (|). Ex: "Bom|Ruim".
- "rating": Para avaliaÃ§Ãµes de 1 a 5.
- "date": Para datas.
- "file": Para evidÃªncias (fotos/arquivos).

DIRETRIZES:
1. Se o input for uma imagem de um checklist fÃ­sico, transcreva fielmente.
2. Se o input for um texto descrevendo um processo, crie perguntas lÃ³gicas de seguranÃ§a.
3. Se for um PDF/Planilha convertido em texto, tente manter a estrutura original.
4. "obrigatorio" deve ser "true" ou "false".
5. REMOVA qualquer texto introdutÃ³rio. RETORNE APENAS O CSV BRUTO.
6. Use aspas duplas nos valores para evitar erros com vÃ­rgulas.
\`;

    // User Prompt Construction
    let userPrompt = \`Contexto: \${context || 'Geral'}\n\n\`;
    
    if (text) {
      userPrompt += \`ConteÃºdo para processar:\n\${text}\n\n\`;
    }

    if (images && images.length > 0) {
      userPrompt += \`[O input contem \${images.length} imagens para anÃ¡lise visual]\n\`;
    }

    userPrompt += "Gere o CSV agora.";

    // Fetch Settings
    let preferredProvider: 'gemini' | 'openai' = 'gemini';
    let fallbackEnabled = true;

    try {
        const settings = await env.DB.prepare("SELECT ai_primary_provider, ai_fallback_enabled FROM system_settings WHERE id = 'global'").first() as any;
        if (settings) {
            if (settings.ai_primary_provider === 'openai') preferredProvider = 'openai';
            if (settings.ai_fallback_enabled === false || settings.ai_fallback_enabled === 0) fallbackEnabled = false;
        }
    } catch (e) { console.warn('Failed to fetch settings', e); }

    // Call AI Service
    const aiResult = await generateAICompletion(geminiKey, openAiKey, {
      systemPrompt,
      userPrompt,
      images: images, // Pass images to updated service
      maxTokens: 3000, 
      temperature: 0.2
    }, { preferredProvider, fallbackEnabled });

    if (!aiResult.success) {
      return c.json({ success: false, error: aiResult.error }, 500);
    }

    // Clean up result (remove markdown code blocks if present)
    let csvContent = aiResult.content;
    const codeBlockRegex = /\`\`\`csv([\s\S]*?)\`\`\`|\`\`\`([\s\S]*?)\`\`\`/i;
    const match = csvContent.match(codeBlockRegex);
    if (match) {
        csvContent = match[1] || match[2];
    }
    
    return c.json({
      success: true,
      csv: csvContent.trim()
    });

  } catch (error) {
    console.error('[AI-CSV] Error:', error);
    return c.json({ success: false, error: "Internal Server Error" }, 500);
  }
});

// Save generated checklist
checklistRoutes.post("/checklist-templates/save-generated", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { template, fields, folder_id } = body;

    // Validate user.id exists before any database operation
    const userId = user.id || (user as any).user_id || (user as any).sub;
    if (!userId) {
      console.error('[SAVE-GENERATED] User has no ID:', JSON.stringify(user));
      return c.json({
        error: "User ID not found",
        details: "Session user does not have a valid ID"
      }, 400);
    }

    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(userId).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: userId, email: user.email, name: (user as any).name };
    }

    // Create template - ensure no undefined values
    const createdBy = user.google_user_data?.name || user.email || 'Sistema';
    const createdByUserId = userId; // Use validated userId
    const orgId = userProfile?.organization_id || null;
    const isPublic = template.is_public === true ? true : false;
    const folderId = folder_id || null;

    console.log('[SAVE-GENERATED] Creating template with:', {
      name: template.name,
      category: template.category,
      createdBy,
      createdByUserId,
      orgId,
      isPublic,
      folderId
    });

    const templateResult = await env.DB.prepare(`
      INSERT INTO checklist_templates(
      name, description, category, created_by, created_by_user_id,
      organization_id, is_public, folder_id, created_at, updated_at
    ) VALUES(?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      RETURNING id
      `).bind(
      template.name || 'Checklist sem nome',
      template.description || null,
      template.category || 'Geral',
      createdBy,
      createdByUserId,
      orgId,
      isPublic,
      folderId
    ).first() as any;

    const templateId = templateResult?.id;

    if (!templateId) {
      console.error('[SAVE-GENERATED] Failed to get template ID after insert:', templateResult);
      return c.json({
        error: "Failed to create template",
        details: "Template ID not returned from database"
      }, 500);
    }

    console.log('[SAVE-GENERATED] Template created with ID:', templateId);

    // Create fields with enhanced validation
    for (const field of fields) {
      // Only process fields with valid names
      const fieldName = field.field_name?.trim();
      if (!fieldName) {
        console.warn('[SAVE-GENERATED] Skipping field without name:', field);
        continue;
      }

      // Ensure field_type is never undefined
      const fieldType = field.field_type || 'text';
      const isRequired = field.is_required === true;
      const orderIndex = typeof field.order_index === 'number' ? field.order_index : 0;

      let processedOptions: string | null = null;

      // VALIDAÃ‡ÃƒO: Garantir que campos que precisam de opÃ§Ãµes tenham opÃ§Ãµes vÃ¡lidas
      const fieldsRequiringOptions = ['select', 'multiselect', 'radio'];
      if (fieldsRequiringOptions.includes(fieldType)) {
        let validOptions: string[] = [];

        if (field.options && typeof field.options === 'string' && field.options.trim() !== '') {
          try {
            if (field.options.startsWith('[')) {
              const parsed = JSON.parse(field.options);
              if (Array.isArray(parsed)) {
                validOptions = parsed.filter((opt: any) => opt && String(opt).trim() !== '');
              }
            } else {
              validOptions = field.options.split(/[|\n]/).map((opt: string) => opt.trim()).filter((opt: string) => opt.length > 0);
            }
          } catch (error) {
            console.warn('Error parsing field options during save:', error);
          }
        } else if (Array.isArray(field.options)) {
          validOptions = field.options.filter((opt: any) => opt && String(opt).trim() !== '');
        }

        // Se nÃ£o hÃ¡ opÃ§Ãµes vÃ¡lidas, usar padrÃ£o
        if (validOptions.length === 0) {
          switch (fieldType) {
            case 'select':
            case 'radio':
              validOptions = ['Conforme', 'NÃ£o Conforme', 'NÃ£o AplicÃ¡vel'];
              break;
            case 'multiselect':
              validOptions = ['Adequado', 'Inadequado', 'NÃ£o Verificado', 'NÃ£o AplicÃ¡vel'];
              break;
          }
        }

        processedOptions = JSON.stringify(validOptions);
      } else if (field.options) {
        // For non-select fields, preserve options as-is if present
        processedOptions = typeof field.options === 'string' ? field.options : JSON.stringify(field.options);
      }

      console.log('[SAVE-GENERATED] Inserting field:', { fieldName, fieldType, isRequired, orderIndex });

      await env.DB.prepare(`
        INSERT INTO checklist_fields(
        template_id, field_name, field_type, is_required, options, order_index,
        created_at, updated_at
      ) VALUES(?, ?, ?, ?, ?, ?, NOW(), NOW())
      `).bind(
        templateId,
        fieldName,
        fieldType,
        isRequired,
        processedOptions,
        orderIndex
      ).run();
    }

    return c.json({
      id: templateId,
      message: "Generated template saved successfully"
    });
  } catch (error) {
    console.error('Error saving generated template:', error);
    return c.json({
      error: "Failed to save generated template",
      details: error instanceof Error ? error.message : "Unknown error"
    }, 500);
  }
});

// Delete template fields (for template editing)
checklistRoutes.delete("/checklist-templates/:id/fields", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const templateId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get user profile to check permissions
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Check if template exists
    const template = await env.DB.prepare("SELECT * FROM checklist_templates WHERE id = ?").bind(templateId).first() as any;

    if (!template) {
      return c.json({ error: "Template not found" }, 404);
    }

    // System admin can delete anything
    if (userProfile?.role !== USER_ROLES.SYSTEM_ADMIN) {
      // Check if user owns the template or it's in their organization
      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {
        return c.json({ error: "Insufficient permissions to modify this template" }, 403);
      }
    }

    // Delete all fields for this template
    await env.DB.prepare("DELETE FROM checklist_fields WHERE template_id = ?").bind(templateId).run();

    return c.json({ message: "Template fields deleted successfully" });
  } catch (error) {
    console.error('Error deleting template fields:', error);
    return c.json({ error: "Failed to delete template fields" }, 500);
  }
});

// Create checklist field
checklistRoutes.post("/checklist-fields", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { template_id, field_name, field_type, is_required, options, order_index } = body;

    // VALIDAÃ‡ÃƒO CRÃTICA: Campos que precisam de opÃ§Ãµes DEVEM ter opÃ§Ãµes vÃ¡lidas
    const fieldsRequiringOptions = ['select', 'multiselect', 'radio'];
    if (fieldsRequiringOptions.includes(field_type)) {
      let validOptions: string[] = [];

      // Tentar parsear as opÃ§Ãµes
      if (options && options.trim() !== '') {
        try {
          // Se Ã© string JSON, parsear
          if (typeof options === 'string' && options.startsWith('[')) {
            const parsed = JSON.parse(options);
            if (Array.isArray(parsed)) {
              validOptions = parsed.filter((opt: any) => opt && opt.trim() !== '');
            }
          } else if (typeof options === 'string') {
            // Se Ã© string separada por | ou \n
            validOptions = options.split(/[|\n]/).map((opt: string) => opt.trim()).filter((opt: string) => opt.length > 0);
          } else if (Array.isArray(options)) {
            validOptions = options.filter((opt: any) => opt && opt.trim() !== '');
          }
        } catch (error) {
          console.warn('Error parsing field options:', error);
        }
      }

      // Se nÃ£o hÃ¡ opÃ§Ãµes vÃ¡lidas, usar padrÃ£o baseado no tipo
      if (validOptions.length === 0) {
        switch (field_type) {
          case 'select':
          case 'radio':
            validOptions = ['Conforme', 'NÃ£o Conforme', 'NÃ£o AplicÃ¡vel'];
            break;
          case 'multiselect':
            validOptions = ['Adequado', 'Inadequado', 'NÃ£o Verificado', 'NÃ£o AplicÃ¡vel'];
            break;
        }
      }

      // Se ainda nÃ£o hÃ¡ opÃ§Ãµes, retornar erro
      if (validOptions.length === 0) {
        return c.json({
          error: `Campo do tipo "${field_type}" requer pelo menos uma opÃ§Ã£o vÃ¡lida.Por favor, forneÃ§a as opÃ§Ãµes necessÃ¡rias.`,
          field_type,
          suggested_options: ['Conforme', 'NÃ£o Conforme', 'NÃ£o AplicÃ¡vel']
        }, 400);
      }

      // Garantir que options Ã© uma string JSON vÃ¡lida
      body.options = JSON.stringify(validOptions);
    }

    // Get user profile to check permissions
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    if (!userProfile && (user as any).profile) {
      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };
    }

    // Check if template exists
    const template = await env.DB.prepare("SELECT * FROM checklist_templates WHERE id = ?").bind(template_id).first() as any;

    if (!template) {
      return c.json({ error: "Template not found" }, 404);
    }

    // System admin can edit anything
    if (userProfile?.role !== USER_ROLES.SYSTEM_ADMIN) {
      // Check if user owns the template or it's in their organization
      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {
        return c.json({ error: "Insufficient permissions to modify this template" }, 403);
      }
    }

    // Create field
    await env.DB.prepare(`
      INSERT INTO checklist_fields(
        template_id, field_name, field_type, is_required, options, order_index,
        created_at, updated_at
      ) VALUES(?, ?, ?, ?, ?, ?, NOW(), NOW())
        `).bind(
      template_id,
      field_name,
      field_type,
      is_required || false,
      options || null,
      order_index || 0
    ).run();

    return c.json({ message: "Field created successfully" });
  } catch (error) {
    console.error('Error creating checklist field:', error);
    return c.json({ error: "Failed to create field" }, 500);
  }
});

// Create folder for templates
checklistRoutes.post("/checklist-templates/create-folder", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { name, description, category, folder_color, folder_icon, parent_category_id } = body;

    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    // Create folder
    const result = await env.DB.prepare(`
      INSERT INTO checklist_templates(
          name, description, category, is_category_folder, folder_color, folder_icon,
          parent_category_id, created_by, created_by_user_id, organization_id, is_public,
          created_at, updated_at
        ) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
          `).bind(
      name,
      description || null,
      category,
      true, // is_category_folder
      folder_color || '#3B82F6',
      folder_icon || 'folder',
      parent_category_id || null,
      user.google_user_data?.name || user.email,
      user.id,
      userProfile?.organization_id || null,
      true // public by default
    ).run();

    return c.json({
      id: result.meta.last_row_id,
      message: "Folder created successfully"
    });
  } catch (error) {
    console.error('Error creating folder:', error);
    return c.json({ error: "Failed to create folder" }, 500);
  }
});

// Pre-analysis with AI multimodal support
checklistRoutes.post("/inspection-items/:itemId/pre-analysis", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (!env.OPENAI_API_KEY) {
    return c.json({ error: "IA nÃ£o disponÃ­vel" }, 503);
  }

  try {
    const body = await c.req.json();
    const { field_name, response_value, media_data, user_prompt } = body;

    // Get inspection item and context
    const item = await env.DB.prepare(`
      SELECT ii.*, i.location, i.company_name, i.title as inspection_title
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
      `).bind(itemId).first() as any;

    if (!item) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // Prepare media context - SEMPRE mencionar se hÃ¡ ou nÃ£o mÃ­dias
    let mediaContext = '';
    let hasMedia = false;

    if (media_data && media_data.length > 0) {
      hasMedia = true;
      const mediaTypes = media_data.reduce((acc: any, media: any) => {
        acc[media.media_type] = (acc[media.media_type] || 0) + 1;
        return acc;
      }, {});

      mediaContext = `EVIDÃŠNCIAS DISPONÃVEIS: ${ mediaTypes.image || 0 } foto(s), ${ mediaTypes.audio || 0 } Ã¡udio(s), ${ mediaTypes.video || 0 } vÃ­deo(s) foram analisados.`;
    } else {
      mediaContext = `EVIDÃŠNCIAS DISPONÃVEIS: Nenhuma mÃ­dia(foto, Ã¡udio ou vÃ­deo) foi anexada.AnÃ¡lise baseada apenas na resposta do inspetor.`;
    }

    // Create comprehensive and detailed prompt for deeper analysis
    const prompt = `VocÃª Ã© um especialista sÃªnior em seguranÃ§a do trabalho e saÃºde ocupacional, com vasta experiÃªncia em anÃ¡lise de conformidade regulatÃ³ria e gestÃ£o de riscos.

CONTEXTO DETALHADO DA INSPEÃ‡ÃƒO:
    - Local da InspeÃ§Ã£o: ${ item.location }
    - Empresa Inspecionada: ${ item.company_name }
    - TÃ­tulo da InspeÃ§Ã£o: ${ item.inspection_title }

ITEM ESPECÃFICO EM ANÃLISE:
    - Campo Inspecionado: ${ field_name }
    - Categoria do Item: ${ item.category }
      - DescriÃ§Ã£o Completa do Item: ${ item.item_description }
        - Resposta Fornecida pelo Inspetor: ${ response_value !== null && response_value !== undefined ? response_value : 'NÃ£o respondido' }
    - ObservaÃ§Ãµes Adicionais do Inspetor: ${ item.observations || 'Nenhuma observaÃ§Ã£o prÃ©via' }

${ mediaContext }

${ user_prompt ? `FOCO PRINCIPAL FORNECIDO PELO USUÃRIO: ${user_prompt}. Priorize esta informaÃ§Ã£o em sua anÃ¡lise detalhada.` : '' }

SUA TAREFA:
Realize uma ** anÃ¡lise tÃ©cnica aprofundada e abrangente ** deste item inspecionado considerando:

    1. ** ObservaÃ§Ãµes Detalhadas **: Descreva minuciosamente o que foi observado e como se relaciona com as evidÃªncias disponÃ­veis
    2. ** AnÃ¡lise de Conformidade **: Avalie claramente se o item estÃ¡ conforme ou nÃ£o conforme com as normas de seguranÃ§a aplicÃ¡veis(cite NRs especÃ­ficas quando relevante)
    3. ** IdentificaÃ§Ã£o de Riscos **: Detalhe os riscos potenciais associados Ã  condiÃ§Ã£o atual do item, incluindo consequÃªncias de curto e longo prazo
    4. ** Causa Raiz **: Identifique possÃ­veis causas fundamentais da nÃ£o conformidade(se aplicÃ¡vel)
    5. ** ImplicaÃ§Ãµes RegulatÃ³rias **: Mencione possÃ­veis implicaÃ§Ãµes com Ã³rgÃ£os fiscalizadores se relevante
    6. ** UrgÃªncia e Prioridade **: Indique claramente a urgÃªncia de uma aÃ§Ã£o corretiva(Baixa, MÃ©dia, Alta, CrÃ­tica) e justifique
    7. ** RecomendaÃ§Ã£o EspecÃ­fica **: Sugira claramente se uma aÃ§Ã£o corretiva Ã© necessÃ¡ria e qual a natureza geral dessa aÃ§Ã£o

ForneÃ§a uma anÃ¡lise estruturada e tÃ©cnica(mÃ¡ximo 600 caracteres) em texto corrido simples.NÃƒO use markdown, asteriscos, negrito, itÃ¡lico, listas ou qualquer formataÃ§Ã£o especial.Seja direto, objetivo e tecnicamente preciso.`;

    // Call OpenAI API
    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${ env.OPENAI_API_KEY } `,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: 'VocÃª Ã© um especialista em seguranÃ§a do trabalho. ForneÃ§a anÃ¡lises tÃ©cnicas objetivas e concisas em texto simples. Seja especÃ­fico sobre evidÃªncias disponÃ­veis e necessidade de aÃ§Ãµes.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 800,
        temperature: 0.4
      })
    });

    if (!openaiResponse.ok) {
      const errorText = await openaiResponse.text();
      console.error('OpenAI API Error:', openaiResponse.status, errorText);
      throw new Error(`Erro na API da OpenAI: ${ openaiResponse.status } `);
    }

    // Robust JSON parsing with HTML error handling
    let openaiResult;
    try {
      const responseText = await openaiResponse.text();

      // Check if response is HTML (common error response format)
      if (responseText.trim().startsWith('<')) {
        console.error('OpenAI returned HTML instead of JSON:', responseText);
        throw new Error('API da OpenAI retornou resposta invÃ¡lida (HTML). Verifique a chave da API e tente novamente.');
      }

      openaiResult = JSON.parse(responseText);
    } catch (parseError) {
      console.error('Failed to parse OpenAI response:', parseError);
      throw new Error('Erro ao processar resposta da IA. Tente novamente.');
    }

    const analysis = openaiResult.choices?.[0]?.message?.content;

    if (!analysis) {
      throw new Error('Resposta invÃ¡lida da IA');
    }

    // Clean up analysis - remove markdown and excessive formatting
    const cleanAnalysis = analysis
      .replace(/\*\*/g, '')
      .replace(/\*/g, '')
      .replace(/#{1,6}\s/g, '')
      .replace(/`/ g, '')
  .replace(/^\s*-\s*/gm, 'â€¢ ')
  .replace(/\n{3,}/g, '\n\n')
  .trim();

// Update the inspection item with the analysis
await env.DB.prepare(`
      UPDATE inspection_items 
      SET ai_pre_analysis = ?, updated_at = NOW()
      WHERE id = ?
    `).bind(cleanAnalysis, itemId).run();

return c.json({
  success: true,
  analysis: cleanAnalysis,
  pre_analysis: cleanAnalysis,
  media_analyzed: hasMedia ? media_data.length : 0,
  item_id: itemId,
  timestamp: new Date().toISOString()
});

  } catch (error) {
  console.error('Error in pre-analysis:', error);
  return c.json({
    error: "Erro ao fazer prÃ©-anÃ¡lise",
    details: error instanceof Error ? error.message : "Erro desconhecido"
  }, 500);
}
});

// Generate field response with AI multimodal analysis
checklistRoutes.post("/inspection-items/:itemId/generate-field-response", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (!env.OPENAI_API_KEY) {
    return c.json({ error: "IA nÃ£o disponÃ­vel" }, 503);
  }

  try {
    const body = await c.req.json();
    const { field_name, field_type, current_response, media_data, field_options } = body;

    // Get inspection item and context
    const item = await env.DB.prepare(`
      SELECT ii.*, i.location, i.company_name, i.title as inspection_title
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
    `).bind(itemId).first() as any;

    if (!item) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // Parse field options
    let availableOptions: string[] = [];
    if (field_options) {
      try {
        if (typeof field_options === 'string' && field_options.startsWith('[')) {
          availableOptions = JSON.parse(field_options);
        } else if (typeof field_options === 'string') {
          availableOptions = field_options.split('|').map(opt => opt.trim()).filter(opt => opt);
        } else if (Array.isArray(field_options)) {
          availableOptions = field_options;
        }
      } catch (error) {
        console.error('Error parsing field options:', error);
      }
    }

    // Prepare media analysis content - SEMPRE mencionar status das mÃ­dias
    let mediaAnalysisContent = '';
    if (media_data && media_data.length > 0) {
      const mediaTypes = media_data.reduce((acc: any, media: any) => {
        acc[media.media_type] = (acc[media.media_type] || 0) + 1;
        return acc;
      }, {});

      mediaAnalysisContent = `EVIDÃŠNCIAS DISPONÃVEIS: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} Ã¡udio(s), ${mediaTypes.video || 0} vÃ­deo(s) analisados para gerar resposta.`;
    } else {
      mediaAnalysisContent = `EVIDÃŠNCIAS DISPONÃVEIS: Nenhuma mÃ­dia anexada. Resposta baseada no contexto da inspeÃ§Ã£o e conhecimento tÃ©cnico.`;
    }

    // Create specialized prompt based on field type
    let responseInstructions = '';
    switch (field_type) {
      case 'boolean':
        responseInstructions = `
RESPOSTA ESPERADA: true (Conforme) ou false (NÃ£o Conforme)
CRITÃ‰RIO: Avalie se o item estÃ¡ em conformidade com as normas de seguranÃ§a.`;
        break;
      case 'select':
      case 'radio':
        if (availableOptions.length > 0) {
          responseInstructions = `
RESPOSTA ESPERADA: Uma das opÃ§Ãµes disponÃ­veis: ${availableOptions.join(', ')}
CRITÃ‰RIO: Escolha a opÃ§Ã£o que melhor descreve a situaÃ§Ã£o observada.`;
        } else {
          responseInstructions = `
RESPOSTA ESPERADA: Uma descriÃ§Ã£o textual da condiÃ§Ã£o observada.`;
        }
        break;
      case 'multiselect':
        if (availableOptions.length > 0) {
          responseInstructions = `
RESPOSTA ESPERADA: Array com uma ou mais opÃ§Ãµes: ${availableOptions.join(', ')}
CRITÃ‰RIO: Selecione todas as opÃ§Ãµes que se aplicam Ã  situaÃ§Ã£o.`;
        }
        break;
      case 'rating':
        responseInstructions = `
RESPOSTA ESPERADA: NÃºmero de 1 a 5 (1 = Inadequado, 5 = Excelente)
CRITÃ‰RIO: Avalie a qualidade/conformidade do item observado.`;
        break;
      case 'text':
      case 'textarea':
        responseInstructions = `
RESPOSTA ESPERADA: DescriÃ§Ã£o textual detalhada
CRITÃ‰RIO: Descreva o que foi observado de forma objetiva e tÃ©cnica.`;
        break;
      default:
        responseInstructions = `
RESPOSTA ESPERADA: Valor adequado para o tipo de campo solicitado.`;
    }

    const prompt = `VocÃª Ã© um especialista sÃªnior em seguranÃ§a do trabalho e saÃºde ocupacional, com vasta experiÃªncia em anÃ¡lise de conformidade regulatÃ³ria e gestÃ£o de riscos industriais.

CONTEXTO DETALHADO DA INSPEÃ‡ÃƒO:
- Local da InspeÃ§Ã£o: ${item.location}
- Empresa Inspecionada: ${item.company_name}
- TÃ­tulo da InspeÃ§Ã£o: ${item.inspection_title}

ITEM ESPECÃFICO EM ANÃLISE:
- Campo Inspecionado: ${field_name}
- Tipo de Campo: ${field_type}
- Categoria do Item: ${item.category}
- DescriÃ§Ã£o Completa do Item: ${item.item_description}
- ObservaÃ§Ãµes Existentes: ${item.observations || 'Nenhuma observaÃ§Ã£o prÃ©via'}
- Resposta Atual: ${current_response !== null && current_response !== undefined ? current_response : 'NÃ£o respondido'}

${mediaAnalysisContent}

${responseInstructions}

SUA TAREFA ESPECIALIZADA:
Como especialista em seguranÃ§a, analise profundamente as evidÃªncias disponÃ­veis e forneÃ§a:

1. **AnÃ¡lise TÃ©cnica das EvidÃªncias**: Considere todos os aspectos tÃ©cnicos, normativos e de risco
2. **Resposta Baseada em EvidÃªncias**: Gere uma resposta precisa baseada na anÃ¡lise das evidÃªncias disponÃ­veis
3. **ComentÃ¡rio TÃ©cnico Detalhado**: ForneÃ§a um comentÃ¡rio tÃ©cnico abrangente (mÃ¡ximo 400 caracteres) que inclua:
   - O que foi especificamente observado nas evidÃªncias
   - ReferÃªncia Ã s normas aplicÃ¡veis (NRs, se relevante)
   - Justificativa tÃ©cnica para a resposta gerada
   - IdentificaÃ§Ã£o de riscos ou nÃ£o conformidades
   - UrgÃªncia de aÃ§Ã£o corretiva (se aplicÃ¡vel)

4. **AvaliaÃ§Ã£o de ConfianÃ§a**: Baseie sua confianÃ§a na qualidade e quantidade das evidÃªncias analisadas

Responda APENAS em formato JSON:
{
  "generated_response": <valor_da_resposta>,
  "generated_comment": "ComentÃ¡rio tÃ©cnico detalhado incluindo observaÃ§Ãµes especÃ­ficas das evidÃªncias, conformidade normativa, riscos identificados e justificativa da resposta",
  "confidence": "alta|media|baixa",
  "media_analyzed": ${media_data ? media_data.length : 0},
  "technical_analysis": "AnÃ¡lise tÃ©cnica especÃ­fica das evidÃªncias observadas",
  "regulatory_compliance": "Status de conformidade com normas aplicÃ¡veis"
}

Seja tecnicamente preciso, detalhado e especÃ­fico sobre as evidÃªncias analisadas.`;

    // Call OpenAI API
    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: 'VocÃª Ã© um especialista em seguranÃ§a do trabalho. Analise evidÃªncias e forneÃ§a respostas tÃ©cnicas precisas. Responda sempre em JSON vÃ¡lido.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 1200,
        temperature: 0.4
      })
    });

    if (!openaiResponse.ok) {
      const errorText = await openaiResponse.text();
      console.error('OpenAI API Error:', openaiResponse.status, errorText);
      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status}`);
    }

    // Robust JSON parsing with HTML error handling
    let openaiResult;
    try {
      const responseText = await openaiResponse.text();

      // Check if response is HTML (common error response format)
      if (responseText.trim().startsWith('<')) {
        console.error('OpenAI returned HTML instead of JSON:', responseText);
        throw new Error('API da OpenAI retornou resposta invÃ¡lida (HTML). Verifique a chave da API e tente novamente.');
      }

      openaiResult = JSON.parse(responseText);
    } catch (parseError) {
      console.error('Failed to parse OpenAI response:', parseError);
      throw new Error('Erro ao processar resposta da IA. Tente novamente.');
    }

    const content = openaiResult.choices?.[0]?.message?.content;

    if (!content) {
      throw new Error('Resposta invÃ¡lida da IA');
    }

    // Parse AI response
    let aiResult;
    try {
      aiResult = JSON.parse(content);
    } catch (parseError) {
      // Try to extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        aiResult = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('Falha ao parsear resposta da IA como JSON');
      }
    }

    // Validate and clean response based on field type
    let finalResponse = aiResult.generated_response;

    if (field_type === 'boolean') {
      if (typeof finalResponse === 'string') {
        finalResponse = finalResponse.toLowerCase() === 'true' || finalResponse === '1';
      } else if (typeof finalResponse !== 'boolean') {
        finalResponse = null;
      }
    } else if (field_type === 'multiselect') {
      if (!Array.isArray(finalResponse)) {
        if (typeof finalResponse === 'string') {
          finalResponse = [finalResponse];
        } else {
          finalResponse = [];
        }
      }
      // Filter to only valid options if available
      if (availableOptions.length > 0) {
        finalResponse = finalResponse.filter((opt: string) => availableOptions.includes(opt));
      }
    } else if ((field_type === 'select' || field_type === 'radio') && availableOptions.length > 0) {
      // Ensure response is one of the available options
      if (!availableOptions.includes(finalResponse)) {
        finalResponse = availableOptions[0]; // Default to first option
      }
    } else if (field_type === 'rating') {
      const numResponse = parseInt(finalResponse);
      if (isNaN(numResponse) || numResponse < 1 || numResponse > 5) {
        finalResponse = 3; // Default to middle rating
      } else {
        finalResponse = numResponse;
      }
    }

    return c.json({
      success: true,
      generated_response: finalResponse,
      generated_comment: aiResult.generated_comment || '',
      confidence: aiResult.confidence || 'media',
      media_analyzed: aiResult.media_analyzed || 0,
      item_id: itemId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error generating field response:', error);
    return c.json({
      error: "Erro ao gerar resposta do campo",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Create AI-generated action item for inspection item
checklistRoutes.post("/inspection-items/:itemId/create-action", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (!env.OPENAI_API_KEY) {
    return c.json({ error: "IA nÃ£o disponÃ­vel" }, 503);
  }

  try {
    const body = await c.req.json();
    const { field_name, field_type, response_value, pre_analysis, media_data, user_prompt } = body;

    // Get inspection item and context
    const item = await env.DB.prepare(`
      SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
    `).bind(itemId).first() as any;

    if (!item) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // CORRIGIDO: LÃ³gica melhorada para determinar necessidade de aÃ§Ã£o
    // Agora considera anÃ¡lise prÃ©via, evidÃªncias de mÃ­dia e respostas
    let needsAction = false;
    let riskLevel = 'baixo';
    let actionReason = '';

    // 1. Verificar resposta direta de nÃ£o conformidade
    if (field_type === 'boolean' && response_value === false) {
      needsAction = true;
      riskLevel = 'alto';
      actionReason = 'Item marcado como nÃ£o conforme';
    } else if (field_type === 'rating' && response_value <= 2) {
      needsAction = true;
      riskLevel = response_value === 1 ? 'critica' : 'alta';
      actionReason = `AvaliaÃ§Ã£o baixa (${response_value}/5)`;
    } else if (field_type === 'select' && response_value) {
      const valueStr = response_value.toLowerCase();
      if (valueStr.includes('nÃ£o conforme') || valueStr.includes('inadequado') ||
        valueStr.includes('nÃ£o aplicÃ¡vel') === false && valueStr.includes('conforme') === false) {
        needsAction = true;
        riskLevel = 'media';
        actionReason = `Resposta indica nÃ£o conformidade: ${response_value}`;
      }
    }

    // 2. Verificar anÃ¡lise prÃ©via para identificar riscos (NOVO)
    if (pre_analysis && !needsAction) {
      const analysisText = pre_analysis.toLowerCase();
      const riskKeywords = [
        'nÃ£o conforme', 'inadequado', 'risco', 'perigo', 'incorreto', 'falha',
        'violaÃ§Ã£o', 'infraÃ§Ã£o', 'necessÃ¡rio', 'corrigir', 'ajustar', 'melhorar',
        'aÃ§Ã£o', 'problema', 'deficiÃªncia', 'insuficiente'
      ];

      const foundRisks = riskKeywords.filter(keyword => analysisText.includes(keyword));
      if (foundRisks.length >= 2) {
        needsAction = true;
        riskLevel = 'media';
        actionReason = `AnÃ¡lise prÃ©via identificou riscos: ${foundRisks.slice(0, 3).join(', ')}`;
      }
    }

    // 3. Se ainda nÃ£o identificou necessidade, deixar a IA decidir baseada em evidÃªncias
    if (!needsAction && (media_data?.length > 0 || pre_analysis)) {
      needsAction = true; // Permitir que a IA analise e decida
      riskLevel = 'media';
      actionReason = 'AnÃ¡lise inteligente das evidÃªncias disponÃ­veis';
    }

    // ÃšLTIMA VALIDAÃ‡ÃƒO: Se realmente nÃ£o hÃ¡ nada para analisar
    if (!needsAction && !response_value && !pre_analysis && (!media_data || media_data.length === 0)) {
      return c.json({
        success: true,
        action: {
          requires_action: false,
          message: "NÃ£o hÃ¡ evidÃªncias suficientes (resposta, anÃ¡lise ou mÃ­dias) para determinar necessidade de aÃ§Ã£o. Adicione mais informaÃ§Ãµes para anÃ¡lise."
        }
      });
    }

    // CORRIGIDO: Preparar anÃ¡lise multimodal real das evidÃªncias
    let mediaContext = '';
    let mediaAnalysisMessages = [];

    if (media_data && media_data.length > 0) {
      const mediaTypes = media_data.reduce((acc: any, media: any) => {
        acc[media.media_type] = (acc[media.media_type] || 0) + 1;
        return acc;
      }, {});

      mediaContext = `EVIDÃŠNCIAS MULTIMODAIS ANALISADAS: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} Ã¡udio(s), ${mediaTypes.video || 0} vÃ­deo(s).`;

      // Preparar imagens para anÃ¡lise visual (mÃ¡ximo 3 para evitar timeout)
      const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);
      for (const img of imageMedia) {
        if (img.file_url) {
          mediaAnalysisMessages.push({
            type: "image_url",
            image_url: {
              url: img.file_url,
              detail: "high" // Para anÃ¡lise detalhada com gpt-4o-mini
            }
          });
        }
      }

      // Adicionar descriÃ§Ã£o de Ã¡udios/vÃ­deos se existirem
      const audioCount = mediaTypes.audio || 0;
      const videoCount = mediaTypes.video || 0;
      if (audioCount > 0 || videoCount > 0) {
        mediaContext += ` Inclui ${audioCount} Ã¡udio(s) e ${videoCount} vÃ­deo(s) que podem conter evidÃªncias sonoras de nÃ£o conformidades.`;
      }
    } else {
      mediaContext = `EVIDÃŠNCIAS DISPONÃVEIS: Nenhuma mÃ­dia anexada. AÃ§Ã£o baseada na resposta e anÃ¡lise prÃ©via.`;
    }

    // Construir mensagens para OpenAI incluindo anÃ¡lise visual
    const systemMessage = {
      role: 'system',
      content: 'VocÃª Ã© um especialista em seguranÃ§a do trabalho especializado em anÃ¡lise multimodal. Analise imagens, textos e contexto para criar planos de aÃ§Ã£o 5W2H precisos baseados em evidÃªncias reais.'
    };

    const userMessage = {
      role: 'user',
      content: [
        {
          type: "text",
          text: `Analise as evidÃªncias e determine se Ã© necessÃ¡ria uma aÃ§Ã£o corretiva.

CONTEXTO DA INSPEÃ‡ÃƒO:
- Local: ${item.location}
- Empresa: ${item.company_name}
- Item: ${field_name} (${item.category})
- DescriÃ§Ã£o: ${item.item_description}
- Resposta do Inspetor: ${response_value || 'NÃ£o respondido'}
- Motivo da AnÃ¡lise: ${actionReason}
- NÃ­vel de Risco Inicial: ${riskLevel}
- ObservaÃ§Ãµes: ${item.observations || 'Nenhuma'}

${mediaContext}

${pre_analysis ? `ANÃLISE PRÃ‰VIA DA IA:
${pre_analysis}

IMPORTANTE: Sua decisÃ£o deve ser coerente com esta anÃ¡lise prÃ©via.` : ''}

${user_prompt ? `FOCO ESPECÃFICO: ${user_prompt}` : ''}

INSTRUÃ‡Ã•ES DETALHADAS PARA ANÃLISE ESPECIALIZADA:
1. **AnÃ¡lise Multimodal Completa**: Examine minuciosamente todas as evidÃªncias disponÃ­veis (imagens, anÃ¡lise prÃ©via, resposta do inspetor, contexto)
2. **AvaliaÃ§Ã£o de Conformidade TÃ©cnica**: Determine conformidade com normas regulamentadoras aplicÃ¡veis (NRs, ABNT, ISO)
3. **AnÃ¡lise de Causa Raiz**: Identifique causas fundamentais de nÃ£o conformidades
4. **AvaliaÃ§Ã£o de Riscos**: Determine riscos de seguranÃ§a, saÃºde, ambientais e legais
5. **Tomada de DecisÃ£o**: Se aÃ§Ã£o corretiva Ã© necessÃ¡ria, crie plano 5W2H detalhado e especÃ­fico
6. **Justificativa TÃ©cnica**: Explique claramente a fundamentaÃ§Ã£o tÃ©cnica da decisÃ£o

Responda APENAS em formato JSON:
{
  "requires_action": true/false,
  "title": "TÃ­tulo especÃ­fico da aÃ§Ã£o ou motivo tÃ©cnico de nÃ£o necessidade",
  "what_description": "DescriÃ§Ã£o detalhada e especÃ­fica do que deve ser feito, incluindo etapas claras e objetivos mensurÃ¡veis",
  "where_location": "Local especÃ­fico da aÃ§Ã£o com detalhes do ambiente",
  "why_reason": "Justificativa tÃ©cnica abrangente baseada em anÃ¡lise de riscos, conformidade regulatÃ³ria e evidÃªncias observadas",
  "how_method": "Metodologia detalhada de execuÃ§Ã£o incluindo recursos necessÃ¡rios, procedimentos e padrÃµes tÃ©cnicos",
  "who_responsible": "ResponsÃ¡vel especÃ­fico com qualificaÃ§Ã£o tÃ©cnica adequada",
  "when_deadline": "Prazo em dias baseado na criticidade e urgÃªncia tÃ©cnica",
  "how_much_cost": "Estimativa detalhada incluindo recursos, materiais e mÃ£o de obra",
  "priority": "baixa|media|alta|critica",
  "evidence_analysis": "AnÃ¡lise tÃ©cnica detalhada das evidÃªncias observadas incluindo aspectos crÃ­ticos de seguranÃ§a",
  "visual_findings": "DescriÃ§Ã£o especÃ­fica e tÃ©cnica do que foi observado nas imagens com foco em nÃ£o conformidades",
  "regulatory_compliance": "Status de conformidade com normas aplicÃ¡veis e implicaÃ§Ãµes regulatÃ³rias",
  "risk_assessment": "AvaliaÃ§Ã£o detalhada dos riscos identificados e suas consequÃªncias potenciais",
  "root_cause_analysis": "AnÃ¡lise das causas fundamentais do problema identificado"
}`
        },
        ...mediaAnalysisMessages
      ]
    };

    const messages = [systemMessage, userMessage];

    // CORRIGIDO: Call OpenAI API com anÃ¡lise multimodal
    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini', // MudanÃ§a solicitada para gpt-4o-mini
        messages: messages,
        max_tokens: 2000, // Aumentado para anÃ¡lise mais detalhada
        temperature: 0.3 // Reduzido para mais consistÃªncia
      })
    });

    if (!openaiResponse.ok) {
      const errorText = await openaiResponse.text();
      console.error('OpenAI API Error:', openaiResponse.status, errorText);
      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status}`);
    }

    // Robust JSON parsing with HTML error handling
    let openaiResult;
    try {
      const responseText = await openaiResponse.text();

      // Check if response is HTML (common error response format)
      if (responseText.trim().startsWith('<')) {
        console.error('OpenAI returned HTML instead of JSON:', responseText);
        throw new Error('API da OpenAI retornou resposta invÃ¡lida (HTML). Verifique a chave da API e tente novamente.');
      }

      openaiResult = JSON.parse(responseText);
    } catch (parseError) {
      console.error('Failed to parse OpenAI response:', parseError);
      throw new Error('Erro ao processar resposta da IA. Tente novamente.');
    }

    const content = openaiResult.choices?.[0]?.message?.content;

    if (!content) {
      throw new Error('Resposta invÃ¡lida da IA');
    }

    // Parse AI response
    let actionPlan;
    try {
      actionPlan = JSON.parse(content);
    } catch (parseError) {
      // Try to extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        actionPlan = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('Falha ao parsear resposta da IA como JSON');
      }
    }

    if (actionPlan.requires_action) {
      // Calculate deadline
      const deadlineDays = parseInt(actionPlan.when_deadline) || 30;
      const deadlineDate = new Date();
      deadlineDate.setDate(deadlineDate.getDate() + deadlineDays);

      // Create action item in database
      const result = await env.DB.prepare(`
        INSERT INTO action_items (
          inspection_id, inspection_item_id, title, what_description, where_location,
          why_reason, how_method, who_responsible, when_deadline, how_much_cost,
          status, priority, is_ai_generated, assigned_to, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `).bind(
        item.inspection_id,
        itemId,
        actionPlan.title,
        actionPlan.what_description,
        actionPlan.where_location,
        actionPlan.why_reason,
        actionPlan.how_method,
        actionPlan.who_responsible,
        deadlineDate.toISOString().split('T')[0],
        actionPlan.how_much_cost,
        'pending',
        actionPlan.priority || 'media',
        true,
        actionPlan.who_responsible,
      ).run();

      // Update action plan in inspection item with enhanced analysis
      const enhancedPlan = {
        ...actionPlan,
        evidence_analysis: actionPlan.evidence_analysis || 'AnÃ¡lise baseada em evidÃªncias disponÃ­veis',
        visual_findings: actionPlan.visual_findings || 'Nenhuma anÃ¡lise visual especÃ­fica',
        media_analyzed: media_data ? media_data.length : 0,
        analysis_type: mediaAnalysisMessages.length > 0 ? 'multimodal' : 'textual'
      };

      await env.DB.prepare(`
        UPDATE inspection_items 
        SET ai_action_plan = ?, updated_at = NOW()
        WHERE id = ?
      `).bind(JSON.stringify(enhancedPlan), itemId).run();

      actionPlan.id = result.meta.last_row_id;
      actionPlan.evidence_analysis = enhancedPlan.evidence_analysis;
      actionPlan.visual_findings = enhancedPlan.visual_findings;
    }

    return c.json({
      success: true,
      action: actionPlan,
      item_id: itemId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error creating action with AI:', error);
    return c.json({
      error: "Erro ao criar aÃ§Ã£o com IA",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Delete pre-analysis for an inspection item
checklistRoutes.delete("/inspection-items/:itemId/pre-analysis", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Update the inspection item to remove pre-analysis
    await env.DB.prepare(`
      UPDATE inspection_items 
      SET ai_pre_analysis = NULL, updated_at = NOW()
      WHERE id = ?
    `).bind(itemId).run();

    return c.json({
      success: true,
      message: "PrÃ©-anÃ¡lise removida com sucesso"
    });

  } catch (error) {
    console.error('Error deleting pre-analysis:', error);
    return c.json({
      error: "Erro ao remover prÃ©-anÃ¡lise"
    }, 500);
  }
});

// Get actions for specific inspection item
checklistRoutes.get("/inspection-items/:itemId/actions", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get inspection item to verify access
    const item = await env.DB.prepare(`
      SELECT ii.*, i.created_by, i.organization_id
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
    `).bind(itemId).first() as any;

    if (!item) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // Get actions for this item
    const actions = await env.DB.prepare(`
      SELECT * FROM action_items 
      WHERE inspection_item_id = ?
      ORDER BY created_at DESC
    `).bind(itemId).all();

    return c.json({
      actions: actions.results || []
    });

  } catch (error) {
    console.error('Error fetching inspection item actions:', error);
    return c.json({ error: "Erro ao buscar aÃ§Ãµes do item" }, 500);
  }
});

// ================================
// ACTION ITEMS MANAGEMENT ENDPOINTS
// ================================

// Get action plan for inspection
checklistRoutes.get("/inspections/:id/action-plan", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get inspection to verify access
    const inspection = await env.DB.prepare(`
      SELECT i.*, u.role as user_role, u.organization_id as user_org_id
      FROM inspections i
      JOIN users u ON u.id = ?
      WHERE i.id = ?
    `).bind(user.id, inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Check access permissions
    const hasAccess = inspection.created_by === user.id ||
      inspection.organization_id === inspection.user_org_id ||
      inspection.user_role === 'system_admin';

    if (!hasAccess) {
      return c.json({ error: "Acesso negado" }, 403);
    }

    // Get action items for this inspection
    const actionItems = await env.DB.prepare(`
      SELECT ai.*, ii.category as item_category, ii.item_description
      FROM action_items ai
      LEFT JOIN inspection_items ii ON ai.inspection_item_id = ii.id
      WHERE ai.inspection_id = ?
      ORDER BY ai.created_at DESC
    `).bind(inspectionId).all();

    return c.json({
      inspection: {
        id: inspection.id,
        title: inspection.title,
        location: inspection.location,
        company_name: inspection.company_name,
        status: inspection.status
      },
      action_items: actionItems.results || []
    });

  } catch (error) {
    console.error('Error fetching action plan:', error);
    return c.json({ error: "Erro ao carregar plano de aÃ§Ã£o" }, 500);
  }
});

// Create manual action item
checklistRoutes.post("/inspections/:inspectionId/action-items", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("inspectionId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const {
      title,
      what_description,
      where_location,
      why_reason,
      how_method,
      who_responsible,
      when_deadline,
      how_much_cost,
      priority = 'media',
      assigned_to,
      inspection_item_id
    } = body;

    // Validate required fields
    if (!title || !what_description || !who_responsible) {
      return c.json({
        error: "Campos obrigatÃ³rios: tÃ­tulo, descriÃ§Ã£o do que fazer e responsÃ¡vel"
      }, 400);
    }

    // Get inspection to verify access and context
    const inspection = await env.DB.prepare(`
      SELECT i.*, u.role as user_role, u.organization_id as user_org_id
      FROM inspections i
      JOIN users u ON u.id = ?
      WHERE i.id = ?
    `).bind(user.id, inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Check permissions to create actions
    const canCreate = inspection.created_by === user.id ||
      inspection.organization_id === inspection.user_org_id ||
      inspection.user_role === 'system_admin';

    if (!canCreate) {
      return c.json({ error: "Sem permissÃ£o para criar aÃ§Ãµes nesta inspeÃ§Ã£o" }, 403);
    }

    // Parse and validate deadline
    let deadlineDate = null;
    if (when_deadline) {
      try {
        deadlineDate = new Date(when_deadline).toISOString().split('T')[0];
      } catch (error) {
        return c.json({ error: "Data de prazo invÃ¡lida" }, 400);
      }
    }

    // Create action item
    const result = await env.DB.prepare(`
      INSERT INTO action_items (
        inspection_id, inspection_item_id, title, what_description, where_location,
        why_reason, how_method, who_responsible, when_deadline, how_much_cost,
        status, priority, is_ai_generated, assigned_to, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, false, ?, NOW(), NOW())
    `).bind(
      inspectionId,
      inspection_item_id || null,
      title,
      what_description,
      where_location || inspection.location,
      why_reason || 'AÃ§Ã£o manual criada pelo inspetor',
      how_method || 'A definir',
      who_responsible,
      deadlineDate,
      how_much_cost || 'A definir',
      priority,
      assigned_to || who_responsible
    ).run();

    return c.json({
      id: result.meta.last_row_id,
      message: "AÃ§Ã£o criada com sucesso"
    });

  } catch (error) {
    console.error('Error creating manual action item:', error);
    return c.json({ error: "Erro ao criar aÃ§Ã£o manual" }, 500);
  }
});

// Update action item
checklistRoutes.put("/action-items/:id", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const actionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const {
      title,
      what_description,
      where_location,
      why_reason,
      how_method,
      who_responsible,
      when_deadline,
      how_much_cost,
      priority,
      status,
      assigned_to
    } = body;

    // Get action item to verify access
    const action = await env.DB.prepare(`
      SELECT ai.*, i.created_by as inspection_created_by, 
             i.organization_id as inspection_org_id, u.role as user_role,
             u.organization_id as user_org_id
      FROM action_items ai
      JOIN inspections i ON ai.inspection_id = i.id
      JOIN users u ON u.id = ?
      WHERE ai.id = ?
    `).bind(user.id, actionId).first() as any;

    if (!action) {
      return c.json({ error: "AÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Check permissions to edit
    const canEdit = action.inspection_created_by === user.id ||
      action.inspection_org_id === action.user_org_id ||
      action.user_role === 'system_admin' ||
      action.assigned_to === user.email;

    if (!canEdit) {
      return c.json({ error: "Sem permissÃ£o para editar esta aÃ§Ã£o" }, 403);
    }

    // Parse deadline if provided
    let deadlineDate = action.when_deadline;
    if (when_deadline !== undefined) {
      if (when_deadline) {
        try {
          deadlineDate = new Date(when_deadline).toISOString().split('T')[0];
        } catch (error) {
          return c.json({ error: "Data de prazo invÃ¡lida" }, 400);
        }
      } else {
        deadlineDate = null;
      }
    }

    // Update action item
    await env.DB.prepare(`
      UPDATE action_items SET 
        title = COALESCE(?, title),
        what_description = COALESCE(?, what_description),
        where_location = COALESCE(?, where_location),
        why_reason = COALESCE(?, why_reason),
        how_method = COALESCE(?, how_method),
        who_responsible = COALESCE(?, who_responsible),
        when_deadline = COALESCE(?, when_deadline),
        how_much_cost = COALESCE(?, how_much_cost),
        priority = COALESCE(?, priority),
        status = COALESCE(?, status),
        assigned_to = COALESCE(?, assigned_to),
        updated_at = NOW()
      WHERE id = ?
    `).bind(
      title,
      what_description,
      where_location,
      why_reason,
      how_method,
      who_responsible,
      deadlineDate,
      how_much_cost,
      priority,
      status,
      assigned_to,
      actionId
    ).run();

    return c.json({ message: "AÃ§Ã£o atualizada com sucesso" });

  } catch (error) {
    console.error('Error updating action item:', error);
    return c.json({ error: "Erro ao atualizar aÃ§Ã£o" }, 500);
  }
});

// Delete action item
checklistRoutes.delete("/action-items/:id", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const actionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get action item to verify access
    const action = await env.DB.prepare(`
      SELECT ai.*, i.created_by as inspection_created_by, 
             i.organization_id as inspection_org_id, u.role as user_role,
             u.organization_id as user_org_id
      FROM action_items ai
      JOIN inspections i ON ai.inspection_id = i.id
      JOIN users u ON u.id = ?
      WHERE ai.id = ?
    `).bind(user.id, actionId).first() as any;

    if (!action) {
      return c.json({ error: "AÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Check permissions to delete
    const canDelete = action.inspection_created_by === user.id ||
      action.inspection_org_id === action.user_org_id ||
      action.user_role === 'system_admin';

    if (!canDelete) {
      return c.json({ error: "Sem permissÃ£o para excluir esta aÃ§Ã£o" }, 403);
    }

    // Delete action item
    await env.DB.prepare("DELETE FROM action_items WHERE id = ?").bind(actionId).run();

    return c.json({ message: "AÃ§Ã£o excluÃ­da com sucesso" });

  } catch (error) {
    console.error('Error deleting action item:', error);
    return c.json({ error: "Erro ao excluir aÃ§Ã£o" }, 500);
  }
});

export default checklistRoutes;

===END_FILE===
===FILE: supabase/functions/api/checkout-flow-v2.ts===
import { Hono } from "hono";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";
import { AsaasService } from "./asaas-service.ts";
import { cors } from 'hono/cors';

const commerceRoutes = new Hono().basePath('/api/commerce');

// Enable CORS
commerceRoutes.use('/*', cors());

// ============================================================================
// UTILITY: Generate SHA256 hash for email (audit without PII)
// ============================================================================
async function hashEmail(email: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(email.toLowerCase().trim());
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

// ============================================================================
// UTILITY: Generate idempotency key
// ============================================================================
function generateIdempotencyKey(email: string, planSlug: string): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 15);
    return `ck_${planSlug}_${timestamp}_${random}`;
}

// ============================================================================
// Rate Limiting (Simple In-Memory - For production, use Redis/KV)
// ============================================================================
const rateLimitMap = new Map<string, { count: number; resetAt: number }>();
const RATE_LIMIT = 5; // requests
const RATE_WINDOW = 60000; // 1 minute

function checkRateLimit(ip: string): boolean {
    const now = Date.now();
    const record = rateLimitMap.get(ip);

    if (!record || now > record.resetAt) {
        rateLimitMap.set(ip, { count: 1, resetAt: now + RATE_WINDOW });
        return true;
    }

    if (record.count >= RATE_LIMIT) {
        return false;
    }

    record.count++;
    return true;
}

// ============================================================================
// UTILITY: Validate and Calculate Coupon Discount
// ============================================================================
async function validateCoupon(supabaseAdmin: any, code: string, planId: string, originalPriceCents: number) {
    if (!code) return { valid: false, message: "CÃ³digo nÃ£o fornecido", discountCents: 0 };

    const { data: coupon, error } = await supabaseAdmin
        .from('coupons')
        .select('*')
        .eq('code', code.toUpperCase().trim())
        .single();

    if (error || !coupon) {
        return { valid: false, message: "Cupom invÃ¡lido", discountCents: 0 };
    }

    if (!coupon.is_active) {
        return { valid: false, message: "Cupom inativo", discountCents: 0 };
    }

    if (coupon.expires_at && new Date(coupon.expires_at) < new Date()) {
        return { valid: false, message: "Cupom expirado", discountCents: 0 };
    }

    if (coupon.max_uses !== null && coupon.uses_count >= coupon.max_uses) {
        return { valid: false, message: "Limite de uso do cupom atingido", discountCents: 0 };
    }

    // Validate Plan constraint
    if (coupon.valid_for_plans) {
        let validPlans: string[] = [];
        try {
            // Handle potential double-encoding or simple JSON
            if (typeof coupon.valid_for_plans === 'string') {
                // Try parsing once
                let parsed = JSON.parse(coupon.valid_for_plans);
                // If result is still string, parse again (handle double check)
                if (typeof parsed === 'string') {
                    parsed = JSON.parse(parsed);
                }
                validPlans = Array.isArray(parsed) ? parsed : [];
            } else if (Array.isArray(coupon.valid_for_plans)) {
                validPlans = coupon.valid_for_plans;
            }
        } catch (e) {
            console.warn("Error parsing valid_for_plans:", e);
        }

        if (validPlans.length > 0 && !validPlans.includes(planId)) {
            // Note: coupon.valid_for_plans usually stores IDs (UUIDs), but we might have slugs. 
            // Ideally we check against the ID we fetched for the plan.
            return { valid: false, message: "Cupom nÃ£o aplicÃ¡vel a este plano", discountCents: 0 };
        }
    }

    let discountCents = 0;
    if (coupon.discount_type === 'percentage') {
        discountCents = Math.round(originalPriceCents * (coupon.discount_value / 100));
    } else {
        discountCents = Math.round(coupon.discount_value * 100); // Fixed value usually in BRL, convert to cents
    }

    // Ensure discount doesn't exceed price (sanity check)
    if (discountCents > originalPriceCents) {
        discountCents = originalPriceCents;
    }

    return {
        valid: true,
        coupon,
        discountCents
    };
}

// ============================================================================
// POST /commerce/validate-coupon
// ============================================================================
commerceRoutes.post("/validate-coupon", async (c) => {
    const supabaseAdmin = createClient(
        Deno.env.get("SUPABASE_URL") ?? "",
        Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
    );

    const { code, plan_slug } = await c.req.json();

    if (!code || !plan_slug) {
        return c.json({ valid: false, message: "Dados incompletos" }, 400);
    }

    // Fetch Plan to get price and ID
    const { data: dbPlan } = await supabaseAdmin
        .from('plans')
        .select('id, price_cents')
        .eq('slug', plan_slug)
        .single();

    if (!dbPlan) {
        return c.json({ valid: false, message: "Plano nÃ£o encontrado" }, 400);
    }

    const result = await validateCoupon(supabaseAdmin, code, dbPlan.id, dbPlan.price_cents);

    if (!result.valid) {
        return c.json({ valid: false, message: result.message }, 200);
    }

    const finalPriceCents = dbPlan.price_cents - result.discountCents;

    return c.json({
        valid: true,
        message: "Cupom aplicado com sucesso!",
        original_price: dbPlan.price_cents,
        discount: result.discountCents,
        final_price: finalPriceCents,
        discount_type: result.coupon.discount_type,
        discount_value: result.coupon.discount_value
    });
});


// ============================================================================
// POST /commerce/initiate - PLG Checkout Flow (Lead-First + Audit Trail)
// ============================================================================
commerceRoutes.post("/initiate", async (c) => {
    // Tracking variables for Audit Trail
    let attemptId: string | null = null;
    let leadId: number | null = null;
    let createdUserId: string | null = null;
    let createdOrgId: number | null = null;
    let asaasCustomerId: string | null = null;
    let asaasSubscriptionId: string | null = null;

    // Initialize Admin Client
    const supabaseAdmin = createClient(
        Deno.env.get("SUPABASE_URL") ?? "",
        Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
    );

    // Get client info for audit
    const clientIp = c.req.header('x-forwarded-for')?.split(',')[0] || 'unknown';
    const userAgent = c.req.header('user-agent') || 'unknown';

    try {
        // ====================================================================
        // STEP 0: Rate Limit Check
        // ====================================================================
        if (!checkRateLimit(clientIp)) {
            return c.json({
                status: "rate_limited",
                message: "Muitas tentativas. Aguarde 1 minuto."
            }, 429);
        }

        const body = await c.req.json();
        const { user, company, plan_slug, payment_method } = body;

        console.log("[COMMERCE] Initiate Checkout for:", user.email, "Plan:", plan_slug);
        c.header('X-Debug-Version', 'v2-check-existing');


        // ====================================================================
        // STEP 1: Validate Plan
        // ====================================================================
        // ====================================================================
        // STEP 1: Validate Plan (Dynamic from DB)
        // ====================================================================
        const { data: dbPlan, error: planError } = await supabaseAdmin
            .from('plans')
            .select('id, slug, name, price_cents, is_active')
            .eq('slug', plan_slug)
            .single();

        if (planError || !dbPlan || !dbPlan.is_active) {
            console.error("[CHECKOUT] Invalid plan:", plan_slug, planError);
            return c.json({ error: "Plano invÃ¡lido ou inativo." }, 400);
        }

        const selectedPlan = {
            price: dbPlan.price_cents / 100, // Original Price
            name: dbPlan.name,
            slug: dbPlan.slug,
            id: dbPlan.id // Need ID for verification
        };

        // ====================================================================
        // STEP 1.5: Apply Coupon (If provided)
        // ====================================================================
        let appliedCoupon = null;
        let finalPrice = selectedPlan.price;
        const couponCode = body.coupon_code;

        if (couponCode) {
            console.log("[COMMERCE] Validating coupon:", couponCode);
            const couponResult = await validateCoupon(supabaseAdmin, couponCode, dbPlan.id, dbPlan.price_cents);

            if (couponResult.valid) {
                appliedCoupon = couponResult.coupon;
                const discountAmount = couponResult.discountCents / 100;
                finalPrice = Math.max(0, finalPrice - discountAmount); // Ensure not negative
                console.log(`[COMMERCE] Coupon applied! Original: ${selectedPlan.price}, Final: ${finalPrice}`);

                // Track usage (can be async/optimistic)
                await supabaseAdmin.rpc('increment_coupon_usage', { coupon_id: appliedCoupon.id });
            } else {
                console.warn("[COMMERCE] Invalid coupon provided:", couponCode, couponResult.message);
                // Decide: Fail validation or just ignore? For explicit user input, failing is better.
                return c.json({ error: `Cupom invÃ¡lido: ${couponResult.message}` }, 400);
            }
        }


        // ====================================================================
        // STEP 2: Create Checkout Attempt (Audit Trail - FIRST!)
        // ====================================================================
        const emailHash = await hashEmail(user.email);
        const idempotencyKey = generateIdempotencyKey(user.email, plan_slug);

        const { data: attempt, error: attemptError } = await supabaseAdmin
            .from('checkout_attempts')
            .insert({
                email_hash: emailHash,
                plan_slug: plan_slug,
                step: 'started',
                status: 'pending',
                idempotency_key: idempotencyKey,
                ip_address: clientIp,
                user_agent: userAgent,
                metadata: { company_name: company?.name, payment_method }
            })
            .select()
            .single();

        if (attemptError) {
            console.error("[COMMERCE] Failed to create attempt:", attemptError);
            // Continue anyway - audit failure shouldn't block checkout
        } else {
            attemptId = attempt.id;
        }

        // ====================================================================
        // STEP 3: UPSERT Lead in CRM (Lead-First Pattern)
        // ====================================================================
        const { data: existingLead } = await supabaseAdmin
            .from('leads')
            .select('id')
            .eq('email', user.email)
            .single();

        if (existingLead) {
            leadId = existingLead.id;
            // Update existing lead
            const { error: updateError } = await supabaseAdmin
                .from('leads')
                .update({
                    company_name: company?.name || user.name,
                    contact_name: user.name,
                    phone: user.phone,
                    source: 'checkout',
                    status: 'qualified',
                    notes: `Checkout iniciado. Plano: ${selectedPlan.name}`,
                    deal_value: selectedPlan.price,
                    updated_at: new Date().toISOString()
                })
                .eq('id', leadId);

            if (updateError) {
                console.error("[COMMERCE] Failed to update lead:", updateError);
            } else {
                console.log("[COMMERCE] Updated existing lead:", leadId);
            }
        } else {
            // Create new lead
            console.log("[COMMERCE] Creating new lead for:", user.email);
            const { data: newLead, error: leadError } = await supabaseAdmin
                .from('leads')
                .insert({
                    email: user.email,
                    company_name: company?.name || user.name,
                    contact_name: user.name,
                    phone: user.phone,
                    source: 'checkout',
                    status: 'qualified',
                    notes: `Checkout iniciado. Plano: ${selectedPlan.name}`,
                    deal_value: selectedPlan.price
                })
                .select()
                .single();

            if (leadError) {
                console.error("[COMMERCE] Failed to create lead:", leadError);
            } else if (newLead) {
                leadId = newLead.id;
                console.log("[COMMERCE] Created new lead:", leadId);
            }
        }

        // Update attempt with lead_id
        if (attemptId && leadId) {
            await supabaseAdmin
                .from('checkout_attempts')
                .update({ lead_id: leadId, step: 'lead_created' })
                .eq('id', attemptId);
        }

        // ====================================================================
        // STEP 4: Check if User Exists (Non-Revealing Response)
        // ====================================================================
        // ====================================================================
        // STEP 4: Handle Auth User (Get Existing or Create New)
        // ====================================================================
        const asaas = new AsaasService();
        let userId = null;
        let isNewUser = false;

        const { data: existingUsers } = await supabaseAdmin.auth.admin.listUsers();
        const existingUser = existingUsers?.users?.find((u: any) => u.email === user.email);

        if (existingUser) {
            console.log("[COMMERCE] User already exists. Proceeding with existing user:", existingUser.id);
            userId = existingUser.id;

            // Optional: Update metadata if needed, but safe to skip to avoid overwriting preferences
        } else {
            // Create New User
            console.log("[COMMERCE] Creating new Auth User:", user.email);
            const { data: authUser, error: authError } = await supabaseAdmin.auth.admin.createUser({
                email: user.email,
                password: user.password,
                email_confirm: true,
                user_metadata: {
                    full_name: user.name,
                    phone: user.phone
                }
            });

            if (authError || !authUser.user) {
                console.error("[COMMERCE] Create user failed:", authError);
                return c.json({ error: "Erro ao criar usuÃ¡rio. Tente novamente." }, 500);
            }
            userId = authUser.user.id;
            isNewUser = true;
        }

        // ====================================================================
        // STEP 5: Create Organization (Always create new org for new subscription context?)
        // OR Check if user has org (Simplification for MVP: Create new Org)
        // ====================================================================

        // Getting user object for context
        const currentUserStub = { id: userId, email: user.email };

        // Ensure we have a valid userId before proceeding
        if (!userId) {
            return c.json({ error: "Falha ao identificar usuÃ¡rio." }, 500);
        }

        createdUserId = userId; // Use userId which is guaranteed to be set

        // Update attempt
        if (attemptId) {
            await supabaseAdmin
                .from('checkout_attempts')
                .update({ step: 'user_created' })
                .eq('id', attemptId);
        }

        // ====================================================================
        // STEP 6: Create Organization
        // ====================================================================
        const { data: org, error: orgError } = await supabaseAdmin
            .from('organizations')
            .insert({
                name: company?.name || user.name + "'s Company",
                cnpj: company?.cnpj,
                document: company?.document,
                slug: company?.slug,
                subscription_status: 'pending_payment',
                subscription_plan: plan_slug,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            })
            .select()
            .single();

        if (orgError) {
            throw new Error("Falha ao criar organizaÃ§Ã£o: " + orgError.message);
        }

        createdOrgId = org.id;

        // ====================================================================
        // STEP 7: Link User to Organization
        // ====================================================================
        // ====================================================================
        // STEP 7: Link User to Organization
        // ====================================================================
        await supabaseAdmin.from('users').insert({
            id: userId,
            email: user.email,
            full_name: user.name,
            role: 'owner',
            is_active: true,
            approval_status: 'approved'
        });

        await supabaseAdmin.from('user_organizations').insert({
            user_id: userId,
            organization_id: org.id,
            role: 'owner',
            is_primary: true
        });

        // ====================================================================
        // STEP 8: Create Asaas Customer & Subscription
        // ====================================================================
        if (attemptId) {
            await supabaseAdmin
                .from('checkout_attempts')
                .update({ step: 'payment_initiated' })
                .eq('id', attemptId);
        }

        const asaasCustomer = await asaas.createOrUpdateCustomer({
            name: user.name,
            email: user.email,
            cpfCnpj: company?.cnpj || undefined,
            phone: user.phone,
            mobilePhone: user.phone
        });

        asaasCustomerId = asaasCustomer.id;

        const billingType = payment_method === 'PIX' ? 'PIX' : 'CREDIT_CARD';

        const subscription = await asaas.createSubscription({
            customer: asaasCustomer.id,
            billingType: billingType,
            value: finalPrice, // Use FINAL discounted price
            nextDueDate: new Date().toISOString().split('T')[0],
            cycle: 'MONTHLY',
            description: `Assinatura Plano ${selectedPlan.name} - COMPIA${appliedCoupon ? ` (Cupom: ${appliedCoupon.code})` : ''}`,
            externalReference: String(org.id)
        });

        asaasSubscriptionId = subscription.id;

        // ====================================================================
        // STEP 9: Store Subscription & Invoice Locally
        // ====================================================================
        await supabaseAdmin.from('subscriptions').insert({
            organization_id: org.id,
            plan_id: plan_slug,
            status: 'pending',
            gateway: 'asaas',
            gateway_subscription_id: subscription.id,
            current_period_start: new Date().toISOString(),
            current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
        });

        const payments = await asaas.getSubscriptionPayments(subscription.id);
        const firstPayment = payments.data && payments.data[0];

        let pixDetails = null;

        if (firstPayment) {
            await supabaseAdmin.from('invoices').insert({
                organization_id: org.id,
                subscription_id: null,
                gateway_invoice_id: firstPayment.id,
                gateway: 'asaas',
                amount: firstPayment.value,
                status: 'pending',
                due_date: firstPayment.dueDate
            });

            // If PIX, get QR Code immediately
            if (billingType === 'PIX') {
                try {
                    const qrCodeData = await asaas.getPixQrCode(firstPayment.id);
                    pixDetails = {
                        qr_code: qrCodeData.encodedImage,
                        copy_paste: qrCodeData.payload,
                        expiration: qrCodeData.expirationDate
                    };
                } catch (qrError) {
                    console.error("[CHECKOUT] Failed to fetch PIX QR Code:", qrError);
                }
            }
        }

        const paymentUrl = firstPayment ? firstPayment.invoiceUrl : null;

        // ====================================================================
        // STEP 10: Mark Success
        // ====================================================================
        if (attemptId) {
            await supabaseAdmin
                .from('checkout_attempts')
                .update({
                    step: 'completed',
                    status: 'success',
                    asaas_customer_id: asaasCustomerId,
                    asaas_subscription_id: asaasSubscriptionId
                })
                .eq('id', attemptId);
        }

        if (leadId) {
            await supabaseAdmin
                .from('leads')
                .update({ status: 'converted' })
                .eq('id', leadId);
        }

        return c.json({
            status: "success",
            user_id: userId,
            organization_id: org.id,
            payment_url: paymentUrl || "https://asaas.com/customer-portal",
            pix_details: pixDetails
        });

    } catch (e: any) {
        console.error("[COMMERCE] Checkout Critical Error:", e);

        // Cleanup if user was newly created and process failed completely? 
        // Be careful not to delete existing users
        if (false) {
            // Implementation detail: Only cleanup if isNewUser is true
        }

        // ====================================================================
        // ROLLBACK: Delete Auth User and Org (Keep Lead for CRM)
        // ====================================================================
        try {
            if (createdOrgId) {
                console.log(`[Rollback] Deleting Organization ${createdOrgId}...`);
                await supabaseAdmin.from('user_organizations').delete().eq('organization_id', createdOrgId);
                await supabaseAdmin.from('users').delete().eq('id', createdUserId);
                await supabaseAdmin.from('organizations').delete().eq('id', createdOrgId);
            }

            if (createdUserId) {
                console.log(`[Rollback] Deleting Auth User ${createdUserId}...`);
                await supabaseAdmin.auth.admin.deleteUser(createdUserId);
            }
        } catch (rollbackError) {
            console.error("CRITICAL: Rollback failed!", rollbackError);
        }

        // Update attempt with failure
        if (attemptId) {
            await supabaseAdmin
                .from('checkout_attempts')
                .update({
                    step: 'failed',
                    status: 'failed',
                    error_code: e.name || 'UNKNOWN',
                    error_message: e.message,
                    asaas_customer_id: asaasCustomerId,
                    asaas_subscription_id: asaasSubscriptionId
                })
                .eq('id', attemptId);
        }

        // Update lead for recovery
        if (leadId) {
            await supabaseAdmin
                .from('leads')
                .update({
                    status: 'payment_failed',
                    notes: `Erro no checkout: ${e.message}`
                })
                .eq('id', leadId);
        }

        // Non-revealing generic response
        return c.json({
            status: "pending",
            message: `Erro no checkout: ${e.message}`, // Expose real error for debugging
            can_retry: true
        }, 200); // 200 OK, not 400 - allows retry
    }
});

export default commerceRoutes;
===END_FILE===
===FILE: supabase/functions/api/cnpj-routes.ts===
import { Hono } from "hono";

const cnpjRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();

// Helper function to perform CNPJ lookup with proper error handling
const performCnpjLookup = async (cnpjInput: string) => {
    try {
        if (!cnpjInput) {
            return {
                success: false,
                error: "CNPJ Ã© obrigatÃ³rio",
                status: 400
            };
        }

        // Clean CNPJ (remove dots, dashes, slashes, spaces)
        const cleanCnpj = cnpjInput.replace(/[.\-/\s]/g, '');

        // Validate CNPJ format (14 digits)
        if (!/^\d{14}$/.test(cleanCnpj)) {
            return {
                success: false,
                error: "CNPJ deve conter 14 dÃ­gitos numÃ©ricos",
                status: 400
            };
        }

        // Call external CNPJ API (using ReceitaWS - API gratuita)
        const apiUrl = `https://receitaws.com.br/v1/cnpj/${cleanCnpj}`;

        const response = await globalThis.fetch(apiUrl, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (compatible; InspectionApp/1.0)',
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            if (response.status === 429) {
                return {
                    success: false,
                    error: "Muitas consultas. Tente novamente em alguns minutos. (Limite da API gratuita: 3/minuto)",
                    status: 429
                };
            }
            return {
                success: false,
                error: `Erro na consulta externa: ${response.status}`,
                status: 502
            };
        }

        const cnpjData = await response.json() as any;

        if (cnpjData.status === 'ERROR') {
            return {
                success: false,
                error: cnpjData.message || "CNPJ nÃ£o encontrado",
                status: 404
            };
        }

        // Transform data to match our organization format
        const companyData = {
            cnpj: cnpjData.cnpj,
            razao_social: cnpjData.nome,
            nome_fantasia: cnpjData.fantasia || cnpjData.nome,
            nome: cnpjData.fantasia || cnpjData.nome,
            cnae_principal: cnpjData.atividade_principal?.[0]?.code || '',
            cnae_descricao: cnpjData.atividade_principal?.[0]?.text || '',
            natureza_juridica: cnpjData.natureza_juridica || '',
            data_abertura: cnpjData.abertura || '',
            capital_social: parseFloat(cnpjData.capital_social?.replace(/[. ]/g, '').replace(',', '.')) || 0,
            porte_empresa: cnpjData.porte || '',
            situacao_cadastral: cnpjData.situacao || '',
            address: cnpjData.logradouro
                ? `${cnpjData.logradouro}, ${cnpjData.numero}${cnpjData.complemento ? ' - ' + cnpjData.complemento : ''}, ${cnpjData.bairro}, ${cnpjData.municipio}/${cnpjData.uf}, CEP: ${cnpjData.cep}`
                : '',
            contact_email: cnpjData.email || '',
            contact_phone: cnpjData.telefone || '',
            website: '',
            // Additional fields for reference
            logradouro: cnpjData.logradouro,
            numero: cnpjData.numero,
            complemento: cnpjData.complemento,
            bairro: cnpjData.bairro,
            municipio: cnpjData.municipio,
            uf: cnpjData.uf,
            cep: cnpjData.cep,
            atividades_secundarias: cnpjData.atividades_secundarias || [],
            qsa: cnpjData.qsa || [] // Quadro de sÃ³cios
        };

        return {
            success: true,
            data: companyData,
            status: 200
        };

    } catch (error) {
        console.error('CNPJ lookup error:', error);
        return {
            success: false,
            error: "Erro interno ao consultar CNPJ",
            details: error instanceof Error ? error.message : "Erro desconhecido",
            status: 500
        };
    }
};

// CNPJ lookup endpoint with path parameter
cnpjRoutes.get("/:cnpj", async (c) => {
    // Set proper JSON content type header
    c.header('Content-Type', 'application/json');

    const cnpj = c.req.param("cnpj");
    const result = await performCnpjLookup(cnpj);

    if (result.success && result.data) {
        return c.json({
            success: true,
            data: result.data
        }, 200);
    } else {
        return c.json({
            success: false,
            error: result.error,
            details: result.details
        }, result.status as any);
    }
});

export default cnpjRoutes;
===END_FILE===
===FILE: supabase/functions/api/crm-routes.ts===

import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { ExtendedMochaUser, USER_ROLES } from "./user-types.ts";

type Env = {
    DB: any;
};

const getDatabase = (env: any) => env.DB;

const app = new Hono<{ Bindings: Env; Variables: { user: any } }>()
    .basePath('/api/crm');

// Require System Admin Middleware
const requireSysAdmin = async (c: any, next: any) => {
    const user = c.get('user');
    // Check both potential locations for role (depending on how user was populated)
    const userRole = user?.role || user?.profile?.role;

    if (userRole !== USER_ROLES.SYSTEM_ADMIN && userRole !== 'sys_admin') {
        return c.json({ error: 'Acesso negado. Apenas System Admins.' }, 403);
    }
    await next();
};

app.use('*', tenantAuthMiddleware);
app.use('*', requireSysAdmin);

// List Leads (with Pagination)
app.get('/leads', async (c) => {
    try {
        const db = getDatabase(c.env);
        const { page = '1', limit = '50', search = '', status = 'all' } = c.req.query();

        const offset = (parseInt(page) - 1) * parseInt(limit);
        const limitVal = parseInt(limit);

        let query = "SELECT * FROM leads";
        let countQuery = "SELECT COUNT(*) as total FROM leads";
        const params: any[] = [];
        const conditions: string[] = [];

        // Apply filters
        if (search) {
            conditions.push("(company_name LIKE ? OR contact_name LIKE ? OR email LIKE ?)");
            const term = `%${search}%`;
            params.push(term, term, term);
        }

        if (status !== 'all') {
            conditions.push("status = ?");
            params.push(status);
        }

        if (conditions.length > 0) {
            const whereClause = " WHERE " + conditions.join(" AND ");
            query += whereClause;
            countQuery += whereClause;
        }

        query += " ORDER BY created_at DESC LIMIT ? OFFSET ?";

        // Execute queries
        const { results: leads } = await db.prepare(query).bind(...params, limitVal, offset).all();
        const { total } = await db.prepare(countQuery).bind(...params).first() || { total: 0 };

        return c.json({
            leads,
            total,
            page: parseInt(page),
            totalPages: Math.ceil(total / limitVal)
        });
    } catch (error) {
        console.error('Error fetching leads:', error);
        return c.json({ error: 'Erro ao buscar leads' }, 500);
    }
});

// Create Lead
app.post('/leads', async (c) => {
    try {
        const db = getDatabase(c.env);
        const user = c.get('user') as ExtendedMochaUser;

        const body = await c.req.json();
        const {
            company_name, contact_name, email, phone, status, source, notes,
            deal_value, probability,
            cnpj, razao_social, nome_fantasia, website,
            cep, logradouro, numero, complemento, bairro, cidade, uf
        } = body;

        const result = await db.prepare(`
      INSERT INTO leads (
          company_name, contact_name, email, phone, status, source, notes, 
          deal_value, probability, owner_id,
          cnpj, razao_social, nome_fantasia, website,
          cep, logradouro, numero, complemento, bairro, cidade, uf
      )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      RETURNING *
    `).bind(
            company_name,
            contact_name || null,
            email || null,
            phone || null,
            status || 'new',
            source || null,
            notes || null,
            deal_value || 0,
            probability || 0,
            user.id,
            cnpj || null,
            razao_social || null,
            nome_fantasia || null,
            website || null,
            cep || null,
            logradouro || null,
            numero || null,
            complemento || null,
            bairro || null,
            cidade || null,
            uf || null
        ).first();

        return c.json({ lead: result });
    } catch (error) {
        console.error('Error creating lead:', error);
        return c.json({ error: 'Erro ao criar lead' }, 500);
    }
});

// Update Lead
app.put('/leads/:id', async (c) => {
    try {
        const db = getDatabase(c.env);
        const leadId = c.req.param('id');
        const body = await c.req.json();

        // Dynamic Update
        const fields = [];
        const values = [];
        const allowed = [
            'company_name', 'contact_name', 'email', 'phone', 'status', 'source', 'notes',
            'deal_value', 'probability',
            'cnpj', 'razao_social', 'nome_fantasia', 'website',
            'cep', 'logradouro', 'numero', 'complemento', 'bairro', 'cidade', 'uf'
        ];

        for (const key of allowed) {
            if (body[key] !== undefined) {
                fields.push(`${key} = ?`);
                values.push(body[key]);
            }
        }

        if (fields.length === 0) return c.json({ message: 'Nothing to update' });

        // Auto-log Status Change & Update status_updated_at
        if (body.status) {
            const currentLead = await db.prepare("SELECT status FROM leads WHERE id = ?").bind(leadId).first();
            if (currentLead && currentLead.status !== body.status) {
                // Log Activity
                await db.prepare(`
                    INSERT INTO crm_activities (lead_id, type, title, description, created_by) 
                    VALUES (?, 'status_change', 'AlteraÃ§Ã£o de Status', ?, ?)
                 `).bind(
                    leadId,
                    `Status alterado de ${currentLead.status.toUpperCase()} para ${body.status.toUpperCase()}`,
                    (c.get('user') as any).id
                ).run();

                // Update status timestamp
                fields.push("status_updated_at = NOW()");
            }
        }

        fields.push("updated_at = NOW()");

        await db.prepare(`UPDATE leads SET ${fields.join(', ')} WHERE id = ?`)
            .bind(...values, leadId)
            .run();

        return c.json({ success: true });
    } catch (error) {
        console.error('Error updating lead:', error);
        return c.json({ error: 'Erro ao atualizar lead' }, 500);
    }
});

// List Activities
app.get('/leads/:id/activities', async (c) => {
    try {
        const db = getDatabase(c.env);
        const leadId = c.req.param('id');

        const { results } = await db.prepare(`
            SELECT a.*, u.email as user_email 
            FROM crm_activities a
            LEFT JOIN auth.users u ON a.created_by = u.id 
            WHERE lead_id = ? 
            ORDER BY created_at DESC
        `).bind(leadId).all();

        return c.json(results || []);
    } catch (error) {
        console.error('Error fetching activities:', error);
        return c.json({ error: 'Erro ao buscar atividades' }, 500);
    }
});

// Create Activity
app.post('/leads/:id/activities', async (c) => {
    try {
        const db = getDatabase(c.env);
        const user = c.get('user') as ExtendedMochaUser;
        const leadId = c.req.param('id');
        const body = await c.req.json();

        const { type, title, description } = body;

        await db.prepare(`
            INSERT INTO crm_activities (lead_id, type, title, description, created_by)
            VALUES (?, ?, ?, ?, ?)
        `).bind(leadId, type, title, description, user.id).run();

        return c.json({ success: true });
    } catch (error) {
        console.error('Error creating activity:', error);
        return c.json({ error: 'Erro ao criar atividade' }, 500);
    }
});

// Delete Lead
app.delete('/leads/:id', async (c) => {
    try {
        const db = getDatabase(c.env);
        const leadId = c.req.param('id');
        await db.prepare("DELETE FROM leads WHERE id = ?").bind(leadId).run();
        return c.json({ success: true });
    } catch (error) {
        return c.json({ error: 'Erro ao deletar lead' }, 500);
    }
});

// âœ¨ CONVERT LEAD TO ORGANIZATION âœ¨
app.post('/leads/:id/convert', async (c) => {
    try {
        const db = getDatabase(c.env);
        const user = c.get('user') as ExtendedMochaUser;
        const leadId = c.req.param('id');

        // 1. Get Lead Data
        const lead = await db.prepare("SELECT * FROM leads WHERE id = ?").bind(leadId).first();
        if (!lead) return c.json({ error: 'Lead not found' }, 404);
        if (lead.converted_organization_id) return c.json({ error: 'Lead jÃ¡ convertido' }, 400);

        // Get Body for Overrides
        let body: any = {};
        try { body = await c.req.json(); } catch (e) { }

        // 2. Prepare Organization Data
        // Map Lead fields to Organizations fields (Prefer Body, fallback to Lead)
        const orgName = body.name || lead.nome_fantasia || lead.company_name;

        // Insert Organization
        const orgResult = await db.prepare(`
            INSERT INTO organizations(
                name, 
                type, 
                description,
                contact_email, 
                contact_phone, 
                
                -- Address (Composite address string)
                address, 
                
                -- Fiscal / Details
                cnpj, 
                razao_social, 
                nome_fantasia, 
                website,
                
                -- Organization Config
                organization_level,
                parent_organization_id,
                subscription_status,
                subscription_plan,
                max_users,
                max_subsidiaries,
                
                -- Business Details
                cnae_principal, cnae_descricao, natureza_juridica, 
                data_abertura, capital_social, porte_empresa,
                situacao_cadastral, numero_funcionarios, setor_industria,
                faturamento_anual, logo_url,

                is_active,
                created_at,
                updated_at
            ) VALUES(
                ?, ?, ?, ?, ?, ?, 
                ?, ?, ?, ?, 
                ?, ?, 'active', ?, ?, ?, 
                ?, ?, ?, 
                ?, ?, ?, 
                ?, ?, ?, 
                ?, ?, 
                true, NOW(), NOW()
            )
            RETURNING id
        `).bind(
            orgName,
            body.type || 'company',
            body.description || null,
            body.contact_email || lead.email,
            body.contact_phone || lead.phone,

            // Address String (Composite or explicit from Body)
            body.address || [lead.logradouro, lead.numero, lead.bairro, lead.cidade, lead.uf].filter(Boolean).join(', ') || 'EndereÃ§o nÃ£o informado',

            // Fiscal
            body.cnpj || lead.cnpj,
            body.razao_social || lead.razao_social,
            body.nome_fantasia || lead.nome_fantasia,
            body.website || lead.website,

            // Config
            body.organization_level || 'company',
            body.parent_organization_id || null,
            body.subscription_plan || 'basic',
            body.max_users || 50,
            body.max_subsidiaries || 0,

            // Business (New Fields)
            body.cnae_principal || null,
            body.cnae_descricao || null,
            body.natureza_juridica || null,
            body.data_abertura || null,
            body.capital_social || null,
            body.porte_empresa || null,
            body.situacao_cadastral || null,
            body.numero_funcionarios || null,
            body.setor_industria || null,
            body.faturamento_anual || null,
            body.logo_url || null
        ).first();

        const newOrgId = orgResult?.id;

        if (!newOrgId) throw new Error("Failed to create organization");

        // 3. Update Lead Status
        await db.prepare(`
            UPDATE leads 
            SET status = 'won', 
                converted_organization_id = ?,
                updated_at = NOW()
            WHERE id = ?
        `).bind(newOrgId, leadId).run();

        // 4. Log Activity
        await db.prepare(`
            INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
            VALUES(?, ?, 'lead_converted', ?, 'lead', ?, NOW())
        `).bind(
            user.id,
            newOrgId,
            `Lead convertido em organizaÃ§Ã£o: ${orgName}`,
            leadId
        ).run();

        return c.json({
            success: true,
            organization_id: newOrgId,
            message: 'Lead convertido com sucesso!'
        });

    } catch (error: any) {
        console.error('Error converting lead:', error);
        return c.json({ error: 'Erro ao converter lead: ' + error.message }, 500);
    }
});


// âœ¨ AI INTELLIGENCE SYNC (The "Motor") âœ¨
app.post('/run-intelligence-sync', async (c) => {
    try {
        const db = getDatabase(c.env);
        const user = c.get('user') as ExtendedMochaUser;
        const results = {
            upsell_opportunities: 0,
            churn_alerts: 0,
            processed_orgs: 0
        };

        // 1. Fetch all active organizations with their limits and usage
        // Note: For simplicity in this "Proof of Concept", we are fetching basics.
        // In production, this would be a more complex join or view.
        const orgs = await db.prepare(`
            SELECT 
                o.id, o.name, o.contact_email, o.contact_phone,
                o.max_users, 
                (SELECT COUNT(*) FROM user_organizations uo WHERE uo.organization_id = o.id) as current_users,
                o.subscription_plan
            FROM organizations o
            WHERE o.is_active = true
        `).all();

        const organizations = orgs.results || [];
        results.processed_orgs = organizations.length;

        for (const org of organizations) {
            // Rule 1: Upsell Opportunity (Users > 80%)
            const userUsagePct = (org.current_users / (org.max_users || 1)) * 100;

            if (userUsagePct >= 80) {
                // Check if we already have an open lead for this org (to avoid duplicate spam)
                const existingLead = await db.prepare(`
                    SELECT id FROM leads 
                    WHERE company_name = ? AND status NOT IN ('won', 'lost')
                `).bind(org.name).first();

                if (!existingLead) {
                    // CREATE UPSELL LEAD
                    await db.prepare(`
                        INSERT INTO leads (
                            company_name, contact_name, email, phone, 
                            status, source, notes, 
                            deal_value, probability, owner_id,
                            deal_type
                        ) VALUES (
                            ?, ?, ?, ?,
                            'new', 'ai_trigger', ?,
                            ?, ?, ?,
                            'upsell'
                        )
                    `).bind(
                        org.name,
                        'Contato Principal',
                        org.contact_email,
                        org.contact_phone,
                        `ALERTA DE IA: Uso de usuÃ¡rios em ${userUsagePct.toFixed(1)}%. Oportunidade de expansÃ£o de plano.`,
                        500.00, // Default Upsell Value
                        60,     // High probability
                        user.id
                    ).run();

                    // Log Activity
                    await db.prepare(`
                        INSERT INTO activity_log(user_id, organization_id, action_type, action_description, created_at)
                        VALUES(?, ?, 'ai_trigger_fired', 'Criou oportunidade de upsell automaticamente', NOW())
                    `).bind(user.id, org.id).run();

                    results.upsell_opportunities++;
                }
            }

            // Rule 2: Churn Risk (Zero activity - Placeholder logic)
            // Ideally check 'last_login_at' but for now let's assume random strictly for demo if no real data
            // Or better: Check if organization was created > 30 days ago and has 0 inspections (if we had inspections count here)
        }

        return c.json({
            success: true,
            summary: results,
            message: `SincronizaÃ§Ã£o concluÃ­da. ${results.upsell_opportunities} oportunidades identificadas.`
        });

    } catch (error: any) {
        console.error('Error running intelligence sync:', error);
        return c.json({ error: 'Erro ao rodar sincronizaÃ§Ã£o de inteligÃªncia: ' + error.message }, 500);
    }
});

export default app;
===END_FILE===
===FILE: supabase/functions/api/d1-wrapper.ts===
import postgres from 'postgres'

// Cache for single connection per worker
let sqlInstance: ReturnType<typeof postgres> | null = null;

export function createD1Wrapper(connectionString: string) {
    // Use single connection with very aggressive settings for Edge Functions
    // Edge Functions are short-lived, so we minimize connection overhead
    if (!sqlInstance) {
        sqlInstance = postgres(connectionString, {
            max: 10,                   // Increased from 3 to 10 to handle parallel requests
            idle_timeout: 5,           // Close idle connections quickly
            connect_timeout: 10,       // Fast connection timeout
            max_lifetime: 30,          // Max connection lifetime 30 seconds
            fetch_types: false,        // Disable type fetching for speed
            prepare: false,            // Disable prepared statements for Transaction Pooler compatibility
        })
    }
    const sql = sqlInstance;

    return {
        prepare: (query: string) => {
            let paramCount = 0;
            const pgQuery = query.replace(/\?/g, () => `$${++paramCount}`);

            const createExecutionMethods = (params: any[], userId?: string) => ({
                bind: (...newParams: any[]) => createExecutionMethods(newParams, userId),
                withUser: (id: string) => createExecutionMethods(params, id),
                first: async () => {
                    const runQuery = async (trx: any) => {
                        if (userId) {
                            await trx`SELECT set_config('request.jwt.claim.sub', ${userId}, true)`;
                            await trx`SELECT set_config('role', 'authenticated', true)`;
                        }
                        const sanitizedParams = params.map(p => p === undefined ? null : p);
                        const result = await trx.unsafe(pgQuery, sanitizedParams);
                        return result[0] || null;
                    };

                    try {
                        if (userId) {
                            // Using a transaction ensures the config is set for THIS operation only
                            return await sql.begin(runQuery);
                        } else {
                            // No RLS context, run directly (might fail policies!)
                            return await runQuery(sql);
                        }
                    } catch (error) {
                        const errObj = error instanceof Error ?
                            { name: error.name, message: error.message, stack: error.stack } :
                            error;
                        console.error('[D1-WRAPPER] Error in first():', JSON.stringify(errObj), 'Query:', pgQuery.substring(0, 100));
                        throw error;
                    }
                },
                run: async () => {
                    const runQuery = async (trx: any) => {
                        if (userId) {
                            await trx`SELECT set_config('request.jwt.claim.sub', ${userId}, true)`;
                            await trx`SELECT set_config('role', 'authenticated', true)`;
                        }
                        const sanitizedParams = params.map(p => p === undefined ? null : p);
                        const result = await trx.unsafe(pgQuery, sanitizedParams);
                        return { success: true, meta: { changes: result.count, last_row_id: result[0]?.id }, id: result[0]?.id };
                    };

                    try {
                        if (userId) {
                            return await sql.begin(runQuery);
                        } else {
                            return await runQuery(sql);
                        }
                    } catch (error) {
                        const errObj = error instanceof Error ?
                            { name: error.name, message: error.message, stack: error.stack } :
                            error;
                        console.error('[D1-WRAPPER] Error in run():', JSON.stringify(errObj), 'Query:', pgQuery.substring(0, 100));
                        throw error;
                    }
                },
                all: async () => {
                    const runQuery = async (trx: any) => {
                        if (userId) {
                            await trx`SELECT set_config('request.jwt.claim.sub', ${userId}, true)`;
                            await trx`SELECT set_config('role', 'authenticated', true)`;
                        }
                        const sanitizedParams = params.map(p => p === undefined ? null : p);
                        const result = await trx.unsafe(pgQuery, sanitizedParams);
                        return { results: result };
                    };

                    try {
                        if (userId) {
                            return await sql.begin(runQuery);
                        } else {
                            return await runQuery(sql);
                        }
                    } catch (error) {
                        const errObj = error instanceof Error ?
                            { name: error.name, message: error.message, stack: error.stack } :
                            error;
                        console.error('[D1-WRAPPER] Error in all():', JSON.stringify(errObj), 'Query:', pgQuery.substring(0, 100));
                        throw error;
                    }
                },
                raw: async () => {
                    const runQuery = async (trx: any) => {
                        if (userId) {
                            await trx`SELECT set_config('request.jwt.claim.sub', ${userId}, true)`;
                            await trx`SELECT set_config('role', 'authenticated', true)`;
                        }
                        const sanitizedParams = params.map(p => p === undefined ? null : p);
                        // raw returns array directly
                        return await trx.unsafe(pgQuery, sanitizedParams);
                    };

                    try {
                        if (userId) {
                            return await sql.begin(runQuery);
                        } else {
                            return await runQuery(sql);
                        }
                    } catch (error) {
                        const errObj = error instanceof Error ?
                            { name: error.name, message: error.message, stack: error.stack } :
                            error;
                        console.error('[D1-WRAPPER] Error in raw():', JSON.stringify(errObj), 'Query:', pgQuery.substring(0, 100));
                        throw error;
                    }
                }
            });

            return createExecutionMethods([]);
        }
    }
}

===END_FILE===
===FILE: supabase/functions/api/dashboard-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";

type Env = {
  DB: any;
};

const dashboardRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>()
  .basePath('/api/dashboard');

// GET estatÃ­sticas gerais do dashboard
dashboardRoutes.get("/stats", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const organizationId = c.req.query("organization_id");

  if (!user) {
    return c.json({ error: "UsuÃ¡rio nÃ£o autenticado" }, 401);
  }

  try {
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    let whereClause = "";
    let params: any[] = [];

    const isAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin';

    if (organizationId) {
      // Se um organization_id for fornecido na query, filtre por ele.
      // O middleware de autenticaÃ§Ã£o (AuthGuard) jÃ¡ garante que o usuÃ¡rio
      // tenha acesso ao scope desta organizaÃ§Ã£o.
      whereClause = "WHERE organization_id = ?";
      params.push(organizationId);
    } else if (isAdmin) {
      // SYSTEM_ADMIN vÃª tudo (sem filtro)
      whereClause = "";
      params = [];
    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {
      // Para Org Admins, se nenhum organization_id especÃ­fico for fornecido,
      // filtre pela organizaÃ§Ã£o gerenciada e suas subsidiÃ¡rias
      whereClause = `
        WHERE organization_id IN (
          SELECT id FROM organizations 
          WHERE id = ? OR parent_organization_id = ?
        )
      `;
      params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
    } else {
      // Para usuÃ¡rios comuns (nÃ£o-admin), filtre pela sua organizaÃ§Ã£o OU atribuiÃ§Ãµes
      const userEmail = userProfile.email || user.email;
      whereClause = "WHERE (organization_id = ? OR inspector_email = ?)";
      // Ensure no undefined values are pushed
      params.push(userProfile.organization_id || 0, userEmail || '');
    }

    const total = await env.DB.prepare(`SELECT COUNT(*) as count FROM inspections ${whereClause}`).bind(...params).first() as any;
    const pending = await env.DB.prepare(`SELECT COUNT(*) as count FROM inspections ${whereClause}${whereClause ? ' AND' : ' WHERE'} status = 'pendente'`).bind(...params).first() as any;
    const inProgress = await env.DB.prepare(`SELECT COUNT(*) as count FROM inspections ${whereClause}${whereClause ? ' AND' : ' WHERE'} status = 'em_andamento'`).bind(...params).first() as any;
    const completed = await env.DB.prepare(`SELECT COUNT(*) as count FROM inspections ${whereClause}${whereClause ? ' AND' : ' WHERE'} status = 'concluida'`).bind(...params).first() as any;

    return c.json({
      total: total?.count || 0,
      pending: pending?.count || 0,
      inProgress: inProgress?.count || 0,
      completed: completed?.count || 0,
    });

  } catch (error) {
    console.error('[DASHBOARD-STATS] Erro ao buscar estatÃ­sticas:', error);
    // Return empty stats instead of error 500
    return c.json({
      total: 0,
      pending: 0,
      inProgress: 0,
      completed: 0
    });
  }
});

// GET sumÃ¡rio do plano de aÃ§Ã£o do dashboard
dashboardRoutes.get("/action-plan-summary", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const organizationId = c.req.query("organization_id");

  if (!user) {
    return c.json({ error: "UsuÃ¡rio nÃ£o autenticado" }, 401);
  }

  try {
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    let whereClause = "";
    let params: any[] = [];

    const isAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin';

    if (organizationId) {
      whereClause = "WHERE i.organization_id = ?";
      params.push(organizationId);
    } else if (isAdmin) {
      // SYSTEM_ADMIN vÃª tudo (sem filtro)
      whereClause = "";
      params = [];
    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {
      whereClause = `
        WHERE i.organization_id IN (
          SELECT id FROM organizations 
          WHERE id = ? OR parent_organization_id = ?
        )
      `;
      params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
    } else {
      const userEmail = userProfile.email || user.email;
      whereClause = "WHERE (i.organization_id = ? OR i.inspector_email = ?)";
      params.push(userProfile.organization_id || 0, userEmail || '');
    }

    const allActions = await env.DB.prepare(`
      SELECT 
        ai.status, 
        ai.priority, 
        ai.when_deadline, 
        ai.is_ai_generated 
      FROM action_items ai
      JOIN inspections i ON ai.inspection_id = i.id
      ${whereClause}
    `).bind(...params).all() as any;

    const actions = allActions.results || [];
    const now = new Date();

    const summary = actions.reduce((acc: any, action: any) => {
      acc.total_actions++;
      if (action.status === 'pending') acc.pending_actions++;
      if (action.status === 'in_progress') acc.in_progress_actions++;
      if (action.status === 'completed') acc.completed_actions++;
      if (action.is_ai_generated) acc.ai_generated_count++;

      if (action.when_deadline) {
        const deadlineDate = new Date(action.when_deadline);
        if (action.status !== 'completed' && deadlineDate < now) {
          acc.overdue_actions++;
        }
        if (action.status !== 'completed' && deadlineDate > now && (deadlineDate.getTime() - now.getTime()) < (7 * 24 * 60 * 60 * 1000)) {
          acc.upcoming_deadline++;
        }
      }
      if (action.status !== 'completed' && action.priority === 'alta') {
        acc.high_priority_pending++;
      }
      return acc;
    }, {
      total_actions: 0,
      pending_actions: 0,
      in_progress_actions: 0,
      completed_actions: 0,
      upcoming_deadline: 0,
      overdue_actions: 0,
      high_priority_pending: 0,
      ai_generated_count: 0
    });

    return c.json(summary);

  } catch (error) {
    console.error('[DASHBOARD-ACTIONS] Erro ao buscar sumÃ¡rio do plano de aÃ§Ã£o:', error);
    // Return empty summary instead of error 500
    return c.json({
      total_actions: 0,
      pending_actions: 0,
      in_progress_actions: 0,
      completed_actions: 0,
      upcoming_deadline: 0,
      overdue_actions: 0,
      high_priority_pending: 0,
      ai_generated_count: 0
    });
  }
});


// GET BI Analytics (Proactive Insights)
dashboardRoutes.get("/bi-analytics", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  // Only System Admins or Org Admins can see this
  if (!user) return c.json({ error: "Unauthorized" }, 401);

  try {
    // --- 1. CHURN RISK (Organizations inactive > 30 days) ---
    // Definition: Active organizations that haven't created an inspection in 30 days
    const churnRiskQuery = `
            SELECT o.id, o.name, MAX(i.created_at) as last_activity
            FROM organizations o
            LEFT JOIN inspections i ON o.id = i.organization_id
            WHERE o.is_active = true 
            AND o.type = 'company'
            GROUP BY o.id, o.name
            HAVING MAX(i.created_at) < (NOW() - INTERVAL '30 days') OR MAX(i.created_at) IS NULL
            LIMIT 5
        `;
    const churnRisk = await env.DB.prepare(churnRiskQuery).all();

    // --- 2. UPSELL OPPORTUNITY (Close to limits) ---
    // Definition: Organizations where user count > 80% of max_users
    // Note: Assuming 'max_users' column exists in organizations (from create_organization logic)
    // If not, we fall back to a fixed number (e.g. 5)
    const upsellQuery = `
            SELECT 
                o.id, 
                o.name, 
                COUNT(u.id) as current_users,
                COALESCE(o.max_users, 5) as max_users
            FROM organizations o
            LEFT JOIN users u ON o.id = u.organization_id
            WHERE o.is_active = true
            GROUP BY o.id, o.name, o.max_users
            HAVING COUNT(u.id) >= (COALESCE(o.max_users, 5) * 0.8)
            LIMIT 5
        `;
    const upsellOpp = await env.DB.prepare(upsellQuery).all();

    // --- 3. AI ADOPTION (Stickiness) ---
    // Definition: % of inspections created in last 30 days that have AI Action Items
    const aiAdoptionQuery = `
            SELECT 
                COUNT(DISTINCT i.id) as total_inspections,
                COUNT(DISTINCT CASE WHEN ai.is_ai_generated = true THEN i.id END) as ai_inspections
            FROM inspections i
            LEFT JOIN action_items ai ON i.id = ai.inspection_id
            WHERE i.created_at > (NOW() - INTERVAL '30 days')
        `;
    const aiAdoption = await env.DB.prepare(aiAdoptionQuery).first();

    // --- 4. LEAD VELOCITY (Sales Efficiency) ---
    // Definition: Avg days between created_at and updated_at for WON leads
    // Only considers leads won in the last 60 days to be relevant
    const leadVelocityQuery = `
            SELECT AVG(EXTRACT(EPOCH FROM (updated_at - created_at)) / 86400) as avg_days
            FROM leads
            WHERE status = 'won'
            AND updated_at > (NOW() - INTERVAL '60 days')
        `;
    const leadVelocity = await env.DB.prepare(leadVelocityQuery).first();


    return c.json({
      churn_risk: churnRisk.results || [],
      upsell_opportunity: upsellOpp.results || [],
      ai_adoption: {
        total: aiAdoption?.total_inspections || 0,
        active: aiAdoption?.ai_inspections || 0,
        rate: aiAdoption?.total_inspections ? (aiAdoption.ai_inspections / aiAdoption.total_inspections) : 0
      },
      lead_velocity: {
        avg_days: Math.round(leadVelocity?.avg_days || 0)
      }
    });

  } catch (error) {
    console.error('[BI-ANALYTICS] Error:', error);
    return c.json({ error: 'Failed to fetch BI analytics' }, 500);
  }

});

// GET Org Admin Analytics (Productivity & Quality)
dashboardRoutes.get("/org-admin-analytics", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const organizationId = c.req.query("organization_id");

  if (!user) return c.json({ error: "Unauthorized" }, 401);

  try {
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    let targetOrgId = organizationId;
    if (!targetOrgId) {
      if (userProfile.role === USER_ROLES.ORG_ADMIN) {
        targetOrgId = userProfile.managed_organization_id || userProfile.organization_id;
      } else {
        targetOrgId = userProfile.organization_id;
      }
    }

    if (!targetOrgId) return c.json({ error: "Organization ID required" }, 400);

    // 1. Productivity (Inspections by Inspector)
    const productivityParam = targetOrgId; // bind param
    const productivityQuery = `
      SELECT 
        inspector_name, 
        COUNT(*) as total_inspections 
      FROM inspections 
      WHERE organization_id = ? 
      AND created_at > (NOW() - INTERVAL '30 days')
      GROUP BY inspector_name 
      ORDER BY total_inspections DESC 
      LIMIT 10
    `;
    const productivity = await env.DB.prepare(productivityQuery).bind(productivityParam).all();

    // 2. Action Plan Bottlenecks (Overdue by Responsible/Area)
    // Note: 'department' or 'responsible' might not be normalized, using inspector_email as proxy for now if needed, 
    // or better, just grouping by priority/status for this org.
    const bottlenecksQuery = `
      SELECT 
        priority,
        COUNT(*) as count
      FROM action_items 
      JOIN inspections ON action_items.inspection_id = inspections.id
      WHERE inspections.organization_id = ?
      AND action_items.status = 'pending'
      AND (action_items.when_deadline < NOW() OR action_items.priority = 'alta')
      GROUP BY priority
    `;
    const bottlenecks = await env.DB.prepare(bottlenecksQuery).bind(targetOrgId).all();

    // 3. Quality Risks (Fast inspections or Many Non-Conformities)
    // For now, let's just count average non-conformities per inspection
    // assuming we have a way to count items. Since we don't have 'items' table joined easily here without complexity,
    // we will return a placeholder or simple metric like "Avg Action Items per Inspection"
    const qualityQuery = `
      SELECT 
        AVG(sub.action_count) as avg_actions_per_inspection
      FROM (
        SELECT inspection_id, COUNT(*) as action_count
        FROM action_items ai
        JOIN inspections i ON ai.inspection_id = i.id
        WHERE i.organization_id = ?
        GROUP BY inspection_id
      ) sub
    `;
    const quality = await env.DB.prepare(qualityQuery).bind(targetOrgId).first();

    return c.json({
      productivity: productivity.results || [],
      bottlenecks: bottlenecks.results || [],
      quality: {
        avg_actions: Math.round(Number(quality?.avg_actions_per_inspection || 0))
      }
    });

  } catch (error) {
    console.error('[ORG-ADMIN-ANALYTICS] Error:', error);
    return c.json({ error: 'Failed to fetch analytics' }, 500);
  }
});



// GET Inspector Personal Analytics (My Performance)
dashboardRoutes.get("/inspector-analytics", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const organizationId = c.req.query("organization_id");

  if (!user) return c.json({ error: "Unauthorized" }, 401);

  try {
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    // For inspector analytics, we strictly use the logged-in user's email/id
    const inspectorEmail = userProfile.email || user.email;
    const targetOrgId = organizationId || userProfile.organization_id;

    if (!targetOrgId) return c.json({ error: "Organization context required" }, 400);

    // 1. My Inspections (This Month vs Total)
    const statsQuery = `
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN created_at > DATE('now', 'start of month') THEN 1 ELSE 0 END) as this_month,
        SUM(CASE WHEN status = 'concluida' THEN 1 ELSE 0 END) as completed
      FROM inspections
      WHERE organization_id = ? AND inspector_email = ?
    `;
    const stats = await env.DB.prepare(statsQuery).bind(targetOrgId, inspectorEmail).first();

    // 2. My Pending Actions ( Assigned to me or My Inspections)
    const pendingActionsQuery = `
      SELECT COUNT(*) as count
      FROM action_items ai
      JOIN inspections i ON ai.inspection_id = i.id
      WHERE i.organization_id = ? 
      AND i.inspector_email = ?
      AND ai.status = 'pending'
    `;
    const pendingActions = await env.DB.prepare(pendingActionsQuery).bind(targetOrgId, inspectorEmail).first();

    // 3. Motivational Feedback
    let feedback = "Continue o bom trabalho!";
    const monthlyCount = Number(stats?.this_month || 0);
    if (monthlyCount > 10) feedback = "ðŸ”¥ IncrÃ­vel! VocÃª estÃ¡ voando baixo este mÃªs!";
    else if (monthlyCount > 5) feedback = "Ã“timo ritmo! Continue assim.";
    else if (monthlyCount === 0) feedback = "Que tal iniciar sua primeira inspeÃ§Ã£o do mÃªs hoje?";

    return c.json({
      my_stats: {
        total: stats?.total || 0,
        this_month: stats?.this_month || 0,
        completed: stats?.completed || 0,
        pending_actions: pendingActions?.count || 0
      },
      feedback_message: feedback
    });

  } catch (error) {
    console.error('[INSPECTOR-ANALYTICS] Error:', error);
    return c.json({ error: 'Failed to fetch personal analytics' }, 500);
  }
});


export default dashboardRoutes;


===END_FILE===
===FILE: supabase/functions/api/database-debug-routes.ts===
import { Hono } from "hono";
import { requireProtectedSysAdmin } from "./rbac-middleware.ts";

type Env = {
  DB: any;
};

const app = new Hono<{ Bindings: Env; Variables: { user: any } }>();

// SEGURANÃ‡A: Verificar se estamos em produÃ§Ã£o - bloquear debug endpoints
const isProduction = Deno.env.get('ENVIRONMENT') === 'production';

// Endpoint para consultar dados do banco
// PROTEGIDO: Apenas SysAdmin pode acessar, e bloqueado em produÃ§Ã£o
app.get("/debug/query", requireProtectedSysAdmin(), async (c) => {
  // Bloquear completamente em produÃ§Ã£o
  if (isProduction) {
    console.warn('[DEBUG-ROUTES] BLOQUEADO: Tentativa de acesso a debug em produÃ§Ã£o');
    return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
  }
  const { table, limit = "10" } = c.req.query();

  if (!table) {
    return c.json({ error: "ParÃ¢metro 'table' Ã© obrigatÃ³rio" }, 400);
  }

  try {
    // Lista de tabelas permitidas por seguranÃ§a
    const allowedTables = [
      'users', 'organizations', 'checklist_templates',
      'inspections', 'action_plans', 'checklist_folders',
      'inspection_items', 'action_plan_items'
    ];

    if (!allowedTables.includes(table)) {
      return c.json({
        error: "Tabela nÃ£o permitida",
        allowedTables
      }, 400);
    }

    const query = `SELECT * FROM ${table} LIMIT ?`;
    const result = await c.env.DB.prepare(query).bind(limit).all();

    return c.json({
      table,
      count: result.results?.length || 0,
      data: result.results || []
    });

  } catch (error) {
    console.error('Database query error:', error);
    return c.json({
      error: "Erro ao consultar banco",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Endpoint para obter estrutura das tabelas (Postgres compatible)
// PROTEGIDO: Apenas SysAdmin pode acessar, e bloqueado em produÃ§Ã£o
app.get("/debug/schema", requireProtectedSysAdmin(), async (c) => {
  if (isProduction) {
    return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
  }
  try {
    const tableParam = c.req.query('table');

    if (tableParam) {
      // Query specific columns for a table
      const result = await c.env.DB.prepare(`
           SELECT column_name, data_type, is_nullable
           FROM information_schema.columns
           WHERE table_name = ?
           ORDER BY ordinal_position
        `).bind(tableParam).all();

      return c.json({
        table: tableParam,
        columns: result.results || []
      });
    }

    const result = await c.env.DB.prepare(`
      SELECT table_name as name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
      ORDER BY table_name
    `).all();

    return c.json({
      tables: result.results || []
    });

  } catch (error) {
    console.error('Schema query error:', error);
    return c.json({
      error: "Erro ao obter schema",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Endpoint para contar registros
// PROTEGIDO: Apenas SysAdmin pode acessar, e bloqueado em produÃ§Ã£o
app.get("/debug/counts", requireProtectedSysAdmin(), async (c) => {
  if (isProduction) {
    return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
  }
  try {
    const tables = ['users', 'organizations', 'checklist_templates', 'inspections', 'action_plans'];
    const counts: Record<string, any> = {};

    for (const table of tables) {
      try {
        const result = await c.env.DB.prepare(`SELECT COUNT(*) as count FROM ${table}`).first() as any;
        counts[table] = result?.count || 0;
      } catch (err) {
        counts[table] = 'Tabela nÃ£o existe ou erro';
      }
    }

    return c.json({ counts });

  } catch (error) {
    console.error('Counts query error:', error);
    return c.json({
      error: "Erro ao contar registros",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

export default app;

===END_FILE===
===FILE: supabase/functions/api/debug-checklist.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { requireProtectedSysAdmin } from "./rbac-middleware.ts";

const debugChecklistRoutes = new Hono().basePath('/api/debug');
const isProduction = Deno.env.get('ENVIRONMENT') === 'production';

// Endpoint de debug para verificar se tabelas existem (PROTEGIDO)
debugChecklistRoutes.get("/checklist-tables", tenantAuthMiddleware, requireProtectedSysAdmin(), async (c) => {
    if (isProduction) {
        return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
    }

    const env = c.env;
    const user = c.get("user");

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        const results: any = {
            user_info: {
                id: user.id,
                email: user.email,
                has_profile: !!(user as any).profile
            },
            tables_check: {},
            sample_data: {}
        };

        // Verificar se tabela checklist_folders existe
        try {
            const foldersTest = await env.DB.prepare("SELECT COUNT(*) as count FROM checklist_folders").first();
            results.tables_check.checklist_folders = {
                exists: true,
                count: foldersTest?.count || 0
            };

            // Buscar exemplo de folder
            const sampleFolder = await env.DB.prepare("SELECT * FROM checklist_folders LIMIT 1").first();
            results.sample_data.folder_sample = sampleFolder;
        } catch (error: any) {
            results.tables_check.checklist_folders = {
                exists: false,
                error: error.message
            };
        }

        // Verificar se tabela checklist_templates existe
        try {
            const templatesTest = await env.DB.prepare("SELECT COUNT(*) as count FROM checklist_templates").first();
            results.tables_check.checklist_templates = {
                exists: true,
                count: templatesTest?.count || 0
            };
        } catch (error: any) {
            results.tables_check.checklist_templates = {
                exists: false,
                error: error.message
            };
        }

        // Buscar perfil do usuÃ¡rio
        try {
            const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first();
            results.user_info.profile_from_db = userProfile;
        } catch (error: any) {
            results.user_info.profile_error = error.message;
        }

        return c.json(results);

    } catch (error: any) {
        return c.json({
            error: "Debug endpoint failed",
            message: error.message,
            ...(isProduction ? {} : { stack: error.stack })
        }, 500);
    }
});

// Teste direto da query que estÃ¡ falhando
debugChecklistRoutes.get("/test-folders-query", tenantAuthMiddleware, requireProtectedSysAdmin(), async (c) => {
    if (isProduction) {
        return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
    }

    const env = c.env;
    const user = c.get("user");

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        // Buscar perfil do usuÃ¡rio
        let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

        if (!userProfile) {
            return c.json({ error: "User profile not found in database" }, 404);
        }

        const parentId = c.req.query('parent_id') || null;

        let whereClause = "WHERE (f.organization_id = ? OR f.organization_id IS NULL)";
        let params: any[] = [userProfile?.organization_id];

        if (parentId === null || parentId === 'null') {
            whereClause += " AND f.parent_id IS NULL";
        } else {
            whereClause += " AND f.parent_id = ?";
            params.push(parentId);
        }

        // Query exata que estÃ¡ falhando
        const query = `
          SELECT
            f.*,
            COUNT(DISTINCT cf.id) as subfolder_count,
            COUNT(DISTINCT ct.id) as template_count
          FROM checklist_folders f
          LEFT JOIN checklist_folders cf ON cf.parent_id = f.id
          LEFT JOIN checklist_templates ct ON ct.folder_id = f.id AND ct.is_category_folder = false
          ${whereClause}
          GROUP BY f.id
          ORDER BY f.display_order ASC, f.name ASC
        `;

        const folders = await env.DB.prepare(query).bind(...params).all();

        return c.json({
            success: true,
            user_org_id: userProfile?.organization_id,
            parent_id: parentId,
            query_used: query,
            params_used: params,
            folders_count: folders.results?.length || 0,
            folders: folders.results || []
        });

    } catch (error: any) {
        return c.json({
            error: "Query test failed",
            message: error.message,
            ...(isProduction ? {} : { stack: error.stack, cause: error.cause })
        }, 500);
    }
});

export default debugChecklistRoutes;
===END_FILE===
===FILE: supabase/functions/api/deno.json===
{
    "tasks": {
        "start": "deno run --allow-net --allow-env --watch index.ts"
    },
    "imports": {
        "hono": "https://esm.sh/hono@4.6.14",
        "hono/": "https://esm.sh/hono@4.6.14/",
        "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@2",
        "postgres": "https://deno.land/x/postgresjs@v3.4.4/mod.js",
        "std/": "https://deno.land/std@0.208.0/",
        "zod": "https://esm.sh/zod@3.23.8",
        "@hono/zod-validator": "https://esm.sh/@hono/zod-validator@0.4.1",
        "@/": "./"
    }
}
===END_FILE===
===FILE: supabase/functions/api/email-service.ts===
import { getBaseTemplate } from './email-templates.ts';

/**
 * Service to handle email sending via Resend API
 */
export class EmailService {
    private apiKey: string;
    private fromEmail: string;

    constructor(apiKey: string) {
        this.apiKey = apiKey;
        this.fromEmail = 'Compia System <system@compia.tech>'; // Official sender
    }

    /**
     * Send an email using Resend API
     */
    async sendEmail(to: string[], subject: string, html: string): Promise<{ success: boolean; id?: string; error?: any }> {
        if (!this.apiKey) {
            console.error('[EmailService] Missing RESEND_API_KEY');
            return { success: false, error: 'Missing configuration' };
        }

        try {
            const response = await fetch('https://api.resend.com/emails', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                    from: this.fromEmail,
                    to: to,
                    subject: subject,
                    html: html
                })
            });

            const data = await response.json();

            if (!response.ok) {
                console.error('[EmailService] Error sending email:', data);
                return { success: false, error: data };
            }

            console.log(`[EmailService] Email sent successfully to ${to.join(', ')}. ID: ${data.id}`);
            return { success: true, id: data.id };

        } catch (error) {
            console.error('[EmailService] Network error:', error);
            return { success: false, error: error };
        }
    }
}
===END_FILE===
===FILE: supabase/functions/api/email-templates.ts===

export const EMAIL_STYLES = {
  container: `
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    background-color: #f4f7f6;
    margin: 0;
    padding: 40px 20px;
    color: #334155;
    line-height: 1.6;
  `,
  card: `
    max-width: 600px;
    margin: 0 auto;
    background-color: #ffffff;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    border: 1px solid #e2e8f0;
  `,
  header: `
    background-color: #0f172a;
    padding: 32px;
    text-align: center;
    background-image: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
  `,
  logo: `
    width: 140px;
    height: auto;
    display: block;
    margin: 0 auto;
  `,
  body: `
    padding: 40px 32px;
  `,
  h1: `
    color: #0f172a;
    font-size: 24px;
    font-weight: 700;
    margin-top: 0;
    margin-bottom: 24px;
    text-align: center;
  `,
  p: `
    font-size: 16px;
    color: #475569;
    margin-bottom: 20px;
  `,
  buttonContainer: `
    text-align: center;
    margin: 32px 0;
  `,
  button: `
    background-color: #2563eb;
    color: #ffffff;
    padding: 14px 32px;
    border-radius: 8px;
    text-decoration: none;
    font-weight: 600;
    font-size: 16px;
    display: inline-block;
    transition: background-color 0.2s;
    box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.2);
  `,
  divider: `
    border-top: 1px solid #e2e8f0;
    margin: 32px 0;
  `,
  footer: `
    background-color: #f8fafc;
    padding: 24px 32px;
    text-align: center;
    font-size: 13px;
    color: #94a3b8;
    border-top: 1px solid #f1f5f9;
  `,
  socialIcon: `
    margin: 0 8px;
    text-decoration: none;
    color: #94a3b8;
    font-size: 20px;
  `
};

export const getBaseTemplate = (content: string, title: string) => `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
</head>
<body style="${EMAIL_STYLES.container}">
  <div style="${EMAIL_STYLES.card}">
    <div style="${EMAIL_STYLES.header}">
      <img src="https://compia.tech/COMPIA_BRAND_KIT/png/2x/compia-logo-mono-white.png" alt="Compia Enterprise" style="${EMAIL_STYLES.logo}">
    </div>
    
    <div style="${EMAIL_STYLES.body}">
      ${content}
    </div>

    <div style="${EMAIL_STYLES.footer}">
      <p style="margin: 0 0 12px 0;">Â© ${new Date().getFullYear()} Compia Enterprise. Todos os direitos reservados.</p>
      <p style="margin: 0;">GestÃ£o Inteligente de Auditorias e Conformidade.</p>
      <div style="margin-top: 16px;">
        <a href="https://compia.tech" style="color: #2563eb; text-decoration: none; margin: 0 10px;">Website</a>
        <a href="https://compia.tech/privacy" style="color: #2563eb; text-decoration: none; margin: 0 10px;">Privacidade</a>
      </div>
    </div>
  </div>
</body>
</html>
`;

export const getWelcomeTemplate = (name: string, loginUrl: string) => {
  const content = `
    <h1 style="${EMAIL_STYLES.h1}">Bem-vindo ao Compia! ðŸš€</h1>
    <p style="${EMAIL_STYLES.p}">OlÃ¡, <strong>${name}</strong>!</p>
    <p style="${EMAIL_STYLES.p}">Estamos muito felizes em ter vocÃª a bordo. Sua conta foi criada com sucesso e vocÃª jÃ¡ pode acessar a plataforma corporativa mais completa para gestÃ£o de auditorias.</p>
    <p style="${EMAIL_STYLES.p}">Comece agora mesmo a otimizar seus processos de conformidade.</p>
    
    <div style="${EMAIL_STYLES.buttonContainer}">
      <a href="${loginUrl}" style="${EMAIL_STYLES.button}">Acessar Plataforma</a>
    </div>
    
    <p style="${EMAIL_STYLES.p}" style="font-size: 14px; text-align: center; color: #94a3b8;">Ou copie este link: <a href="${loginUrl}" style="color: #2563eb;">${loginUrl}</a></p>
  `;
  return getBaseTemplate(content, "Bem-vindo ao Compia");
};

export const getApprovalTemplate = (name: string, loginUrl: string) => {
  const content = `
    <h1 style="${EMAIL_STYLES.h1}">Acesso Aprovado! âœ…</h1>
    <p style="${EMAIL_STYLES.p}">OlÃ¡, <strong>${name}</strong>.</p>
    <p style="${EMAIL_STYLES.p}">Temos Ã³timas notÃ­cias! O administrador revisou seu cadastro e seu acesso ao <strong>Compia Enterprise</strong> foi aprovado.</p>
    <p style="${EMAIL_STYLES.p}">VocÃª agora tem acesso total Ã s funcionalidades atribuÃ­das ao seu perfil.</p>
    
    <div style="${EMAIL_STYLES.buttonContainer}">
      <a href="${loginUrl}" style="${EMAIL_STYLES.button}">Entrar no Sistema</a>
    </div>
  `;
  return getBaseTemplate(content, "Seu acesso foi aprovado");
};

export const getAlertTemplate = (title: string, message: string, actionUrl?: string, actionText?: string) => {
  const content = `
    <h1 style="${EMAIL_STYLES.h1}">âš ï¸ ${title}</h1>
    <p style="${EMAIL_STYLES.p}">${message}</p>
    
    ${actionUrl ? `
    <div style="${EMAIL_STYLES.buttonContainer}">
      <a href="${actionUrl}" style="${EMAIL_STYLES.button}">${actionText || 'Ver Detalhes'}</a>
    </div>
    ` : ''}
  `;
  return getBaseTemplate(content, `Alerta: ${title}`);
};

export const getResetPasswordTemplate = (name: string, resetUrl: string) => {
  const content = `
    <h1 style="${EMAIL_STYLES.h1}">Redefinir sua Senha ðŸ”’</h1>
    <p style="${EMAIL_STYLES.p}">OlÃ¡, <strong>${name}</strong>.</p>
    <p style="${EMAIL_STYLES.p}">Recebemos uma solicitaÃ§Ã£o para redefinir a senha da sua conta no <strong>Compia Enterprise</strong>.</p>
    <p style="${EMAIL_STYLES.p}">Se foi vocÃª quem solicitou, clique no botÃ£o abaixo para criar uma nova senha:</p>
    
    <div style="${EMAIL_STYLES.buttonContainer}">
      <a href="${resetUrl}" style="${EMAIL_STYLES.button}">Redefinir Senha</a>
    </div>
    
    <p style="${EMAIL_STYLES.p}">Este link expira em 1 hora.</p>
    <p style="${EMAIL_STYLES.p}" style="font-size: 14px; text-align: center; color: #94a3b8;">Ou copie este link: <a href="${resetUrl}" style="color: #2563eb;">${resetUrl}</a></p>
    <p style="${EMAIL_STYLES.p}">Se vocÃª nÃ£o solicitou esta alteraÃ§Ã£o, pode ignorar este email com seguranÃ§a.</p>
  `;
  return getBaseTemplate(content, "RedefiniÃ§Ã£o de Senha");
};
===END_FILE===
===FILE: supabase/functions/api/financial-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { requireProtectedSysAdmin } from "./rbac-middleware.ts";
import { USER_ROLES } from "./user-types.ts";

type Env = {
    DB: any;
};

const financialRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>()
    .basePath('/api/financial');

// ============================================================================
// GET /plans - Lista todos os planos ativos (pÃºblico para autenticados)
// ============================================================================
financialRoutes.get("/plans", async (c) => {
    const env = c.env;

    try {
        const plans = await env.DB.prepare(`
            SELECT 
                id, name, display_name, slug, description,
                price_cents, currency, billing_period,
                limits, features, is_active
            FROM plans 
            WHERE is_active = true
            ORDER BY price_cents ASC
        `).all();

        // Formatar preÃ§o para exibiÃ§Ã£o
        const formattedPlans = (plans?.results || []).map((plan: any) => ({
            ...plan,
            limits: typeof plan.limits === 'string' ? JSON.parse(plan.limits) : plan.limits,
            features: typeof plan.features === 'string' ? JSON.parse(plan.features) : plan.features,
            price_display: plan.price_cents > 0
                ? `R$ ${(plan.price_cents / 100).toFixed(2).replace('.', ',')}`
                : 'Sob consulta'
        }));

        return c.json({ plans: formattedPlans });
    } catch (error: any) {
        console.error("[FINANCIAL] Error fetching plans:", error);
        return c.json({ error: "Erro ao buscar planos", details: error.message }, 500);
    }
});

// ============================================================================
// GET /current - Retorna a assinatura atual da organizaÃ§Ã£o
// ============================================================================
financialRoutes.get("/current", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const organizationId = c.req.query("organization_id");

    if (!user) {
        return c.json({ error: "UsuÃ¡rio nÃ£o autenticado" }, 401);
    }

    try {
        // Verificar permissÃ£o (OrgAdmin ou SysAdmin)
        const userProfile = await env.DB.prepare(
            "SELECT role, managed_organization_id FROM users WHERE id = ?"
        ).bind(user.id).first() as any;

        const isAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||
            userProfile?.role === 'sys_admin' ||
            userProfile?.role === USER_ROLES.ORG_ADMIN;

        if (!isAdmin) {
            return c.json({ error: "Apenas administradores podem acessar informaÃ§Ãµes de billing" }, 403);
        }

        // Determinar qual org buscar
        const targetOrgId = organizationId || userProfile?.managed_organization_id;

        if (!targetOrgId) {
            return c.json({ error: "OrganizaÃ§Ã£o nÃ£o especificada" }, 400);
        }

        // Buscar assinatura ativa
        const subscription = await env.DB.prepare(`
            SELECT 
                s.id, s.status, s.gateway_name,
                s.current_period_start, s.current_period_end,
                s.trial_ends_at, s.canceled_at,
                s.mrr_value_cents,
                p.name as plan_name, p.display_name as plan_display_name,
                p.price_cents, p.limits, p.features
            FROM subscriptions s
            JOIN plans p ON s.plan_id = p.id
            WHERE s.organization_id = ?
            AND s.status NOT IN ('canceled')
            ORDER BY s.created_at DESC
            LIMIT 1
        `).bind(targetOrgId).first() as any;

        // Buscar uso atual (Ãºltima mÃ©trica)
        const usage = await env.DB.prepare(`
            SELECT 
                active_users_count, inspections_count, 
                ai_analyses_count, storage_used_mb, date
            FROM usage_metrics
            WHERE organization_id = ?
            ORDER BY date DESC
            LIMIT 1
        `).bind(targetOrgId).first() as any;

        // Buscar faturas recentes
        const invoices = await env.DB.prepare(`
            SELECT id, amount_cents, status, due_date, paid_at, payment_link
            FROM invoices
            WHERE organization_id = ?
            ORDER BY due_date DESC
            LIMIT 5
        `).bind(targetOrgId).all();

        // Formatar resposta
        const billingInfo = {
            subscription: subscription ? {
                ...subscription,
                limits: typeof subscription.limits === 'string'
                    ? JSON.parse(subscription.limits)
                    : subscription.limits,
                features: typeof subscription.features === 'string'
                    ? JSON.parse(subscription.features)
                    : subscription.features,
                price_display: subscription.price_cents > 0
                    ? `R$ ${(subscription.price_cents / 100).toFixed(2).replace('.', ',')}`
                    : 'Sob consulta'
            } : null,
            usage: usage || {
                active_users_count: 0,
                inspections_count: 0,
                ai_analyses_count: 0,
                storage_used_mb: 0
            },
            invoices: (invoices?.results || []).map((inv: any) => ({
                ...inv,
                amount_display: `R$ ${(inv.amount_cents / 100).toFixed(2).replace('.', ',')}`
            })),
            has_active_subscription: !!subscription
        };

        return c.json(billingInfo);
    } catch (error: any) {
        console.error("[FINANCIAL] Error fetching billing info:", error);
        return c.json({ error: "Erro ao buscar informaÃ§Ãµes de billing", details: error.message }, 500);
    }
});

// ============================================================================
// GET /usage - Retorna o uso atual vs limites do plano
// ============================================================================
financialRoutes.get("/usage", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const organizationId = c.req.query("organization_id");

    if (!user) {
        return c.json({ error: "UsuÃ¡rio nÃ£o autenticado" }, 401);
    }

    try {
        const userProfile = await env.DB.prepare(
            "SELECT role, managed_organization_id FROM users WHERE id = ?"
        ).bind(user.id).first() as any;

        const targetOrgId = organizationId || userProfile?.managed_organization_id;

        if (!targetOrgId) {
            return c.json({ error: "OrganizaÃ§Ã£o nÃ£o especificada" }, 400);
        }

        // Buscar limites do plano
        // 1. Fetch Subscription first (most recent active)
        const subscription = await env.DB.prepare(`
            SELECT plan_id, current_period_start, created_at, status
            FROM subscriptions 
            WHERE organization_id = ? AND status NOT IN ('canceled')
            ORDER BY created_at DESC
            LIMIT 1
        `).bind(targetOrgId).first() as any;

        let limits: any = null;

        if (subscription && subscription.plan_id) {
            // 2. Fetch Plan details
            const plan = await env.DB.prepare(`
                SELECT limits FROM plans WHERE id = ?
             `).bind(subscription.plan_id).first() as any;

            if (plan?.limits) {
                try {
                    limits = typeof plan.limits === 'string' ? JSON.parse(plan.limits) : plan.limits;
                } catch (e) {
                    console.error("[FINANCIAL] Failed to parse limits:", e);
                }
            }
        }

        // 3. Fallback if no subscription or plan found
        const finalLimits = limits || { users: 2, storage_gb: 5, inspections_monthly: 100 }; // Default free tier

        // Contar uso atual
        const userCount = await env.DB.prepare(`
            SELECT COUNT(*) as count FROM user_organizations WHERE organization_id = ?
        `).bind(targetOrgId).first() as any;

        const currentPeriodStart = subscription?.current_period_start || new Date().toISOString().slice(0, 7) + '-01'; // Fallback to start of month

        const inspectionsThisMonth = await env.DB.prepare(`
            SELECT COUNT(*) as count FROM inspections 
            WHERE organization_id = ? 
            AND created_at >= ?
        `).bind(targetOrgId, currentPeriodStart).first() as any;

        // Calcular porcentagens
        // Calcular porcentagens
        const usage = {
            users: {
                current: userCount?.count || 0,
                limit: finalLimits.users || 999,
                percentage: Math.round(((userCount?.count || 0) / (finalLimits.users || 1)) * 100)
            },
            inspections: {
                current: inspectionsThisMonth?.count || 0,
                limit: finalLimits.inspections_monthly || 999,
                percentage: Math.round(((inspectionsThisMonth?.count || 0) / (finalLimits.inspections_monthly || 1)) * 100)
            },
            storage: {
                current: 0, // TODO: Calcular storage real
                limit: finalLimits.storage_gb || 5,
                percentage: 0
            }
        };

        // Alertas
        const alerts = [];
        if (usage.users.percentage >= 80) alerts.push({ type: 'users', level: usage.users.percentage >= 100 ? 'critical' : 'warning' });
        if (usage.inspections.percentage >= 80) alerts.push({ type: 'inspections', level: usage.inspections.percentage >= 100 ? 'critical' : 'warning' });

        return c.json({ usage, alerts, has_subscription: !!subscription });
    } catch (error: any) {
        console.error("[FINANCIAL] Error fetching usage:", error);
        return c.json({ error: "Erro ao buscar uso", details: error.message }, 500);
    }
});

// ============================================================================
// POST /checkout - Inicia o processo de checkout (cria link de pagamento)
// ============================================================================
// Import AsaasService
import { AsaasService } from "./asaas-service.ts";

// ... existing code ...

financialRoutes.post("/checkout", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");

    if (!user) {
        return c.json({ error: "UsuÃ¡rio nÃ£o autenticado" }, 401);
    }

    try {
        const body = await c.req.json();
        const { plan_id, organization_id, billing_type } = body;

        if (!plan_id) {
            return c.json({ error: "Plano Ã© obrigatÃ³rio" }, 400);
        }

        // Validate billing type if provided
        const validBillingTypes = ['CREDIT_CARD', 'PIX', 'UNDEFINED'];
        const selectedBillingType = billing_type && validBillingTypes.includes(billing_type)
            ? billing_type
            : 'UNDEFINED';

        // 1. Get user profile and org details
        const userProfile = await env.DB.prepare(
            "SELECT id, email, raw_user_meta_data, role, managed_organization_id FROM users WHERE id = ?"
        ).bind(user.id).first() as any;

        const targetOrgId = organization_id || userProfile?.managed_organization_id;

        if (!targetOrgId) {
            return c.json({ error: "OrganizaÃ§Ã£o nÃ£o especificada" }, 400);
        }

        // Get Plan details
        const plan = await env.DB.prepare("SELECT * FROM plans WHERE id = ?").bind(plan_id).first() as any;
        if (!plan) {
            return c.json({ error: "Plano nÃ£o encontrado" }, 404);
        }

        if (plan.price_cents <= 0) {
            return c.json({ error: "Este plano nÃ£o permite checkout automÃ¡tico." }, 400);
        }

        // 2. Prepare Customer Data
        // Try to get name/cpf from metadata
        let userData: any = {};
        try {
            userData = typeof userProfile.raw_user_meta_data === 'string'
                ? JSON.parse(userProfile.raw_user_meta_data)
                : userProfile.raw_user_meta_data || {};
        } catch (e) {
            userData = {};
        }

        const asaasService = new AsaasService();

        // 3. Create/Get Asaas Customer
        const customer = await asaasService.createOrUpdateCustomer({
            name: userData.full_name || userData.name || user.email || 'Cliente Compia',
            email: userProfile.email || user.email,
            cpfCnpj: userData.cpf || userData.cnpj, // Optional
            mobilePhone: userData.phone
        });

        console.log(`[CHECKOUT] Asaas Customer: ${customer.id}`);

        // 4. Create Subscription in Asaas
        // Determine cycle and value
        const cycle = plan.billing_period === 'yearly' ? 'YEARLY' : 'MONTHLY';

        // Define due date for 3 days from now (or immediate if using credit card flow later)
        const nextDueDate = new Date();
        nextDueDate.setDate(nextDueDate.getDate() + 1); // Tomorrow

        const subscription = await asaasService.createSubscription({
            customer: customer.id,
            billingType: selectedBillingType, // Use user selected type
            value: plan.price_cents / 100,
            nextDueDate: nextDueDate.toISOString().split('T')[0],
            cycle: cycle,
            description: `Assinatura Plano ${plan.display_name} - Compia`,
            externalReference: targetOrgId.toString()
        });

        console.log(`[CHECKOUT] Asaas Subscription: ${subscription.id}`);

        // 5. Store Subscription in DB
        const result = await env.DB.prepare(`
            INSERT INTO subscriptions (
                organization_id, plan_id, status, 
                current_period_start, current_period_end, 
                gateway_name, gateway_customer_id, gateway_subscription_id,
                mrr_value_cents,
                created_at, updated_at
            ) VALUES (
                ?, ?, 'trial',
                NOW(), NOW() + INTERVAL '30 days',
                'asaas', ?, ?,
                ?,
                NOW(), NOW()
            )
            RETURNING id
        `).bind(
            targetOrgId, plan_id,
            customer.id, subscription.id,
            plan.price_cents
        ).first() as any;

        const internalSubId = result?.id;

        // 6. Get Initial Payment/Invoice from Asaas (to get the URL)
        // Usually Asaas creates the first payment immediately
        let paymentUrl = '';
        try {
            const payments = await asaasService.getSubscriptionPayments(subscription.id);
            if (payments.data && payments.data.length > 0) {
                const firstPayment = payments.data[0];
                paymentUrl = firstPayment.invoiceUrl || firstPayment.bankSlipUrl; // Prefer invoiceUrl (checkout page)

                // Store Invoice
                await env.DB.prepare(`
                    INSERT INTO invoices (
                        subscription_id, organization_id,
                        gateway_invoice_id, payment_link, pdf_url,
                        amount_cents, status, due_date
                    ) VALUES (
                        ?, ?,
                        ?, ?, ?,
                        ?, 'pending', ?
                    )
                `).bind(
                    internalSubId, targetOrgId,
                    firstPayment.id, firstPayment.invoiceUrl, firstPayment.bankSlipUrl,
                    Math.round(firstPayment.value * 100), firstPayment.dueDate
                ).run();
            }
        } catch (err) {
            console.error("[CHECKOUT] Failed to fetch initial payment:", err);
            // Non-critical: User can still see subscription in dashboard later, 
            // but we might fail to redirect. Fallback?
        }

        // Return URL
        return c.json({
            url: paymentUrl || `https://www.compia.tech/billing?status=pending_link`,
            subscriptionId: internalSubId,
            mock: false
        });

    } catch (error: any) {
        console.error("[FINANCIAL] Error in checkout:", error);
        return c.json({ error: "Erro ao processar checkout", details: error.message }, 500);
    }
});

// ============================================================================
// GET /debug-limits - DEBUG APENAS
// ============================================================================
financialRoutes.get("/debug-limits", tenantAuthMiddleware, requireProtectedSysAdmin(), async (c) => {
    if (Deno.env.get('ENVIRONMENT') === 'production') {
        return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
    }

    const env = c.env;
    const user = c.get("user");
    const organizationId = c.req.query("organization_id");

    // Determine Org ID similar to /usage
    const userProfile = await env.DB.prepare(
        "SELECT role, managed_organization_id FROM users WHERE id = ?"
    ).bind(user.id).first() as any;
    const targetOrgId = organizationId || userProfile?.managed_organization_id;

    if (!targetOrgId) {
        return c.json({ error: "No org id" });
    }

    // Run the Logic Query
    const subscription = await env.DB.prepare(`
        SELECT s.id, s.status, s.gateway_name, s.current_period_start, p.name as plan_name, p.limits, p.limits as debug_limits_raw
        FROM subscriptions s
        JOIN plans p ON s.plan_id = p.id
        WHERE s.organization_id = ? AND s.status NOT IN ('canceled')
        ORDER BY s.created_at DESC
        LIMIT 1
    `).bind(targetOrgId).first() as any;

    // Check parsing
    let parsedLimits = null;
    let parseError = null;
    if (subscription?.limits) {
        try {
            parsedLimits = typeof subscription.limits === 'string' ? JSON.parse(subscription.limits) : subscription.limits;
        } catch (e: any) {
            parseError = e.message;
        }
    }

    // Raw Usage Query
    const currentPeriodStart = subscription?.current_period_start || new Date().toISOString().slice(0, 7) + '-01';
    const inspectionsThisMonth = await env.DB.prepare(`
        SELECT COUNT(*) as count FROM inspections 
        WHERE organization_id = ? 
        AND created_at >= ?
    `).bind(targetOrgId, currentPeriodStart).first() as any;

    return c.json({
        targetOrgId,
        subscription,
        parsedLimits,
        parseError,
        inspectionsCount: inspectionsThisMonth,
        currentPeriodStart
    });
});

export default financialRoutes;
===END_FILE===
===FILE: supabase/functions/api/gamification-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";

/**
 * GAMIFICATION ROUTES
 * 
 * Refactored to use D1 Wrapper (postgres) and shared Auth Context.
 * Eliminates "401 Unauthorized" by trusting the tenantAuthMiddleware.
 */

// Exported function for other modules to add XP
export async function addXP(userId: string, xpAmount: number, db: any): Promise<void> {
    try {
        // Get current XP
        const current = await db.prepare(
            "SELECT current_xp, level FROM user_gamification WHERE user_id = ?"
        ).bind(userId).first();

        // If no gamification record, insert one
        if (!current) {
            await db.prepare(
                "INSERT INTO user_gamification (user_id, current_xp, level, points_this_month, created_at, updated_at) VALUES (?, ?, 1, 0, NOW(), NOW())"
            ).bind(userId, xpAmount).run();
            console.log(`[GAMIFICATION] Created profile for ${userId} with ${xpAmount}XP`);
            return;
        }

        const newXP = (current.current_xp || 0) + xpAmount;
        // Level formula: floor(sqrt(XP / 100)) + 1
        const newLevel = Math.floor(Math.sqrt(newXP / 100)) + 1;

        await db.prepare(
            "UPDATE user_gamification SET current_xp = ?, level = ?, updated_at = NOW() WHERE user_id = ?"
        ).bind(newXP, newLevel, userId).run();

        // Also update total_points in users table if needed (redundant but kept for legacy sync)
        await db.prepare(
            "UPDATE users SET total_points = COALESCE(total_points, 0) + ? WHERE id = ?"
        ).bind(xpAmount, userId).run();

        console.log(`[GAMIFICATION] User ${userId}: +${xpAmount}XP (total: ${newXP}, level: ${newLevel})`);
    } catch (error) {
        console.error('[GAMIFICATION] Error adding XP:', error);
    }
}

const gamificationRoutes = new Hono<{ Bindings: { DB: any }; Variables: { user: any } }>().basePath('/api/gamification');

// Helper to calculate next level threshold
function getNextLevelMinXP(currentLevel: number): number {
    // Threshold for Level L+1: 100 * L^2
    return 100 * Math.pow(currentLevel, 2);
}

function getCurrentLevelMinXP(currentLevel: number): number {
    // Threshold for current Level L: 100 * (L-1)^2
    return 100 * Math.pow(currentLevel - 1, 2);
}

// Get My Gamification Stats
gamificationRoutes.get("/me", tenantAuthMiddleware, async (c) => {
    const user = c.get("user") as any;
    const env = c.env;

    if (!user) {
        return c.json({ error: "Unauthorized" }, 401);
    }

    try {
        // 1. Fetch User Stats from DB
        let userGamification = await env.DB.prepare(
            "SELECT * FROM user_gamification WHERE user_id = ?"
        ).bind(user.id).first();

        if (!userGamification) {
            // Initialize if missing
            await env.DB.prepare(
                "INSERT INTO user_gamification (user_id, current_xp, level, points_this_month, created_at, updated_at) VALUES (?, 0, 1, 0, NOW(), NOW())"
            ).bind(user.id).run();

            userGamification = { user_id: user.id, current_xp: 0, level: 1 };
        }

        // 2. Calculate Progress
        const currentLevel = userGamification.level || 1;
        const currentXP = userGamification.current_xp || 0;

        const xpStart = getCurrentLevelMinXP(currentLevel);
        const xpNext = getNextLevelMinXP(currentLevel);

        // Progress percentage within the level
        const totalToNext = xpNext - xpStart;
        const earnedInLevel = currentXP - xpStart;

        const percentage = totalToNext > 0
            ? Math.min(100, Math.max(0, (earnedInLevel / totalToNext) * 100))
            : 100;

        // 3. Get Achievements Count
        const achievementsResult = await env.DB.prepare(
            "SELECT COUNT(*) as count FROM user_achievements WHERE user_id = ?"
        ).bind(user.id).first();

        return c.json({
            ...userGamification,
            achievements_count: Number(achievementsResult?.count || 0),
            progress: {
                current: currentXP,
                min: xpStart,
                max: xpNext,
                percentage: Math.round(percentage)
            }
        });

    } catch (error: any) {
        console.error("Error fetching gamification stats:", error);
        return c.json({ error: "Failed to fetch stats", details: error.message }, 500);
    }
});

// Get Leaderboard (Top 10 by Organization)
gamificationRoutes.get("/leaderboard", tenantAuthMiddleware, async (c) => {
    const user = c.get("user") as any;
    const env = c.env;

    if (!user) return c.json({ error: "Unauthorized" }, 401);

    try {
        const orgId = user.organization_id; // Injected by tenantAuthMiddleware (confirmed logic)

        if (!orgId) return c.json({ leaderboard: [] });

        // Fetch Leaderboard with Join
        // Using direct SQL for efficiency
        const leaderboard = await env.DB.prepare(`
            SELECT 
                ug.user_id, 
                ug.current_xp, 
                ug.level, 
                u.name, 
                u.avatar_url
            FROM user_gamification ug
            JOIN users u ON ug.user_id = u.id
            WHERE u.organization_id = ?
            ORDER BY ug.current_xp DESC
            LIMIT 10
        `).bind(orgId).all();

        // Process results to format avatar
        const processed = (leaderboard.results || []).map((entry: any) => {
            return {
                user_id: entry.user_id,
                name: entry.name || 'Unknown',
                current_xp: entry.current_xp,
                level: entry.level,
                avatar_url: entry.avatar_url
            };
        });

        return c.json({ leaderboard: processed });

    } catch (error: any) {
        console.error("Error fetching leaderboard:", error);
        return c.json({ error: "Failed to fetch leaderboard", details: error.message }, 500);
    }
});

export default gamificationRoutes;
===END_FILE===
===FILE: supabase/functions/api/index.ts===
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { createLogger } from './shared/logger.ts'
// Imports removidos para Lazy Loading (d1-wrapper, supabase-js)


// Types
type Env = {
    DB: any;
    SUPABASE_URL: string;
    SUPABASE_ANON_KEY: string;
    SUPABASE_SERVICE_ROLE_KEY: string;
    OPENAI_API_KEY: string;
    GEMINI_API_KEY: string;
};

const app = new Hono<{ Bindings: Env }>()
const log = createLogger('api')

// GLOBAL ERROR HANDLER (Sentinela Security Pattern)
app.onError((err, c) => {
    log.error('GLOBAL-ERROR Uncaught exception', err);

    // Fail Secure: NÃ£o vazar stack trace em produÃ§Ã£o
    const isDev = Deno.env.get('ENVIRONMENT') === 'development';

    const response: Record<string, unknown> = {
        error: "Internal Server Error",
        message: isDev ? (err.message || "Ocorreu um erro interno (DEBUG MODE).") : "Internal Server Error",
        code: "INTERNAL_ERROR",
        env_check: {
            is_dev: isDev,
            has_db: !!c.env?.DB
        }
    };

    if (isDev) {
        response.stack = err.stack;
    }

    return c.json(response, 500);
});

app.use('/*', cors({
    origin: (origin) => {
        const allowed = [
            'https://compia.tech',
            'https://www.compia.tech',
            'http://localhost:3000',
            'http://localhost:5173',
            'https://compia-06092520-aqb5140o0-tiagossms-projects.vercel.app'
        ];
        const allowedFromEnv = (Deno.env.get('ALLOWED_ORIGINS') || '')
            .split(',')
            .map((o) => o.trim())
            .filter(Boolean);
        const allowedOrigins = [...allowed, ...allowedFromEnv];

        if (origin && allowedOrigins.includes(origin)) {
            return origin;
        }
        // SEGURANÃ‡A: NÃ£o permitir origens desconhecidas (retorna null = bloqueio CORS)
        return null;
    },

    allowHeaders: ['authorization', 'x-client-info', 'apikey', 'content-type'],
    allowMethods: ['POST', 'GET', 'OPTIONS', 'PUT', 'DELETE'],
    exposeHeaders: ['Content-Length', 'X-Kuma-Revision'],
    maxAge: 600,
    credentials: true,
}))

// Middleware para injetar DB wrapper e User
app.use('*', async (c, next) => {
    const dbUrl = Deno.env.get('SUPABASE_DB_URL')
    // @ts-ignore
    c.env = c.env || {}

    if (dbUrl) {
        try {
            // Lazy load D1 Wrapper (Postgres driver) to reduce boot time
            // console.log('[DB-DEBUG] Lazy loading d1-wrapper...');
            const { createD1Wrapper } = await import('./d1-wrapper.ts');
            // @ts-ignore
            c.env.DB = createD1Wrapper(dbUrl)
            // console.log('[DB-DEBUG] DB Wrapper initialized');
        } catch (dbErr: any) {
            log.error('DB-DEBUG Failed to lazy load DB wrapper', dbErr);
        }
    } else {
        log.warn('DB-DEBUG No SUPABASE_DB_URL found');
    }

    // Inject keys from Deno.env
    // @ts-ignore
    c.env.OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY') || ''
    // @ts-ignore
    c.env.GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY') || ''
    // @ts-ignore
    c.env.SUPABASE_URL = Deno.env.get('SUPABASE_URL') || ''
    // @ts-ignore
    c.env.SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY') || ''
    // @ts-ignore
    c.env.SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || ''

    // NormalizaÃ§Ã£o robusta do path para Supabase Edge Functions
    const url = new URL(c.req.url);
    const rawPath = url.pathname;
    const path = rawPath.replace('/functions/v1', ''); // Remove prefixo padrÃ£o do Supabase se existir

    log.debug(`AUTH-DEBUG Request: ${c.req.method} ${path} (raw: ${rawPath})`);

    // Rotas pÃºblicas que nÃ£o precisam de autenticaÃ§Ã£o
    const publicPaths = [
        '/api/health',
        '/api/',
        '/api/shared',
        '/api/public-plans', // CORREÃ‡ÃƒO: Adicionada rota de planos pÃºblicos
        '/api/auth/callback', // Garantir callback
        '/api/auth/login', // Login nÃ£o requer autenticaÃ§Ã£o prÃ©via
        '/api/auth/register', // Registro nÃ£o requer autenticaÃ§Ã£o prÃ©via
        '/api/auth/forgot-password', // RecuperaÃ§Ã£o de senha nÃ£o requer autenticaÃ§Ã£o
        '/api/auth/reset-password' // Reset de senha nÃ£o requer autenticaÃ§Ã£o
    ];

    // VerificaÃ§Ã£o flexÃ­vel (exact match ou prefixo)
    const isPublicRoute = publicPaths.some(p => path === p || path.startsWith(p + '/'));

    // --- RATE LIMIT GLOBAL ---
    // Aplica rate limit O MAIS CEDO POSSÃVEL (antes de rotas pÃºblicas)
    // Usa env.DB (d1-wrapper)
    if (c.env.DB) {
        try {
            const { rateLimitMiddleware } = await import('./rate-limit-middleware.ts');

            // Re-instantiate middleware function
            const limiter = rateLimitMiddleware(60); // 60 req/min base

            let passed = false;
            const mockNext = async () => { passed = true; };

            const response = await limiter(c, mockNext);

            // If limiter returned a response (429), return it and stop chain
            if (response instanceof Response) {
                return response;
            }
        } catch (rlError) {
            log.error('RATE-LIMIT Failed to load/exec middleware', rlError);
        }
    }
    // -------------------------

    if (isPublicRoute) {
        log.debug(`AUTH-DEBUG Public route, skipping auth: ${path}`);
        await next();
        return;
    }

    // Verificar se jÃ¡ tem user (algumas rotas pÃºblicas nÃ£o precisam)
    if (!c.get('user')) {
        let user = null;

        // 1. Primeiro, tentar via Supabase Auth (para Google login)
        const authHeader = c.req.header('Authorization');
        log.debug(`AUTH-DEBUG Authorization header: ${authHeader ? 'present (' + authHeader.substring(0, 30) + '...)' : 'absent'}`);

        if (authHeader) {
            log.debug('AUTH-DEBUG Lazy loading Supabase Client...');
            try {
                // Lazy load Supabase Client to reduce boot time
                const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2');
                log.debug('AUTH-DEBUG Supabase Client loaded');

                const supabaseClient = createClient(
                    Deno.env.get('SUPABASE_URL') ?? '',
                    Deno.env.get('SUPABASE_ANON_KEY') ?? '',
                    { global: { headers: { Authorization: authHeader } } }
                )
                const { data, error } = await supabaseClient.auth.getUser()
                user = data?.user;
                log.debug(`AUTH-DEBUG Supabase Auth: ${user ? 'found user ' + user.email : 'no user'}, error: ${error?.message || 'none'}`);
            } catch (err: any) {
                log.error('AUTH-DEBUG Error loading/using Supabase Client', err);
            }

            // AUTO-SYNC: If user from Supabase Auth doesn't exist in DB, create them
            if (user && user.email && c.env?.DB) {
                const existingDbUser = await c.env.DB.prepare("SELECT id, role FROM users WHERE id = ? OR email = ?").bind(user.id, user.email).first();
                if (!existingDbUser) {
                    const userName = user.user_metadata?.full_name || user.user_metadata?.name || user.email?.split('@')[0] || 'User';
                    log.info(`AUTH-DEBUG Creating new user in DB for Google user: ${user.email}`);
                    try {
                        await c.env.DB.prepare(`
                            INSERT INTO users (id, email, name, role, is_active, approval_status, created_at, updated_at)
                            VALUES (?, ?, ?, 'inspector', true, 'pending', NOW(), NOW())
                        `).bind(user.id, user.email, userName).run();
                        log.info(`AUTH-DEBUG Created new user: ${user.email} with pending approval`);
                    } catch (insertError) {
                        log.error('AUTH-DEBUG Error creating user', insertError);
                    }
                } else {
                    // Enrich user object with DB role
                    (user as any).role = (existingDbUser as any).role;
                }
            }
        }


        if (!user) {
            const cookies = c.req.header('Cookie') || '';
            const sessionMatch = cookies.match(/mocha-session-token=([^;]+)/);
            log.debug(`AUTH-DEBUG Cookie session: ${sessionMatch ? 'found token' : 'no token'}`);
            if (sessionMatch) {
                const sessionToken = sessionMatch[1];
                const isDevelopment = Deno.env.get('ENVIRONMENT') === 'development';
                if (sessionToken && sessionToken.startsWith('dev-session-') && isDevelopment) {
                    const userId = sessionToken.replace('dev-session-', '');
                    // Buscar usuÃ¡rio no DB
                    if (c.env?.DB) {
                        const dbUser = await c.env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(userId).first();
                        log.debug(`AUTH-DEBUG Cookie user lookup: ${dbUser ? 'found ' + (dbUser as any).email : 'not found'}`);
                        if (dbUser) {
                            user = {
                                id: (dbUser as any).id,
                                email: (dbUser as any).email,
                                role: (dbUser as any).role,
                                user_metadata: { name: (dbUser as any).name }
                            };
                        }
                    }
                } else if (sessionToken && sessionToken.startsWith('dev-session-') && !isDevelopment) {
                    log.warn('AUTH-DEBUG BLOQUEADO: Tentativa de usar dev-session em produÃ§Ã£o');
                }
            }
        }

        log.debug(`[AUTH-DEBUG] Final user: ${user ? (user as any).email + ' (role: ' + (user as any).role + ')' : 'NONE'}`);
        c.set('user', user)
    } else {
        log.debug(`[AUTH-DEBUG] User already in context: ${(c.get('user') as any)?.email}`);
    }

    await next()
})

// Criar sub-app para as rotas da API
const apiRoutes = new Hono<{ Bindings: Env }>();

// Middleware para propagar contexto de autenticaÃ§Ã£o do app pai para o sub-app
apiRoutes.use('*', async (c, next) => {
    // O contexto jÃ¡ foi preenchido pelo middleware do app principal
    // Mas precisamos garantir que o user estÃ¡ acessÃ­vel
    log.debug(`[SUBROUTES] Path: ${c.req.path}, User in context: ${c.get('user') ? (c.get('user') as any).email : 'NONE'}`);
    await next();
});

// Rotas bÃ¡sicas no sub-app
apiRoutes.get('/', (c) => {
    return c.text('COMPIA API running on Supabase Edge Functions with Postgres Wrapper! Status: Online v2')
})

apiRoutes.get('/health', async (c) => {
    const dbUrl = Deno.env.get('SUPABASE_DB_URL');
    let dbStatus = 'unknown';
    let dbError = null;
    let orgAddresses = null;

    if (c.env?.DB) {
        try {
            await c.env.DB.prepare('SELECT 1').bind().first();
            dbStatus = 'connected';
        } catch (e) {
            dbStatus = 'error';
            dbError = e instanceof Error ? e.message : String(e);
        }
    } else {
        dbStatus = 'not_configured';
        dbError = !dbUrl ? 'Missing SUPABASE_DB_URL env var' : 'DB wrapper failed to initialize';
    }

    return c.json({
        status: dbStatus === 'connected' ? 'online' : 'degraded',
        database: dbStatus,
        db_error: dbError,
        timestamp: new Date().toISOString()
    }, dbStatus === 'connected' ? 200 : 503)
})

// SMOKE TEST ROUTE
apiRoutes.get('/smoke-test', (c) => {
    return c.json({
        status: 'alive',
        message: 'Routing is working',
        timestamp: new Date().toISOString()
    });
});

// --- SCALABLE LAZY LOADING ARCHITECTURE ---
const lazy = (importer: () => Promise<any>) => async (c: any) => {
    try {
        const { default: router } = await importer();
        // SAFE ACCESS: c.executionCtx throws if undefined in Hono
        let executionCtx = undefined;
        try {
            executionCtx = c.executionCtx;
        } catch { }

        return router.fetch(c.req.raw, c.env, executionCtx);
    } catch (e: any) {
        log.error(`Lazy Load Error (${c.req.path})`, e);
        return c.json({
            error: 'Lazy Load Crash',
            details: e.message,
            path: c.req.path,
            ...(isDev ? { stack: e.stack } : {})
        }, 500);
    }
};

// CHECKLIST ROUTING (Advanced Dispatch)
apiRoutes.all('/checklist/*', async (c) => {
    try {
        // Safe access to executionCtx (may not exist in Supabase Edge)
        let executionCtx = undefined;
        try {
            executionCtx = c.executionCtx;
        } catch { }

        if (c.req.path.includes('/checklist/folders') || c.req.path.includes('/checklist/migrate-categories') || c.req.path.includes('/checklist/tree')) {
            const { default: router } = await import('./checklist-folders-routes.ts');
            return router.fetch(c.req.raw, c.env, executionCtx);
        }
        const { default: router } = await import('./checklist-routes.ts');
        return router.fetch(c.req.raw, c.env, executionCtx);
    } catch (e: any) {
        log.error('LazyLoad Checklist Route Error', e);
        return c.json({ error: 'Lazy Load Error', details: e.message, ...(isDev ? { stack: e.stack } : {}) }, 500);
    }
});

const isDev = Deno.env.get('ENVIRONMENT') === 'development';

// DEBUG ROUTES (temporary for troubleshooting)
if (isDev) {
    apiRoutes.all('/debug/*', lazy(() => import('./debug-checklist.ts')));
}

// Explicit Lazy Routes
apiRoutes.all('/users', lazy(() => import('./users-routes.ts')));
apiRoutes.all('/users/*', lazy(() => import('./users-routes.ts')));
apiRoutes.all('/organizations/*', lazy(() => import('./organizations-routes.ts')));
apiRoutes.all('/inspections/*', lazy(() => import('./inspection-routes.ts')));
apiRoutes.all('/dashboard/*', lazy(() => import('./dashboard-routes.ts')));
apiRoutes.all('/auth/*', lazy(() => import('./auth-routes.ts')));
apiRoutes.all('/ai-assistants/*', lazy(() => import('./ai-assistants-routes.ts')));
apiRoutes.all('/share/*', lazy(() => import('./share-routes.ts')));
apiRoutes.all('/notifications/*', lazy(() => import('./notifications-routes.ts')));
apiRoutes.all('/test-email/*', lazy(() => import('./test-email-routes.ts'))); // Temporary test route
apiRoutes.all('/admin/*', lazy(() => import('./admin-approval-routes.ts')));
apiRoutes.all('/user-assignments/*', lazy(() => import('./user-assignment-routes.ts')));
apiRoutes.all('/multi-tenant/*', lazy(() => import('./multi-tenant-routes.ts')));
apiRoutes.all('/ai-usage/*', lazy(() => import('./ai-usage-routes.ts')));
apiRoutes.all('/system-admin/*', lazy(() => import('./system-admin-routes.ts')));
apiRoutes.all('/role-permissions/*', lazy(() => import('./role-permissions-routes.ts')));
apiRoutes.all('/cep/*', lazy(() => import('./cep-routes.ts')));
apiRoutes.all('/cnpj/*', lazy(() => import('./cnpj-routes.ts')));
apiRoutes.all('/inspection-items/*', lazy(() => import('./inspection-item-routes.ts')));
apiRoutes.all('/media/*', lazy(() => import('./media-routes.ts')));
apiRoutes.all('/gamification/*', lazy(() => import('./gamification-routes.ts')));
apiRoutes.all('/action-plans/*', lazy(() => import('./action-plans-routes.ts')));

// Alias action-items -> action-plans
apiRoutes.all('/action-items/*', async (c) => {
    try {
        // Safe access to executionCtx
        let executionCtx = undefined;
        try {
            executionCtx = c.executionCtx;
        } catch { }

        const { default: router } = await import('./action-plans-routes.ts');
        const newUrl = c.req.url.replace('/action-items', '/action-plans');
        const newReq = new Request(newUrl, c.req.raw);
        return router.fetch(newReq, c.env, executionCtx);
    } catch (e: any) {
        return c.json({ error: 'Lazy Load Error', details: e.message }, 500);
    }
});

apiRoutes.all('/autosuggest/*', lazy(() => import('./autosuggest-routes.ts')));
apiRoutes.all('/ai-assistant/*', lazy(() => import('./ai-assistant-routes.ts')));
apiRoutes.all('/kanban/*', lazy(() => import('./kanban-routes.ts')));
apiRoutes.all('/audit/*', lazy(() => import('./audit-routes.ts')));
apiRoutes.all('/calendar/*', lazy(() => import('./calendar-routes.ts')));
apiRoutes.all('/calendar-settings/*', lazy(() => import('./calendar-settings-routes.ts')));
apiRoutes.all('/calendar-upload/*', lazy(() => import('./calendar-upload-routes.ts')));
apiRoutes.all('/integrations/*', lazy(() => import('./integrations-routes.ts')));
apiRoutes.all('/crm/*', lazy(() => import('./crm-routes.ts')));
apiRoutes.all('/financial/*', lazy(() => import('./financial-routes.ts')));
apiRoutes.all('/billing/*', lazy(() => import('./financial-routes.ts'))); // Alias
apiRoutes.all('/webhooks/asaas/*', lazy(() => import('./asaas-webhook.ts')));
apiRoutes.all('/commerce/*', lazy(() => import('./checkout-flow-v2.ts')));
apiRoutes.all('/system-commerce/*', lazy(() => import('./system-plans-routes.ts')));
apiRoutes.all('/leads/*', lazy(() => import('./lead-capture.ts')));
apiRoutes.all('/test-orgs/*', lazy(() => import('./test-orgs.ts')));
apiRoutes.all('/test/*', lazy(() => import('./test-rls-routes.ts'))); // RLS Testing Routes

// PUBLIC ROUTES (Landing Page)
apiRoutes.get('/public-plans', async (c) => {
    try {
        const { results } = await c.env.DB.prepare("SELECT * FROM plans WHERE is_active = true AND is_public = true ORDER BY price_cents ASC").all();

        const plans = (results || []).map((p: any) => ({
            ...p,
            limits: typeof p.limits === 'string' ? JSON.parse(p.limits) : p.limits,
            features: typeof p.features === 'string' ? JSON.parse(p.features) : p.features,
            addon_config: typeof p.addon_config === 'string' ? JSON.parse(p.addon_config) : p.addon_config,
            is_active: Boolean(p.is_active),
            is_public: Boolean(p.is_public)
        }));

        return c.json({ plans });
    } catch (e: any) {
        return c.json({ error: e.message }, 500);
    }
});


// TEMPORARY DEBUG ROUTE
if (isDev) {
    apiRoutes.get('/debug-usage/:orgId', async (c) => {
        const orgId = c.req.param('orgId');
        try {
            // @ts-ignore
            const result = await c.env.DB.prepare('SELECT id, name, ai_usage_count FROM organizations WHERE id = ?').bind(orgId).first();
            return c.json(result || { error: 'Not found' });
        } catch (e: any) {
            return c.json({ error: e.message }, 500);
        }
    });
}

// App principal monta o sub-app em dois lugares:
app.route('/', apiRoutes);
app.route('/api', apiRoutes);

// Explicit mounts for critical routes to ensure they work at root level if needed
// Or simply rely on the default route. 
// Given the user wants "Conserte", cleaner is better.
// The /financial, /organizations explicit mounts are redundant if apiRoutes handles them.

Deno.serve(app.fetch)

===END_FILE===
===FILE: supabase/functions/api/inspection-item-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { incrementAiUsage } from "./ai-usage-tracker.ts";
import {
    getPreAnalysisPrompt,
    getActionPlanPrompt,
    SYSTEM_PROMPT_FIELD_RESPONSE
} from "./ai-prompts.ts";

type Env = {
    DB: any;
    MOCHA_USERS_SERVICE_API_URL: string;
    MOCHA_USERS_SERVICE_API_KEY: string;
    OPENAI_API_KEY: string;
    GOOGLE_CLIENT_ID: string;
    GEMINI_API_KEY: string;
};

const inspectionItemRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/inspection-items');

// Robust helper for AI Usage Increment
// incrementAiUsage moved to ai-usage-tracker.ts


// Get actions for specific inspection item
// Path: /api/inspection-items/:itemId/actions
inspectionItemRoutes.get("/:itemId/actions", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const itemId = parseInt(c.req.param("itemId"));

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        const item = await env.DB.prepare(`
      SELECT ii.*, i.created_by, i.organization_id
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
    `).bind(itemId).first() as any;

        if (!item) {
            return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado", actions: [] }, 200);
        }

        const actions = await env.DB.prepare(`
      SELECT * FROM action_items 
      WHERE inspection_item_id = ?
      ORDER BY created_at DESC
    `).bind(itemId).all();

        return c.json({
            actions: actions.results || []
        });

    } catch (error) {
        console.error('Error fetching item actions:', error);
        return c.json({ error: "Erro ao buscar aÃ§Ãµes", actions: [] }, 200);
    }
});

// Pre-analysis with AI - POST
inspectionItemRoutes.post("/:itemId/pre-analysis", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const itemId = parseInt(c.req.param("itemId"));

    // Gemini API Key - Security Best Practice
    const GEMINI_API_KEY = c.req.header('x-gemini-key') || c.env.GEMINI_API_KEY;

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        const body = await c.req.json();
        const { field_name, response_value, user_prompt, inspection_id } = body;
        let { media_data } = body;

        // Increment AI Usage MOVED to after response to capture token count
        const userId = user.id || (user as any).sub;


        // Fetch Item
        let item = await env.DB.prepare(`
            SELECT ii.*, i.location, i.company_name, i.title as inspection_title
            FROM inspection_items ii
            JOIN inspections i ON ii.inspection_id = i.id
            WHERE ii.id = ?
        `).bind(itemId).first() as any;

        if (!item && inspection_id && field_name) {
            item = await env.DB.prepare(`
                SELECT ii.*, i.location, i.company_name, i.title as inspection_title
                FROM inspection_items ii
                JOIN inspections i ON ii.inspection_id = i.id
                WHERE ii.inspection_id = ? AND ii.item_description = ?
            `).bind(inspection_id, field_name).first() as any;
        }

        if (!item) {
            return c.json({ success: true, analysis: "Erro: Item de inspeÃ§Ã£o nÃ£o encontrado." });
        }

        let mediaContext = '';
        const geminiParts: any[] = [];
        const mediaCounts = { image: 0, audio: 0, document: 0 };
        let warningMsg = '';

        if (media_data && media_data.length > 0) {
            // LIMIT MAX FILES (5) to prevent timeout/OOM
            if (media_data.length > 5) {
                warningMsg = `(Analisando apenas as 5 primeiras mÃ­dias de ${media_data.length})`;
                media_data = media_data.slice(0, 5);
            }

            console.log(`[PRE-ANALYSIS] Processing ${media_data.length} media items`);

            const mediaPromises = media_data.map(async (media: any) => {
                try {
                    let mimeType = 'application/octet-stream';
                    let category = 'other';

                    if (media.media_type === 'image') {
                        mimeType = media.mime_type || 'image/jpeg';
                        category = 'image';
                    } else if (media.media_type === 'audio') {
                        mimeType = media.mime_type || 'audio/mp3';
                        if (mimeType.includes('webm')) mimeType = 'audio/mp3'; // Gemini hint
                        category = 'audio';
                    } else if (media.file_name?.toLowerCase().endsWith('.pdf')) {
                        mimeType = 'application/pdf';
                        category = 'document';
                    } else {
                        return null; // Skip unsupported
                    }

                    // Get/Fetch Data
                    let base64Data = media.file_data;
                    if (!base64Data && media.file_url) {
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 3000); // 3s Timeout
                            const fetchRes = await globalThis.fetch(media.file_url, { signal: controller.signal });
                            clearTimeout(timeoutId);

                            if (fetchRes.ok) {
                                const arrBuf = await fetchRes.arrayBuffer();
                                const bytes = new Uint8Array(arrBuf);

                                // SIZE LIMIT: 2.5MB per file
                                if (bytes.byteLength > 2.5 * 1024 * 1024) {
                                    console.warn(`Skipping large file: ${media.file_name}`);
                                    return null;
                                }

                                // Chunked conversion
                                let binary = '';
                                const CHUNK_SIZE = 8192;
                                for (let i = 0; i < bytes.byteLength; i += CHUNK_SIZE) {
                                    binary += String.fromCharCode(...bytes.subarray(i, i + CHUNK_SIZE));
                                }
                                base64Data = btoa(binary);

                                const hMime = fetchRes.headers.get('content-type');
                                if (hMime && !media.mime_type) mimeType = hMime;
                            }
                        } catch (err) { console.error('Fetch error:', err); return null; }
                    } else if (base64Data?.includes(',')) {
                        base64Data = base64Data.split(',')[1];
                    }

                    if (base64Data) {
                        return { inlineData: { mimeType, data: base64Data }, category };
                    }
                    return null;
                } catch (e) { return null; }
            });

            const results = await Promise.all(mediaPromises);
            results.forEach(res => {
                if (res) {
                    geminiParts.push({ inlineData: res.inlineData });
                    if (res.category === 'image') mediaCounts.image++;
                    if (res.category === 'audio') mediaCounts.audio++;
                    if (res.category === 'document') mediaCounts.document++;
                }
            });

            mediaContext = `MÃDIAS: ${mediaCounts.image} Img, ${mediaCounts.audio} Ãudios, ${mediaCounts.document} Docs. ${warningMsg}`;
        } else {
            mediaContext = "Sem mÃ­dias.";
        }

        const promptText = getPreAnalysisPrompt(
            field_name,
            response_value === false ? 'NÃƒO CONFORME' : 'CONFORME',
            item.location,
            mediaContext,
            user_prompt
        );

        geminiParts.push({ text: promptText });

        if (!GEMINI_API_KEY) throw new Error("API Key Gemini nÃ£o configurada.");

        // Retry multiple models if one fails
        // Retry multiple models and API versions (Updated for 2026 Availability)
        const attempts = [
            { model: 'gemini-2.5-flash', version: 'v1beta' },
            { model: 'gemini-2.5-pro', version: 'v1beta' },
            { model: 'gemini-2.0-flash', version: 'v1beta' },
            { model: 'gemini-flash-latest', version: 'v1beta' },
            { model: 'gemini-pro-latest', version: 'v1beta' }
        ];

        let geminiResponse: Response | null = null;
        let modelUsed = '';
        let fallbackTextOnly = false;
        let lastErrorDetail = "";

        for (const attempt of attempts) {
            try {
                const url = `https://generativelanguage.googleapis.com/${attempt.version}/models/${attempt.model}:generateContent?key=${GEMINI_API_KEY}`;
                const resp = await globalThis.fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: geminiParts }],
                        generationConfig: { maxOutputTokens: 2500, temperature: 0.35 }
                    })
                });

                if (resp.ok) {
                    geminiResponse = resp;
                    modelUsed = `${attempt.model} (${attempt.version})`;
                    break;
                } else {
                    const status = resp.status;
                    const errText = await resp.text();
                    // Accumulate errors instead of overwriting
                    lastErrorDetail += ` | [${attempt.model}:${attempt.version}] ${status}`;

                    if (status === 404 || status === 503 || status === 400) continue;
                    console.warn(`Model error: ${lastErrorDetail}`);
                }
            } catch (e: any) {
                lastErrorDetail += ` | [${attempt.model}] Ex: ${e.message}`;
                continue;
            }
        }

        // Final Fallback: Text Only (if all multimodal failed)
        if (!geminiResponse) {
            console.warn("[PRE-ANALYSIS] Multimodal failed. Trying Text-Only Fallback.");
            fallbackTextOnly = true;
            // Remove images/audio, keep only text
            const textParts = geminiParts.filter(p => p.text);
            textParts.push({ text: "\n[ALERTA: Analise apenas o contexto de texto acima. As mÃ­dias falharam no processamento devido a restriÃ§Ãµes tÃ©cnicas da API.]" });

            try {
                const resp = await globalThis.fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: textParts }] })
                });
                if (resp.ok) {
                    geminiResponse = resp;
                } else {
                    lastErrorDetail += ` | [Fallback Text] ${resp.status}: ${await resp.text()}`;
                }
            } catch (e: any) { lastErrorDetail += ` | [Fallback Exception] ${e.message}`; }
        }

        if (!geminiResponse) {
            throw new Error(`Falha Geral na IA. Detalhes: ${lastErrorDetail.substring(0, 200)}`);
        }
        let cleanAnalysis = '';
        // Use non-null assertion (!) because we threw error above if it was null
        if (geminiResponse!.ok) {
            const result = await geminiResponse!.json();
            cleanAnalysis = result.candidates?.[0]?.content?.parts?.[0]?.text || "Erro: Resposta vazia da IA.";
        } else {
            const errBody = await geminiResponse!.text();
            throw new Error(`Erro Gemini (${geminiResponse!.status}): ${errBody.substring(0, 100)}...`);
        }

        cleanAnalysis = cleanAnalysis.replace(/\*\*/g, '').replace(/#{1,6}\s/g, '').trim();
        if (warningMsg) cleanAnalysis += `\n\n${warningMsg}`;

        // Update DB
        const now = new Date().toISOString();
        await env.DB.prepare("UPDATE inspection_items SET ai_pre_analysis = ?, updated_at = ? WHERE id = ?").bind(cleanAnalysis, now, itemId).run();

        // Extract Token Usage (Gemini)
        const usageMetadata = (geminiResponse as any).usageMetadata || {};
        const totalTokens = usageMetadata.totalTokenCount || 0;

        // Log AI Usage with actual tokens
        await incrementAiUsage(env.DB, userId, 'pre_analysis', modelUsed || 'gemini-1.5-flash', totalTokens);

        return c.json({
            success: true,
            analysis: cleanAnalysis,
            pre_analysis: cleanAnalysis,
            media_stats: mediaCounts,
            _trace: 'v4-robust-return200'
        });

    } catch (error: any) {
        console.error('PRE-ANALYSIS ERROR:', error);
        // RETURN 200 to show error in frontend
        return c.json({
            success: true,
            analysis: `[Erro TÃ©cnico]: ${error.message || "Erro desconhecido"}.`,
            pre_analysis: `[Erro TÃ©cnico]: ${error.message || "Erro desconhecido"}.`
        });
    }
});

// Delete pre-analysis
inspectionItemRoutes.delete("/:itemId/pre-analysis", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const itemId = parseInt(c.req.param("itemId"));

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        const now = new Date().toISOString();
        await env.DB.prepare(`
      UPDATE inspection_items 
      SET ai_pre_analysis = NULL, updated_at = ?
      WHERE id = ?
    `).bind(now, itemId).run();

        return c.json({
            success: true,
            message: "PrÃ©-anÃ¡lise removida com sucesso"
        });

    } catch (error) {
        console.error('Error deleting pre-analysis:', error);
        return c.json({ error: "Erro ao remover prÃ©-anÃ¡lise" }, 500);
    }
});

// Update pre-analysis (manual edit)
inspectionItemRoutes.put("/:itemId/analysis", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const itemId = parseInt(c.req.param("itemId"));

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        const body = await c.req.json();
        const { analysis } = body;

        const now = new Date().toISOString();
        await env.DB.prepare(`
      UPDATE inspection_items 
      SET ai_pre_analysis = ?, updated_at = ?
      WHERE id = ?
    `).bind(analysis, now, itemId).run();

        return c.json({
            success: true,
            message: "AnÃ¡lise atualizada com sucesso",
            analysis: analysis
        });

    } catch (error) {
        console.error('Error updating analysis:', error);
        return c.json({ error: "Erro ao atualizar anÃ¡lise" }, 500);
    }
});

// Create action for inspection item
inspectionItemRoutes.post("/:itemId/create-action", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const itemId = parseInt(c.req.param("itemId"));

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    if (!env.OPENAI_API_KEY) {
        return c.json({ error: "IA nÃ£o disponÃ­vel" }, 503);
    }

    try {
        const body = await c.req.json();
        const { field_name, field_type, response_value, comment, compliance_status, pre_analysis, media_data, inspection_id } = body;

        // Increment AI Usage MOVED to after response
        const userId = user.id || (user as any).sub;


        // First, try to find by itemId (direct ID)
        let item = await env.DB.prepare(`
      SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
    `).bind(itemId).first() as any;

        // Fallback 1: If not found and we have inspection_id + field_name, search by exact match
        if (!item && inspection_id && field_name) {
            item = await env.DB.prepare(`
                SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id
                FROM inspection_items ii
                JOIN inspections i ON ii.inspection_id = i.id
                WHERE ii.inspection_id = ? AND ii.item_description = ?
            `).bind(inspection_id, field_name).first() as any;
        }

        // Fallback 2: Search with LIKE (partial match) for flexibility
        if (!item && inspection_id && field_name) {
            item = await env.DB.prepare(`
                SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id
                FROM inspection_items ii
                JOIN inspections i ON ii.inspection_id = i.id
                WHERE ii.inspection_id = ? AND LOWER(ii.item_description) LIKE LOWER(?)
                LIMIT 1
            `).bind(inspection_id, `%${field_name}%`).first() as any;
        }

        // Fallback 3: Try to match by field order if itemId looks like a template field id
        if (!item && inspection_id && itemId > 100) {
            // The itemId might be a template field ID, try to find by position
            const items = await env.DB.prepare(`
                SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id
                FROM inspection_items ii
                JOIN inspections i ON ii.inspection_id = i.id
                WHERE ii.inspection_id = ?
                ORDER BY ii.id
            `).bind(inspection_id).all();

            // Log for debugging
            console.log(`[CREATE-ACTION] Searching for template field ${itemId} in inspection ${inspection_id}, found ${items.results?.length || 0} items`);

            // If we have items, use the first one that matches field_name loosely
            if (items.results && items.results.length > 0 && field_name) {
                item = items.results.find((i: any) =>
                    i.item_description?.toLowerCase().includes(field_name.toLowerCase().substring(0, 10))
                ) || items.results[0];
            }
        }

        if (!item) {
            console.error('[CREATE-ACTION] Item not found:', { itemId, inspection_id, field_name });
            return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado", details: { itemId, inspection_id, field_name } }, 404);
        }

        // Determinar se precisa de aÃ§Ã£o baseado na resposta
        let needsAction = false;
        let riskLevel = 'baixo';

        // ForÃ§ar "needsAction" se a resposta for negativa
        if (field_type === 'boolean' && response_value === false) {
            needsAction = true;
            riskLevel = 'alto';
        } else if (field_type === 'rating' && response_value <= 2) {
            needsAction = true;
            riskLevel = response_value === 1 ? 'critico' : 'alto';
        }

        // Se jÃ¡ sabemos que precisa de aÃ§Ã£o (NÃ£o Conforme), incluÃ­mos isso explicitamente no prompt
        const complianceStatus = needsAction ? 'NÃƒO CONFORME (ObrigatÃ³rio gerar plano de aÃ§Ã£o)' : 'Em anÃ¡lise (Verificar necessidade)';

        const prompt = getActionPlanPrompt(
            item.company_name,
            item.location,
            item.inspection_title,
            field_name,
            response_value === false ? 'NÃƒO CONFORME' : response_value === true ? 'CONFORME' : response_value || 'NÃ£o informado',
            comment || 'Nenhuma observaÃ§Ã£o',
            compliance_status === 'non_compliant' ? 'NÃƒO CONFORME' : compliance_status === 'compliant' ? 'CONFORME' : complianceStatus,
            pre_analysis || 'Nenhuma observaÃ§Ã£o prÃ©via',
            riskLevel
        );

        const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'gpt-4o', // Upgrade to gpt-4o for better logic
                messages: [
                    { role: 'system', content: 'VocÃª Ã© um especialista sÃªnior em seguranÃ§a do trabalho. Seja rigoroso na anÃ¡lise de riscos.' },
                    { role: 'user', content: prompt }
                ],
                max_tokens: 1000,
                temperature: 0.2 // Lower component for more deterministic following of instructions
            })
        });

        if (!openaiResponse.ok) {
            throw new Error(`Erro na API: ${openaiResponse.status}`);
        }

        const responseText = await openaiResponse.text();
        const openaiResult = JSON.parse(responseText);
        const actionText = openaiResult.choices?.[0]?.message?.content || '';

        let actionData;
        try {
            const jsonMatch = actionText.match(/\{[\s\S]*\}/);
            actionData = jsonMatch ? JSON.parse(jsonMatch[0]) : { requires_action: false };
        } catch {
            actionData = { requires_action: false, error: "NÃ£o foi possÃ­vel processar resposta" };
        }

        let actionItemId = null;
        let deadline: Date | null = null;

        if (actionData.requires_action) {
            const now = new Date().toISOString();
            deadline = new Date();
            deadline.setDate(deadline.getDate() + (actionData.priority === 'critica' ? 7 : actionData.priority === 'alta' ? 14 : 30));

            const insertResult = await env.DB.prepare(`
        INSERT INTO action_items (
          inspection_id, inspection_item_id, title,
          what_description, why_reason, where_location, when_deadline, who_responsible,
          how_method, how_much_cost, priority, status, is_ai_generated, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', true, ?, ?)
        RETURNING id
      `).bind(
                item.inspection_id,
                item.id, // Use the correct item.id from database lookup, not the URL parameter
                field_name,
                actionData.what || '',
                actionData.why || '',
                actionData.where || item.location,
                deadline.toISOString().split('T')[0],
                actionData.who || 'A definir',
                actionData.how || '',
                actionData.how_much || 'A orÃ§ar',
                actionData.priority || 'media',
                now,
                now
            ).first() as any;

            actionItemId = insertResult?.id || null;
        }

        // Always return suggestion data for inline display, even if not saved
        const finalAction = {
            id: actionItemId || null,
            title: field_name,
            what_description: actionData.what || '',
            why_description: actionData.why || '',
            why_reason: actionData.why || '',
            where_description: actionData.where || item.location,
            where_location: actionData.where || item.location,
            when_deadline: deadline?.toISOString().split('T')[0] || null,
            who_responsible: actionData.who || 'A definir',
            how_description: actionData.how || '',
            how_method: actionData.how || '',
            how_much_cost: actionData.how_much || 'A orÃ§ar',
            priority: actionData.priority || 'media',
            status: actionItemId ? 'pending' : 'suggested',
            is_ai_generated: true,
            requires_action: actionData.requires_action,
            justification: actionData.justification || ''
        };

        const usageData = (openaiResult as any).usage || {};
        const totalTokens = usageData.total_tokens || 0;

        // Log AI Usage with actual tokens
        const usageResult = await incrementAiUsage(env.DB, userId, 'action_plan', 'gpt-4o', totalTokens);

        const debugUsage = usageResult.success ? { success: true, org_id: usageResult.debug_org_id } : { success: false, error: usageResult.error };
        const usageIncremented = usageResult.success;

        return c.json({
            success: true,
            action_item: actionData.requires_action ? finalAction : null,
            analysis: actionText,
            raw_response: actionText,
            ai_usage_incremented: usageIncremented,
            debug_usage: debugUsage
        });

    } catch (error) {
        console.error('Error creating action:', error);

        const errorMessage = error instanceof Error ? error.message : "Erro desconhecido";
        let userMessage = "Erro ao criar aÃ§Ã£o com IA";
        let status = 500;

        if (errorMessage.includes('401')) {
            userMessage = "Chave OpenAI InvÃ¡lida ou Expirada (401)";
            status = 502; // Bad Gateway
        } else if (errorMessage.includes('429')) {
            userMessage = "Limite de cota da OpenAI atingido (429)";
            status = 429;
        } else if (errorMessage.includes('503')) {
            userMessage = "ServiÃ§o OpenAI IndisponÃ­vel (503)";
            status = 503;
        } else {
            // Include raw error for debugging 500s
            userMessage = `Erro interno: ${errorMessage}`;
        }

        return c.json({
            error: userMessage,
            details: errorMessage
        }, status as any); // cast for Hono/TS
    }
});

// Delete inspection item
inspectionItemRoutes.delete("/:itemId", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const itemId = parseInt(c.req.param("itemId"));

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    try {
        // Basic permission check - ensure item exists
        const item = await env.DB.prepare(`
            SELECT ii.*, i.organization_id, i.created_by 
            FROM inspection_items ii
            JOIN inspections i ON ii.inspection_id = i.id
            WHERE ii.id = ?
        `).bind(itemId).first() as any;

        if (!item) {
            return c.json({ error: "Item n\u00E3o encontrado" }, 404);
        }

        // Verify if user has permission (same organization or sys admin)
        // Assuming tenantAuthMiddleware handles basic tenant check via secureOrgId context if applicable
        // But double checking logic:
        // if (item.organization_id !== user.organization_id && user.role !== 'sys_admin') ...

        await env.DB.prepare("DELETE FROM inspection_items WHERE id = ?").bind(itemId).run();

        return c.json({ success: true });
    } catch (error) {
        console.error('Error deleting item:', error);
        return c.json({ error: "Erro ao excluir item" }, 500);
    }
});

// Generate field response with AI for inspection items
inspectionItemRoutes.post("/:itemId/generate-field-response", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const itemId = parseInt(c.req.param("itemId"));

    if (!user) {
        return c.json({ error: "User not found" }, 401);
    }

    if (!env.OPENAI_API_KEY) {
        return c.json({ error: "IA nÃ£o disponÃ­vel" }, 503);
    }

    try {
        const body = await c.req.json();
        const { field_name, field_type, current_response, media_data, field_options } = body;

        // Increment AI Usage MOVED to after response
        const userId = user.id || (user as any).sub;


        // Get inspection item and context
        const item = await env.DB.prepare(`
      SELECT ii.*, i.location, i.company_name, i.title as inspection_title
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
  `).bind(itemId).first() as any;

        if (!item) {
            return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
        }

        // Parse field options
        let availableOptions: string[] = [];
        if (field_options) {
            try {
                if (typeof field_options === 'string' && field_options.startsWith('[')) {
                    availableOptions = JSON.parse(field_options);
                } else if (typeof field_options === 'string') {
                    availableOptions = field_options.split('|').map(opt => opt.trim()).filter(opt => opt);
                } else if (Array.isArray(field_options)) {
                    availableOptions = field_options;
                }
            } catch (error) {
                console.error('Error parsing field options:', error);
            }
        }

        // CORRIGIDO: Preparar anÃ¡lise multimodal real das evidÃªncias  
        let mediaAnalysisContent = '';
        let mediaAnalyzed = 0;
        let mediaAnalysisMessages = [];

        if (media_data && media_data.length > 0) {
            mediaAnalyzed = media_data.length;
            const mediaTypes = media_data.reduce((acc: any, media: any) => {
                acc[media.media_type] = (acc[media.media_type] || 0) + 1;
                return acc;
            }, {});

            mediaAnalysisContent = `EVIDÃŠNCIAS MULTIMODAIS PARA ANÃLISE: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} Ã¡udio(s), ${mediaTypes.video || 0} vÃ­deo(s), ${mediaTypes.pdf || mediaTypes.document || 0} documento(s) PDF.`;

            // Preparar imagens para anÃ¡lise visual (mÃ¡ximo 3 para evitar timeout)
            const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);
            for (const img of imageMedia) {
                if (img.file_url) {
                    mediaAnalysisMessages.push({
                        type: "image_url",
                        image_url: {
                            url: img.file_url,
                            detail: "high" // Para anÃ¡lise detalhada mesmo com gpt-4o-mini
                        }
                    });
                }
            }

            // Adicionar nomes dos arquivos PDF ao contexto
            const pdfMedia = media_data.filter((m: any) => m.media_type === 'pdf' || m.media_type === 'document');
            if (pdfMedia.length > 0) {
                const pdfNames = pdfMedia.map((p: any) => p.file_name || 'Documento sem nome').join(', ');
                mediaAnalysisContent += `\nDOCUMENTOS PDF ANEXADOS: ${pdfNames}. A IA deve mencionar que estÃ¡ ciente destes documentos na resposta e usar seu conteÃºdo se o usuÃ¡rio fornecer contexto sobre eles.`;
            }

            // Adicionar descriÃ§Ã£o de Ã¡udios/vÃ­deos se existirem
            const audioCount = mediaTypes.audio || 0;
            const videoCount = mediaTypes.video || 0;
            if (audioCount > 0 || videoCount > 0) {
                mediaAnalysisContent += ` Inclui ${audioCount} Ã¡udio(s) e ${videoCount} vÃ­deo(s) que podem conter evidÃªncias sonoras importantes.IMPORTANTE: PeÃ§a para o usuÃ¡rio descrever o conteÃºdo dos Ã¡udios no prompt personalizado para anÃ¡lise completa.`;
            }
        } else {
            mediaAnalysisContent = `EVIDÃŠNCIAS DISPONÃVEIS: Nenhuma mÃ­dia anexada.Resposta baseada no contexto da inspeÃ§Ã£o e conhecimento tÃ©cnico.`;
        }

        // Create specialized prompt based on field type
        let responseInstructions = '';
        switch (field_type) {
            case 'boolean':
                responseInstructions = `
RESPOSTA ESPERADA: true(Conforme) ou false(NÃ£o Conforme)
CRITÃ‰RIO: Avalie se o item estÃ¡ em conformidade com as normas de seguranÃ§a baseado nas evidÃªncias visuais / sonoras.`;
                break;
            case 'select':
            case 'radio':
                if (availableOptions.length > 0) {
                    responseInstructions = `
RESPOSTA ESPERADA: Uma das opÃ§Ãµes disponÃ­veis: ${availableOptions.join(', ')}
CRITÃ‰RIO: Escolha a opÃ§Ã£o que melhor descreve o que foi observado nas evidÃªncias.`;
                } else {
                    responseInstructions = `
RESPOSTA ESPERADA: Uma descriÃ§Ã£o textual da condiÃ§Ã£o observada nas evidÃªncias.`;
                }
                break;
            case 'multiselect':
                if (availableOptions.length > 0) {
                    responseInstructions = `
RESPOSTA ESPERADA: Array com uma ou mais opÃ§Ãµes: ${availableOptions.join(', ')}
CRITÃ‰RIO: Selecione todas as opÃ§Ãµes que se aplicam ao que foi observado.`;
                }
                break;
            case 'rating':
                responseInstructions = `
RESPOSTA ESPERADA: NÃºmero de 1 a 5(1 = Inadequado, 5 = Excelente)
CRITÃ‰RIO: Avalie baseado no que foi observado nas evidÃªncias visuais / sonoras.`;
                break;
            case 'text':
            case 'textarea':
                responseInstructions = `
RESPOSTA ESPERADA: DescriÃ§Ã£o textual detalhada
CRITÃ‰RIO: Descreva especificamente o que foi observado nas evidÃªncias de forma tÃ©cnica.`;
                break;
            default:
                responseInstructions = `
RESPOSTA ESPERADA: Valor adequado baseado na anÃ¡lise das evidÃªncias disponÃ­veis.`;
        }

        // Construir mensagens para OpenAI incluindo anÃ¡lise visual detalhada
        const systemMessage = {
            role: 'system',
            content: SYSTEM_PROMPT_FIELD_RESPONSE
        };

        const userMessage = {
            role: 'user',
            content: [
                {
                    type: "text",
                    text: `Analise as evidÃªncias multimodais e gere uma resposta tÃ©cnica detalhada para este campo.
CONEXO DA INSPEÃ‡ÃƒO:
- Local: ${item.location}
- Empresa: ${item.company_name}
- InspeÃ§Ã£o: ${item.inspection_title}

ITEM EM ANÃLISE:
- Campo: ${field_name}
- Categoria: ${item.category}
- DescriÃ§Ã£o: ${item.item_description}
- ObservaÃ§Ãµes existentes: ${item.observations || 'Nenhuma'}
- Resposta atual: ${current_response !== null && current_response !== undefined ? current_response : 'NÃ£o respondido'}

${mediaAnalysisContent}

${responseInstructions}

INSTRUÃ‡Ã•ES ESPECÃFICAS PARA ANÃLISE DETALHADA:
1. ** ANÃLISE VISUAL(se houver imagens) **: Descreva especificamente o que vÃª nas imagens relacionado Ã  seguranÃ§a do trabalho:
  - CondiÃ§Ãµes dos equipamentos, estruturas, ambiente
    - EPIs(Equipamentos de ProteÃ§Ã£o Individual) presentes ou ausentes
      - SinalizaÃ§Ãµes de seguranÃ§a, placas, avisos
        - CondiÃ§Ãµes de limpeza, organizaÃ§Ã£o, 5S
          - Riscos visuais identificados(altura, energia, produtos quÃ­micos, etc.)
            - Estado de conservaÃ§Ã£o de materiais, ferramentas, instalaÃ§Ãµes

2. ** ANÃLISE SONORA(se houver Ã¡udios / vÃ­deos) **:
- RuÃ­dos de mÃ¡quinas, equipamentos(nÃ­veis, anormalidades)
  - ComunicaÃ§Ãµes verbais sobre seguranÃ§a
    - Sons que indicam riscos(vazamentos, falhas mecÃ¢nicas)
      - Para assistentes psicossociais: tom de voz, sinais de estresse, ansiedade

3. ** CONFORMIDADE TÃ‰CNICA **: Avalie conformidade com NRs aplicÃ¡veis
4. ** EVIDÃŠNCIAS ESPECÃFICAS **: Cite detalhes visuais / sonoros concretos observados
5. ** RECOMENDAÃ‡Ã•ES **: Base nas evidÃªncias analisadas

Responda APENAS em formato JSON(mÃ¡ximo 400 caracteres no comentÃ¡rio):
{
  "generated_response": <valor_da_resposta>,
    "generated_comment": "AnÃ¡lise tÃ©cnica detalhada baseada nas evidÃªncias visuais/sonoras observadas. Descreva especificamente o que foi visto/ouvido.",
      "confidence": "alta|media|baixa",
        "media_analyzed": ${mediaAnalyzed},
  "visual_observations": "DescriÃ§Ã£o especÃ­fica do que foi visto nas imagens - condiÃ§Ãµes, EPIs, riscos, conformidade visual",
    "technical_assessment": "AvaliaÃ§Ã£o de conformidade tÃ©cnica baseada nas evidÃªncias"
}

Seja especÃ­fico sobre as evidÃªncias analisadas e cite detalhes visuais / sonoros concretos.`
                },
                ...mediaAnalysisMessages
            ]
        };

        const messages = [systemMessage, userMessage];

        // CORRIGIDO: Call OpenAI API com anÃ¡lise multimodal
        const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${env.OPENAI_API_KEY} `,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'gpt-4o-mini', // MudanÃ§a solicitada para gpt-4o-mini
                messages: messages,
                max_tokens: 2000, // Aumentado para anÃ¡lise mais detalhada
                temperature: 0.3 // Reduzido para mais consistÃªncia
            })
        });

        if (!openaiResponse.ok) {
            const errorText = await openaiResponse.text();
            console.error('OpenAI API Error:', openaiResponse.status, errorText);
            throw new Error(`Erro na API da OpenAI: ${openaiResponse.status} - ${errorText} `);
        }

        const openaiResult = await openaiResponse.json() as any;
        const content = openaiResult.choices?.[0]?.message?.content;

        if (!content) {
            throw new Error('Resposta invÃ¡lida da IA');
        }

        // Parse AI response
        let aiResult;
        try {
            aiResult = JSON.parse(content);
        } catch (parseError) {
            // Try to extract JSON from the response
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                aiResult = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('Falha ao parsear resposta da IA como JSON');
            }
        }

        // Validate and clean response based on field type
        let finalResponse = aiResult.generated_response;

        if (field_type === 'boolean') {
            if (typeof finalResponse === 'string') {
                finalResponse = finalResponse.toLowerCase() === 'true' || finalResponse === '1';
            } else if (typeof finalResponse !== 'boolean') {
                finalResponse = null;
            }
        } else if (field_type === 'multiselect') {
            if (!Array.isArray(finalResponse)) {
                if (typeof finalResponse === 'string') {
                    finalResponse = [finalResponse];
                } else {
                    finalResponse = [];
                }
            }
            // Filter to only valid options if available
            if (availableOptions.length > 0) {
                finalResponse = finalResponse.filter((opt: string) => availableOptions.includes(opt));
            }
        } else if ((field_type === 'select' || field_type === 'radio') && availableOptions.length > 0) {
            // Ensure response is one of the available options
            if (!availableOptions.includes(finalResponse)) {
                finalResponse = availableOptions[0]; // Default to first option
            }
        } else if (field_type === 'rating') {
            const numResponse = parseInt(finalResponse);
            if (isNaN(numResponse) || numResponse < 1 || numResponse > 5) {
                finalResponse = 3; // Default to middle rating
            } else {
                finalResponse = numResponse;
            }
        }

        // Validar: OpenAI Usage Extraction
        const usageData = (openaiResult as any).usage || {};
        const totalTokens = usageData.total_tokens || 0;

        // Log AI Usage
        const usageResult = await incrementAiUsage(env.DB, userId, 'field_response', 'gpt-4o-mini', totalTokens);
        const usageIncremented = usageResult.success;

        return c.json({
            success: true,
            generated_response: finalResponse,
            generated_comment: aiResult.generated_comment || '',
            confidence: aiResult.confidence || 'media',
            media_analyzed: mediaAnalyzed,
            item_id: itemId,
            timestamp: new Date().toISOString(),
            ai_usage_incremented: usageIncremented
        });

    } catch (error) {
        console.error('Error generating field response:', error);
        return c.json({
            error: "Erro ao gerar resposta do campo",
            details: error instanceof Error ? error.message : "Erro desconhecido"
        }, 500);
    }
});

// Generate comprehensive action plan (5W2H) for inspection item
inspectionItemRoutes.post("/:itemId/generate-action-plan", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const itemId = parseInt(c.req.param("itemId"));

    if (!user) return c.json({ error: "User not found" }, 401);
    if (!env.OPENAI_API_KEY) return c.json({ error: "IA nÃ£o disponÃ­vel" }, 503);

    try {
        const body = await c.req.json();
        const { field_name, response_value, media_data, user_prompt } = body;

        const item = await env.DB.prepare(`
      SELECT ii.*, i.location, i.company_name, i.title as inspection_title
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
    `).bind(itemId).first() as any;

        if (!item) return c.json({ error: "Item nÃ£o encontrado" }, 404);

        let mediaContext = '';
        let mediaAnalysisMessages = [];

        if (media_data && media_data.length > 0) {
            mediaContext = `EVIDÃŠNCIAS MULTIMODAIS: ${media_data.length} arquivos analisados.`;

            // Add PDF context
            const pdfMedia = media_data.filter((m: any) => m.media_type === 'pdf' || m.media_type === 'document');
            if (pdfMedia.length > 0) {
                const pdfNames = pdfMedia.map((p: any) => p.file_name).join(', ');
                mediaContext += ` DOCUMENTOS PDF: ${pdfNames}`;
            }

            // Process images for GPT-4o-mini
            const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);
            for (const img of imageMedia) {
                if (img.file_url) {
                    mediaAnalysisMessages.push({
                        type: "image_url",
                        image_url: { url: img.file_url, detail: "high" }
                    });
                }
            }
        }

        const systemMessage = {
            role: 'system',
            content: 'VocÃª Ã© um especialista em seguranÃ§a do trabalho. Gere um plano de aÃ§Ã£o 5W2H detalhado e prÃ¡tico em formato JSON.'
        };

        const userContent = `Gere um plano de aÃ§Ã£o 5W2H tÃ©cnico para a nÃ£o conformidade detectada.
    
    CONTEXTO:
    - Item: ${item.item_description} (Local: ${item.location})
    - Resposta Encontrada: ${response_value}
- Prompt UsuÃ¡rio: ${user_prompt || 'Gere aÃ§Ã£o corretiva padrÃ£o'}
    
    ${mediaContext}
    
    Retorne JSON:
{
    "requires_action": true,
        "what": "O que fazer",
            "why": "Por que (Norma/Risco)",
                "where": "Local exato",
                    "when": "Prazo",
                        "who": "ResponsÃ¡vel",
                            "how": "Como fazer",
                                "how_much": "Custo estimado",
                                    "priority": "alta/media/baixa"
} `;

        // Construct message array effectively
        const messages = [
            systemMessage,
            {
                role: 'user',
                content: [
                    { type: "text", text: userContent },
                    ...mediaAnalysisMessages
                ]
            }
        ];

        const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${env.OPENAI_API_KEY} `,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'gpt-4o-mini',
                messages: messages,
                max_tokens: 1500,
                temperature: 0.3
            })
        });

        if (!openaiResponse.ok) throw new Error('Erro na API OpenAI');

        const resJson = await openaiResponse.json();
        const content = resJson.choices?.[0]?.message?.content;
        let actionPlan = JSON.parse(content.replace(/```json/g, '').replace(/```/g, '').trim());

        // Log AI Usage
        const usageData = (resJson as any).usage || {};
        const totalTokens = usageData.total_tokens || 0;
        await incrementAiUsage(env.DB, user.id, 'action_plan_5w2h', 'gpt-4o-mini', totalTokens);

        // Validate and Insert into DB
        if (actionPlan.requires_action) {
            try {
                const now = new Date().toISOString();

                // Try to parse deadline or default to 7 days
                let deadline = new Date();
                deadline.setDate(deadline.getDate() + 7);
                const deadlineStr = actionPlan.when || deadline.toISOString();

                const insertResult = await env.DB.prepare(`
                    INSERT INTO action_items (
                        inspection_id, inspection_item_id, 
                        title, what_description, why_reason, where_location, 
                        who_responsible, when_deadline, how_method, how_much_cost,
                        priority, status, is_ai_generated, created_by, organization_id,
                        created_at, updated_at
                    ) VALUES (
                        ?, ?, 
                        ?, ?, ?, ?,
                        ?, ?, ?, ?,
                        ?, 'open', true, ?, ?,
                        ?, ?
                    )
                `).bind(
                    item.inspection_id, itemId,
                    `AÃ§Ã£o 5W2H: ${item.item_description?.substring(0, 30)}...`,
                    actionPlan.what || '', actionPlan.why || '', actionPlan.where || item.location || '',
                    actionPlan.who || 'ResponsÃ¡vel', deadlineStr, actionPlan.how || '', actionPlan.how_much || '',
                    actionPlan.priority?.toLowerCase() || 'medium',
                    user.id, user.organization_id || null,
                    now, now
                ).run();

                actionPlan.id = insertResult.meta.last_row_id;
                actionPlan.persisted = true;
            } catch (dbError) {
                console.error("Error persisting action plan:", dbError);
                // Continue to return the plan even if save fails, but mark as not persisted
                actionPlan.persisted = false;
                actionPlan.dbError = String(dbError);
            }
        }

        return c.json({ success: true, action: actionPlan });

    } catch (e) {
        console.error(e);
        return c.json({ error: "Falha ao gerar plano", details: String(e) }, 500);
    }
});

export default inspectionItemRoutes;
===END_FILE===
===FILE: supabase/functions/api/inspection-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";
// import database-init removido
import { TenantContext } from "./tenant-auth-middleware.ts";
import { logActivity } from "./audit-logger.ts";
import { addXP } from "./gamification-routes.ts";

type Env = {
  DB: any;
  OPENAI_API_KEY?: string;
  [key: string]: any;
};

const inspectionRoutes = new Hono<{ Bindings: Env; Variables: { user: any; tenantContext: TenantContext } }>()
  .basePath('/api/inspections');

// Get all inspections for current user
// Get all inspections with Pagination & Server-Side Filtering
inspectionRoutes.get("/", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    // Parameters
    const requestedOrgId = c.req.query("organization_id");
    const page = parseInt(c.req.query("page") || "1");
    const limit = parseInt(c.req.query("limit") || "20"); // Default 20 per page
    const search = c.req.query("search") || "";
    const status = c.req.query("status") || "all";
    const offset = (page - 1) * limit;

    let baseQuery = `
      SELECT i.*, u.name as created_by_name, o.name as organization_name
      FROM inspections i
      LEFT JOIN users u ON i.created_by = u.id
      LEFT JOIN organizations o ON i.organization_id = o.id
    `;


    let countQuery = `SELECT COUNT(*) as total FROM inspections i`;

    const params: any[] = [];
    const whereConditions: string[] = [];

    // --- 1. Security & RBAC Filtering ---

    // Helper: Get all organization IDs accessible to the user
    // This is needed for both checking specific org access AND for the default "all" view
    let accessibleOrgIds: any[] = [];
    if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {
      // Sysadmin has all access, list is effectively "all" (we'll handle logic below)
    } else {
      // Fetch specifically assigned orgs
      const userOrgs = await env.DB.prepare("SELECT organization_id FROM user_organizations WHERE user_id = ? AND is_active = true").bind(user.id).all();
      accessibleOrgIds = (userOrgs.results || []).map((r: any) => r.organization_id);

      // Add primary and managed orgs if not already present
      if (userProfile?.organization_id && !accessibleOrgIds.includes(userProfile.organization_id)) {
        accessibleOrgIds.push(userProfile.organization_id);
      }
      if (userProfile?.managed_organization_id && !accessibleOrgIds.includes(userProfile.managed_organization_id)) {
        accessibleOrgIds.push(userProfile.managed_organization_id);
      }

      // Add child orgs for Org Admins
      if (userProfile?.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {
        const childOrgs = await env.DB.prepare("SELECT id FROM organizations WHERE parent_organization_id = ?").bind(userProfile.managed_organization_id).all();
        const childIds = (childOrgs.results || []).map((r: any) => r.id);
        childIds.forEach((id: any) => {
          if (!accessibleOrgIds.includes(id)) accessibleOrgIds.push(id);
        });
      }
    }

    if (requestedOrgId && requestedOrgId !== '0') {
      const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin';

      // Check access: SysAdmin OR Org is in accessible list
      const canAccessOrg = isSysAdmin || accessibleOrgIds.includes(Number(requestedOrgId)) || accessibleOrgIds.includes(String(requestedOrgId)); // Handle potential string/number mismatch

      if (canAccessOrg) {
        whereConditions.push("i.organization_id = ?");
        params.push(requestedOrgId);
        // console.log(`[INSPECTIONS] Filtering by organization_id=${requestedOrgId}`);
      } else {
        console.warn(`[INSPECTIONS] User ${user.id} tried to access org ${requestedOrgId} without permission`);
        // Fallback: Don't show inspections from this forbidden org (logic falls through to empty result effectively if we strictly controlled, 
        // but here we just ignore the filter and Apply Default Logic below? NO. We should probably return empty or error.
        // Let's force filter to an impossible ID to return nothing safe.
        whereConditions.push("i.organization_id = -1");
      }
    } else {
      // Default / Role-based visibility (No specific org selected, or "All" selected)

      if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {
        // sees everything (no WHERE condition needed for orgs)
      } else {
        // Regular Users & Org Admins:
        // See inspections Created By Self OR Belonging to Accessible Orgs

        if (accessibleOrgIds.length > 0) {
          const placeholders = accessibleOrgIds.map(() => '?').join(',');
          whereConditions.push(`(i.created_by = ? OR i.organization_id IN (${placeholders}))`);
          params.push(user.id, ...accessibleOrgIds);
        } else {
          // No orgs? Just own inspections
          whereConditions.push(`i.created_by = ?`);
          params.push(user.id);
        }
      }
    }

    // --- 2. Search Filtering (Server-Side) ---
    if (search) {
      // Postgres ILIKE for case-insensitive search
      whereConditions.push(`(
        i.title ILIKE ? OR 
        i.location ILIKE ? OR 
        i.company_name ILIKE ? OR 
        i.inspector_name ILIKE ?
      )`);
      const searchParam = `%${search}%`;
      params.push(searchParam, searchParam, searchParam, searchParam);
    }

    // --- 3. Status Filtering (Server-Side) ---
    if (status && status !== 'all') {
      whereConditions.push("i.status = ?");
      params.push(status);
    }

    // Combine conditions
    if (whereConditions.length > 0) {
      const whereClause = " WHERE " + whereConditions.join(" AND ");
      baseQuery += whereClause;
      countQuery += whereClause;
    }

    // --- 4. Execute Count (for pagination metadata) ---
    // Note: Bind params need to be duplicated for count query as it uses the same WHERE clause
    const totalResult = await env.DB.prepare(countQuery).bind(...params).first() as any;
    const total = totalResult?.total || 0;
    const totalPages = Math.ceil(total / limit);

    // --- 5. Execute Data Fetch (with Limit/Offset) ---
    baseQuery += " ORDER BY i.created_at DESC LIMIT ? OFFSET ?";
    params.push(limit, offset);

    const inspections = await env.DB.prepare(baseQuery).bind(...params).all();

    return c.json({
      inspections: inspections.results || [],
      pagination: {
        total,
        page,
        limit,
        totalPages
      }
    });

  } catch (error) {
    console.error('Error fetching inspections:', error);
    return c.json({ error: "Failed to fetch inspections" }, 500);
  }
});

// Get simple list of inspections for dropdowns
inspectionRoutes.get("/simple-list", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const organizationId = c.req.query("organization_id");

  try {
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    let query = `
       SELECT i.id, i.title, i.created_at, i.status 
       FROM inspections i
     `;

    const params: any[] = [];
    const whereConditions: string[] = [];

    // Filter by Org if provided (and allowed)
    if (organizationId) {
      // TODO: Validate user has access to this org
      whereConditions.push("i.organization_id = ?");
      params.push(organizationId);
    } else {
      // RBAC (Simplified for dropdown, usually showing user's org stuff)
      if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {
        // All
      } else if (userProfile?.role === USER_ROLES.ORG_ADMIN) {
        if (userProfile.managed_organization_id) {
          whereConditions.push(`(i.organization_id = ? OR i.organization_id IN (SELECT id FROM organizations WHERE parent_organization_id = ?))`);
          params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
        }
      } else {
        whereConditions.push(`(i.created_by = ? OR i.organization_id = ?)`);
        params.push(user.id, userProfile?.organization_id);
      }
    }

    if (whereConditions.length > 0) {
      query += " WHERE " + whereConditions.join(" AND ");
    }

    query += " ORDER BY i.created_at DESC LIMIT 50"; // Limit to recent 50

    const inspections = await env.DB.prepare(query).bind(...params).all();
    return c.json({ inspections: inspections.results || [] });

  } catch (error) {
    console.log("Error fetching inspection list:", error);
    return c.json({ inspections: [] });
  }
});

// Get specific inspection with all related data
inspectionRoutes.get("/:id", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get inspection with related data
    const inspection = await env.DB.prepare(`
      SELECT i.*, u.name as created_by_name, o.name as organization_name
      FROM inspections i
      LEFT JOIN users u ON i.created_by = u.id
      LEFT JOIN organizations o ON i.organization_id = o.id
      WHERE i.id = ?
  `).bind(inspectionId).first() as any;


    if (!inspection) {
      return c.json({ error: "Inspection not found" }, 404);
    }

    // SERIALIZATION FIX: Execute queries sequentially to prevent connection contention on the single-connection wrapper
    // Edge Functions with 'max: 1' connection pool can become unstable with Promise.all
    console.log(`[INSPECTION-DEBUG] Fetching details for inspection ${inspectionId}`);

    // Get inspection items
    const itemsResult = await env.DB.prepare(`
      SELECT * FROM inspection_items 
      WHERE inspection_id = ?
      ORDER BY id ASC
    `).bind(inspectionId).all();
    console.log(`[INSPECTION-DEBUG] Items fetched: ${itemsResult?.results?.length || 0}`);

    // Get action items
    const actionItemsResult = await env.DB.prepare(`
      SELECT * FROM action_items 
      WHERE inspection_id = ?
      ORDER BY created_at DESC
    `).bind(inspectionId).all();
    console.log(`[INSPECTION-DEBUG] Action items fetched: ${actionItemsResult?.results?.length || 0}`);

    // Get media for all items
    // OPTIMIZATION: Select only necessary columns and LIMIT to prevent timeout on huge inspections
    // CRITICAL FIX: Truncate file_url if it's base64 data (> 5KB) to prevent 40MB+ payload timeouts
    const mediaResult = await env.DB.prepare(`
        SELECT 
          id, 
          inspection_id, 
          inspection_item_id, 
          media_type, 
          CASE 
            WHEN LENGTH(file_url) > 5000 AND file_url LIKE 'data:%' 
            THEN CONCAT(LEFT(file_url, 100), '...[TRUNCATED_BASE64]...')
            ELSE file_url 
          END as file_url,
          CASE WHEN LENGTH(file_url) > 5000 THEN true ELSE false END as is_truncated,
          file_name, 
          mime_type, 
          created_at, 
          latitude, 
          longitude
        FROM inspection_media 
        WHERE inspection_id = ?
        ORDER BY created_at DESC
        LIMIT 200
    `).bind(inspectionId).all();

    // Log warning if limit reached (heuristic)
    if (mediaResult?.results?.length >= 200) {
      console.warn(`[PERFORMANCE] Inspection ${inspectionId} has >= 200 media items. Truncated.`);
    }
    console.log(`[INSPECTION-DEBUG] Media fetched: ${mediaResult?.results?.length || 0}`);


    const items = itemsResult.results || [];
    const actionItems = actionItemsResult.results || [];
    const media = mediaResult.results || [];

    return c.json({
      inspection,
      items,
      action_items: actionItems,
      media
    });

  } catch (error) {
    console.error('Error fetching inspection:', error);
    return c.json({ error: "Failed to fetch inspection" }, 500);
  }
});

// Create new inspection - BLINDADO
// @security: organization_id vem do contexto seguro, NUNCA do body
inspectionRoutes.post("/", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const tenantContext = c.get("tenantContext");

  // VerificaÃ§Ã£o de autenticaÃ§Ã£o
  if (!user) {
    return c.json({ error: "AutenticaÃ§Ã£o necessÃ¡ria" }, 401);
  }

  // VerificaÃ§Ã£o de permissÃ£o: Inspector ou superior pode criar inspeÃ§Ãµes
  const allowedRoles = ['inspector', 'manager', 'org_admin', 'system_admin', 'sys_admin', 'admin'];
  if (!allowedRoles.includes(user.role?.toLowerCase())) {
    return c.json({
      error: "PermissÃ£o negada",
      message: "Apenas Inspetores ou superiores podem criar inspeÃ§Ãµes",
      required_roles: allowedRoles
    }, 403);
  }

  try {
    const body = await c.req.json();
    const {
      title, description, location, inspector_name, inspector_email,
      company_name, cep, address, scheduled_date,
      logradouro, numero, complemento, bairro, cidade, uf, sectors,
      status = 'pendente', priority = 'media', responsible_name, responsible_email,
      template_id, ai_assistant_id, action_plan_type = '5w2h',
      // Novos campos de auditoria (opcionais, enviados pelo cliente)
      started_at_user_time,
      location_start_lat, location_start_lng,
      device_fingerprint, device_model, device_os,
      is_offline_sync = false
    } = body;

    // CRÃTICO: organization_id validaÃ§Ã£o segura
    // O usuÃ¡rio pode especificar qualquer organizaÃ§Ã£o que ele tenha acesso (allowedOrganizationIds)
    let secureOrgId = tenantContext?.organizationId || user.organization_id;

    console.log(`[DEBUG-INSPECTION] User: ${user.id}, Role: ${user.role}, IsSystemAdmin: ${tenantContext?.isSystemAdmin}`);
    console.log(`[DEBUG-INSPECTION] AllowedOrgs: ${JSON.stringify(tenantContext?.allowedOrganizationIds)}`);
    console.log(`[DEBUG-INSPECTION] Requested Org: ${body.organization_id} (Type: ${typeof body.organization_id})`);

    if (body.organization_id) {
      // ValidaÃ§Ã£o: Se o usuÃ¡rio enviou um ID, ele deve estar na lista de IDs permitidos
      // Cast para Number para garantir comparaÃ§Ã£o correta
      const reqOrgId = Number(body.organization_id);

      // Se isSystemAdmin (user.role == sys_admin), permite qualquer ID
      if (tenantContext?.isSystemAdmin || tenantContext?.allowedOrganizationIds?.includes(reqOrgId)) {
        secureOrgId = reqOrgId;
      } else {
        const allowedIdsSt = tenantContext?.allowedOrganizationIds?.join(', ') || 'Nenhum';
        const middlewareError = c.get('tenantAuthError' as any); // Capture error from middleware
        console.warn(`[SECURITY] Bloqueada tentativa de criar inspeÃ§Ã£o em organizaÃ§Ã£o nÃ£o permitida. User: ${user.id}, Target: ${body.organization_id}`);
        return c.json({
          error: "PermissÃ£o negada",
          message: `VocÃª nÃ£o tem permissÃ£o para criar inspeÃ§Ãµes nesta organizaÃ§Ã£o. (Debug: MiddlewareErr=${middlewareError || 'None'}, Req=${reqOrgId}, Allowed=[${allowedIdsSt}])`,
          debug: {
            user_id: user.id,
            requested_org_id: reqOrgId,
            allowed_org_ids: tenantContext?.allowedOrganizationIds || [],
            is_system_admin: tenantContext?.isSystemAdmin,
            middleware_error: middlewareError,
            middleware_log: (tenantContext as any)?._debugLog
          }
        }, 403);
      }
    }

    if (!secureOrgId) {
      return c.json({
        error: "OrganizaÃ§Ã£o nÃ£o definida",
        message: "UsuÃ¡rio nÃ£o estÃ¡ associado a nenhuma organizaÃ§Ã£o e nenhuma foi selecionada."
      }, 400);
    }


    // Capturar IP e User-Agent para auditoria
    const ipAddress = c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown';
    const userAgent = c.req.header('user-agent') || 'unknown';

    const result = await env.DB.prepare(`
      INSERT INTO inspections(
      title, description, location, inspector_name, inspector_email,
      company_name, cep, address, scheduled_date,
      logradouro, numero, complemento, bairro, cidade, uf, sectors,
      status, priority, created_by, organization_id, responsible_name, responsible_email,
      ai_assistant_id, action_plan_type,
      started_at_user_time, started_at_server_time,
      location_start_lat, location_start_lng,
      device_fingerprint, device_model, device_os,
      is_offline_sync, sync_timestamp,
      created_at, updated_at
    ) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    RETURNING id
      `).bind(
      title || null,
      description || null,
      location || null,
      inspector_name || user.name || null,
      inspector_email || user.email || null,
      company_name || null,
      cep || null,
      address || null,
      scheduled_date || null,
      logradouro || null,
      numero || null,
      complemento || null,
      bairro || null,
      cidade || null,
      uf || null,
      sectors ? JSON.stringify(sectors) : null,
      status,
      priority,
      user.id,
      secureOrgId, // SEGURO: vem do contexto, nÃ£o do body
      responsible_name || null,
      responsible_email || null,
      ai_assistant_id || null,
      action_plan_type,
      started_at_user_time || null,
      new Date().toISOString(), // started_at_server_time
      location_start_lat || null,
      location_start_lng || null,
      device_fingerprint || null,
      device_model || null,
      device_os || null,
      is_offline_sync ? 1 : 0,
      is_offline_sync ? new Date().toISOString() : null,
      new Date().toISOString(), // created_at
      new Date().toISOString()  // updated_at
    ).first();

    console.log('[DEBUG] SQL Result:', JSON.stringify(result));

    // Robust ID extraction for D1/SQLite/Postgres
    let inspectionId = (result as any)?.id || (result as any)?.meta?.last_row_id || (result as any)?.lastInsertRowid;

    console.log('[DEBUG] Extracted Inspection ID:', inspectionId);

    // Fail Secure: Se nÃ£o conseguirmos o ID diretamente, FALHAMOS.
    // NÃ£o tentamos adivinhar com MAX(id) para evitar Race Condition.
    if (!inspectionId) {
      console.error('[CRITICAL] Failed to retrieve Inspection ID via RETURNING/meta. Aborting to prevent data corruption.');
      throw new Error("Failed to retrieve new inspection ID. Transaction aborted.");
    }

    // Registrar log de criaÃ§Ã£o (LGPD)
    try {
      await env.DB.prepare(`
        INSERT INTO inspection_logs(
        inspection_id, user_id, action, ip_address, user_agent, created_at
      ) VALUES(?, ?, 'CREATE', ?, ?, NOW())
        `).bind(inspectionId, user.id, ipAddress, userAgent).run();
    } catch (logError) {
      console.error('[AUDIT] Erro ao registrar log de criaÃ§Ã£o:', logError);
      // NÃ£o bloquear a operaÃ§Ã£o principal
    }

    // Registrar log global de auditoria
    await logActivity(env, {
      userId: user.id,
      orgId: secureOrgId,
      actionType: 'CREATE',
      actionDescription: `CriaÃ§Ã£o de inspeÃ§Ã£o: ${title}`,
      targetType: 'INSPECTION',
      targetId: inspectionId,
      metadata: { title, status, priority, template_id },
      req: c.req
    });

    // If a template is selected, create inspection items based on template fields
    // OPTIMIZATION (Batch Insert): Fix N+1 Query Problem
    if (template_id) {
      const fields = await env.DB.prepare(`
        SELECT * FROM checklist_fields 
        WHERE template_id = ?
        ORDER BY order_index ASC
      `).bind(template_id).all();

      const fieldResults = fields.results || [];

      if (fieldResults.length > 0) {
        // Construct Batch Insert Query
        let insertQuery = `
          INSERT INTO inspection_items(
            inspection_id, category, item_description, template_id,
            field_responses, created_at, updated_at
          ) VALUES 
        `;

        const insertParams: any[] = [];
        const placeholders: string[] = [];
        // Helper date for batch
        const nowIso = new Date().toISOString();

        // Template category cache
        const template = await env.DB.prepare("SELECT category FROM checklist_templates WHERE id = ?").bind(template_id).first() as any;
        const category = template?.category || 'Geral';

        for (const field of fieldResults) {
          const fieldData = field as any;

          // Type validation (simplified for batch speed)
          const fieldType = fieldData.field_type || 'text';

          const fieldResponseData = {
            field_id: fieldData.id,
            field_name: fieldData.field_name,
            field_type: fieldType,
            is_required: fieldData.is_required,
            options: fieldData.options,
            response_value: null,
            comment: null
          };

          placeholders.push('(?, ?, ?, ?, ?, ?, ?)');
          insertParams.push(
            inspectionId,
            category,
            fieldData.field_name,
            template_id,
            JSON.stringify(fieldResponseData),
            nowIso,
            nowIso
          );
        }

        // Execute Batch Insert
        if (placeholders.length > 0) {
          insertQuery += placeholders.join(', ');
          try {
            // Using .all() because .run() in D1 wrapper might behave differently with multiple values
            // But typically .run() is for writes.
            await env.DB.prepare(insertQuery).bind(...insertParams).run();
            console.log(`[PERFORMANCE] Batch inserted ${placeholders.length} items for inspection ${inspectionId}`);
          } catch (batchError) {
            console.error('[CRITICAL] Failed to batch insert items:', batchError);
            // We don't rollback inspection creation here because we lack transactions, 
            // but we log it. User will see empty checklist.
          }
        }
      }
    }

    return c.json({
      id: inspectionId,
      message: "InspeÃ§Ã£o criada com sucesso",
      organization_id: secureOrgId // Confirmar qual org foi usada
    });

  } catch (error) {
    console.error('Error creating inspection:', error);
    // NÃ£o expor stack trace para o cliente
    return c.json({
      error: "Erro ao criar inspeÃ§Ã£o",
      message: "Erro interno: " + (error instanceof Error ? error.message : String(error))
    }, 500);
  }
});




// Configure inspection (Template & AI)
inspectionRoutes.put("/:id/configure", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "AutenticaÃ§Ã£o necessÃ¡ria" }, 401);
  }

  try {
    const body = await c.req.json();
    const { template_id, ai_assistant_id } = body;

    // 1. Update Inspection Record
    await env.DB.prepare(`
      UPDATE inspections 
      SET template_id = ?, ai_assistant_id = ?, updated_at = NOW()
      WHERE id = ?
    `).bind(template_id, ai_assistant_id, inspectionId).run();

    // 2. Generate Items if Template Selected (and no items exist)
    if (template_id) {
      // Check if items already exist
      const existing = await env.DB.prepare("SELECT count(*) as count FROM inspection_items WHERE inspection_id = ?").bind(inspectionId).first() as any;

      if (existing.count === 0) {
        console.log(`[CONFIGURE] Generating items for inspection ${inspectionId} from template ${template_id}`);
        const template = await env.DB.prepare("SELECT * FROM checklist_templates WHERE id = ?").bind(template_id).first() as any;
        const fields = await env.DB.prepare(`
               SELECT * FROM checklist_fields 
               WHERE template_id = ?
               ORDER BY order_index ASC
           `).bind(template_id).all();

        // OPTIMIZATION: Batch Insert (fix N+1 query)
        const fieldResults = fields.results || [];
        if (fieldResults.length > 0) {
          const category = template?.category || 'Geral';
          const nowIso = new Date().toISOString();

          let insertQuery = `
            INSERT INTO inspection_items(
              inspection_id, category, item_description, template_id,
              field_responses, created_at, updated_at
            ) VALUES 
          `;
          const insertParams: any[] = [];
          const placeholders: string[] = [];

          for (const field of fieldResults) {
            const fieldData = field as any;

            // Fallback for types
            const validTypes = [
              'text', 'textarea', 'select', 'multiselect', 'radio', 'checkbox',
              'number', 'date', 'time', 'boolean', 'rating', 'file'
            ];
            if (!validTypes.includes(fieldData.field_type)) {
              fieldData.field_type = 'text';
            }

            const fieldResponseData = {
              field_id: fieldData.id,
              field_name: fieldData.field_name,
              field_type: fieldData.field_type,
              is_required: fieldData.is_required,
              options: fieldData.options,
              response_value: null,
              comment: null
            };

            placeholders.push('(?, ?, ?, ?, ?, ?, ?)');
            insertParams.push(
              inspectionId,
              category,
              fieldData.field_name,
              template_id,
              JSON.stringify(fieldResponseData),
              nowIso,
              nowIso
            );
          }

          insertQuery += placeholders.join(', ');
          await env.DB.prepare(insertQuery).bind(...insertParams).run();
          console.log(`[CONFIGURE] Batch inserted ${fieldResults.length} items for inspection ${inspectionId}`);
        }
      } else {
        console.log(`[CONFIGURE] Skipping item generation: Items already exist for inspection ${inspectionId}`);
      }
    }

    // Log Activity
    await logActivity(env, {
      userId: user.id,
      orgId: user.organization_id, // Or from inspection lookup if needed, but context is safer
      actionType: 'UPDATE',
      actionDescription: `Configurou inspeÃ§Ã£o (Template: ${template_id}, AI: ${ai_assistant_id})`,
      targetType: 'INSPECTION',
      targetId: inspectionId,
      metadata: { template_id, ai_assistant_id },
      req: c.req
    });

    return c.json({ success: true, message: "ConfiguraÃ§Ã£o atualizada com sucesso" });

  } catch (error) {
    console.error('Error configuring inspection:', error);
    return c.json({ error: "Erro ao configurar inspeÃ§Ã£o" }, 500);
  }
});

// Update status (Workflow Transition with GPS & Audit)
inspectionRoutes.put("/:id/status", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const tenantContext = c.get("tenantContext");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "AutenticaÃ§Ã£o necessÃ¡ria" }, 401);
  }

  try {
    const body = await c.req.json();
    const { status, location_lat, location_lng } = body;

    // Validate Status Enum
    const validStatuses = ['scheduled', 'acknowledged', 'in_progress', 'completed', 'delivered'];
    if (!validStatuses.includes(status)) {
      return c.json({ error: "Status invÃ¡lido" }, 400);
    }

    // Get current inspection
    const inspection = await env.DB.prepare("SELECT * FROM inspections WHERE id = ?").bind(inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Verify Access
    const hasAccess = tenantContext?.isSystemAdmin ||
      (inspection.organization_id && tenantContext?.allowedOrganizationIds.includes(inspection.organization_id)) ||
      inspection.created_by === user.id ||
      inspection.inspector_email === user.email; // Allow assigned inspector update

    if (!hasAccess) {
      return c.json({ error: "Acesso negado" }, 403);
    }

    // Update Query
    let updateQuery = "UPDATE inspections SET status = ?, updated_at = NOW()";
    const updateParams: any[] = [status];

    // Status-specific updates
    if (status === 'in_progress' && !inspection.started_at_server_time) {
      updateQuery += ", started_at_server_time = NOW()";
      if (location_lat) { updateQuery += ", location_start_lat = ?"; updateParams.push(location_lat); }
      if (location_lng) { updateQuery += ", location_start_lng = ?"; updateParams.push(location_lng); }
    }

    updateQuery += " WHERE id = ?";
    updateParams.push(inspectionId);

    // Execute Update
    await env.DB.prepare(updateQuery).bind(...updateParams).run();

    // Audit History
    await env.DB.prepare(`
        INSERT INTO inspection_status_history (
            inspection_id, status_from, status_to, changed_by, 
            location_lat, location_lng, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, NOW())
    `).bind(
      inspectionId, inspection.status, status, user.id,
      location_lat || null, location_lng || null
    ).run();

    // Log Activity
    await logActivity(env, {
      userId: user.id,
      orgId: inspection.organization_id,
      actionType: 'STATUS_CHANGE',
      actionDescription: `Alterou status para ${status}`,
      targetType: 'INSPECTION',
      targetId: inspectionId,
      metadata: { from: inspection.status, to: status, gps: { lat: location_lat, lng: location_lng } },
      req: c.req
    });

    return c.json({ success: true, message: `Status atualizado para ${status}` });

  } catch (error) {
    console.error('Error updating status:', error);
    return c.json({ error: "Erro ao atualizar status" }, 500);
  }
});

inspectionRoutes.post("/:id/deliver", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "AutenticaÃ§Ã£o necessÃ¡ria" }, 401);
  }

  try {
    const body = await c.req.json();
    const { pdf_url } = body;

    // Get current inspection
    const inspection = await env.DB.prepare("SELECT * FROM inspections WHERE id = ?").bind(inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Verify Access (Creator, Inspector, or Admin)
    const hasAccess = inspection.created_by === user.id ||
      inspection.inspector_email === user.email ||
      (c.get("tenantContext")?.isSystemAdmin ?? false);

    if (!hasAccess) {
      return c.json({ error: "Acesso negado" }, 403);
    }

    // Update Status to Delivered
    const newStatus = 'delivered';
    await env.DB.prepare(`
        UPDATE inspections 
        SET status = ?, 
            pdf_report_url = ?, 
            delivered_at = NOW(), 
            updated_at = NOW() 
        WHERE id = ?
    `).bind(newStatus, pdf_url || inspection.pdf_report_url, inspectionId).run();

    // Audit History
    await env.DB.prepare(`
        INSERT INTO inspection_status_history (
            inspection_id, status_from, status_to, changed_by, created_at
        ) VALUES (?, ?, ?, ?, NOW())
    `).bind(inspectionId, inspection.status, newStatus, user.id).run();

    // Log Activity
    await logActivity(env, {
      userId: user.id,
      orgId: inspection.organization_id,
      actionType: 'DELIVERY',
      actionDescription: `Entregou relatÃ³rio de inspeÃ§Ã£o`,
      targetType: 'INSPECTION',
      targetId: inspectionId,
      metadata: { pdf_url },
      req: c.req
    });

    return c.json({ success: true, message: "InspeÃ§Ã£o entregue com sucesso", new_status: 'delivered' });

  } catch (error) {
    console.error('Error delivering inspection:', error);
    return c.json({ error: "Erro ao entregar inspeÃ§Ã£o" }, 500);
  }
});

// Update inspection - BLINDADO
// @security: Verifica propriedade e registra log de auditoria
inspectionRoutes.put("/:id", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const tenantContext = c.get("tenantContext");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "AutenticaÃ§Ã£o necessÃ¡ria" }, 401);
  }

  try {
    // CRÃTICO: Verificar se a inspeÃ§Ã£o existe e se o usuÃ¡rio tem acesso
    const inspection = await env.DB.prepare(`
SELECT * FROM inspections WHERE id = ?
  `).bind(inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Verificar acesso baseado em tenant
    const hasAccess = tenantContext?.isSystemAdmin ||
      (inspection.organization_id && tenantContext?.allowedOrganizationIds.includes(inspection.organization_id)) ||
      inspection.created_by === user.id ||
      inspection.inspector_email === user.email; // Allow assigned inspector to update

    if (!hasAccess) {
      return c.json({
        error: "Acesso negado",
        message: "VocÃª nÃ£o tem permissÃ£o para editar esta inspeÃ§Ã£o"
      }, 403);
    }

    const body = await c.req.json();

    // CRÃTICO: Impedir modificaÃ§Ã£o de organization_id via body
    if (body.organization_id && body.organization_id !== inspection.organization_id) {
      console.warn(`[SECURITY] Tentativa de alterar organization_id bloqueada.User: ${user.id}, Inspection: ${inspectionId} `);
      return c.json({
        error: "OperaÃ§Ã£o nÃ£o permitida",
        message: "NÃ£o Ã© possÃ­vel alterar a organizaÃ§Ã£o de uma inspeÃ§Ã£o"
      }, 403);
    }

    // Build dynamic update query
    const updateFields = [];
    const updateValues = [];
    const changedFields: Record<string, { old: any; new: any }> = {};

    const allowedFields = [
      'title', 'description', 'location', 'inspector_name', 'inspector_email',
      'company_name', 'cep', 'address', 'scheduled_date',
      'logradouro', 'numero', 'complemento', 'bairro', 'cidade', 'uf', 'sectors',
      'completed_date', 'status', 'priority', 'action_plan', 'action_plan_type',
      'inspector_signature', 'responsible_signature', 'responsible_name', 'responsible_email',
      // Campos de auditoria que podem ser atualizados
      'location_end_lat', 'location_end_lng'
    ];

    for (const field of allowedFields) {
      if (body[field] !== undefined && body[field] !== inspection[field]) {
        updateFields.push(`${field} = ?`);
        updateValues.push(body[field]);
        changedFields[field] = { old: inspection[field], new: body[field] };
      }
    }

    if (updateFields.length === 0) {
      return c.json({ message: "Nenhuma alteraÃ§Ã£o detectada" }, 400);
    }

    updateFields.push("updated_at = NOW()");

    await env.DB.prepare(`
      UPDATE inspections 
      SET ${updateFields.join(", ")}
      WHERE id = ?
  `).bind(...updateValues, inspectionId).run();

    // Registrar log global de auditoria
    await logActivity(env, {
      userId: user.id,
      orgId: inspection.organization_id,
      actionType: 'UPDATE',
      actionDescription: `AtualizaÃ§Ã£o de inspeÃ§Ã£o: ${inspection.title}`,
      targetType: 'INSPECTION',
      targetId: inspectionId,
      metadata: { changed_fields: Object.keys(changedFields) },
      req: c.req
    });

    // Registrar log de auditoria para cada campo alterado (LGPD)
    const ipAddress = c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown';
    const userAgent = c.req.header('user-agent') || 'unknown';

    for (const [field, values] of Object.entries(changedFields)) {
      try {
        await env.DB.prepare(`
          INSERT INTO inspection_logs(
    inspection_id, user_id, action, field_changed, old_value, new_value,
    ip_address, user_agent, created_at
  ) VALUES(?, ?, 'UPDATE', ?, ?, ?, ?, ?, NOW())
    `).bind(
          inspectionId,
          user.id,
          field,
          JSON.stringify(values.old),
          JSON.stringify(values.new),
          ipAddress,
          userAgent
        ).run();
      } catch (logError) {
        console.error('[AUDIT] Erro ao registrar log de atualizaÃ§Ã£o:', logError);
      }
    }

    return c.json({
      message: "InspeÃ§Ã£o atualizada com sucesso",
      fields_updated: Object.keys(changedFields)
    });

  } catch (error) {
    console.error('Error updating inspection:', error);
    return c.json({
      error: "Erro ao atualizar inspeÃ§Ã£o",
      message: "Ocorreu um erro interno. Tente novamente."
    }, 500);
  }
});


// Finalize inspection
inspectionRoutes.post("/:id/finalize", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { inspector_signature, responsible_signature, responsible_name, responsible_email, responsible_role } = body;

    if (!inspector_signature || !responsible_signature) {
      return c.json({ error: "Ambas assinaturas sÃ£o obrigatÃ³rias" }, 400);
    }

    // CORRIGIDO: Garantir que as assinaturas sejam salvas antes da finalizaÃ§Ã£o
    if (inspector_signature || responsible_signature) {
      console.log(`[FINALIZE] Salvando assinaturas para inspeÃ§Ã£o ${inspectionId} `);
      await env.DB.prepare(`
        UPDATE inspections 
        SET inspector_signature = ?, responsible_signature = ?, updated_at = NOW()
        WHERE id = ?
  `).bind(
        inspector_signature || null,
        responsible_signature || null,
        inspectionId
      ).run();

      // Verificar se foi salvo corretamente
      const verification = await env.DB.prepare(`
        SELECT inspector_signature, responsible_signature 
        FROM inspections WHERE id = ?
  `).bind(inspectionId).first() as any;

      console.log(`[FINALIZE] VerificaÃ§Ã£o pÃ³s - salvamento: `, {
        inspector_saved: verification?.inspector_signature ? 'Sim' : 'NÃ£o',
        responsible_saved: verification?.responsible_signature ? 'Sim' : 'NÃ£o'
      });
    }

    // Update inspection status and signatures with responsible info
    await env.DB.prepare(`
      UPDATE inspections 
      SET status = 'concluida',
  completed_date = date('now'),
  inspector_signature = ?,
  responsible_signature = ?,
  responsible_name = ?,
  responsible_email = ?,
  responsible_role = COALESCE(?, responsible_role),
  updated_at = NOW()
      WHERE id = ?
  `).bind(inspector_signature, responsible_signature, responsible_name, responsible_email, responsible_role || null, inspectionId).run();

    // Log FINALIZE action for audit trail
    try {
      await env.DB.prepare(`
        INSERT INTO inspection_logs (inspection_id, user_id, action, field_changed, old_value, new_value, created_at)
        VALUES (?, ?, 'FINALIZE', 'status', 'em_andamento', 'concluida', NOW())
      `).bind(inspectionId, user.id).run();
    } catch (logErr) {
      console.error('[AUDIT] Failed to log FINALIZE:', logErr);
    }

    return c.json({
      success: true,
      message: "Inspection finalized successfully"
    });

  } catch (error) {
    console.error('Error finalizing inspection:', error);
    return c.json({ error: "Failed to finalize inspection" }, 500);
  }
});

// Reopen inspection (with audit trail)
inspectionRoutes.post("/:id/reopen", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { justification } = body;

    if (!justification || justification.trim() === '') {
      return c.json({ error: "Justificativa Ã© obrigatÃ³ria para reabrir a inspeÃ§Ã£o" }, 400);
    }

    // Get current inspection state
    const inspection = await env.DB.prepare(`
      SELECT id, status, inspector_signature, responsible_signature, completed_date
      FROM inspections WHERE id = ?
    `).bind(inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    if (inspection.status !== 'concluida' && inspection.status !== 'completed') {
      return c.json({ error: "Apenas inspeÃ§Ãµes finalizadas podem ser reabertas" }, 400);
    }

    // Archive current state in history
    await env.DB.prepare(`
      INSERT INTO inspection_reopening_history (
        inspection_id, reopened_by, justification, 
        previous_status, previous_inspector_signature, 
        previous_responsible_signature, previous_completed_date
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(
      inspectionId,
      user.id,
      justification.trim(),
      inspection.status,
      inspection.inspector_signature,
      inspection.responsible_signature,
      inspection.completed_date
    ).run();

    // Update inspection: clear signatures and set status to in_progress
    await env.DB.prepare(`
      UPDATE inspections 
      SET status = 'em_andamento',
          inspector_signature = NULL,
          responsible_signature = NULL,
          completed_date = NULL,
          updated_at = NOW()
      WHERE id = ?
    `).bind(inspectionId).run();

    // Log REOPEN action for audit trail
    try {
      await env.DB.prepare(`
        INSERT INTO inspection_logs (inspection_id, user_id, action, field_changed, old_value, new_value, created_at)
        VALUES (?, ?, 'REOPEN', 'status', 'concluida', 'em_andamento', NOW())
      `).bind(inspectionId, user.id).run();
    } catch (logErr) {
      console.error('[AUDIT] Failed to log REOPEN:', logErr);
    }

    console.log(`[REOPEN] InspeÃ§Ã£o ${inspectionId} reaberta por ${user.email}. Justificativa: ${justification.substring(0, 50)}...`);

    return c.json({
      success: true,
      message: "InspeÃ§Ã£o reaberta com sucesso"
    });

  } catch (error) {
    console.error('Error reopening inspection:', error);
    return c.json({ error: "Falha ao reabrir inspeÃ§Ã£o" }, 500);
  }
});

// PATCH endpoint for individual response auto-save
inspectionRoutes.patch("/:id/responses/:itemId", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { answer, comment } = body;

    // Get inspection to verify access
    const inspection = await env.DB.prepare("SELECT * FROM inspections WHERE id = ?").bind(inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Block editing if inspection is finalized
    if (inspection.status === 'concluida' || inspection.status === 'completed') {
      return c.json({ error: "NÃ£o Ã© possÃ­vel editar uma inspeÃ§Ã£o finalizada. Reabra a inspeÃ§Ã£o primeiro." }, 403);
    }

    // Get existing inspection item
    const existingItem = await env.DB.prepare(
      "SELECT * FROM inspection_items WHERE id = ? AND inspection_id = ?"
    ).bind(itemId, inspectionId).first() as any;

    if (!existingItem) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // Parse existing field responses
    let fieldData;
    try {
      fieldData = JSON.parse(existingItem.field_responses || '{}');
    } catch (error) {
      return c.json({ error: "Dados do campo corrompidos" }, 400);
    }

    // Update response value and comment
    fieldData.response_value = answer;
    fieldData.comment = comment || null;

    // Determine compliance status from answer
    let complianceStatus = null;
    if (answer !== null && answer !== undefined) {
      if (typeof answer === 'boolean') {
        complianceStatus = answer ? 'conforme' : 'nao_conforme';
      } else if (typeof answer === 'string') {
        const answerLower = answer.toLowerCase();
        if (answerLower === 'conforme' || answerLower === 'sim') {
          complianceStatus = 'conforme';
        } else if (answerLower === 'nÃ£o conforme' || answerLower === 'nao conforme' || answerLower === 'nÃ£o') {
          complianceStatus = 'nao_conforme';
        } else if (answerLower === 'nÃ£o aplicÃ¡vel' || answerLower === 'nao aplicavel' || answerLower === 'n/a') {
          complianceStatus = 'nao_aplicavel';
        }
      }
    }

    // Update database
    await env.DB.prepare(`
      UPDATE inspection_items 
      SET field_responses = ?, is_compliant = ?, updated_at = NOW()
      WHERE id = ? AND inspection_id = ?
  `).bind(JSON.stringify(fieldData), complianceStatus, itemId, inspectionId).run();

    // Clean response (remove BOM if present)
    const responseText = JSON.stringify({
      success: true,
      message: "Resposta salva automaticamente",
      compliance_status: complianceStatus,
      timestamp: new Date().toISOString()
    });

    return c.json(JSON.parse(responseText));

  } catch (error) {
    console.error('Error saving individual response:', error);
    return c.json({
      error: "Erro ao salvar resposta",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Save template responses for inspection
inspectionRoutes.post("/:id/template-responses", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { responses } = body;

    // Get inspection to verify access
    const inspection = await env.DB.prepare("SELECT * FROM inspections WHERE id = ?").bind(inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    const updateStatements: Promise<any>[] = [];

    // Enhanced saving logic for inspection items
    for (const [itemId, responseData] of Object.entries(responses as Record<string, any>)) {
      const itemIdNum = parseInt(itemId);

      if (isNaN(itemIdNum)) continue;

      // Enhanced response data processing
      const updatedFieldData = responseData as any;
      const fieldResponsesJson = JSON.stringify(updatedFieldData);

      // Extract compliance_status with improved logic
      let complianceStatus = null;
      if (updatedFieldData.compliance_status !== undefined && updatedFieldData.compliance_status !== 'unanswered') {
        complianceStatus = updatedFieldData.compliance_status;
      } else if (updatedFieldData.response_value !== undefined) {
        // Enhanced compliance deduction logic
        if (typeof updatedFieldData.response_value === 'boolean') {
          complianceStatus = updatedFieldData.response_value ? 'conforme' : 'nao_conforme';
        } else if (typeof updatedFieldData.response_value === 'string') {
          const valueStr = updatedFieldData.response_value.toLowerCase();
          if (valueStr.includes('conforme') && !valueStr.includes('nÃ£o')) {
            complianceStatus = 'conforme';
          } else if (valueStr.includes('nÃ£o conforme') || valueStr.includes('inadequado')) {
            complianceStatus = 'nao_conforme';
          } else if (valueStr.includes('nÃ£o aplicÃ¡vel') || valueStr.includes('n/a')) {
            complianceStatus = 'nao_aplicavel';
          }
        } else if (typeof updatedFieldData.response_value === 'number') {
          // For rating fields (1-5 scale)
          if (updatedFieldData.response_value >= 4) {
            complianceStatus = 'conforme';
          } else if (updatedFieldData.response_value <= 2) {
            complianceStatus = 'nao_conforme';
          } else {
            complianceStatus = 'parcialmente_conforme';
          }
        }
      }

      // Convert compliance status to boolean for legacy column
      // Accept both EN (compliant, non_compliant) and PT-BR (conforme, nao_conforme) values
      let isCompliantBool: boolean | null = null;
      if (complianceStatus === 'conforme' || complianceStatus === 'compliant') {
        isCompliantBool = true;
      } else if (complianceStatus === 'nao_conforme' || complianceStatus === 'non_compliant') {
        isCompliantBool = false;
      }

      // Update inspection item with both compliance_status (text) and is_compliant (boolean for legacy)
      updateStatements.push(
        env.DB.prepare(`
          UPDATE inspection_items 
          SET field_responses = ?, is_compliant = ?, compliance_status = ?, updated_at = NOW()
          WHERE id = ? AND inspection_id = ?
  `).bind(fieldResponsesJson, isCompliantBool, complianceStatus, itemIdNum, inspectionId).run()
      );
    }

    await Promise.all(updateStatements);

    return c.json({
      success: true,
      message: "Respostas salvas com sucesso",
      items_updated: updateStatements.length
    });

  } catch (error) {
    console.error('Error saving template responses:', error);
    return c.json({
      error: "Erro ao salvar respostas",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Get template responses for inspection
inspectionRoutes.get("/:id/template-responses", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get inspection items with field responses
    const items = await env.DB.prepare(`
      SELECT id, field_responses 
      FROM inspection_items 
      WHERE inspection_id = ? AND field_responses IS NOT NULL
  `).bind(inspectionId).all();

    const responses: Record<string, any> = {};

    for (const item of (items.results || [])) {
      const itemData = item as any;
      if (itemData.field_responses) {
        try {
          responses[itemData.id] = JSON.parse(itemData.field_responses);
        } catch (error) {
          console.error('Error parsing field responses:', error);
        }
      }
    }

    return c.json({ responses });

  } catch (error) {
    console.error('Error fetching template responses:', error);
    return c.json({ error: "Erro ao buscar respostas" }, 500);
  }
});

// Get signatures for inspection
inspectionRoutes.get("/:id/signatures", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const inspection = await env.DB.prepare(`
      SELECT inspector_signature, responsible_signature, responsible_name
      FROM inspections 
      WHERE id = ?
  `).bind(inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    return c.json({
      inspector_signature: inspection.inspector_signature,
      responsible_signature: inspection.responsible_signature,
      responsible_name: inspection.responsible_name
    });

  } catch (error) {
    console.error('Error fetching signatures:', error);
    return c.json({ error: "Erro ao buscar assinaturas" }, 500);
  }
});

// Save signatures for inspection
inspectionRoutes.post("/:id/signatures", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { inspector_signature, responsible_signature, responsible_name, responsible_email, responsible_role } = body;

    console.log(`[SIGNATURES] Salvando assinaturas para inspeÃ§Ã£o ${inspectionId}: `, {
      inspector_signature: inspector_signature ? 'Presente' : 'Ausente',
      responsible_signature: responsible_signature ? 'Presente' : 'Ausente',
      responsible_name,
      responsible_email,
      responsible_role
    });

    await env.DB.prepare(`
      UPDATE inspections 
      SET inspector_signature = ?, responsible_signature = ?, responsible_name = COALESCE(?, responsible_name), responsible_email = COALESCE(?, responsible_email), responsible_role = COALESCE(?, responsible_role), updated_at = NOW()
      WHERE id = ?
  `).bind(
      inspector_signature || null,
      responsible_signature || null,
      responsible_name || null,
      responsible_email || null,
      responsible_role || null,
      inspectionId
    ).run();

    // CORRIGIDO: Verificar se as assinaturas foram salvas corretamente
    const verification = await env.DB.prepare(`
      SELECT inspector_signature, responsible_signature, responsible_name, responsible_email, responsible_role
      FROM inspections WHERE id = ?
  `).bind(inspectionId).first() as any;

    console.log(`[SIGNATURES] VerificaÃ§Ã£o pÃ³s - salvamento: `, {
      inspector_saved: verification?.inspector_signature ? 'Sim' : 'NÃ£o',
      responsible_saved: verification?.responsible_signature ? 'Sim' : 'NÃ£o',
      responsible_name_saved: verification?.responsible_name || 'NÃ£o definido',
      responsible_email_saved: verification?.responsible_email || 'NÃ£o definido',
      responsible_role_saved: verification?.responsible_role || 'NÃ£o definido'
    });

    return c.json({
      success: true,
      message: "Assinaturas salvas com sucesso",
      saved_data: {
        inspector_signature: verification?.inspector_signature ? 'Salva' : 'NÃ£o salva',
        responsible_signature: verification?.responsible_signature ? 'Salva' : 'NÃ£o salva',
        responsible_name: verification?.responsible_name || null
      }
    });

  } catch (error) {
    console.error('Error saving signatures:', error);
    return c.json({
      error: "Erro ao salvar assinaturas",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Delete inspection - BLINDADO
// @security: Apenas Manager+ pode deletar, com verificaÃ§Ã£o de tenant e log de auditoria
inspectionRoutes.delete("/:id", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const tenantContext = c.get("tenantContext");
  const inspectionId = parseInt(c.req.param("id"));

  console.log('[DELETE-INSPECTION] Iniciando exclusÃ£o:', { inspectionId, userId: user?.id, userRole: user?.role });

  if (!user) {
    console.log('[DELETE-INSPECTION] UsuÃ¡rio nÃ£o autenticado');
    return c.json({ error: "AutenticaÃ§Ã£o necessÃ¡ria" }, 401);
  }

  try {
    // CRÃTICO: Verificar se a inspeÃ§Ã£o existe
    const inspection = await env.DB.prepare(`
SELECT * FROM inspections WHERE id = ?
  `).bind(inspectionId).first() as any;

    if (!inspection) {
      console.log('[DELETE-INSPECTION] InspeÃ§Ã£o nÃ£o encontrada:', inspectionId);
      return c.json({ error: 'InspeÃ§Ã£o nÃ£o encontrada' }, 404);
    }

    console.log('[DELETE-INSPECTION] InspeÃ§Ã£o encontrada:', {
      id: inspection.id,
      created_by: inspection.created_by,
      organization_id: inspection.organization_id
    });

    // Verificar permissÃµes: Manager+, System Admin ou criador da inspeÃ§Ã£o
    const allowedRoles = ['manager', 'org_admin', 'system_admin', 'sys_admin', 'admin', 'technician', 'inspector'];
    const userRole = user.role?.toLowerCase() || '';
    const hasRolePermission = allowedRoles.includes(userRole);
    const isCreator = inspection.created_by === user.id;
    const isSystemAdmin = userRole === 'sys_admin' || userRole === 'system_admin';

    console.log('[DELETE-INSPECTION] VerificaÃ§Ã£o de permissÃµes:', {
      userRole,
      hasRolePermission,
      isCreator,
      isSystemAdmin,
      tenantContext: tenantContext ? 'presente' : 'ausente'
    });

    // SIMPLIFICADO: Permitir se tem role vÃ¡lida OU Ã© o criador OU Ã© sys_admin
    if (!hasRolePermission && !isCreator && !isSystemAdmin) {
      console.log('[DELETE-INSPECTION] PermissÃ£o negada - role nÃ£o permitida');
      return c.json({
        error: 'PermissÃ£o negada',
        message: 'Apenas Managers, criadores da inspeÃ§Ã£o ou superiores podem excluir',
        debug: { userRole, hasRolePermission, isCreator }
      }, 403);
    }

    // Capturar dados para log de auditoria antes de deletar
    const ipAddress = c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown';
    const userAgent = c.req.header('user-agent') || 'unknown';

    // Registrar log de deleÃ§Ã£o (LGPD) ANTES de deletar
    try {
      await env.DB.prepare(`
        INSERT INTO inspection_logs(
    inspection_id, user_id, action, old_value,
    ip_address, user_agent, created_at
  ) VALUES(?, ?, 'DELETE', ?, ?, ?, NOW())
    `).bind(
        inspectionId,
        user.id,
        JSON.stringify({
          title: inspection.title,
          organization_id: inspection.organization_id,
          created_by: inspection.created_by,
          status: inspection.status
        }),
        ipAddress,
        userAgent
      ).run();
    } catch (logError) {
      console.error('[AUDIT] Erro ao registrar log de deleÃ§Ã£o:', logError);
    }

    // Registrar log global de auditoria
    try {
      await env.DB.prepare(`
          INSERT INTO activity_log (
            user_id, organization_id, action_type, action_description, 
            target_type, target_id, metadata, ip_address, user_agent, created_at
          ) VALUES (?, ?, 'DELETE', ?, 'INSPECTION', ?, ?, ?, ?, NOW())
        `).bind(
        user.id,
        inspection.organization_id,
        `ExclusÃ£o de inspeÃ§Ã£o: ${inspection.title}`,
        inspectionId,
        JSON.stringify({ title: inspection.title, status: inspection.status }),
        ipAddress,
        userAgent
      ).run();
    } catch (logErr) {
      console.error('Failed to log to global activity_log:', logErr);
    }

    // Excluir itens relacionados na ordem correta (filhos -> pais)
    // 1. MÃ­dia (ligada a items e inspeÃ§Ã£o)
    await env.DB.prepare('DELETE FROM inspection_media WHERE inspection_id = ?').bind(inspectionId).run();

    // 2. Planos de AÃ§Ã£o (ligados a items e inspeÃ§Ã£o)
    await env.DB.prepare('DELETE FROM action_items WHERE inspection_id = ?').bind(inspectionId).run();

    // 3. Logs (ligados a inspeÃ§Ã£o)
    await env.DB.prepare('DELETE FROM inspection_logs WHERE inspection_id = ?').bind(inspectionId).run();

    // 4. Itens da InspeÃ§Ã£o (agora seguro deletar)
    await env.DB.prepare('DELETE FROM inspection_items WHERE inspection_id = ?').bind(inspectionId).run();

    // 5. A InspeÃ§Ã£o
    await env.DB.prepare('DELETE FROM inspections WHERE id = ?').bind(inspectionId).run();

    return c.json({
      success: true,
      message: 'InspeÃ§Ã£o excluÃ­da com sucesso'
    });
  } catch (error: any) {
    console.error('Erro ao excluir inspeÃ§Ã£o:', error);
    return c.json({
      error: 'Erro ao excluir inspeÃ§Ã£o',
      message: error.message,
      stack: error.stack,
      details: JSON.stringify(error)
    }, 500);
  }
});


// Generate Full AI Analysis for Inspection (Action Plan)
inspectionRoutes.post("/:id/ai-analysis", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (!env.OPENAI_API_KEY) {
    return c.json({ error: "IA nÃ£o disponÃ­vel" }, 503);
  }

  try {
    const body = await c.req.json();
    const { media_urls, inspection_context, non_compliant_items } = body;

    // Verify access
    const inspection = await env.DB.prepare("SELECT * FROM inspections WHERE id = ?").bind(inspectionId).first() as any;
    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Increment AI Usage
    let usageIncremented = false;
    try {
      const userId = user.id || (user as any).sub;
      const userProfile = await env.DB.prepare(
        "SELECT organization_id FROM users WHERE id = ?"
      ).bind(userId).first() as { organization_id?: number };

      if (userProfile?.organization_id) {
        await env.DB.prepare(
          "UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?"
        ).bind(userProfile.organization_id).run();

        usageIncremented = true;

        try {
          await env.DB.prepare(`
             INSERT INTO ai_usage_log (organization_id, user_id, feature_type, model_used, status, created_at)
             VALUES (?, ?, 'analysis', ?, 'success', NOW())
           `).bind(userProfile.organization_id, userId, 'gpt-4o-mini').run();
        } catch (e) { /* ignore log error */ }
      }
    } catch (usageErr) {
      console.error("Failed to increment AI usage:", usageErr);
    }

    // Prepare OpenAI Prompt
    const systemMessage = {
      role: 'system',
      content: 'VocÃª Ã© um especialista sÃªnior em SeguranÃ§a do Trabalho. Sua funÃ§Ã£o Ã© analisar listas de nÃ£o conformidades e gerar um PLANO DE AÃ‡ÃƒO PRÃTICO e assertivo.'
    };

    const userMessage = {
      role: 'user',
      content: `CONTEXTO DA INSPEÃ‡ÃƒO:
${inspection_context}

ITENS NÃƒO CONFORMES IDENTIFICADOS:
${non_compliant_items.join('\n')}

EVIDÃŠNCIAS:
${media_urls?.length || 0} arquivos de mÃ­dia anexados pelo inspetor.

TAREFA:
Com base APENAS nos itens nÃ£o conformes listados, gere um PLANO DE AÃ‡ÃƒO consolidado.
O plano deve ser prÃ¡tico, direto e focado em resolver os problemas de seguranÃ§a.

Retorne APENAS um JSON no seguinte formato:
{
  "action_plan": "Texto completo do plano de aÃ§Ã£o formatado em Markdown (use tÃ³picos, negrito para destaque)",
  "priority": "alta|media|baixa",
  "estimated_time": "Tempo estimado para resoluÃ§Ã£o (ex: 5 dias)"
}`
    };

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [systemMessage, userMessage],
        temperature: 0.4,
        max_tokens: 2000
      })
    });

    if (!response.ok) {
      throw new Error('Falha na comunicaÃ§Ã£o com a OpenAI');
    }

    const aiData = await response.json();
    const content = aiData.choices?.[0]?.message?.content;

    let result;
    try {
      result = JSON.parse(content);
    } catch (e) {
      // Fallback for plain text
      result = { action_plan: content, priority: 'media' };
    }

    // Save Action Plan to Inspection
    await env.DB.prepare("UPDATE inspections SET action_plan = ?, updated_at = NOW() WHERE id = ?")
      .bind(result.action_plan, inspectionId).run();

    // Award XP (15 XP for full analysis)
    try {
      await addXP(user.id, 15, env.DB);
    } catch (xpError) {
      console.error('Error awarding XP:', xpError);
    }

    return c.json({
      success: true,
      action_plan: result.action_plan,
      priority: result.priority,
      ai_usage_incremented: usageIncremented
    });

  } catch (error) {
    console.error('Error in AI Analysis:', error);
    return c.json({ error: "Erro ao gerar anÃ¡lise de IA" }, 500);
  }
});


// Generate field response with AI for inspection items
inspectionRoutes.post("/items/:itemId/generate-field-response", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (!env.OPENAI_API_KEY) {
    return c.json({ error: "IA nÃ£o disponÃ­vel" }, 503);
  }

  try {
    const body = await c.req.json();
    const { field_name, field_type, current_response, media_data, field_options } = body;

    // Increment AI Usage
    let usageIncremented = false;
    try {
      const userId = user.id || (user as any).sub;
      const userProfile = await env.DB.prepare(
        "SELECT organization_id FROM users WHERE id = ?"
      ).bind(userId).first() as { organization_id?: number };

      if (userProfile?.organization_id) {
        await env.DB.prepare(
          "UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?"
        ).bind(userProfile.organization_id).run();

        usageIncremented = true;

        try {
          await env.DB.prepare(`
             INSERT INTO ai_usage_log (organization_id, user_id, feature_type, model_used, status, created_at)
             VALUES (?, ?, 'analysis', ?, 'success', NOW())
           `).bind(userProfile.organization_id, userId, 'gpt-4o-mini').run();
        } catch (e) { /* ignore log error */ }
      }
    } catch (usageErr) {
      console.error("Failed to increment AI usage:", usageErr);
    }

    // Get inspection item and context
    const item = await env.DB.prepare(`
      SELECT ii.*, i.location, i.company_name, i.title as inspection_title
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
  `).bind(itemId).first() as any;

    if (!item) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // Parse field options
    let availableOptions: string[] = [];
    if (field_options) {
      try {
        if (typeof field_options === 'string' && field_options.startsWith('[')) {
          availableOptions = JSON.parse(field_options);
        } else if (typeof field_options === 'string') {
          availableOptions = field_options.split('|').map(opt => opt.trim()).filter(opt => opt);
        } else if (Array.isArray(field_options)) {
          availableOptions = field_options;
        }
      } catch (error) {
        console.error('Error parsing field options:', error);
      }
    }

    // CORRIGIDO: Preparar anÃ¡lise multimodal real das evidÃªncias  
    let mediaAnalysisContent = '';
    let mediaAnalyzed = 0;
    let mediaAnalysisMessages = [];

    if (media_data && media_data.length > 0) {
      mediaAnalyzed = media_data.length;
      const mediaTypes = media_data.reduce((acc: any, media: any) => {
        acc[media.media_type] = (acc[media.media_type] || 0) + 1;
        return acc;
      }, {});

      mediaAnalysisContent = `EVIDÃŠNCIAS MULTIMODAIS PARA ANÃLISE: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} Ã¡udio(s), ${mediaTypes.video || 0} vÃ­deo(s) foram analisados para gerar a resposta.`;

      // Preparar imagens para anÃ¡lise visual (mÃ¡ximo 3 para evitar timeout)
      const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);
      for (const img of imageMedia) {
        if (img.file_url) {
          mediaAnalysisMessages.push({
            type: "image_url",
            image_url: {
              url: img.file_url,
              detail: "high" // Para anÃ¡lise detalhada mesmo com gpt-4o-mini
            }
          });
        }
      }

      // Adicionar descriÃ§Ã£o de Ã¡udios/vÃ­deos se existirem
      const audioCount = mediaTypes.audio || 0;
      const videoCount = mediaTypes.video || 0;
      if (audioCount > 0 || videoCount > 0) {
        mediaAnalysisContent += ` Inclui ${audioCount} Ã¡udio(s) e ${videoCount} vÃ­deo(s) que podem conter evidÃªncias sonoras importantes.IMPORTANTE: PeÃ§a para o usuÃ¡rio descrever o conteÃºdo dos Ã¡udios no prompt personalizado para anÃ¡lise completa.`;
      }
    } else {
      mediaAnalysisContent = `EVIDÃŠNCIAS DISPONÃVEIS: Nenhuma mÃ­dia anexada.Resposta baseada no contexto da inspeÃ§Ã£o e conhecimento tÃ©cnico.`;
    }

    // Create specialized prompt based on field type
    let responseInstructions = '';
    switch (field_type) {
      case 'boolean':
        responseInstructions = `
RESPOSTA ESPERADA: true(Conforme) ou false(NÃ£o Conforme)
CRITÃ‰RIO: Avalie se o item estÃ¡ em conformidade com as normas de seguranÃ§a baseado nas evidÃªncias visuais / sonoras.`;
        break;
      case 'select':
      case 'radio':
        if (availableOptions.length > 0) {
          responseInstructions = `
RESPOSTA ESPERADA: Uma das opÃ§Ãµes disponÃ­veis: ${availableOptions.join(', ')}
CRITÃ‰RIO: Escolha a opÃ§Ã£o que melhor descreve o que foi observado nas evidÃªncias.`;
        } else {
          responseInstructions = `
RESPOSTA ESPERADA: Uma descriÃ§Ã£o textual da condiÃ§Ã£o observada nas evidÃªncias.`;
        }
        break;
      case 'multiselect':
        if (availableOptions.length > 0) {
          responseInstructions = `
RESPOSTA ESPERADA: Array com uma ou mais opÃ§Ãµes: ${availableOptions.join(', ')}
CRITÃ‰RIO: Selecione todas as opÃ§Ãµes que se aplicam ao que foi observado.`;
        }
        break;
      case 'rating':
        responseInstructions = `
RESPOSTA ESPERADA: NÃºmero de 1 a 5(1 = Inadequado, 5 = Excelente)
CRITÃ‰RIO: Avalie baseado no que foi observado nas evidÃªncias visuais / sonoras.`;
        break;
      case 'text':
      case 'textarea':
        responseInstructions = `
RESPOSTA ESPERADA: DescriÃ§Ã£o textual detalhada
CRITÃ‰RIO: Descreva especificamente o que foi observado nas evidÃªncias de forma tÃ©cnica.`;
        break;
      default:
        responseInstructions = `
RESPOSTA ESPERADA: Valor adequado baseado na anÃ¡lise das evidÃªncias disponÃ­veis.`;
    }

    // Construir mensagens para OpenAI incluindo anÃ¡lise visual detalhada
    const systemMessage = {
      role: 'system',
      content: 'VocÃª Ã© um especialista em seguranÃ§a do trabalho especializado em anÃ¡lise multimodal avanÃ§ada. Sua funÃ§Ã£o Ã© analisar imagens, Ã¡udios, vÃ­deos e contexto para gerar respostas tÃ©cnicas precisas e detalhadas baseadas em evidÃªncias reais. SEMPRE descreva especificamente o que observa nas imagens em relaÃ§Ã£o Ã  seguranÃ§a do trabalho. Para Ã¡udios, identifique ruÃ­dos, comunicaÃ§Ãµes verbais e, se for assistente psicossocial, analise tom de voz, sinais de estresse, ansiedade ou bem-estar emocional. Seja tÃ©cnico, detalhado e especÃ­fico sobre as evidÃªncias analisadas.'
    };

    const userMessage = {
      role: 'user',
      content: [
        {
          type: "text",
          text: `Analise as evidÃªncias multimodais e gere uma resposta tÃ©cnica detalhada para este campo.

CONTEXTO DA INSPEÃ‡ÃƒO:
- Local: ${item.location}
- Empresa: ${item.company_name}
- InspeÃ§Ã£o: ${item.inspection_title}

ITEM EM ANÃLISE:
- Campo: ${field_name}
- Categoria: ${item.category}
- DescriÃ§Ã£o: ${item.item_description}
- ObservaÃ§Ãµes existentes: ${item.observations || 'Nenhuma'}
- Resposta atual: ${current_response !== null && current_response !== undefined ? current_response : 'NÃ£o respondido'}

${mediaAnalysisContent}

${responseInstructions}

INSTRUÃ‡Ã•ES ESPECÃFICAS PARA ANÃLISE DETALHADA:
1. ** ANÃLISE VISUAL(se houver imagens) **: Descreva especificamente o que vÃª nas imagens relacionado Ã  seguranÃ§a do trabalho:
  - CondiÃ§Ãµes dos equipamentos, estruturas, ambiente
    - EPIs(Equipamentos de ProteÃ§Ã£o Individual) presentes ou ausentes
      - SinalizaÃ§Ãµes de seguranÃ§a, placas, avisos
        - CondiÃ§Ãµes de limpeza, organizaÃ§Ã£o, 5S
          - Riscos visuais identificados(altura, energia, produtos quÃ­micos, etc.)
            - Estado de conservaÃ§Ã£o de materiais, ferramentas, instalaÃ§Ãµes

2. ** ANÃLISE SONORA(se houver Ã¡udios / vÃ­deos) **:
- RuÃ­dos de mÃ¡quinas, equipamentos(nÃ­veis, anormalidades)
  - ComunicaÃ§Ãµes verbais sobre seguranÃ§a
    - Sons que indicam riscos(vazamentos, falhas mecÃ¢nicas)
      - Para assistentes psicossociais: tom de voz, sinais de estresse, ansiedade

3. ** CONFORMIDADE TÃ‰CNICA **: Avalie conformidade com NRs aplicÃ¡veis
4. ** EVIDÃŠNCIAS ESPECÃFICAS **: Cite detalhes visuais / sonoros concretos observados
5. ** RECOMENDAÃ‡Ã•ES **: Base nas evidÃªncias analisadas

Responda APENAS em formato JSON(mÃ¡ximo 400 caracteres no comentÃ¡rio):
{
  "generated_response": <valor_da_resposta>,
    "generated_comment": "AnÃ¡lise tÃ©cnica detalhada baseada nas evidÃªncias visuais/sonoras observadas. Descreva especificamente o que foi visto/ouvido.",
      "confidence": "alta|media|baixa",
        "media_analyzed": ${mediaAnalyzed},
  "visual_observations": "DescriÃ§Ã£o especÃ­fica do que foi visto nas imagens - condiÃ§Ãµes, EPIs, riscos, conformidade visual",
    "technical_assessment": "AvaliaÃ§Ã£o de conformidade tÃ©cnica baseada nas evidÃªncias"
}

Seja especÃ­fico sobre as evidÃªncias analisadas e cite detalhes visuais / sonoros concretos.`
        },
        ...mediaAnalysisMessages
      ]
    };

    const messages = [systemMessage, userMessage];

    // CORRIGIDO: Call OpenAI API com anÃ¡lise multimodal
    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENAI_API_KEY} `,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini', // MudanÃ§a solicitada para gpt-4o-mini
        messages: messages,
        max_tokens: 2000, // Aumentado para anÃ¡lise mais detalhada
        temperature: 0.3 // Reduzido para mais consistÃªncia
      })
    });

    if (!openaiResponse.ok) {
      const errorText = await openaiResponse.text();
      console.error('OpenAI API Error:', openaiResponse.status, errorText);
      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status} - ${errorText} `);
    }

    const openaiResult = await openaiResponse.json() as any;
    const content = openaiResult.choices?.[0]?.message?.content;

    if (!content) {
      throw new Error('Resposta invÃ¡lida da IA');
    }

    // Parse AI response
    let aiResult;
    try {
      aiResult = JSON.parse(content);
    } catch (parseError) {
      // Try to extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        aiResult = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('Falha ao parsear resposta da IA como JSON');
      }
    }

    // Validate and clean response based on field type
    let finalResponse = aiResult.generated_response;

    if (field_type === 'boolean') {
      if (typeof finalResponse === 'string') {
        finalResponse = finalResponse.toLowerCase() === 'true' || finalResponse === '1';
      } else if (typeof finalResponse !== 'boolean') {
        finalResponse = null;
      }
    } else if (field_type === 'multiselect') {
      if (!Array.isArray(finalResponse)) {
        if (typeof finalResponse === 'string') {
          finalResponse = [finalResponse];
        } else {
          finalResponse = [];
        }
      }
      // Filter to only valid options if available
      if (availableOptions.length > 0) {
        finalResponse = finalResponse.filter((opt: string) => availableOptions.includes(opt));
      }
    } else if ((field_type === 'select' || field_type === 'radio') && availableOptions.length > 0) {
      // Ensure response is one of the available options
      if (!availableOptions.includes(finalResponse)) {
        finalResponse = availableOptions[0]; // Default to first option
      }
    } else if (field_type === 'rating') {
      const numResponse = parseInt(finalResponse);
      if (isNaN(numResponse) || numResponse < 1 || numResponse > 5) {
        finalResponse = 3; // Default to middle rating
      } else {
        finalResponse = numResponse;
      }
    }

    const responseJson = {
      success: true,
      ai_usage_incremented: usageIncremented,
      generated_response: finalResponse,
      generated_comment: aiResult.generated_comment || '',
      confidence: aiResult.confidence || 'media',
      media_analyzed: mediaAnalyzed,
      item_id: itemId,
      timestamp: new Date().toISOString()
    };

    // Award XP (5 XP for field help)
    // Note: We intentionally do this after sending response to not block UI, but technically Hono waits. 
    // Ideally use waitUntil but not available here easily without ctx.
    try {
      await addXP(user.id, 5, env.DB);
    } catch (e) { console.error('XP Error', e); }

    return c.json(responseJson);



  } catch (error) {
    console.error('Error generating field response:', error);
    return c.json({
      error: "Erro ao gerar resposta do campo",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Get media for specific inspection item
inspectionRoutes.get("/items/:itemId/media", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get inspection item to verify access
    const item = await env.DB.prepare(`
      SELECT ii.*, i.created_by, i.organization_id
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
  `).bind(itemId).first() as any;

    if (!item) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // Get media for this item
    const media = await env.DB.prepare(`
      SELECT * FROM inspection_media 
      WHERE inspection_item_id = ?
  ORDER BY created_at DESC
    `).bind(itemId).all();

    return c.json({
      media: media.results || []
    });

  } catch (error) {
    console.error('Error fetching inspection item media:', error);
    return c.json({ error: "Erro ao buscar mÃ­dia do item" }, 500);
  }
});

// Upload media for inspection item
inspectionRoutes.post("/items/:itemId/media", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const {
      media_type, file_name, file_url, file_size, mime_type, description
    } = body;

    // Get inspection item to get inspection_id
    const item = await env.DB.prepare(`
      SELECT inspection_id FROM inspection_items WHERE id = ?
  `).bind(itemId).first() as any;

    if (!item) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // Insert media record
    const result = await env.DB.prepare(`
      INSERT INTO inspection_media(
    inspection_id, inspection_item_id, media_type, file_name, file_url,
    file_size, mime_type, description, created_at, updated_at
  ) VALUES(?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
    `).bind(
      item.inspection_id,
      itemId,
      media_type,
      file_name,
      file_url,
      file_size || null,
      mime_type || null,
      description || null
    ).run();

    return c.json({
      id: result.meta.last_row_id,
      message: "MÃ­dia enviada com sucesso"
    });

  } catch (error) {
    console.error('Error uploading media:', error);
    return c.json({ error: "Erro ao enviar mÃ­dia" }, 500);
  }
});

// Create AI-generated action item for inspection item
inspectionRoutes.post("/items/:itemId/create-action", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (!env.OPENAI_API_KEY) {
    return c.json({ error: "IA nÃ£o disponÃ­vel" }, 503);
  }

  try {
    const body = await c.req.json();
    const { field_name, field_type, response_value, pre_analysis, media_data, user_prompt } = body;

    // Increment AI Usage
    let usageIncremented = false;
    try {
      const userId = user.id || (user as any).sub;
      const userProfile = await env.DB.prepare(
        "SELECT organization_id FROM users WHERE id = ?"
      ).bind(userId).first() as { organization_id?: number };

      if (userProfile?.organization_id) {
        await env.DB.prepare(
          "UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?"
        ).bind(userProfile.organization_id).run();

        usageIncremented = true;

        try {
          await env.DB.prepare(`
             INSERT INTO ai_usage_log (organization_id, user_id, feature_type, model_used, status, created_at)
             VALUES (?, ?, 'action_plan', ?, 'success', NOW())
           `).bind(userProfile.organization_id, userId, 'gpt-4o-mini').run();
        } catch (e) { /* ignore log error */ }
      }
    } catch (usageErr) {
      console.error("Failed to increment AI usage:", usageErr);
    }

    // Get inspection item and context
    const item = await env.DB.prepare(`
      SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
  `).bind(itemId).first() as any;

    if (!item) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // CORRIGIDO: LÃ³gica melhorada para determinar necessidade de aÃ§Ã£o
    let needsAction = false;
    let riskLevel = 'baixo';
    let actionReason = '';

    // 1. Verificar resposta direta de nÃ£o conformidade
    if (field_type === 'boolean' && response_value === false) {
      needsAction = true;
      riskLevel = 'alto';
      actionReason = 'Item marcado como nÃ£o conforme';
    } else if (field_type === 'rating' && response_value <= 2) {
      needsAction = true;
      riskLevel = response_value === 1 ? 'critica' : 'alta';
      actionReason = `AvaliaÃ§Ã£o baixa(${response_value} / 5)`;
    } else if (field_type === 'select' && response_value) {
      const valueStr = response_value.toLowerCase();
      if (valueStr.includes('nÃ£o conforme') || valueStr.includes('inadequado') ||
        valueStr.includes('nÃ£o aplicÃ¡vel') === false && valueStr.includes('conforme') === false) {
        needsAction = true;
        riskLevel = 'media';
        actionReason = `Resposta indica nÃ£o conformidade: ${response_value} `;
      }
    }

    // 2. Verificar anÃ¡lise prÃ©via para identificar riscos
    if (pre_analysis && !needsAction) {
      const analysisText = pre_analysis.toLowerCase();
      const riskKeywords = [
        'nÃ£o conforme', 'inadequado', 'risco', 'perigo', 'incorreto', 'falha',
        'violaÃ§Ã£o', 'infraÃ§Ã£o', 'necessÃ¡rio', 'corrigir', 'ajustar', 'melhorar',
        'aÃ§Ã£o', 'problema', 'deficiÃªncia', 'insuficiente'
      ];

      const foundRisks = riskKeywords.filter(keyword => analysisText.includes(keyword));
      if (foundRisks.length >= 2) {
        needsAction = true;
        riskLevel = 'media';
        actionReason = `AnÃ¡lise prÃ©via identificou riscos: ${foundRisks.slice(0, 3).join(', ')} `;
      }
    }

    // 3. Se ainda nÃ£o identificou necessidade, deixar a IA decidir baseada em evidÃªncias
    if (!needsAction && (media_data?.length > 0 || pre_analysis)) {
      needsAction = true; // Permitir que a IA analise e decida
      riskLevel = 'media';
      actionReason = 'AnÃ¡lise inteligente das evidÃªncias disponÃ­veis';
    }

    // ÃšLTIMA VALIDAÃ‡ÃƒO: Se realmente nÃ£o hÃ¡ nada para analisar
    if (!needsAction && !response_value && !pre_analysis && (!media_data || media_data.length === 0)) {
      return c.json({
        success: true,
        action: {
          requires_action: false,
          message: "NÃ£o hÃ¡ evidÃªncias suficientes (resposta, anÃ¡lise ou mÃ­dias) para determinar necessidade de aÃ§Ã£o. Adicione mais informaÃ§Ãµes para anÃ¡lise."
        }
      });
    }

    // CORRIGIDO: Preparar anÃ¡lise multimodal real das evidÃªncias
    let mediaContext = '';
    let mediaAnalysisMessages = [];

    if (media_data && media_data.length > 0) {
      const mediaTypes = media_data.reduce((acc: any, media: any) => {
        acc[media.media_type] = (acc[media.media_type] || 0) + 1;
        return acc;
      }, {});

      mediaContext = `EVIDÃŠNCIAS MULTIMODAIS ANALISADAS: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} Ã¡udio(s), ${mediaTypes.video || 0} vÃ­deo(s).`;

      // Preparar imagens para anÃ¡lise visual (mÃ¡ximo 3 para evitar timeout)
      const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);
      for (const img of imageMedia) {
        if (img.file_url) {
          mediaAnalysisMessages.push({
            type: "image_url",
            image_url: {
              url: img.file_url,
              detail: "high" // Para anÃ¡lise detalhada com gpt-4o-mini
            }
          });
        }
      }

      // Adicionar descriÃ§Ã£o de Ã¡udios/vÃ­deos se existirem
      const audioCount = mediaTypes.audio || 0;
      const videoCount = mediaTypes.video || 0;
      if (audioCount > 0 || videoCount > 0) {
        mediaContext += ` Inclui ${audioCount} Ã¡udio(s) e ${videoCount} vÃ­deo(s) que podem conter evidÃªncias sonoras de nÃ£o conformidades, comunicaÃ§Ãµes, sinais de estresse ou preocupaÃ§Ã£o.`;
      }
    } else {
      mediaContext = `EVIDÃŠNCIAS DISPONÃVEIS: Nenhuma mÃ­dia anexada.AÃ§Ã£o baseada na resposta e anÃ¡lise prÃ©via.`;
    }

    // Construir mensagens para OpenAI incluindo anÃ¡lise visual
    const systemMessage = {
      role: 'system',
      content: 'VocÃª Ã© um especialista em seguranÃ§a do trabalho especializado em anÃ¡lise multimodal. Analise imagens, Ã¡udios, textos e contexto para criar planos de aÃ§Ã£o 5W2H precisos baseados em evidÃªncias reais. Para Ã¡udios, considere o conteÃºdo sonoro e, se for assistente psicossocial, analise tambÃ©m tom de voz e sinais de bem-estar emocional.'
    };

    const userMessage = {
      role: 'user',
      content: [
        {
          type: "text",
          text: `Analise as evidÃªncias multimodais e determine se Ã© necessÃ¡ria uma aÃ§Ã£o corretiva com base em anÃ¡lise tÃ©cnica detalhada.

CONTEXTO DA INSPEÃ‡ÃƒO:
- Local: ${item.location}
- Empresa: ${item.company_name}
- Item: ${field_name} (${item.category})
- DescriÃ§Ã£o: ${item.item_description}
- Resposta do Inspetor: ${response_value || 'NÃ£o respondido'}
- Motivo da AnÃ¡lise: ${actionReason}
- NÃ­vel de Risco Inicial: ${riskLevel}
- ObservaÃ§Ãµes: ${item.observations || 'Nenhuma'}

${mediaContext}

${pre_analysis ? `ANÃLISE PRÃ‰VIA DA IA:
${pre_analysis}

IMPORTANTE: Sua decisÃ£o deve ser coerente com esta anÃ¡lise prÃ©via.` : ''
            }

${user_prompt ? `FOCO ESPECÃFICO DO USUÃRIO: ${user_prompt} - Priorize esta informaÃ§Ã£o.` : ''}

INSTRUÃ‡Ã•ES PARA ANÃLISE COMPLETA E CRIAÃ‡ÃƒO DE PLANO 5W2H:

1. ** ANÃLISE MULTIMODAL DETALHADA **:
   - ** Imagens **: Descreva especificamente condiÃ§Ãµes visuais de seguranÃ§a, EPIs, riscos, nÃ£o conformidades
  - ** Ãudios / VÃ­deos **: Analise ruÃ­dos, comunicaÃ§Ãµes, sinais sonoros de risco
    - ** Assistentes Psicossociais **: Analise tom emocional, estresse, sinais de bem - estar

2. ** AVALIAÃ‡ÃƒO DE CONFORMIDADE TÃ‰CNICA **:
- Identifique nÃ£o conformidades especÃ­ficas com NRs
  - Avalie causa raiz do problema
    - Determine gravidade e urgÃªncia

3. ** PLANO 5W2H ESPECÃFICO ** (se aÃ§Ã£o necessÃ¡ria):
   - ** O QUÃŠ **: AÃ§Ã£o corretiva especÃ­fica baseada nas evidÃªncias
  - ** ONDE **: Local exato onde aplicar a correÃ§Ã£o
    - ** POR QUÃŠ **: Justificativa baseada nos riscos e evidÃªncias identificadas
      - ** COMO **: MÃ©todo detalhado de execuÃ§Ã£o
        - ** QUEM **: ResponsÃ¡vel especÃ­fico(ex: tÃ©cnico em seguranÃ§a, supervisor)
          - ** QUANDO **: Prazo realÃ­stico baseado na urgÃªncia
            - ** QUANTO **: Estimativa de recursos necessÃ¡rios

4. ** DECISÃƒO TÃ‰CNICA **: Se nÃ£o hÃ¡ necessidade de aÃ§Ã£o, justifique tecnicamente

Responda APENAS em formato JSON:
{
  "requires_action": true / false,
    "title": "TÃ­tulo especÃ­fico da aÃ§Ã£o ou motivo tÃ©cnico de nÃ£o necessidade",
      "what_description": "AÃ§Ã£o especÃ­fica detalhada ou justificativa tÃ©cnica de nÃ£o necessidade",
        "where_location": "Local especÃ­fico ou N/A",
          "why_reason": "Justificativa tÃ©cnica baseada nas evidÃªncias visuais/sonoras analisadas",
            "how_method": "MÃ©todo detalhado de execuÃ§Ã£o ou N/A",
              "who_responsible": "ResponsÃ¡vel especÃ­fico (ex: TÃ©cnico em SeguranÃ§a, Supervisor) ou N/A",
                "when_deadline": "Prazo em dias baseado na urgÃªncia ou 0",
                  "how_much_cost": "Estimativa realÃ­stica ou 'Sem custo'",
                    "priority": "baixa|media|alta|critica",
                      "evidence_analysis": "Resumo tÃ©cnico detalhado do que foi observado nas evidÃªncias multimodais",
                        "visual_findings": "DescriÃ§Ã£o especÃ­fica e tÃ©cnica do que foi visto nas imagens relacionado Ã  seguranÃ§a",
                          "compliance_assessment": "AvaliaÃ§Ã£o de conformidade com normas tÃ©cnicas aplicÃ¡veis"
}

Base sua decisÃ£o exclusivamente nas evidÃªncias analisadas e seja especÃ­fico sobre os achados visuais / sonoros.`
        },
        ...mediaAnalysisMessages
      ]
    };

    const messages = [systemMessage, userMessage];

    // CORRIGIDO: Call OpenAI API com anÃ¡lise multimodal detalhada
    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENAI_API_KEY} `,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini', // MudanÃ§a solicitada para gpt-4o-mini
        messages: messages,
        max_tokens: 2000, // Aumentado para anÃ¡lise mais detalhada
        temperature: 0.3 // Reduzido para mais consistÃªncia
      })
    });

    if (!openaiResponse.ok) {
      const errorText = await openaiResponse.text();
      console.error('OpenAI API Error:', openaiResponse.status, errorText);
      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status} `);
    }

    // Robust JSON parsing with HTML error handling
    let openaiResult;
    try {
      const responseText = await openaiResponse.text();

      // Check if response is HTML (common error response format)
      if (responseText.trim().startsWith('<')) {
        console.error('OpenAI returned HTML instead of JSON:', responseText);
        throw new Error('API da OpenAI retornou resposta invÃ¡lida (HTML). Verifique a chave da API e tente novamente.');
      }

      openaiResult = JSON.parse(responseText);
    } catch (parseError) {
      console.error('Failed to parse OpenAI response:', parseError);
      throw new Error('Erro ao processar resposta da IA. Tente novamente.');
    }

    const content = openaiResult.choices?.[0]?.message?.content;

    if (!content) {
      throw new Error('Resposta invÃ¡lida da IA');
    }

    // Parse AI response
    let actionPlan;
    try {
      actionPlan = JSON.parse(content);
    } catch (parseError) {
      // Try to extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        actionPlan = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('Falha ao parsear resposta da IA como JSON');
      }
    }

    if (actionPlan.requires_action) {
      // Calculate deadline
      const deadlineDays = parseInt(actionPlan.when_deadline) || 30;
      const deadlineDate = new Date();
      deadlineDate.setDate(deadlineDate.getDate() + deadlineDays);

      // Create action item in database
      const result = await env.DB.prepare(`
        INSERT INTO action_items(
  inspection_id, inspection_item_id, title, what_description, where_location,
  why_reason, how_method, who_responsible, when_deadline, how_much_cost,
  status, priority, is_ai_generated, assigned_to, created_at, updated_at
) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
  `).bind(
        item.inspection_id,
        itemId,
        actionPlan.title,
        actionPlan.what_description,
        actionPlan.where_location,
        actionPlan.why_reason,
        actionPlan.how_method,
        actionPlan.who_responsible,
        deadlineDate.toISOString().split('T')[0],
        actionPlan.how_much_cost,
        'pending',
        actionPlan.priority || 'media',
        true,
        actionPlan.who_responsible,
      ).run();

      // Update action plan in inspection item with enhanced analysis
      const enhancedPlan = {
        ...actionPlan,
        evidence_analysis: actionPlan.evidence_analysis || 'AnÃ¡lise baseada em evidÃªncias disponÃ­veis',
        visual_findings: actionPlan.visual_findings || 'Nenhuma anÃ¡lise visual especÃ­fica',
        media_analyzed: media_data ? media_data.length : 0,
        analysis_type: mediaAnalysisMessages.length > 0 ? 'multimodal' : 'textual'
      };

      await env.DB.prepare(`
        UPDATE inspection_items 
        SET ai_action_plan = ?, updated_at = NOW()
        WHERE id = ?
  `).bind(JSON.stringify(enhancedPlan), itemId).run();

      actionPlan.id = result.meta.last_row_id;
      actionPlan.evidence_analysis = enhancedPlan.evidence_analysis;
      actionPlan.visual_findings = enhancedPlan.visual_findings;
      actionPlan.visual_findings = enhancedPlan.visual_findings;
    }

    // Award XP (10 XP for creating action item)
    try {
      await addXP(user.id, 10, env.DB);
    } catch (e) { console.error('XP Error', e); }

    return c.json({
      success: true,
      ai_usage_incremented: usageIncremented,
      action: actionPlan,
      item_id: itemId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error creating action with AI:', error);
    return c.json({
      error: "Erro ao criar aÃ§Ã£o com IA",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Pre-analysis endpoint for inspection items
inspectionRoutes.post("/items/:itemId/pre-analysis", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const itemId = parseInt(c.req.param("itemId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  if (!env.OPENAI_API_KEY) {
    return c.json({ error: "IA nÃ£o configurada no sistema" }, 503);
  }

  try {
    const body = await c.req.json();
    const { field_name, field_type, response_value, media_data, user_prompt } = body;

    // Increment AI Usage
    let usageIncremented = false;
    try {
      const userId = user.id || (user as any).sub;
      const userProfile = await env.DB.prepare(
        "SELECT organization_id FROM users WHERE id = ?"
      ).bind(userId).first() as { organization_id?: number };

      if (userProfile?.organization_id) {
        await env.DB.prepare(
          "UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?"
        ).bind(userProfile.organization_id).run();

        usageIncremented = true;

        try {
          await env.DB.prepare(`
             INSERT INTO ai_usage_log (organization_id, user_id, feature_type, model_used, status, created_at)
             VALUES (?, ?, 'pre_analysis', ?, 'success', NOW())
           `).bind(userProfile.organization_id, userId, 'gpt-4o-mini').run();
        } catch (e) { /* ignore log error */ }
      }
    } catch (usageErr) {
      console.error("Failed to increment AI usage:", usageErr);
    }

    // Get inspection item with inspection context
    const item = await env.DB.prepare(`
      SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id
      FROM inspection_items ii
      JOIN inspections i ON ii.inspection_id = i.id
      WHERE ii.id = ?
  `).bind(itemId).first() as any;

    if (!item) {
      return c.json({ error: "Item de inspeÃ§Ã£o nÃ£o encontrado" }, 404);
    }

    // CORRIGIDO: Preparar anÃ¡lise multimodal real das evidÃªncias
    let mediaAnalysisContent = '';
    let mediaAnalyzed = 0;
    let mediaAnalysisMessages = [];

    if (media_data && media_data.length > 0) {
      mediaAnalyzed = media_data.length;
      const mediaTypes = media_data.reduce((acc: any, media: any) => {
        acc[media.media_type] = (acc[media.media_type] || 0) + 1;
        return acc;
      }, {});

      mediaAnalysisContent = `EVIDÃŠNCIAS MULTIMODAIS DISPONÃVEIS: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} Ã¡udio(s), ${mediaTypes.video || 0} vÃ­deo(s) para anÃ¡lise detalhada.`;

      // Preparar imagens para anÃ¡lise visual (mÃ¡ximo 3 para evitar timeout)
      const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);
      for (const img of imageMedia) {
        if (img.file_url) {
          mediaAnalysisMessages.push({
            type: "image_url",
            image_url: {
              url: img.file_url,
              detail: "high" // Para anÃ¡lise detalhada na prÃ©-anÃ¡lise
            }
          });
        }
      }

      // Adicionar descriÃ§Ã£o de Ã¡udios/vÃ­deos se existirem
      const audioCount = mediaTypes.audio || 0;
      const videoCount = mediaTypes.video || 0;
      if (audioCount > 0 || videoCount > 0) {
        mediaAnalysisContent += ` Inclui ${audioCount} Ã¡udio(s) e ${videoCount} vÃ­deo(s) que podem conter evidÃªncias sonoras importantes, comunicaÃ§Ãµes verbais, tom de voz e sinais emocionais.`;
      }
    } else {
      mediaAnalysisContent = `EVIDÃŠNCIAS DISPONÃVEIS: Nenhuma mÃ­dia anexada.AnÃ¡lise baseada apenas na resposta do inspetor e contexto da inspeÃ§Ã£o.`;
    }

    // Construir mensagens para OpenAI incluindo anÃ¡lise visual
    const systemMessage = {
      role: 'system',
      content: 'VocÃª Ã© um especialista em seguranÃ§a do trabalho especializado em anÃ¡lise multimodal. Analise imagens, Ã¡udios, contexto e respostas para fornecer prÃ©-anÃ¡lises tÃ©cnicas detalhadas e prÃ¡ticas. Para Ã¡udios, considere conteÃºdo sonoro, comunicaÃ§Ãµes verbais e, se for assistente psicossocial, analise tom de voz, sinais de estresse, ansiedade ou bem-estar emocional.'
    };

    const userMessage = {
      role: 'user',
      content: [
        {
          type: "text",
          text: `FaÃ§a uma prÃ© - anÃ¡lise tÃ©cnica aprofundada e abrangente deste item de seguranÃ§a.

CONTEXTO DA INSPEÃ‡ÃƒO:
- Local: ${item.location}
- Empresa: ${item.company_name || 'NÃ£o informado'}
- TÃ­tulo da InspeÃ§Ã£o: ${item.inspection_title}

ITEM EM ANÃLISE:
- Campo: ${field_name}
- Tipo: ${field_type}
- Categoria: ${item.category}
- DescriÃ§Ã£o: ${item.item_description}
- Resposta: ${response_value !== null && response_value !== undefined ? response_value : 'NÃ£o respondido'}
- ObservaÃ§Ãµes: ${item.observations || 'Nenhuma observaÃ§Ã£o'}

${mediaAnalysisContent}

${user_prompt ? `FOCO ESPECÃFICO DO USUÃRIO: ${user_prompt} - PRIORIZE esta informaÃ§Ã£o em sua anÃ¡lise.` : ''}

INSTRUÃ‡Ã•ES PARA ANÃLISE TÃ‰CNICA DETALHADA:

1. ** ANÃLISE VISUAL DETALHADA(se houver imagens) **:
- Descreva especificamente condiÃ§Ãµes de seguranÃ§a observadas
  - Identifique EPIs presentes / ausentes, estado de conservaÃ§Ã£o
    - Avalie sinalizaÃ§Ãµes, placas, avisos de seguranÃ§a
      - Observe organizaÃ§Ã£o, limpeza, aplicaÃ§Ã£o de 5S
        - Identifique riscos visuais(altura, elÃ©tricos, quÃ­micos, mecÃ¢nicos)
          - Verifique conformidade visual com NRs aplicÃ¡veis

2. ** ANÃLISE SONORA(se houver Ã¡udios / vÃ­deos) **:
- Identifique ruÃ­dos de equipamentos, nÃ­veis sonoros
  - Analise comunicaÃ§Ãµes verbais sobre seguranÃ§a
    - Detecte sons anÃ´malos que indiquem riscos
      - Para assistentes psicossociais: analise tom emocional, estresse, ansiedade

3. ** AVALIAÃ‡ÃƒO DE CONFORMIDADE TÃ‰CNICA **:
- Cite NRs especÃ­ficas aplicÃ¡veis ao contexto
  - Identifique nÃ£o conformidades tÃ©cnicas especÃ­ficas
    - Avalie causa raiz de problemas identificados
      - Determine implicaÃ§Ãµes regulatÃ³rias

4. ** ANÃLISE DE RISCOS **:
- Classifique riscos por gravidade e probabilidade
  - Identifique consequÃªncias potenciais
    - Avalie urgÃªncia de aÃ§Ãµes corretivas
      - Considere impactos a longo prazo

5. ** RECOMENDAÃ‡Ã•ES ESPECÃFICAS **:
- Sugira aÃ§Ãµes corretivas concretas e acionÃ¡veis
  - Indique prioridade(Baixa / MÃ©dia / Alta / CrÃ­tica)
    - Recomende prazos para correÃ§Ãµes
      - Base tudo nas evidÃªncias analisadas

ForneÃ§a uma anÃ¡lise tÃ©cnica estruturada(mÃ¡ximo 600 caracteres) incluindo:
- ** ObservaÃ§Ãµes Detalhadas **: O que foi especificamente observado nas evidÃªncias
  - ** Conformidade **: AvaliaÃ§Ã£o clara conforme / nÃ£o conforme com normas
    - ** Riscos **: Riscos identificados com base nas evidÃªncias
      - ** UrgÃªncia **: NÃ­vel de prioridade para aÃ§Ã£o corretiva
        - ** RecomendaÃ§Ã£o **: AÃ§Ã£o necessÃ¡ria baseada na anÃ¡lise

Seja tÃ©cnico, especÃ­fico e cite detalhes visuais / sonoros concretos das evidÃªncias.`
        },
        ...mediaAnalysisMessages
      ]
    };

    const messages = [systemMessage, userMessage];

    // CORRIGIDO: Call OpenAI API com anÃ¡lise multimodal detalhada
    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENAI_API_KEY} `,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini', // MudanÃ§a solicitada para gpt-4o-mini
        messages: messages,
        max_tokens: 1500, // Aumentado para anÃ¡lise mais detalhada
        temperature: 0.4 // Ajustado para melhor anÃ¡lise
      })
    });

    if (!openaiResponse.ok) {
      const errorText = await openaiResponse.text();
      console.error('OpenAI API Error:', openaiResponse.status, errorText);
      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status} `);
    }

    const openaiResult = await openaiResponse.json() as any;
    const analysis = openaiResult.choices?.[0]?.message?.content;

    if (!analysis) {
      throw new Error('Resposta invÃ¡lida da IA');
    }

    // Update the inspection item with pre-analysis
    await env.DB.prepare(`
      UPDATE inspection_items 
      SET ai_pre_analysis = ?, updated_at = NOW()
      WHERE id = ?
  `).bind(analysis, itemId).run();

    // Award XP (5 XP for pre-analysis)
    try {
      await addXP(user.id, 5, env.DB);
    } catch (e) { console.error('XP Error', e); }

    return c.json({
      success: true,
      ai_usage_incremented: usageIncremented,
      pre_analysis: analysis,
      analysis: analysis, // For backward compatibility
      media_analyzed: mediaAnalyzed,
      item_id: itemId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error in pre-analysis:', error);
    return c.json({
      error: "Erro ao processar prÃ©-anÃ¡lise",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// NOTE: Media upload route REMOVED from here.
// The correct implementation is in media-routes.ts which uses Supabase Storage.
// Use /api/media/:inspectionId/media/upload instead of /api/inspections/:inspectionId/media/upload


// GET action items for inspection
inspectionRoutes.get("/:inspectionId/action-items", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("inspectionId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const actionItems = await env.DB.prepare(`
      SELECT ai.*, ii.item_description as inspection_item_name
      FROM action_items ai
      LEFT JOIN inspection_items ii ON ai.inspection_item_id = ii.id
      WHERE ai.inspection_id = ?
      ORDER BY ai.created_at DESC
    `).bind(inspectionId).all();

    return c.json(actionItems.results || []);
  } catch (error) {
    console.error('Error loading action items:', error);
    return c.json({ error: "Erro ao carregar aÃ§Ãµes" }, 500);
  }
});

// Create action item for inspection (Manual action creation)
inspectionRoutes.post("/:inspectionId/action-items", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("inspectionId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const {
      inspection_item_id,
      title,
      what_description,
      where_location,
      why_reason,
      how_method,
      who_responsible,
      when_deadline,
      how_much_cost,
      priority = 'media',
      status = 'pending',
      is_ai_generated = false,
      field_name
    } = body;

    // Verify inspection exists
    const inspection = await env.DB.prepare(`
      SELECT id, location, company_name, title FROM inspections WHERE id = ?
    `).bind(inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Resolve the correct inspection_item_id if provided
    let resolvedItemId = inspection_item_id;

    if (inspection_item_id) {
      // Check if ID exists directly
      const itemExists = await env.DB.prepare(`
        SELECT id FROM inspection_items WHERE id = ? AND inspection_id = ?
      `).bind(inspection_item_id, inspectionId).first();

      if (!itemExists && field_name) {
        // Fallback: Try to find by field_name
        const itemByName = await env.DB.prepare(`
          SELECT id FROM inspection_items 
          WHERE inspection_id = ? AND item_description = ?
        `).bind(inspectionId, field_name).first() as any;

        if (itemByName) {
          resolvedItemId = itemByName.id;
        } else {
          resolvedItemId = null; // Avoid FK error
        }
      } else if (!itemExists) {
        resolvedItemId = null;
      }
    }

    const now = new Date().toISOString();
    const deadline = when_deadline || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

    const result = await env.DB.prepare(`
      INSERT INTO action_items (
        inspection_id, inspection_item_id, title, what_description, where_location,
        why_reason, how_method, who_responsible, when_deadline, how_much_cost,
        priority, status, is_ai_generated, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      inspectionId,
      resolvedItemId || null,
      title || 'AÃ§Ã£o Corretiva',
      what_description || '',
      where_location || inspection.location || '',
      why_reason || '',
      how_method || '',
      who_responsible || 'A definir',
      deadline,
      how_much_cost || 'A orÃ§ar',
      priority,
      status,
      is_ai_generated,
      now,
      now
    ).run();

    return c.json({
      success: true,
      action_item: {
        id: result.meta.last_row_id,
        inspection_id: inspectionId,
        title,
        priority,
        status
      }
    }, 201);

  } catch (error) {
    console.error('Error creating action item:', error);
    return c.json({
      error: "Erro ao criar aÃ§Ã£o",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Get inspection history/logs
inspectionRoutes.get("/:id/history", tenantAuthMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("id"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Check if inspection_logs table exists and fetch logs
    const logs = await env.DB.prepare(`
            SELECT il.*, u.name as user_name
            FROM inspection_logs il
            LEFT JOIN users u ON il.user_id = u.id
            WHERE il.inspection_id = ?
            ORDER BY il.created_at DESC
            LIMIT 50
        `).bind(inspectionId).all();

    return c.json({
      success: true,
      history: logs.results || []
    });

  } catch (error) {
    console.error('Error fetching inspection history:', error);
    // Return empty history if table doesn't exist or other error
    return c.json({
      success: true,
      history: [],
      message: "HistÃ³rico nÃ£o disponÃ­vel"
    });
  }
});

export default inspectionRoutes;

===END_FILE===
===FILE: supabase/functions/api/integrations-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { ExtendedMochaUser } from "./user-types.ts";

type Env = {
    DB: any;
};

const getDatabase = (env: any) => env.DB;

const app = new Hono<{ Bindings: Env; Variables: { user: any } }>()
    .basePath('/api/integrations');

// GET /: List integrations status for the user/organization
app.get('/', tenantAuthMiddleware, async (c) => {
    try {
        const user = c.get('user') as ExtendedMochaUser;
        const db = getDatabase(c.env);

        const integrations = await db.prepare(`
            SELECT provider, created_at, expires_at 
            FROM integrations 
            WHERE user_id = ?
        `).bind(user.id).all();

        return c.json({
            google: integrations.results?.find((i: any) => i.provider === 'google') ? true : false,
            // outlook: ... later
        });
    } catch (error) {
        console.error('Error fetching integrations:', error);
        return c.json({ error: 'Erro ao buscar integraÃ§Ãµes' }, 500);
    }
});

// POST /google/authorize-url: Generate Google OAuth URL
app.post('/google/authorize-url', tenantAuthMiddleware, async (c) => {
    const CLIENT_ID = Deno.env.get('GOOGLE_CLIENT_ID');
    const REDIRECT_URI = Deno.env.get('GOOGLE_REDIRECT_URI'); // e.g. https://<project>.functions.supabase.co/api/integrations/google/callback OR frontend URL?
    // Usually frontend handles the redirect, but better to keep secrets on server. 
    // Flow: Frontend -> API (get URL) -> Frontend Redirects -> Google -> Frontend (Callback Page) -> API (Exchange Code)

    if (!CLIENT_ID || !REDIRECT_URI) {
        return c.json({ error: "Google Client ID/Redirect URI not configured" }, 500);
    }

    const SCOPES = [
        'https://www.googleapis.com/auth/calendar',
        'https://www.googleapis.com/auth/calendar.events',
        'https://www.googleapis.com/auth/gmail.send',
        'https://www.googleapis.com/auth/userinfo.email'
    ].join(' ');

    const url = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}&response_type=code&scope=${SCOPES}&access_type=offline&prompt=consent`;

    return c.json({ url });
});

// POST /google/callback: Exchange code for token
app.post('/google/callback', tenantAuthMiddleware, async (c) => {
    try {
        const user = c.get('user') as ExtendedMochaUser;
        const db = getDatabase(c.env);
        const { code } = await c.req.json();

        const CLIENT_ID = Deno.env.get('GOOGLE_CLIENT_ID');
        const CLIENT_SECRET = Deno.env.get('GOOGLE_CLIENT_SECRET');
        const REDIRECT_URI = Deno.env.get('GOOGLE_REDIRECT_URI');

        if (!code || !CLIENT_ID || !CLIENT_SECRET) {
            return c.json({ error: "Missing code or config" }, 400);
        }

        // Exchange code
        const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({
                code,
                client_id: CLIENT_ID,
                client_secret: CLIENT_SECRET,
                redirect_uri: REDIRECT_URI,
                grant_type: 'authorization_code'
            })
        });

        const tokens = await tokenResponse.json();

        if (tokens.error) {
            console.error('Google Token Error:', tokens);
            return c.json({ error: "Failed to exchange token", details: tokens }, 400);
        }

        // Get user profile for organization_id
        const userProfile = await db.prepare("SELECT organization_id FROM users WHERE id = ?").bind(user.id).first() as any;
        const orgId = userProfile?.organization_id;

        if (!orgId) return c.json({ error: "No organization" }, 400);

        // Calculate expiry
        const expiresAt = new Date(Date.now() + tokens.expires_in * 1000);

        // Upsert integration
        await db.prepare(`
            INSERT INTO integrations (organization_id, user_id, provider, access_token, refresh_token, expires_at, scope, updated_at)
            VALUES (?, ?, 'google', ?, ?, ?, ?, NOW())
            ON CONFLICT(user_id, provider) DO UPDATE SET
                access_token = excluded.access_token,
                refresh_token = COALESCE(excluded.refresh_token, integrations.refresh_token), -- Keep old refresh if new one not provided
                expires_at = excluded.expires_at,
                updated_at = NOW()
        `).bind(
            orgId, user.id,
            tokens.access_token,
            tokens.refresh_token || null,
            expiresAt.toISOString(),
            tokens.scope
        ).run();

        return c.json({ success: true });

    } catch (error) {
        console.error('Callback error:', error);
        return c.json({ error: "Internal error during callback" }, 500);
    }
});

// DELETE /google: Disconnect
app.delete('/google', tenantAuthMiddleware, async (c) => {
    const user = c.get('user') as ExtendedMochaUser;
    const db = getDatabase(c.env);

    await db.prepare("DELETE FROM integrations WHERE user_id = ? AND provider = 'google'").bind(user.id).run();

    return c.json({ success: true });
});

export default app;
===END_FILE===
===FILE: supabase/functions/api/invitation-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware, TenantContext, AuthenticatedUser } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";

type Env = {
    DB: any;
    SUPABASE_URL?: string;
};

const invitationRoutes = new Hono<{ Bindings: Env; Variables: { user: AuthenticatedUser; tenantContext: TenantContext } }>()
    .basePath('/api/invitations');

// Middleware de autenticaÃ§Ã£o em todas as rotas
invitationRoutes.use('/*', tenantAuthMiddleware);

/**
 * GET /api/invitations
 * Lista convites da organizaÃ§Ã£o do usuÃ¡rio
 */
invitationRoutes.get("/", async (c) => {
    const env = c.env;
    const user = c.get("user");
    const tenantContext = c.get("tenantContext");

    if (!user) {
        return c.json({ error: "NÃ£o autenticado" }, 401);
    }

    const orgId = tenantContext?.organizationId || user.managed_organization_id;

    if (!orgId && !tenantContext?.isSystemAdmin) {
        return c.json({ error: "OrganizaÃ§Ã£o nÃ£o encontrada" }, 400);
    }

    try {
        let query = `
            SELECT 
                i.id,
                i.email,
                i.role,
                i.status,
                i.expires_at,
                i.created_at,
                i.resend_count,
                i.email_sent,
                o.name as organization_name,
                u.name as invited_by_name
            FROM organization_invitations i
            JOIN organizations o ON o.id = i.organization_id
            LEFT JOIN users u ON u.id = i.created_by
        `;

        const params: any[] = [];

        if (tenantContext?.isSystemAdmin) {
            // SysAdmin vÃª todos
            query += ` ORDER BY i.created_at DESC LIMIT 100`;
        } else {
            query += ` WHERE i.organization_id = ? ORDER BY i.created_at DESC`;
            params.push(orgId);
        }

        const result = await env.DB.prepare(query).bind(...params).all();
        return c.json({ invitations: result.results || [] });
    } catch (error: any) {
        console.error("[INVITATIONS] Erro ao listar:", error);
        return c.json({ error: "Erro ao listar convites", details: error.message }, 500);
    }
});

/**
 * GET /api/invitations/seats
 * Retorna vagas disponÃ­veis da organizaÃ§Ã£o
 */
invitationRoutes.get("/seats", async (c) => {
    const env = c.env;
    const user = c.get("user");
    const tenantContext = c.get("tenantContext");

    if (!user) {
        return c.json({ error: "NÃ£o autenticado" }, 401);
    }

    const orgId = c.req.query("organization_id") || tenantContext?.organizationId || user.managed_organization_id;

    if (!orgId) {
        return c.json({ error: "organization_id obrigatÃ³rio" }, 400);
    }

    try {
        const result = await env.DB.prepare("SELECT * FROM get_available_seats(?)").bind(orgId).first();
        return c.json(result || { max_users: 5, active_users: 0, pending_invites: 0, available_seats: 5 });
    } catch (error: any) {
        console.error("[INVITATIONS] Erro ao buscar vagas:", error);
        return c.json({ error: "Erro ao buscar vagas", details: error.message }, 500);
    }
});

/**
 * POST /api/invitations
 * Envia convite(s) para email(s)
 */
invitationRoutes.post("/", async (c) => {
    const env = c.env;
    const user = c.get("user");
    const tenantContext = c.get("tenantContext");

    if (!user) {
        return c.json({ error: "NÃ£o autenticado" }, 401);
    }

    // Verificar permissÃ£o
    if (user.role !== USER_ROLES.ORG_ADMIN && user.role !== USER_ROLES.SYSTEM_ADMIN && user.role !== 'sys_admin' && user.role !== 'org_admin') {
        return c.json({ error: "PermissÃ£o negada. Apenas administradores podem enviar convites." }, 403);
    }

    const body = await c.req.json();
    const { emails, role = 'inspector', organization_id } = body;

    if (!emails || !Array.isArray(emails) || emails.length === 0) {
        return c.json({ error: "Lista de emails obrigatÃ³ria" }, 400);
    }

    const orgId = organization_id || tenantContext?.organizationId || user.managed_organization_id;

    if (!orgId) {
        return c.json({ error: "organization_id obrigatÃ³rio" }, 400);
    }

    // Verificar limite do plano
    try {
        const seats = await env.DB.prepare("SELECT * FROM get_available_seats(?)").bind(orgId).first();
        const available = seats?.available_seats || 0;

        if (emails.length > available) {
            return c.json({
                error: "plan_limit_reached",
                message: `Limite do plano atingido. Vagas disponÃ­veis: ${available}, solicitado: ${emails.length}`,
                available,
                requested: emails.length
            }, 403);
        }
    } catch (e) {
        console.error("[INVITATIONS] Erro ao verificar vagas:", e);
    }

    const results: any[] = [];
    const failed: any[] = [];
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(); // 7 dias

    for (const email of emails) {
        const normalizedEmail = email.trim().toLowerCase();

        if (!normalizedEmail || !normalizedEmail.includes('@')) {
            failed.push({ email, error: "Email invÃ¡lido" });
            continue;
        }

        try {
            // Verificar se jÃ¡ existe convite pendente
            const existing = await env.DB.prepare(`
                SELECT id FROM organization_invitations 
                WHERE organization_id = ? AND LOWER(email) = ? AND status = 'pending'
            `).bind(orgId, normalizedEmail).first();

            if (existing) {
                failed.push({ email: normalizedEmail, error: "Convite pendente jÃ¡ existe" });
                continue;
            }

            // Gerar token seguro
            const token = crypto.randomUUID() + '-' + crypto.randomUUID();

            // Inserir convite
            await env.DB.prepare(`
                INSERT INTO organization_invitations 
                (organization_id, email, role, token, expires_at, created_by)
                VALUES (?, ?, ?, ?, ?, ?)
            `).bind(orgId, normalizedEmail, role, token, expiresAt, user.id).run();

            // Buscar o convite criado
            const invitation = await env.DB.prepare(`
                SELECT id, email, role, expires_at FROM organization_invitations WHERE token = ?
            `).bind(token).first();

            // TODO: Enviar email via email-worker
            // Por agora, marcar como nÃ£o enviado para admin copiar link
            const inviteUrl = `${Deno.env.get('FRONTEND_URL') || 'https://compia.tech'}/invite/accept?token=${token}`;

            results.push({
                id: invitation?.id,
                email: normalizedEmail,
                role,
                expires_at: expiresAt,
                invite_url: inviteUrl,
                email_sent: false
            });

        } catch (error: any) {
            console.error(`[INVITATIONS] Erro ao criar convite para ${normalizedEmail}:`, error);
            failed.push({ email: normalizedEmail, error: error.message });
        }
    }

    return c.json({
        success: results.length > 0,
        created: results.length,
        failed: failed.length,
        invitations: results,
        errors: failed
    }, results.length > 0 ? 201 : 400);
});

/**
 * POST /api/invitations/:id/revoke
 * Revoga um convite pendente
 */
invitationRoutes.post("/:id/revoke", async (c) => {
    const env = c.env;
    const user = c.get("user");
    const id = c.req.param("id");

    if (!user) {
        return c.json({ error: "NÃ£o autenticado" }, 401);
    }

    try {
        // Verificar se convite existe e pertence Ã  org do usuÃ¡rio
        const invitation = await env.DB.prepare(`
            SELECT i.*, o.name as org_name 
            FROM organization_invitations i
            JOIN organizations o ON o.id = i.organization_id
            WHERE i.id = ?
        `).bind(id).first();

        if (!invitation) {
            return c.json({ error: "Convite nÃ£o encontrado" }, 404);
        }

        if (invitation.status !== 'pending') {
            return c.json({ error: "Apenas convites pendentes podem ser revogados" }, 400);
        }

        // Revogar
        await env.DB.prepare(`
            UPDATE organization_invitations 
            SET status = 'revoked', revoked_at = NOW(), revoked_by = ?
            WHERE id = ?
        `).bind(user.id, id).run();

        return c.json({ success: true, message: "Convite revogado com sucesso" });
    } catch (error: any) {
        console.error("[INVITATIONS] Erro ao revogar:", error);
        return c.json({ error: "Erro ao revogar convite", details: error.message }, 500);
    }
});

/**
 * POST /api/invitations/:id/resend
 * Reenvia email do convite e renova validade
 */
invitationRoutes.post("/:id/resend", async (c) => {
    const env = c.env;
    const user = c.get("user");
    const id = c.req.param("id");

    if (!user) {
        return c.json({ error: "NÃ£o autenticado" }, 401);
    }

    try {
        const invitation = await env.DB.prepare(`
            SELECT * FROM organization_invitations WHERE id = ? AND status = 'pending'
        `).bind(id).first();

        if (!invitation) {
            return c.json({ error: "Convite nÃ£o encontrado ou nÃ£o estÃ¡ pendente" }, 404);
        }

        // Gerar novo token e renovar validade
        const newToken = crypto.randomUUID() + '-' + crypto.randomUUID();
        const newExpiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();

        await env.DB.prepare(`
            UPDATE organization_invitations 
            SET token = ?, expires_at = ?, resend_count = resend_count + 1, last_resent_at = NOW()
            WHERE id = ?
        `).bind(newToken, newExpiresAt, id).run();

        const inviteUrl = `${Deno.env.get('FRONTEND_URL') || 'https://compia.tech'}/invite/accept?token=${newToken}`;

        // TODO: Reenviar email

        return c.json({
            success: true,
            message: "Convite reenviado",
            new_expires_at: newExpiresAt,
            invite_url: inviteUrl
        });
    } catch (error: any) {
        console.error("[INVITATIONS] Erro ao reenviar:", error);
        return c.json({ error: "Erro ao reenviar convite", details: error.message }, 500);
    }
});

/**
 * GET /api/invitations/validate
 * Valida token de convite (para frontend)
 */
invitationRoutes.get("/validate", async (c) => {
    const env = c.env;
    const token = c.req.query("token");

    if (!token) {
        return c.json({ valid: false, error: "Token obrigatÃ³rio" }, 400);
    }

    try {
        const result = await env.DB.prepare("SELECT * FROM validate_invitation_token(?)").bind(token).first();

        if (!result || !result.invitation_id) {
            return c.json({ valid: false, reason: "Token invÃ¡lido ou expirado" }, 400);
        }

        return c.json({
            valid: true,
            organization_name: result.organization_name,
            email: result.email,
            role: result.role,
            expires_at: result.expires_at
        });
    } catch (error: any) {
        console.error("[INVITATIONS] Erro ao validar token:", error);
        return c.json({ valid: false, error: "Erro ao validar token" }, 500);
    }
});

/**
 * POST /api/invitations/accept
 * Aceita convite e vincula usuÃ¡rio Ã  organizaÃ§Ã£o
 */
invitationRoutes.post("/accept", async (c) => {
    const env = c.env;
    const user = c.get("user");
    const body = await c.req.json();
    const { token } = body;

    if (!user) {
        return c.json({ error: "VocÃª precisa estar logado para aceitar o convite" }, 401);
    }

    if (!token) {
        return c.json({ error: "Token obrigatÃ³rio" }, 400);
    }

    try {
        const result = await env.DB.prepare("SELECT accept_invitation(?, ?) as result").bind(token, user.id).first();
        const acceptResult = typeof result?.result === 'string' ? JSON.parse(result.result) : result?.result;

        if (!acceptResult?.success) {
            const errorMessages: Record<string, string> = {
                'invalid_or_expired_token': 'Convite invÃ¡lido ou expirado. Solicite um novo convite.',
                'user_not_found': 'UsuÃ¡rio nÃ£o encontrado.',
                'email_mismatch': `Este convite foi enviado para ${acceptResult?.expected_email}. FaÃ§a login com esse email.`
            };

            return c.json({
                success: false,
                error: errorMessages[acceptResult?.error] || acceptResult?.error || 'Erro desconhecido'
            }, 400);
        }

        return c.json({
            success: true,
            message: "Convite aceito com sucesso!",
            organization_id: acceptResult.organization_id,
            role: acceptResult.role,
            redirectTo: "/dashboard"
        });
    } catch (error: any) {
        console.error("[INVITATIONS] Erro ao aceitar convite:", error);
        return c.json({ error: "Erro ao aceitar convite", details: error.message }, 500);
    }
});

export default invitationRoutes;
===END_FILE===
===FILE: supabase/functions/api/kanban-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";

type Env = {
    DB: any;
};

const kanbanRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/kanban');

// Get columns for organization
kanbanRoutes.get("/:orgId/columns", tenantAuthMiddleware, async (c) => {
    const user = c.get('user');
    const orgId = c.req.param('orgId');
    const env = c.env;

    if (!user) return c.json({ error: "Unauthorized" }, 401);

    try {
        let columns = await env.DB.prepare("SELECT * FROM kanban_columns WHERE organization_id = ? ORDER BY position ASC").bind(orgId).all();

        // Lazy seed if empty
        if (!columns.results || columns.results.length === 0) {
            await env.DB.prepare(`
                INSERT INTO kanban_columns (organization_id, title, status_key, position, color) VALUES 
                (?, 'A Fazer', 'pending', 0, 'bg-slate-100'),
                (?, 'Em Andamento', 'in_progress', 1, 'bg-blue-50'),
                (?, 'ConcluÃ­do', 'completed', 2, 'bg-green-50')
            `).bind(orgId, orgId, orgId).run();

            columns = await env.DB.prepare("SELECT * FROM kanban_columns WHERE organization_id = ? ORDER BY position ASC").bind(orgId).all();
        }

        return c.json({ columns: columns.results });
    } catch (e) {
        console.error("Error fetching columns:", e);
        return c.json({ error: "Failed to fetch columns" }, 500);
    }
});

// Create new column
kanbanRoutes.post("/:orgId/columns", tenantAuthMiddleware, async (c) => {
    const user = c.get('user');
    const orgId = c.req.param('orgId');
    const env = c.env;
    const { title, color } = await c.req.json();

    if (!title) return c.json({ error: "Title required" }, 400);

    try {
        // Generate a simplified status key from title
        const statusKey = title.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');

        // Get max position
        const maxPos = await env.DB.prepare("SELECT MAX(position) as max_pos FROM kanban_columns WHERE organization_id = ?").bind(orgId).first();
        const nextPos = (maxPos?.max_pos || 0) + 1;

        const result = await env.DB.prepare(`
            INSERT INTO kanban_columns (organization_id, title, status_key, position, color)
            VALUES (?, ?, ?, ?, ?)
            RETURNING *
        `).bind(orgId, title, statusKey, nextPos, color || 'bg-slate-100').first();

        return c.json({ column: result });
    } catch (e) {
        return c.json({ error: "Failed to create column" }, 500);
    }
});

// Update column order
kanbanRoutes.put("/:orgId/columns/reorder", tenantAuthMiddleware, async (c) => {
    const orgId = c.req.param('orgId');
    const env = c.env;
    const { columnIds } = await c.req.json();

    try {
        // Prepare batch updates (or sequential)
        for (let i = 0; i < columnIds.length; i++) {
            await env.DB.prepare("UPDATE kanban_columns SET position = ? WHERE id = ? AND organization_id = ?").bind(i, columnIds[i], orgId).run();
        }
        return c.json({ success: true });
    } catch (e) {
        return c.json({ error: "Failed to reorder" }, 500);
    }
});

// Update column (title/color)
kanbanRoutes.put("/:orgId/columns/:colId", tenantAuthMiddleware, async (c) => {
    const orgId = c.req.param('orgId');
    const colId = c.req.param('colId');
    const env = c.env;
    const { title, color } = await c.req.json();

    try {
        await env.DB.prepare("UPDATE kanban_columns SET title = ?, color = ? WHERE id = ? AND organization_id = ?").bind(title, color, colId, orgId).run();
        return c.json({ success: true });
    } catch (e) {
        return c.json({ error: "Failed to update column" }, 500);
    }
});

// Delete column
kanbanRoutes.delete("/:orgId/columns/:colId", tenantAuthMiddleware, async (c) => {
    const orgId = c.req.param('orgId');
    const colId = c.req.param('colId');
    const env = c.env;

    try {
        // Optional: Check if items exist in this column?
        // For now, let's just delete (items statuses might become orphaned visually but exist in DB)
        // Better: Move items to 'pending'?
        // Skipping complex logic for MVP.
        await env.DB.prepare("DELETE FROM kanban_columns WHERE id = ? AND organization_id = ?").bind(colId, orgId).run();
        return c.json({ success: true });
    } catch (e) {
        return c.json({ error: "Failed to delete column" }, 500);
    }
});

// Move Item (Update Status)
kanbanRoutes.put("/:orgId/items/:itemId/move", tenantAuthMiddleware, async (c) => {
    const { status } = await c.req.json();
    const itemId = c.req.param('itemId');
    const env = c.env;

    try {
        // 1. Get current item data before update
        const item = await env.DB.prepare("SELECT title, notification_emails FROM action_items WHERE id = ?").bind(itemId).first();

        // 2. Update status
        await env.DB.prepare("UPDATE action_items SET status = ?, updated_at = NOW() WHERE id = ?").bind(status, itemId).run();

        // 3. Send notifications if configured
        if (item && item.notification_emails && Array.isArray(JSON.parse(item.notification_emails))) {
            const emails = JSON.parse(item.notification_emails);
            // Dynamic import to avoid circular dependency issues if any (though unlikely here)
            // Email service code removed to preventing broken build warnings
            console.warn("Email service missing. Skipping notification for item:", item.title);
            console.warn("Email service missing. Skipping notification for item:", item.title);
        }

        return c.json({ success: true });
    } catch (e) {
        console.error("Error moving item:", e);
        return c.json({ error: "Failed to move item" }, 500);
    }
});

export default kanbanRoutes;
===END_FILE===
===FILE: supabase/functions/api/lead-capture.ts===
import { Hono } from "hono";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";
import { cors } from 'hono/cors';

const leadRoutes = new Hono().basePath('/api/leads');

// Enable CORS for external forms
leadRoutes.use('/*', cors({
    origin: '*', // Allow all origins for lead capture
    allowMethods: ['POST', 'OPTIONS'],
    allowHeaders: ['Content-Type']
}));

// ============================================================================
// Rate Limiting (Simple In-Memory)
// ============================================================================
const rateLimitMap = new Map<string, { count: number; resetAt: number }>();
const RATE_LIMIT = 10; // requests per minute
const RATE_WINDOW = 60000; // 1 minute

function checkRateLimit(ip: string): boolean {
    const now = Date.now();
    const record = rateLimitMap.get(ip);

    if (!record || now > record.resetAt) {
        rateLimitMap.set(ip, { count: 1, resetAt: now + RATE_WINDOW });
        return true;
    }

    if (record.count >= RATE_LIMIT) {
        return false;
    }

    record.count++;
    return true;
}

// ============================================================================
// POST /leads/capture - Generic Lead Capture Endpoint
// ============================================================================
leadRoutes.post("/capture", async (c) => {
    const supabaseAdmin = createClient(
        Deno.env.get("SUPABASE_URL") ?? "",
        Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
    );

    const clientIp = c.req.header('x-forwarded-for')?.split(',')[0] || 'unknown';

    // Rate limit check
    if (!checkRateLimit(clientIp)) {
        return c.json({
            success: false,
            error: "Muitas requisiÃ§Ãµes. Aguarde 1 minuto."
        }, 429);
    }

    try {
        const body = await c.req.json();
        const {
            name,
            email,
            phone,
            company,
            source,      // e.g., 'ebook_guia', 'webinar', 'newsletter'
            campaign,    // Optional campaign ID/name
            notes,       // Optional custom notes
            metadata     // Optional extra data (JSON)
        } = body;

        // Basic validation
        if (!email) {
            return c.json({ success: false, error: "Email Ã© obrigatÃ³rio" }, 400);
        }

        // Email format validation
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            return c.json({ success: false, error: "Email invÃ¡lido" }, 400);
        }

        console.log("[LEADS] Capturing lead:", email, "Source:", source);

        // Check if lead already exists
        const { data: existingLead } = await supabaseAdmin
            .from('leads')
            .select('id, email, source')
            .eq('email', email)
            .single();

        let leadId: number;
        let isNew = false;

        if (existingLead) {
            // Update existing lead with new source/info
            leadId = existingLead.id;

            const updateData: any = {
                updated_at: new Date().toISOString()
            };

            // Only update fields if provided
            if (name) updateData.contact_name = name;
            if (phone) updateData.phone = phone;
            if (company) updateData.company_name = company;
            if (notes) updateData.notes = `${existingLead.source || ''} | ${source}: ${notes}`;

            await supabaseAdmin
                .from('leads')
                .update(updateData)
                .eq('id', leadId);

            console.log("[LEADS] Updated existing lead:", leadId);

        } else {
            // Create new lead
            isNew = true;
            const { data: newLead, error: leadError } = await supabaseAdmin
                .from('leads')
                .insert({
                    email,
                    contact_name: name || null,
                    company_name: company || name || email.split('@')[0],
                    phone: phone || null,
                    source: source || 'landing_page',
                    status: 'new',
                    notes: campaign ? `Campanha: ${campaign}` : notes || null,
                    deal_value: 0
                })
                .select()
                .single();

            if (leadError) {
                console.error("[LEADS] Failed to create lead:", leadError);
                return c.json({ success: false, error: "Erro ao cadastrar" }, 500);
            }

            leadId = newLead.id;
            console.log("[LEADS] Created new lead:", leadId);
        }

        // Success response
        return c.json({
            success: true,
            is_new: isNew,
            message: isNew ? "Cadastro realizado com sucesso!" : "Dados atualizados!",
            lead_id: leadId
        });

    } catch (e: any) {
        console.error("[LEADS] Error:", e);
        return c.json({
            success: false,
            error: "Erro interno. Tente novamente."
        }, 500);
    }
});

// ============================================================================
// GET /leads/sources - List available lead sources (for analytics)
// ============================================================================
leadRoutes.get("/sources", async (c) => {
    const supabaseAdmin = createClient(
        Deno.env.get("SUPABASE_URL") ?? "",
        Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
    );

    const { data } = await supabaseAdmin
        .from('leads')
        .select('source')
        .not('source', 'is', null);

    const sources = [...new Set(data?.map(l => l.source) || [])];

    return c.json({ sources });
});

export default leadRoutes;
===END_FILE===
===FILE: supabase/functions/api/media-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware as authMiddleware } from "./tenant-auth-middleware.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const mediaRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/media');

type Env = {
  DB: any;
  SUPABASE_URL: string;
  SUPABASE_SERVICE_ROLE_KEY: string;
};

// File size limits in bytes
const FILE_SIZE_LIMITS = {
  image: 10 * 1024 * 1024,      // 10 MB
  video: 100 * 1024 * 1024,     // 100 MB
  audio: 20 * 1024 * 1024,      // 20 MB
  document: 50 * 1024 * 1024    // 50 MB
};

// Upload media for inspection
mediaRoutes.post("/:inspectionId/media/upload", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("inspectionId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const {
      inspection_item_id,
      media_type,
      file_name,
      file_data,
      thumbnail_data,
      file_size,
      mime_type,
      description,
      latitude,
      longitude,
      captured_at
    } = body;

    // Validate file size based on media type
    const sizeLimit = FILE_SIZE_LIMITS[media_type as keyof typeof FILE_SIZE_LIMITS];
    if (file_size > sizeLimit) {
      const limitMB = Math.round(sizeLimit / 1024 / 1024);
      return c.json({
        error: `Arquivo muito grande. Limite para ${media_type}: ${limitMB}MB`
      }, 400);
    }

    // Validate required fields
    if (!file_data || typeof file_data !== 'string') {
      return c.json({ error: "Dados do arquivo sÃ£o obrigatÃ³rios (file_data)" }, 400);
    }
    if (!file_name) {
      return c.json({ error: "Nome do arquivo Ã© obrigatÃ³rio (file_name)" }, 400);
    }
    if (!media_type) {
      return c.json({ error: "Tipo de mÃ­dia Ã© obrigatÃ³rio (media_type)" }, 400);
    }

    // Verify inspection exists and user has access
    const inspection = await env.DB.prepare(`
      SELECT i.*, u.organization_id as user_org_id, u.role as user_role, u.managed_organization_id
      FROM inspections i
      JOIN users u ON u.id = ?
      WHERE i.id = ?
    `).bind(user.id, inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Check access permissions with proper role handling
    const isCreator = inspection.created_by === user.id;
    const isSameOrg = inspection.organization_id === inspection.user_org_id;
    const isSystemAdmin = ['sys_admin', 'system_admin', 'admin'].includes(inspection.user_role?.toLowerCase());
    const isOrgAdmin = inspection.user_role?.toLowerCase() === 'org_admin' && isSameOrg;
    const managesThisOrg = inspection.managed_organization_id === inspection.organization_id;

    // Also check if user's org is parent of inspection's org (supervision case)
    let isParentOrg = false;
    if (!isSameOrg && inspection.user_org_id) {
      const parentCheck = await env.DB.prepare(`
        SELECT 1 FROM organizations WHERE id = ? AND parent_organization_id = ?
      `).bind(inspection.organization_id, inspection.user_org_id).first();
      isParentOrg = !!parentCheck;
    }

    const hasAccess = isCreator || isSameOrg || isSystemAdmin || isOrgAdmin || managesThisOrg || isParentOrg;

    if (!hasAccess) {
      console.log(`[MEDIA] Access denied: user=${user.id}, inspection=${inspectionId}, isCreator=${isCreator}, isSameOrg=${isSameOrg}, isAdmin=${isSystemAdmin || isOrgAdmin}`);
      return c.json({ error: "Sem permissÃ£o para acessar esta inspeÃ§Ã£o" }, 403);
    }

    // Resolve the correct inspection_item_id
    // The frontend sends the template field_id, but we need the actual inspection_item.id
    let resolvedItemId = inspection_item_id;

    if (inspection_item_id) {
      // First, check if the ID exists directly as inspection_items.id
      const itemExists = await env.DB.prepare(`
        SELECT id FROM inspection_items WHERE id = ? AND inspection_id = ?
      `).bind(inspection_item_id, inspectionId).first();

      if (!itemExists) {
        // Fallback 1: Search by field_id inside the JSON field_responses column
        // The frontend's fieldId is actually the template's checklist_fields.id stored in field_responses->>field_id
        const itemByFieldId = await env.DB.prepare(`
          SELECT id FROM inspection_items 
          WHERE inspection_id = ? AND (field_responses::text)::jsonb->>'field_id' = ?
        `).bind(inspectionId, String(inspection_item_id)).first() as any;

        if (itemByFieldId) {
          resolvedItemId = itemByFieldId.id;
          console.log(`[MEDIA] Resolved field_id ${inspection_item_id} to inspection_item.id ${resolvedItemId}`);
        } else {
          // Fallback 2: Try to find by field_name (passed in body)
          const { field_name } = body;
          if (field_name) {
            const itemByName = await env.DB.prepare(`
              SELECT id FROM inspection_items 
              WHERE inspection_id = ? AND item_description = ?
            `).bind(inspectionId, field_name).first() as any;

            if (itemByName) {
              resolvedItemId = itemByName.id;
              console.log(`[MEDIA] Resolved by field_name '${field_name}' to inspection_item.id ${resolvedItemId}`);
            } else {
              // If still not found, set to null to avoid FK error
              console.warn(`[MEDIA] Could not resolve inspection_item_id for fieldId=${inspection_item_id}, field_name=${field_name}`);
              resolvedItemId = null;
            }
          } else {
            console.warn(`[MEDIA] Could not resolve inspection_item_id ${inspection_item_id}, no field_name provided`);
            resolvedItemId = null;
          }
        }
      }
    }

    let file_url = '';
    let thumbnail_url = ''; // New variable

    try {
      // Upload to Supabase Storage
      const supabaseUrl = env.SUPABASE_URL;
      const supabaseServiceKey = env.SUPABASE_SERVICE_ROLE_KEY;

      if (supabaseUrl && supabaseServiceKey) {
        // Use Supabase Storage
        const supabase = createClient(supabaseUrl, supabaseServiceKey);

        // Convert base64 to binary
        const base64Data = file_data.split(',')[1];
        const binaryData = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));

        // Generate unique file path
        const timestamp = Date.now();
        const sanitizedFileName = file_name.replace(/[^a-zA-Z0-9.-]/g, '_');
        const filePath = `${inspectionId}/${timestamp}_${sanitizedFileName}`;

        const { data: uploadData, error: uploadError } = await supabase.storage
          .from('inspection-media')
          .upload(filePath, binaryData, {
            contentType: mime_type,
            upsert: false
          });

        if (uploadError) {
          console.error('Supabase Storage error:', uploadError);
          throw new Error(uploadError.message);
        }

        // Get public URL
        const { data: urlData } = supabase.storage
          .from('inspection-media')
          .getPublicUrl(filePath);

        file_url = urlData.publicUrl;

        // Process Thumbnail if present
        if (thumbnail_data) {
          try {
            const thumbBase64 = thumbnail_data.split(',')[1];
            const thumbBinary = Uint8Array.from(atob(thumbBase64), c => c.charCodeAt(0));
            const thumbPath = `${filePath}_thumb`;

            const { data: thumbUploadData, error: thumbError } = await supabase.storage
              .from('inspection-media')
              .upload(thumbPath, thumbBinary, {
                contentType: 'image/jpeg', // Assuming thumbs are JPEGs
                upsert: false
              });

            if (!thumbError) {
              const { data: thumbUrlData } = supabase.storage
                .from('inspection-media')
                .getPublicUrl(thumbPath);
              thumbnail_url = thumbUrlData.publicUrl;
            } else {
              console.warn('Thumbnail upload failed:', thumbError);
            }
          } catch (e) {
            console.warn('Error processing thumbnail:', e);
          }
        }

      } else {
        // Fallback: Store base64 reference (truncated for DB)
        // This is a workaround - store just a marker and keep base64 client-side
        console.warn('Supabase Storage not configured, using fallback');
        file_url = `local:${file_name}`;
        if (thumbnail_data) {
          thumbnail_url = `local:thumb_${file_name}`;
        }
      }

      const now = new Date().toISOString();

      // Insert media record with storage URL and geolocation
      const result = await env.DB.prepare(`
        INSERT INTO inspection_media (
          inspection_id, inspection_item_id, media_type, file_name, file_url, thumbnail_url,
          file_size, mime_type, description, latitude, longitude, captured_at, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        RETURNING id
      `).bind(
        inspectionId,
        resolvedItemId || null,
        media_type,
        file_name,
        file_url,
        thumbnail_url,
        file_size,
        mime_type,
        description || null,
        latitude || null,
        longitude || null,
        captured_at || now,
        now,
        now
      ).run();

      return c.json({
        success: true,
        media: {
          id: result.meta.last_row_id,
          file_url: file_url,
          media_type: media_type,
          file_name: file_name,
          latitude: latitude || null,
          longitude: longitude || null,
          captured_at: captured_at || now
        },
        message: "Upload realizado com sucesso"
      });

    } catch (storageError) {
      console.error('Storage error:', storageError);
      return c.json({
        error: "Erro ao armazenar arquivo",
        details: String(storageError)
      }, 500);
    }

  } catch (error) {
    console.error('Error uploading media:', error);
    return c.json({
      error: "Erro ao fazer upload",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Get media for inspection
mediaRoutes.get("/:inspectionId/media", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("inspectionId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Verify inspection access
    const inspection = await env.DB.prepare(`
      SELECT i.*, u.organization_id as user_org_id
      FROM inspections i
      JOIN users u ON u.id = ?
      WHERE i.id = ?
    `).bind(user.id, inspectionId).first() as any;

    if (!inspection) {
      return c.json({ error: "InspeÃ§Ã£o nÃ£o encontrada" }, 404);
    }

    // Get all media for the inspection
    const media = await env.DB.prepare(`
      SELECT * FROM inspection_media 
      WHERE inspection_id = ?
      ORDER BY created_at DESC
    `).bind(inspectionId).all();

    return c.json({ media: media.results });

  } catch (error) {
    console.error('Error fetching media:', error);
    return c.json({
      error: "Erro ao buscar mÃ­dia",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Delete media
mediaRoutes.delete("/:inspectionId/media/:mediaId", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const inspectionId = parseInt(c.req.param("inspectionId"));
  const mediaId = parseInt(c.req.param("mediaId"));

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get media record first
    const media = await env.DB.prepare(`
      SELECT * FROM inspection_media WHERE id = ? AND inspection_id = ?
    `).bind(mediaId, inspectionId).first() as any;

    if (!media) {
      return c.json({ error: "MÃ­dia nÃ£o encontrada" }, 404);
    }

    // Delete from Supabase Storage if applicable
    const supabaseUrl = env.SUPABASE_URL;
    const supabaseServiceKey = env.SUPABASE_SERVICE_ROLE_KEY;

    if (supabaseUrl && supabaseServiceKey && media.file_url && !media.file_url.startsWith('local:')) {
      try {
        const supabase = createClient(supabaseUrl, supabaseServiceKey);
        // Extract path from URL
        const urlParts = media.file_url.split('/inspection-media/');
        if (urlParts[1]) {
          await supabase.storage.from('inspection-media').remove([urlParts[1]]);
        }
      } catch (e) {
        console.error('Error deleting from storage:', e);
      }
    }

    // Delete from database
    await env.DB.prepare(`DELETE FROM inspection_media WHERE id = ?`).bind(mediaId).run();

    return c.json({ success: true, message: "MÃ­dia excluÃ­da com sucesso" });

  } catch (error) {
    console.error('Error deleting media:', error);
    return c.json({
      error: "Erro ao excluir mÃ­dia",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

export default mediaRoutes;
===END_FILE===
===FILE: supabase/functions/api/multi-tenant-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware as authMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";

type Env = {
  DB: any;
};

const multiTenantRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/multi-tenant');

// Middleware to check if user can manage organizations
const requireOrgAdmin = async (c: any, next: any) => {
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await c.env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile) {
    return c.json({ error: "User profile not found" }, 404);
  }

  // System admin can do anything
  if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {
    return next();
  }

  // Org admin can manage their organization and subsidiaries
  if (userProfile.role === USER_ROLES.ORG_ADMIN && userProfile.can_manage_users) {
    return next();
  }

  return c.json({ error: "Insufficient permissions" }, 403);
};

// Create a new organization hierarchy (for system admin or org admin creating subsidiaries)
multiTenantRoutes.post("/organizations/hierarchy", authMiddleware, requireOrgAdmin, async (c) => {
  const env = c.env;
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  const body = await c.req.json();
  const {
    name, type, description, contact_email, contact_phone, address, parent_organization_id,
    subscription_plan, max_users, max_subsidiaries,
    // New professional fields
    cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao, natureza_juridica,
    data_abertura, capital_social, porte_empresa, situacao_cadastral, numero_funcionarios,
    setor_industria, subsetor_industria, certificacoes_seguranca, data_ultima_auditoria,
    nivel_risco, contato_seguranca_nome, contato_seguranca_email, contato_seguranca_telefone,
    historico_incidentes, observacoes_compliance, website, faturamento_anual
  } = body;

  try {
    let finalParentOrgId = parent_organization_id;
    let orgLevel = 'company' as const;

    // SYSTEM_ADMIN has complete privileges and bypasses all restrictions
    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {
      // System admin can create organizations at any level without any restrictions
      if (parent_organization_id) {
        orgLevel = 'subsidiary' as any;
        finalParentOrgId = parent_organization_id; // Use the provided parent
      } else {
        orgLevel = 'company' as const;
        finalParentOrgId = null; // Top-level organization
      }
      // No subsidiary limit checks for SYSTEM_ADMIN
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Org admin can create companies/clients or subsidiaries under their managed organization
      if (!userProfile.managed_organization_id) {
        return c.json({ error: "User is an Org Admin but not assigned to a managed organization." }, 400);
      }
      finalParentOrgId = userProfile.managed_organization_id;

      // Determine organization level based on type
      // If type is explicitly 'subsidiary', treat as subsidiary with limits
      // Otherwise (company, consultancy, client), treat as company level without subsidiary limits
      if (type === 'subsidiary') {
        orgLevel = 'subsidiary' as any;

        // Check subsidiary limit only for actual subsidiaries
        const subsidiaryCount = await env.DB.prepare(`
          SELECT COUNT(*) as count FROM organizations 
          WHERE parent_organization_id = ? AND organization_level = 'subsidiary' AND is_active = true
        `).bind(finalParentOrgId).first() as any;

        const parentOrg = await env.DB.prepare("SELECT max_subsidiaries FROM organizations WHERE id = ?").bind(finalParentOrgId).first() as any;

        if (parentOrg && subsidiaryCount.count >= parentOrg.max_subsidiaries) {
          return c.json({ error: "Maximum number of subsidiaries reached for the parent organization." }, 400);
        }
      } else {
        // For companies, consultancies, and clients - treat as company level (no subsidiary limits)
        orgLevel = 'company' as const;
        // No limit check for company-level organizations managed by org admin
      }
    }

    const result = await env.DB.prepare(`
      INSERT INTO organizations (
        name, type, description, contact_email, contact_phone, address,
        parent_organization_id, organization_level, subscription_status, 
        subscription_plan, max_users, max_subsidiaries, is_active,
        cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao, natureza_juridica,
        data_abertura, capital_social, porte_empresa, situacao_cadastral, numero_funcionarios,
        setor_industria, subsetor_industria, certificacoes_seguranca, data_ultima_auditoria,
        nivel_risco, contato_seguranca_nome, contato_seguranca_email, contato_seguranca_telefone,
        historico_incidentes, observacoes_compliance, website, faturamento_anual,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
    `).bind(
      name,
      type || 'company',
      description || null,
      contact_email || null,
      contact_phone || null,
      address || null,
      finalParentOrgId || null,
      orgLevel,
      'active', // Default status
      subscription_plan || 'basic', // Default plan
      max_users || 50,
      max_subsidiaries || 0,
      true, // Active by default
      // New professional fields
      cnpj || null,
      razao_social || null,
      nome_fantasia || null,
      cnae_principal || null,
      cnae_descricao || null,
      natureza_juridica || null,
      data_abertura || null,
      capital_social || null,
      porte_empresa || null,
      situacao_cadastral || null,
      numero_funcionarios || null,
      setor_industria || null,
      subsetor_industria || null,
      certificacoes_seguranca || null,
      data_ultima_auditoria || null,
      nivel_risco || 'medio',
      contato_seguranca_nome || null,
      contato_seguranca_email || null,
      contato_seguranca_telefone || null,
      historico_incidentes || null,
      observacoes_compliance || null,
      website || null,
      faturamento_anual || null
    ).run();

    const organizationId = result.meta.last_row_id as number;

    // Log activity
    if (user) {
      await env.DB.prepare(`
        INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, NOW())
      `).bind(
        user.id,
        organizationId,
        'organization_created',
        `Created organization: ${name}`,
        'organization',
        organizationId.toString()
      ).run();
    }

    return c.json({
      id: organizationId,
      message: "Organization created successfully in hierarchy"
    });

  } catch (error) {
    console.error('Error creating organization:', error);
    return c.json({ error: "Failed to create organization" }, 500);
  }
});

// Invite user to organization
multiTenantRoutes.post("/organizations/:id/invite-user", authMiddleware, requireOrgAdmin, async (c) => {
  const env = c.env;
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
    const organizationId = parseInt(c.req.param("id"));

    if (isNaN(organizationId)) {
      return c.json({ error: "Invalid organization ID" }, 400);
    }

    const body = await c.req.json();
    const { email, role } = body;

    if (!email || !role) {
      return c.json({ error: "Email and role are required" }, 400);
    }

    // Verify the user can invite to this organization
    if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Org admin can only invite to their managed organization or its subsidiaries
      const org = await env.DB.prepare(`
        SELECT id FROM organizations 
        WHERE id = ? AND (id = ? OR parent_organization_id = ?)
      `).bind(organizationId, userProfile.managed_organization_id, userProfile.managed_organization_id).first();

      if (!org) {
        return c.json({ error: "Cannot invite users to this organization due to scope limitations." }, 403);
      }
      // Org admin can only invite roles within their allowed scope (e.g., no other org_admins)
      if (role === USER_ROLES.ORG_ADMIN || role === USER_ROLES.SYSTEM_ADMIN) {
        return c.json({ error: `Org Admins cannot invite users with the role: ${role}.` }, 403);
      }
    }

    // Check if user already exists
    const existingUser = await env.DB.prepare("SELECT id FROM users WHERE email = ?").bind(email).first();
    if (existingUser) {
      return c.json({ error: "A user with this email already exists in the system." }, 400);
    }

    // Check for existing invitation
    const existingInvitation = await env.DB.prepare(`
      SELECT id FROM user_invitations 
      WHERE email = ? AND organization_id = ? AND accepted_at IS NULL AND expires_at > NOW()
    `).bind(email, organizationId).first();

    if (existingInvitation) {
      return c.json({ error: "An active invitation already exists for this email and organization." }, 400);
    }

    // Generate invitation token
    const invitationToken = self.crypto.randomUUID();
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // 7 days expiration

    // Create invitation
    await env.DB.prepare(`
      INSERT INTO user_invitations (
        email, organization_id, role, invited_by, invitation_token, 
        expires_at, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())
    `).bind(
      email,
      organizationId,
      role,
      user.id,
      invitationToken,
      expiresAt.toISOString()
    ).run();

    // Log activity
    if (user) {
      await env.DB.prepare(`
        INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, NOW())
      `).bind(
        user.id,
        organizationId,
        'user_invited',
        `Invited user: ${email} with role: ${role}`,
        'user',
        email
      ).run();
    }

    // In a real implementation, you would send an email here
    const invitationUrl = `${c.req.header('origin') || 'https://localhost'}/accept-invitation/${invitationToken}`;

    return c.json({
      invitation_token: invitationToken,
      invitation_url: invitationUrl,
      expires_at: expiresAt.toISOString(),
      message: "User invitation created successfully."
    });

  } catch (error) {
    console.error('Error creating invitation:', error);
    return c.json({ error: "Failed to create invitation." }, 500);
  }
});

// Get invitation details moved to main index.ts for public access

// Accept invitation moved to main index.ts for public access

// Get organizations list (basic endpoint for user profile and other components)
multiTenantRoutes.get("/organizations", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile) {
    return c.json({ error: "User profile not found." }, 404);
  }

  try {
    let query = `
      SELECT o.id, o.name, o.type, o.description, o.is_active
      FROM organizations o
    `;

    let params: any[] = [];

    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {
      // System admin sees ALL active organizations
      query += " WHERE o.is_active = true ORDER BY o.name ASC";
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Org admin sees their organization and subsidiaries/clients
      query += ` 
        WHERE (o.id = ? OR o.parent_organization_id = ?) AND o.is_active = true
        ORDER BY o.name ASC
      `;
      params = [userProfile.managed_organization_id, userProfile.managed_organization_id];
    } else {
      // Other roles see only their organization
      query += " WHERE o.id = ? AND o.is_active = true ORDER BY o.name ASC";
      params = [userProfile.organization_id];
    }

    const organizations = await env.DB.prepare(query).bind(...params).all();

    return c.json({
      organizations: organizations.results || []
    });

  } catch (error) {
    console.error('Error fetching organizations:', error);
    return c.json({ error: "Failed to fetch organizations." }, 500);
  }
});

// Get organization hierarchy (for system admin and org admin) - Available at both /organizations/hierarchy and /hierarchy
multiTenantRoutes.get("/organizations/hierarchy", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile) {
    return c.json({ error: "User profile not found." }, 404);
  }

  try {
    let query = `
      SELECT o.*, 
             (SELECT COUNT(id) FROM users WHERE organization_id = o.id AND is_active = true) as user_count,
             (SELECT COUNT(id) FROM organizations WHERE parent_organization_id = o.id AND is_active = true) as subsidiary_count,
             po.name as parent_organization_name
      FROM organizations o
      LEFT JOIN organizations po ON o.parent_organization_id = po.id
    `;

    let params: any[] = [];

    console.log('User profile:', userProfile.role, 'managed_org_id:', userProfile.managed_organization_id);

    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {
      // System admin sees ALL organizations (active and inactive)
      query += " WHERE o.is_active = true ORDER BY o.organization_level, o.name ASC";
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Org admin sees their organization and subsidiaries/clients (only active ones)
      // Include their managed organization AND any organizations that have it as parent
      query += ` 
        WHERE (o.id = ? OR o.parent_organization_id = ?) AND o.is_active = true
        ORDER BY 
          CASE 
            WHEN o.id = ? THEN 0 
            WHEN o.organization_level = 'company' THEN 1
            WHEN o.organization_level = 'subsidiary' THEN 2
            ELSE 3
          END,
          o.name ASC
      `;
      params = [userProfile.managed_organization_id, userProfile.managed_organization_id, userProfile.managed_organization_id];
    } else {
      // Other roles see only their organization (only active ones)
      query += " WHERE o.id = ? AND o.is_active = true ORDER BY o.organization_level, o.name ASC";
      params = [userProfile.organization_id];
    }

    console.log('Query:', query);
    console.log('Params:', params);

    const organizations = await env.DB.prepare(query).bind(...params).all();

    console.log('Found organizations:', organizations.results?.length || 0);

    return c.json({
      organizations: organizations.results || [],
      user_role: userProfile.role,
      can_manage: userProfile.can_manage_users || userProfile.role === USER_ROLES.SYSTEM_ADMIN,
      debug: {
        user_id: user.id,
        managed_organization_id: userProfile.managed_organization_id,
        role: userProfile.role
      }
    });

  } catch (error) {
    console.error('Error fetching organization hierarchy:', error);
    return c.json({ error: "Failed to fetch organization hierarchy." }, 500);
  }
});

// Get users within organization scope
multiTenantRoutes.get("/organizations/:id/users", authMiddleware, requireOrgAdmin, async (c) => {
  const env = c.env;
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
  const organizationId = parseInt(c.req.param("id"));

  try {
    let query = `
      SELECT u.id, u.email, u.name, u.role, u.organization_id, u.phone, u.avatar_url, u.is_active, u.last_login_at, u.created_at,
             o.name as organization_name
      FROM users u
      LEFT JOIN organizations o ON u.organization_id = o.id
    `;

    let params: any[] = [];
    let whereClause = [];

    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {
      // System admin can see users from any organization
      whereClause.push("u.organization_id = ?");
      params.push(organizationId);
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Org admin can see users from their organization and subsidiaries
      whereClause.push(`u.organization_id IN (
        SELECT id FROM organizations 
        WHERE id = ? OR parent_organization_id = ?
      )`);
      params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
    } else {
      return c.json({ error: "Insufficient permissions." }, 403);
    }

    if (whereClause.length > 0) {
      query += " WHERE " + whereClause.join(" AND ");
    }

    query += " ORDER BY u.created_at DESC";

    const users = await env.DB.prepare(query).bind(...params).all();

    // Also get pending invitations for this organization
    const invitations = await env.DB.prepare(`
      SELECT ui.*, u.name as inviter_name
      FROM user_invitations ui
      LEFT JOIN users u ON ui.invited_by = u.id
      WHERE ui.organization_id = ? AND ui.accepted_at IS NULL AND ui.expires_at > NOW()
      ORDER BY ui.created_at DESC
    `).bind(organizationId).all();

    return c.json({
      users: users.results,
      pending_invitations: invitations.results
    });

  } catch (error) {
    console.error('Error fetching organization users:', error);
    return c.json({ error: "Failed to fetch organization users." }, 500);
  }
});

// Update user role within organization (for org admins)
multiTenantRoutes.put("/organizations/:orgId/users/:userId", authMiddleware, requireOrgAdmin, async (c) => {
  const env = c.env;
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
  const organizationId = parseInt(c.req.param("orgId"));
  const targetUserId = c.req.param("userId");

  const body = await c.req.json();
  const { role, is_active } = body;

  try {
    // Verify target user belongs to organization scope
    const targetUser = await env.DB.prepare(`
      SELECT u.*, o.parent_organization_id 
      FROM users u
      LEFT JOIN organizations o ON u.organization_id = o.id
      WHERE u.id = ?
    `).bind(targetUserId).first() as any;

    if (!targetUser) {
      return c.json({ error: "Target user not found." }, 404);
    }

    // Check permissions
    if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      const canManage = targetUser.organization_id === userProfile.managed_organization_id ||
        targetUser.parent_organization_id === userProfile.managed_organization_id; // Check if it's a direct subsidiary

      if (!canManage) {
        return c.json({ error: "Cannot manage users outside your assigned organization scope." }, 403);
      }

      // Org admin cannot assign roles higher than or equal to their own, except for basic roles
      if (role === USER_ROLES.ORG_ADMIN || role === USER_ROLES.SYSTEM_ADMIN) {
        return c.json({ error: `Org Admins cannot assign role: ${role}.` }, 403);
      }
    }

    // Update user
    const updateFields = [];
    const updateValues = [];

    if (role !== undefined) {
      updateFields.push("role = ?");
      updateValues.push(role);
    }

    if (is_active !== undefined) {
      updateFields.push("is_active = ?");
      updateValues.push(is_active);
    }

    if (updateFields.length > 0) {
      updateFields.push("updated_at = NOW()");

      await env.DB.prepare(`
        UPDATE users SET ${updateFields.join(", ")} WHERE id = ?
      `).bind(...updateValues, targetUserId).run();

      // Log activity
      if (user) {
        await env.DB.prepare(`
          INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
          VALUES (?, ?, ?, ?, ?, ?, NOW())
        `).bind(
          user.id,
          organizationId,
          'user_updated',
          `Updated user: ${targetUser.email} - Role: ${role}, Active: ${is_active}`,
          'user',
          targetUserId
        ).run();
      }
    }

    return c.json({ message: "User updated successfully." });

  } catch (error) {
    console.error('Error updating user:', error);
    return c.json({ error: "Failed to update user." }, 500);
  }
});

// Update organization (PUT endpoint)
multiTenantRoutes.put("/organizations/:id", authMiddleware, requireOrgAdmin, async (c) => {
  const env = c.env;
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const organizationId = parseInt(c.req.param("id"));
    const body = await c.req.json();

    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    // Verify permissions
    if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      const orgToUpdate = await env.DB.prepare("SELECT * FROM organizations WHERE id = ?").bind(organizationId).first() as any;
      if (!orgToUpdate || (orgToUpdate.id !== userProfile.managed_organization_id && orgToUpdate.parent_organization_id !== userProfile.managed_organization_id)) {
        return c.json({ error: "PermissÃµes insuficientes para atualizar esta organizaÃ§Ã£o." }, 403);
      }
    }

    // Build dynamic update query
    const updateFields = [];
    const updateValues = [];

    const allowedFields = [
      'name', 'type', 'description', 'contact_email', 'contact_phone', 'address',
      'subscription_plan', 'max_users', 'max_subsidiaries', 'cnpj', 'razao_social',
      'nome_fantasia', 'cnae_principal', 'cnae_descricao', 'natureza_juridica',
      'data_abertura', 'capital_social', 'porte_empresa', 'situacao_cadastral',
      'numero_funcionarios', 'setor_industria', 'subsetor_industria',
      'certificacoes_seguranca', 'data_ultima_auditoria', 'nivel_risco',
      'contato_seguranca_nome', 'contato_seguranca_email', 'contato_seguranca_telefone',
      'historico_incidentes', 'observacoes_compliance', 'website', 'faturamento_anual'
    ];

    for (const field of allowedFields) {
      if (body[field] !== undefined) {
        updateFields.push(`${field} = ?`);
        updateValues.push(body[field]);
      }
    }

    if (updateFields.length === 0) {
      return c.json({ message: "Nenhum campo vÃ¡lido para atualizar." }, 400);
    }

    updateFields.push("updated_at = NOW()");

    await env.DB.prepare(`
      UPDATE organizations 
      SET ${updateFields.join(", ")}
      WHERE id = ?
    `).bind(...updateValues, organizationId).run();

    // Log activity
    if (user) {
      await env.DB.prepare(`
        INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, NOW())
      `).bind(
        user.id,
        organizationId,
        'organization_updated',
        `Atualizou organizaÃ§Ã£o: ${body.name || organizationId}`,
        'organization',
        organizationId.toString()
      ).run();
    }

    return c.json({ message: "OrganizaÃ§Ã£o atualizada com sucesso!" });
  } catch (error) {
    console.error('Erro ao atualizar organizaÃ§Ã£o:', error);
    return c.json({ error: "Falha ao atualizar organizaÃ§Ã£o." }, 500);
  }
});

// Get activity log for organization
multiTenantRoutes.get("/organizations/:id/activity", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const organizationId = parseInt(c.req.param("id"));
  const limit = parseInt(c.req.query("limit") || "50");
  const offset = parseInt(c.req.query("offset") || "0");

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  try {
    let query = `
      SELECT al.*, u.name as user_name, u.email as user_email
      FROM activity_log al
      LEFT JOIN users u ON al.user_id = u.id
    `;

    let params: any[] = [];
    let whereClause = [];

    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN) {
      // System admin can see all activity
      if (organizationId > 0) {
        whereClause.push("al.organization_id = ?");
        params.push(organizationId);
      }
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Org admin can see activity for their organization and subsidiaries
      whereClause.push(`al.organization_id IN (
        SELECT id FROM organizations 
        WHERE id = ? OR parent_organization_id = ?
      )`);
      params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
    } else {
      // Other roles see activity for their organization only
      whereClause.push("al.organization_id = ?");
      params.push(userProfile.organization_id);
    }

    if (whereClause.length > 0) {
      query += " WHERE " + whereClause.join(" AND ");
    }

    query += " ORDER BY al.created_at DESC LIMIT ? OFFSET ?";
    params.push(limit, offset);

    const activities = await env.DB.prepare(query).bind(...params).all();

    return c.json({ activities: activities.results });

  } catch (error) {
    console.error('Error fetching activity log:', error);
    return c.json({ error: "Failed to fetch activity log." }, 500);
  }
});

// Add alternative hierarchy route for compatibility
multiTenantRoutes.get("/hierarchy", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile) {
    return c.json({ error: "User profile not found." }, 404);
  }

  try {
    let query = `
      SELECT o.*, 
             (SELECT COUNT(id) FROM users WHERE organization_id = o.id AND is_active = true) as user_count,
             (SELECT COUNT(id) FROM organizations WHERE parent_organization_id = o.id AND is_active = true) as subsidiary_count,
             po.name as parent_organization_name
      FROM organizations o
      LEFT JOIN organizations po ON o.parent_organization_id = po.id
    `;

    let params: any[] = [];

    console.log('User profile:', userProfile.role, 'managed_org_id:', userProfile.managed_organization_id);

    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN) {
      // System admin sees ALL organizations (active and inactive)
      query += " WHERE o.is_active = true ORDER BY o.organization_level, o.name ASC";
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Org admin sees their organization and subsidiaries/clients (only active ones)
      // Include their managed organization AND any organizations that have it as parent
      query += ` 
        WHERE (o.id = ? OR o.parent_organization_id = ?) AND o.is_active = true
        ORDER BY 
          CASE 
            WHEN o.id = ? THEN 0 
            WHEN o.organization_level = 'company' THEN 1
            WHEN o.organization_level = 'subsidiary' THEN 2
            ELSE 3
          END,
          o.name ASC
      `;
      params = [userProfile.managed_organization_id, userProfile.managed_organization_id, userProfile.managed_organization_id];
    } else {
      // Other roles see only their organization (only active ones)
      query += " WHERE o.id = ? AND o.is_active = true ORDER BY o.organization_level, o.name ASC";
      params = [userProfile.organization_id];
    }

    console.log('Query:', query);
    console.log('Params:', params);

    const organizations = await env.DB.prepare(query).bind(...params).all();

    console.log('Found organizations:', organizations.results?.length || 0);

    return c.json({
      organizations: organizations.results || [],
      user_role: userProfile.role,
      can_manage: userProfile.can_manage_users || userProfile.role === USER_ROLES.SYSTEM_ADMIN,
      debug: {
        user_id: user.id,
        managed_organization_id: userProfile.managed_organization_id,
        role: userProfile.role
      }
    });

  } catch (error) {
    console.error('Error fetching organization hierarchy:', error);
    return c.json({ error: "Failed to fetch organization hierarchy." }, 500);
  }
});

export default multiTenantRoutes;

===END_FILE===
===FILE: supabase/functions/api/notifications-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";

const notificationsRoutes = new Hono<{ Bindings: any; Variables: { user: any } }>().basePath('/api/notifications');

// List notifications
notificationsRoutes.get("/", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const limit = parseInt(c.req.query("limit") || "50");

    if (!user) return c.json({ error: "Unauthorized" }, 401);

    try {
        const results = await env.DB.prepare(`
            SELECT * FROM notifications 
            WHERE user_id = ? 
            ORDER BY created_at DESC 
            LIMIT ?
        `).bind(user.id, limit).all();

        // Count unread
        const countResult = await env.DB.prepare(`
            SELECT COUNT(*) as count FROM notifications 
            WHERE user_id = ? AND read = false
        `).bind(user.id).first();

        return c.json({
            notifications: results.results || [],
            unread_count: countResult?.count || 0
        });
    } catch (error) {
        console.error("Error fetching notifications:", error);
        return c.json({ error: "Failed to fetch notifications" }, 500);
    }
});

// Mark as read
notificationsRoutes.post("/:id/read", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");
    const id = c.req.param("id");

    if (!user) return c.json({ error: "Unauthorized" }, 401);

    try {
        await env.DB.prepare(`
            UPDATE notifications SET read = true WHERE id = ? AND user_id = ?
        `).bind(id, user.id).run();

        return c.json({ success: true });
    } catch (error) {
        return c.json({ error: "Failed to update" }, 500);
    }
});

// Mark all as read
notificationsRoutes.post("/read-all", tenantAuthMiddleware, async (c) => {
    const env = c.env;
    const user = c.get("user");

    if (!user) return c.json({ error: "Unauthorized" }, 401);

    try {
        await env.DB.prepare(`
            UPDATE notifications SET read = true WHERE user_id = ? AND read = false
        `).bind(user.id).run();

        return c.json({ success: true });
    } catch (error) {
        return c.json({ error: "Failed to update" }, 500);
    }
});

export default notificationsRoutes;
===END_FILE===
===FILE: supabase/functions/api/openai-assistants-service.ts===
// OpenAI Assistants Service for NR compliance analysis
import OpenAI from "openai";

// Assistant configurations for different NR standards
export const ASSISTANTS = {
  'NR-01': {
    id: 'asst_nr01',
    name: 'Assistente NR-01',
    description: 'DisposiÃ§Ãµes Gerais e Gerenciamento de Riscos Ocupacionais',
    instructions: `VocÃª Ã© um especialista em NR-01 - DisposiÃ§Ãµes Gerais e Gerenciamento de Riscos Ocupacionais. 
    Analise situaÃ§Ãµes de trabalho e forneÃ§a orientaÃ§Ãµes sobre:
    - Programa de Gerenciamento de Riscos (PGR)
    - InventÃ¡rio de riscos
    - Plano de aÃ§Ã£o
    - Medidas de prevenÃ§Ã£o
    - Treinamentos obrigatÃ³rios
    Sempre cite os itens especÃ­ficos da norma e forneÃ§a recomendaÃ§Ãµes prÃ¡ticas.`
  },
  'NR-05': {
    id: 'asst_nr05', 
    name: 'Assistente NR-05',
    description: 'ComissÃ£o Interna de PrevenÃ§Ã£o de Acidentes e AssÃ©dio (CIPA)',
    instructions: `VocÃª Ã© um especialista em NR-05 - CIPA. Analise e oriente sobre:
    - Dimensionamento da CIPA
    - Processo eleitoral
    - AtribuiÃ§Ãµes e responsabilidades
    - Treinamento de cipeiros
    - Mapa de riscos
    - SIPAT
    ForneÃ§a orientaÃ§Ãµes prÃ¡ticas e conformidade normativa.`
  },
  'NR-06': {
    id: 'asst_nr06',
    name: 'Assistente NR-06',
    description: 'Equipamento de ProteÃ§Ã£o Individual (EPI)',
    instructions: `VocÃª Ã© um especialista em NR-06 - EPIs. Analise e oriente sobre:
    - SeleÃ§Ã£o adequada de EPIs
    - Certificado de AprovaÃ§Ã£o (CA)
    - Responsabilidades do empregador e empregado
    - Treinamento e uso correto
    - Guarda e conservaÃ§Ã£o
    - SubstituiÃ§Ã£o e higienizaÃ§Ã£o
    ForneÃ§a recomendaÃ§Ãµes especÃ­ficas para cada situaÃ§Ã£o.`
  },
  'NR-07': {
    id: 'asst_nr07',
    name: 'Assistente NR-07',
    description: 'Programa de Controle MÃ©dico de SaÃºde Ocupacional (PCMSO)',
    instructions: `VocÃª Ã© um especialista em NR-07 - PCMSO. Analise e oriente sobre:
    - EstruturaÃ§Ã£o do PCMSO
    - Exames mÃ©dicos obrigatÃ³rios
    - ASO (Atestado de SaÃºde Ocupacional)
    - Periodicidade de exames
    - RelatÃ³rio analÃ­tico
    - ProntuÃ¡rio mÃ©dico
    ForneÃ§a orientaÃ§Ãµes mÃ©dicas ocupacionais adequadas.`
  },
  'NR-09': {
    id: 'asst_nr09',
    name: 'Assistente NR-09',
    description: 'AvaliaÃ§Ã£o e Controle das ExposiÃ§Ãµes Ocupacionais',
    instructions: `VocÃª Ã© um especialista em NR-09 - ExposiÃ§Ãµes Ocupacionais. Analise e oriente sobre:
    - Agentes fÃ­sicos, quÃ­micos e biolÃ³gicos
    - Limites de tolerÃ¢ncia
    - Medidas de controle
    - Monitoramento de exposiÃ§Ã£o
    - EPCs e EPIs adequados
    - Laudos tÃ©cnicos
    ForneÃ§a anÃ¡lises tÃ©cnicas detalhadas.`
  },
  'NR-10': {
    id: 'asst_nr10',
    name: 'Assistente NR-10',
    description: 'SeguranÃ§a em InstalaÃ§Ãµes e ServiÃ§os em Eletricidade',
    instructions: `VocÃª Ã© um especialista em NR-10 - Eletricidade. Analise e oriente sobre:
    - ProntuÃ¡rio de instalaÃ§Ãµes elÃ©tricas
    - Medidas de controle do risco elÃ©trico
    - Medidas de proteÃ§Ã£o coletiva e individual
    - SeguranÃ§a em projetos
    - Procedimentos de trabalho
    - SituaÃ§Ã£o de emergÃªncia
    - QualificaÃ§Ã£o, habilitaÃ§Ã£o e autorizaÃ§Ã£o
    ForneÃ§a orientaÃ§Ãµes tÃ©cnicas de seguranÃ§a elÃ©trica.`
  },
  'NR-11': {
    id: 'asst_nr11',
    name: 'Assistente NR-11',
    description: 'Transporte, MovimentaÃ§Ã£o, Armazenagem e Manuseio de Materiais',
    instructions: `VocÃª Ã© um especialista em NR-11. Analise e oriente sobre:
    - OperaÃ§Ã£o de equipamentos de transporte
    - MovimentaÃ§Ã£o de cargas
    - Armazenamento seguro
    - CapacitaÃ§Ã£o de operadores
    - SinalizaÃ§Ã£o e demarcaÃ§Ã£o
    - InspeÃ§Ã£o de equipamentos
    ForneÃ§a orientaÃ§Ãµes prÃ¡ticas de seguranÃ§a.`
  },
  'NR-12': {
    id: 'asst_nr12',
    name: 'Assistente NR-12',
    description: 'SeguranÃ§a no Trabalho em MÃ¡quinas e Equipamentos',
    instructions: `VocÃª Ã© um especialista em NR-12 - MÃ¡quinas. Analise e oriente sobre:
    - ProteÃ§Ãµes de mÃ¡quinas
    - Dispositivos de seguranÃ§a
    - Sistemas de seguranÃ§a
    - ManutenÃ§Ã£o e inspeÃ§Ã£o
    - Manual de instruÃ§Ãµes
    - CapacitaÃ§Ã£o
    - InventÃ¡rio de mÃ¡quinas
    ForneÃ§a anÃ¡lises tÃ©cnicas detalhadas de seguranÃ§a.`
  },
  'NR-15': {
    id: 'asst_nr15',
    name: 'Assistente NR-15',
    description: 'Atividades e OperaÃ§Ãµes Insalubres',
    instructions: `VocÃª Ã© um especialista em NR-15 - Insalubridade. Analise e oriente sobre:
    - Agentes insalubres
    - Limites de tolerÃ¢ncia
    - Graus de insalubridade (10%, 20%, 40%)
    - Laudos de insalubridade
    - Medidas de eliminaÃ§Ã£o ou neutralizaÃ§Ã£o
    - Adicional de insalubridade
    ForneÃ§a anÃ¡lises tÃ©cnicas e orientaÃ§Ãµes legais.`
  },
  'NR-16': {
    id: 'asst_nr16',
    name: 'Assistente NR-16',
    description: 'Atividades e OperaÃ§Ãµes Perigosas',
    instructions: `VocÃª Ã© um especialista em NR-16 - Periculosidade. Analise e oriente sobre:
    - Atividades com explosivos
    - Atividades com inflamÃ¡veis
    - Trabalho com energia elÃ©trica
    - Atividades com radiaÃ§Ãµes ionizantes
    - SeguranÃ§a pessoal e patrimonial
    - Adicional de periculosidade (30%)
    ForneÃ§a anÃ¡lises tÃ©cnicas e orientaÃ§Ãµes legais.`
  },
  'NR-17': {
    id: 'asst_nr17',
    name: 'Assistente NR-17',
    description: 'Ergonomia',
    instructions: `VocÃª Ã© um especialista em NR-17 - Ergonomia. Analise e oriente sobre:
    - AnÃ¡lise ErgonÃ´mica do Trabalho (AET)
    - MobiliÃ¡rio dos postos de trabalho
    - Equipamentos dos postos de trabalho
    - CondiÃ§Ãµes ambientais de trabalho
    - OrganizaÃ§Ã£o do trabalho
    - Pausas e descansos
    ForneÃ§a recomendaÃ§Ãµes ergonÃ´micas especÃ­ficas.`
  },
  'NR-18': {
    id: 'asst_nr18',
    name: 'Assistente NR-18',
    description: 'SeguranÃ§a e SaÃºde na IndÃºstria da ConstruÃ§Ã£o',
    instructions: `VocÃª Ã© um especialista em NR-18 - ConstruÃ§Ã£o Civil. Analise e oriente sobre:
    - PCMAT (Programa de CondiÃ§Ãµes e Meio Ambiente de Trabalho)
    - Ãreas de vivÃªncia
    - DemoliÃ§Ã£o e escavaÃ§Ãµes
    - Trabalho em altura
    - Andaimes e plataformas
    - InstalaÃ§Ãµes elÃ©tricas temporÃ¡rias
    - ProteÃ§Ãµes coletivas
    ForneÃ§a orientaÃ§Ãµes especÃ­ficas para canteiros de obras.`
  },
  'NR-23': {
    id: 'asst_nr23',
    name: 'Assistente NR-23',
    description: 'ProteÃ§Ã£o Contra IncÃªndios',
    instructions: `VocÃª Ã© um especialista em NR-23 - ProteÃ§Ã£o Contra IncÃªndios. Analise e oriente sobre:
    - SaÃ­das de emergÃªncia
    - Combate ao fogo
    - ExercÃ­cio de alerta
    - Classes de fogo
    - Extintores adequados
    - Sistemas de alarme
    - IluminaÃ§Ã£o de emergÃªncia
    ForneÃ§a orientaÃ§Ãµes de prevenÃ§Ã£o e combate a incÃªndios.`
  },
  'NR-24': {
    id: 'asst_nr24',
    name: 'Assistente NR-24',
    description: 'CondiÃ§Ãµes SanitÃ¡rias e de Conforto',
    instructions: `VocÃª Ã© um especialista em NR-24. Analise e oriente sobre:
    - InstalaÃ§Ãµes sanitÃ¡rias
    - VestiÃ¡rios
    - RefeitÃ³rios
    - Cozinhas
    - Alojamentos
    - CondiÃ§Ãµes de higiene e conforto
    ForneÃ§a orientaÃ§Ãµes sobre condiÃ§Ãµes adequadas.`
  },
  'NR-35': {
    id: 'asst_nr35',
    name: 'Assistente NR-35',
    description: 'Trabalho em Altura',
    instructions: `VocÃª Ã© um especialista em NR-35 - Trabalho em Altura. Analise e oriente sobre:
    - AnÃ¡lise de Risco (AR)
    - PermissÃ£o de Trabalho (PT)
    - Equipamentos de proteÃ§Ã£o individual
    - Sistemas de ancoragem
    - Procedimentos de emergÃªncia
    - CapacitaÃ§Ã£o e treinamento
    - AptidÃ£o para trabalho em altura
    ForneÃ§a orientaÃ§Ãµes detalhadas de seguranÃ§a.`
  },
  'GENERAL': {
    id: 'asst_general',
    name: 'Assistente Geral SST',
    description: 'Assistente geral para questÃµes de SeguranÃ§a e SaÃºde do Trabalho',
    instructions: `VocÃª Ã© um especialista em SeguranÃ§a e SaÃºde do Trabalho (SST) com conhecimento em todas as NRs.
    Analise situaÃ§Ãµes e forneÃ§a orientaÃ§Ãµes sobre:
    - IdentificaÃ§Ã£o de riscos
    - Medidas de prevenÃ§Ã£o
    - Conformidade com NRs
    - Boas prÃ¡ticas de SST
    - GestÃ£o de seguranÃ§a
    Sempre identifique qual NR se aplica e forneÃ§a orientaÃ§Ãµes prÃ¡ticas.`
  },
  'CHATBOT': {
    id: 'asst_chatbot',
    name: 'Chatbot COMPIA',
    description: 'Assistente virtual para ajuda geral do sistema',
    instructions: `VocÃª Ã© o assistente virtual do sistema COMPIA - InteligÃªncia em SeguranÃ§a do Trabalho.
    Ajude os usuÃ¡rios com:
    - NavegaÃ§Ã£o no sistema
    - CriaÃ§Ã£o de inspeÃ§Ãµes e checklists
    - InterpretaÃ§Ã£o de normas de SST
    - GeraÃ§Ã£o de relatÃ³rios
    - Planos de aÃ§Ã£o
    - DÃºvidas sobre funcionalidades
    Seja amigÃ¡vel, claro e objetivo. Sempre forneÃ§a exemplos prÃ¡ticos.`
  }
};

export class OpenAIAssistantsService {
  private client: OpenAI;
  private assistants: Map<string, any> = new Map();

  constructor(apiKey: string) {
    this.client = new OpenAI({ apiKey });
  }

  async initializeAssistants() {
    try {
      console.log('[OPENAI-ASSISTANTS] Initializing assistants...');
      // Create or retrieve assistants
      for (const [key, config] of Object.entries(ASSISTANTS)) {
        try {
          // Try to retrieve existing assistant
          let assistant;
          const assistantsList = await this.client.beta.assistants.list();
          const existing = assistantsList.data.find(a => a.name === config.name);
          
          if (existing) {
            assistant = existing;
            console.log(`[OPENAI-ASSISTANTS] Found existing assistant: ${key} (${assistant.id})`);
          } else {
            // Create new assistant
            console.log(`[OPENAI-ASSISTANTS] Creating new assistant: ${key}`);
            assistant = await this.client.beta.assistants.create({
              name: config.name,
              instructions: config.instructions,
              model: "gpt-4o", // Using gpt-4o for assistants API compatibility
              tools: [{ type: "code_interpreter" }, { type: "file_search" }]
            });
            console.log(`[OPENAI-ASSISTANTS] Created assistant: ${key} (${assistant.id})`);
          }
          
          this.assistants.set(key, assistant);
        } catch (error) {
          console.error(`[OPENAI-ASSISTANTS] Failed to initialize assistant ${key}:`, error);
        }
      }
      console.log(`[OPENAI-ASSISTANTS] Initialized ${this.assistants.size} assistants`);
    } catch (error) {
      console.error('[OPENAI-ASSISTANTS] Failed to initialize assistants:', error);
    }
  }

  async analyzeWithAssistant(
    assistantKey: string, 
    content: string,
    files?: Array<{ url: string; type: string }>
  ) {
    try {
      const assistant = this.assistants.get(assistantKey) || this.assistants.get('GENERAL');
      if (!assistant) {
        throw new Error('Assistant not found');
      }

      console.log(`[OPENAI-ASSISTANTS] Analyzing with ${assistantKey} assistant (${assistant.id})`);

      // Create thread
      const thread = await this.client.beta.threads.create();

      // Add message with file attachments if provided
      const messageData: any = {
        role: "user" as const,
        content
      };

      // Handle file attachments
      if (files && files.length > 0) {
        const fileIds = [];
        for (const file of files) {
          try {
            // Upload file to OpenAI
            const uploadedFile = await this.client.files.create({
              file: await fetch(file.url).then(r => r.blob()),
              purpose: "assistants"
            });
            fileIds.push(uploadedFile.id);
          } catch (fileError) {
            console.error('[OPENAI-ASSISTANTS] Error uploading file:', fileError);
          }
        }
        if (fileIds.length > 0) {
          messageData.file_ids = fileIds;
        }
      }

      await this.client.beta.threads.messages.create(thread.id, messageData);

      // Run assistant
      const run = await this.client.beta.threads.runs.create(thread.id, {
        assistant_id: assistant.id
      });

      // Wait for completion
      let runStatus = await this.client.beta.threads.runs.retrieve(run.id, { thread_id: thread.id });
      let attempts = 0;
      while (runStatus.status !== 'completed' && runStatus.status !== 'failed' && attempts < 30) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        runStatus = await this.client.beta.threads.runs.retrieve(run.id, { thread_id: thread.id });
        attempts++;
      }

      if (runStatus.status === 'failed') {
        console.error('[OPENAI-ASSISTANTS] Assistant run failed:', runStatus.last_error);
        throw new Error('Assistant run failed');
      }

      // Get messages
      const messages = await this.client.beta.threads.messages.list(thread.id);
      const assistantMessage = messages.data.find(m => m.role === 'assistant');
      
      if (assistantMessage && assistantMessage.content[0] && assistantMessage.content[0].type === 'text') {
        const assistantInfo = ASSISTANTS[assistantKey as keyof typeof ASSISTANTS];
        return {
          analysis: assistantMessage.content[0].text.value,
          assistant: assistantInfo?.name || 'Assistant',
          threadId: thread.id
        };
      }

      throw new Error('No response from assistant');
    } catch (error) {
      console.error('[OPENAI-ASSISTANTS] Assistant analysis error:', error);
      throw error;
    }
  }

  async chatbotResponse(message: string) {
    return this.analyzeWithAssistant('CHATBOT', message);
  }

  async analyzeInspection(
    inspectionData: any,
    assistantKey: string = 'GENERAL',
    files?: Array<{ url: string; type: string }>
  ) {
    const prompt = `
    AnÃ¡lise de InspeÃ§Ã£o de SeguranÃ§a do Trabalho:
    
    Local: ${inspectionData.location}
    Data: ${new Date().toLocaleDateString('pt-BR')}
    
    Checklist aplicado:
    ${JSON.stringify(inspectionData.checklist, null, 2)}
    
    Por favor, analise:
    1. Conformidades e nÃ£o-conformidades identificadas
    2. Riscos potenciais
    3. RecomendaÃ§Ãµes de melhoria
    4. Prioridades de aÃ§Ã£o
    5. Conformidade com as normas aplicÃ¡veis
    
    ${files?.length ? 'Arquivos anexados para anÃ¡lise adicional.' : ''}
    `;

    return this.analyzeWithAssistant(assistantKey, prompt, files);
  }

  async generateActionPlan(nonConformities: any[], assistantKey: string = 'GENERAL') {
    const prompt = `
    Gere um plano de aÃ§Ã£o detalhado para as seguintes nÃ£o-conformidades:
    
    ${JSON.stringify(nonConformities, null, 2)}
    
    Para cada nÃ£o-conformidade, forneÃ§a:
    1. O QUE deve ser feito (aÃ§Ã£o corretiva)
    2. POR QUE Ã© importante (justificativa)
    3. ONDE aplicar a aÃ§Ã£o
    4. QUANDO deve ser concluÃ­do (prazo sugerido)
    5. QUEM deve ser responsÃ¡vel
    6. COMO implementar
    7. QUANTO custarÃ¡ (estimativa se aplicÃ¡vel)
    
    Priorize as aÃ§Ãµes por criticidade e risco.
    `;

    return this.analyzeWithAssistant(assistantKey, prompt);
  }

  getAvailableAssistants() {
    return Object.entries(ASSISTANTS).map(([key, config]) => ({
      key,
      name: config.name,
      description: config.description,
      openai_id: this.assistants.get(key)?.id || null
    }));
  }
}

===END_FILE===
===FILE: supabase/functions/api/organizations-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { ExtendedMochaUser, USER_ROLES, ORGANIZATION_LEVELS } from "./user-types.ts";

type Env = {
  DB: any;
  MOCHA_USERS_SERVICE_API_URL: string;
  MOCHA_USERS_SERVICE_API_KEY: string;
  OPENAI_API_KEY: string;
  GOOGLE_CLIENT_ID: string;
};

const getDatabase = (env: any) => env.DB;

const app = new Hono<{ Bindings: Env; Variables: { user: any; tenantContext: any } }>()
  .basePath('/api/organizations');

// DEBUG: Log all requests hitting this router
app.get('*', async (c, next) => {
  console.log('[ORGS_ROUTER] Incoming request path:', c.req.path);
  await next();
});

// DEBUG: Public ping route
app.get('/ping', (c) => c.json({ message: 'pong', path: c.req.path }));

// Organizations stats endpoint
app.get('/stats', tenantAuthMiddleware, async (c) => {
  try {
    const user = c.get('user') as ExtendedMochaUser;
    const tenantContext = c.get('tenantContext') as any;
    const db = getDatabase(c.env);

    // Check if a specific context is active (from X-Organization-Id header)
    const activeOrgId = tenantContext?.organizationId;
    const isGlobalView = !activeOrgId || activeOrgId === 0;

    let stats = {
      totalMasterOrgs: 0,
      totalCompanies: 0,
      totalSubsidiaries: 0,
      totalUsers: 0,
      userManagedStats: undefined as any
    };

    // CASE 1: Specific Organization Selected (Any Role)
    if (!isGlobalView) {
      // Return stats specific to this organization
      const orgUsers = await db.prepare('SELECT COUNT(*) as count FROM users WHERE (organization_id = ? OR managed_organization_id = ?) AND is_active = true').bind(activeOrgId, activeOrgId).first();
      const subsidiaries = await db.prepare('SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ? AND is_active = true').bind(activeOrgId).first();
      const departmentCount = await db.prepare('SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ? AND organization_level = ?').bind(activeOrgId, 'department').first(); // Adjust if department exists

      // Reuse the structure but populate with scoped data
      // For the dashboard UI compatibility, we might need to adjust what we return
      // or simply return "userManagedStats" structure which seems to be what the UI uses for detailed view

      const pendingInspections = await db.prepare('SELECT COUNT(*) as count FROM inspections WHERE organization_id = ? AND status = ?').bind(activeOrgId, 'pendente').first();
      const activeInspections = await db.prepare('SELECT COUNT(*) as count FROM inspections WHERE organization_id = ? AND status IN (?, ?)').bind(activeOrgId, 'em_andamento', 'revisao').first();

      stats.userManagedStats = {
        totalUsers: orgUsers?.count || 0,
        totalSubsidiaries: subsidiaries?.count || 0,
        pendingInspections: pendingInspections?.count || 0,
        activeInspections: activeInspections?.count || 0
      };

      // Also populate top counters if this is an organization view
      stats.totalUsers = orgUsers?.count || 0;
      stats.totalSubsidiaries = subsidiaries?.count || 0;
      // Master/Companies count makes less sense here, keeping 0 or maybe showing 1
    }
    // CASE 2: Global View (System Admin)
    else if (user.role === USER_ROLES.SYSTEM_ADMIN || user.role === 'sys_admin' || user.role === 'system_admin') {
      const masterOrgs = await db.prepare("SELECT COUNT(*) as count FROM organizations WHERE type = 'master'").first();
      // Companies: Top level (no parent) and NOT master
      const companies = await db.prepare("SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id IS NULL AND type != 'master'").first();
      // Subsidiaries: Any org with a parent
      const subsidiaries = await db.prepare("SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id IS NOT NULL").first();
      const users = await db.prepare('SELECT COUNT(*) as count FROM users WHERE is_active = true').first();

      stats.totalMasterOrgs = masterOrgs?.count || 0;
      stats.totalCompanies = companies?.count || 0;
      stats.totalSubsidiaries = subsidiaries?.count || 0;
      stats.totalUsers = users?.count || 0;
    }
    // CASE 3: Managed View (Org Admin - legacy fallback)
    else if ((user.role === USER_ROLES.ORG_ADMIN || user.role === 'org_admin') && user.managed_organization_id) {
      const orgId = user.managed_organization_id;

      const orgUsers = await db.prepare(`
        SELECT COUNT(*) as count 
        FROM users u 
        WHERE u.organization_id = ? OR u.organization_id IN(
          SELECT id FROM organizations WHERE parent_organization_id = ?
        ) AND u.is_active = true
      `).bind(orgId, orgId).first();

      const subsidiaries = await db.prepare('SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ?').bind(orgId).first();

      const pendingInspections = await db.prepare(`
        SELECT COUNT(*) as count 
        FROM inspections 
        WHERE organization_id = ? OR organization_id IN(
          SELECT id FROM organizations WHERE parent_organization_id = ?
        ) AND status = 'pendente'
      `).bind(orgId, orgId).first();

      const activeInspections = await db.prepare(`
        SELECT COUNT(*) as count 
        FROM inspections 
        WHERE organization_id = ? OR organization_id IN(
          SELECT id FROM organizations WHERE parent_organization_id = ?
        ) AND status IN('em_andamento', 'revisao')
      `).bind(orgId, orgId).first();

      stats.userManagedStats = {
        totalUsers: orgUsers?.count || 0,
        totalSubsidiaries: subsidiaries?.count || 0,
        pendingInspections: pendingInspections?.count || 0,
        activeInspections: activeInspections?.count || 0
      };
      // Populate defaults for UI
      stats.totalUsers = orgUsers?.count || 0;
    }

    return c.json(stats);
  } catch (error) {
    console.error('Error fetching organization stats:', error);
    return c.json({ error: 'Erro interno do servidor' }, 500);
  }
});

// Get all organizations (with user filtering)
app.get('/', tenantAuthMiddleware, async (c) => {
  console.log('[ORGS] GET / route handler reached');
  try {
    const user = c.get('user') as ExtendedMochaUser;
    console.log('[ORGS] User:', user?.email || 'NO USER');
    const db = getDatabase(c.env);

    // Get user profile
    const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile) {
      console.error('[ORGS] User profile NOT found for ID:', user.id);
      return c.json({ error: "User profile not found (DB mismatch)" }, 400);
    }
    console.log('[ORGS] User profile found, role:', userProfile.role);

    let query = `
      SELECT o.*,
  (SELECT COUNT(*) FROM users WHERE organization_id = o.id AND is_active = true) as user_count,
    (SELECT COUNT(*) FROM organizations WHERE parent_organization_id = o.id AND is_active = true) as subsidiary_count,
      po.name as parent_organization_name
      FROM organizations o
      LEFT JOIN organizations po ON o.parent_organization_id = po.id
  `;

    const params: any[] = [];
    const whereConditions: string[] = [];

    // Filter based on user role
    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {
      // System admin sees all organizations
      whereConditions.push("o.is_active = true");
    } else {
      // All other users see:
      // 1. Orgs they manage (if Org Admin) + Subsidiaries
      // 2. Orgs they are explicitly assigned to via user_organizations
      // 3. Their primary organization (fallback)

      const userId = user.id;
      // We use a broader clause:
      // ID in user_organizations
      // OR ID = primary org
      // OR (Role=OrgAdmin AND (ID=Managed OR Parent=Managed))

      let subConditions = [];
      const subParams = [];

      // 1. Explicit assignments & Primary (via user_organizations usually has primary, but legacy fallback:)
      subConditions.push(`o.id IN (SELECT organization_id FROM user_organizations WHERE user_id = '${userId}')`);

      // 2. Legacy Primary
      if (userProfile.organization_id) {
        subConditions.push("o.id = ?");
        subParams.push(userProfile.organization_id);
      }

      // 3. Managed Hierarchy (Org Admin)
      if (userProfile.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {
        subConditions.push("(o.id = ? OR o.parent_organization_id = ?)");
        subParams.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
      }

      if (subConditions.length > 0) {
        whereConditions.push(`(${subConditions.join(' OR ')}) AND o.is_active = true`);
        params.push(...subParams);
      } else {
        whereConditions.push("1 = 0"); // No access
      }
    }

    if (whereConditions.length > 0) {
      query += " WHERE " + whereConditions.join(" AND ");
    }

    query += " ORDER BY o.parent_organization_id IS NULL DESC, o.name ASC";

    const organizations = await db.prepare(query).bind(...params).all();

    // Get user counts for each organization
    const userCounts: Record<number, number> = {};
    for (const org of (organizations.results || [])) {
      const orgData = org as any;
      userCounts[orgData.id] = orgData.user_count || 0;
    }

    return c.json({
      organizations: organizations.results || [],
      userCounts
    });

  } catch (error) {
    console.error('Error fetching organizations:', error);
    return c.json({ error: 'Erro ao buscar organizaÃ§Ãµes' }, 500);
  }
});

// Get single organization by ID
app.get('/:id', tenantAuthMiddleware, async (c) => {
  try {
    const user = c.get('user') as ExtendedMochaUser;
    const db = getDatabase(c.env);
    const organizationId = parseInt(c.req.param('id'));

    if (isNaN(organizationId)) {
      return c.json({ error: 'ID de organizaÃ§Ã£o invÃ¡lido' }, 400);
    }

    // Get user profile
    const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile) {
      return c.json({ error: "User profile not found" }, 404);
    }

    // Check permissions
    let hasAccess = false;
    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {
      hasAccess = true;
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Check if this organization is under their management
      const orgCheck = await db.prepare(`
        SELECT id FROM organizations 
        WHERE id = ? AND(id = ? OR parent_organization_id = ?)
        `).bind(organizationId, userProfile.managed_organization_id, userProfile.managed_organization_id).first();
      hasAccess = !!orgCheck;
    } else {
      console.log(`[ORGS - DEBUG] Deep Check for User: ${user.email} Role: ${userProfile.role} `);
      console.log(`[ORGS - DEBUG] User OrgID: ${userProfile.organization_id} (Type: ${typeof userProfile.organization_id})`);
      console.log(`[ORGS - DEBUG] Target OrgID: ${organizationId} (Type: ${typeof organizationId})`);

      // Use loose equality to handle possible BigInt/Number mismatch
      hasAccess = userProfile.organization_id == organizationId;
      console.log(`[ORGS - DEBUG] Direct Access Result: ${hasAccess} `);
    }

    if (!hasAccess) {
      // Allow access if user is participating in an event or inspection in this organization
      const userEmail = userProfile.email || user.email;
      console.log(`[ORGS] Checking participation for ${userEmail} in Org ${organizationId} `);

      const inspectionAccess = await db.prepare("SELECT id FROM inspections WHERE organization_id = ? AND inspector_email = ?").bind(organizationId, userEmail).first();
      if (inspectionAccess) {
        console.log('[ORGS-DEBUG] Access granted via Inspection:', inspectionAccess);
        hasAccess = true;
      } else {
        // Check calendar participation
        console.log(`[ORGS - DEBUG] Checking calendar for: ${userEmail} `);
        const calendarAccess = await db.prepare("SELECT id FROM calendar_events WHERE organization_id = ? AND participants::text LIKE ?").bind(organizationId, `%"${userEmail}"%`).first();
        if (calendarAccess) {
          console.log('[ORGS-DEBUG] Access granted via Calendar:', calendarAccess);
          hasAccess = true;
        } else {
          console.log('[ORGS-DEBUG] No calendar access found.');
        }
      }
    }

    if (!hasAccess) {
      return c.json({ error: 'Acesso negado a esta organizaÃ§Ã£o' }, 403);
    }

    // Get organization with additional data
    // Get organization basic data
    const organization = await db.prepare(`
      SELECT o.*, po.name as parent_organization_name
      FROM organizations o
      LEFT JOIN organizations po ON o.parent_organization_id = po.id
      WHERE o.id = ?
    `).bind(organizationId).first() as any;

    if (!organization) {
      return c.json({ error: 'OrganizaÃ§Ã£o nÃ£o encontrada' }, 404);
    }

    // Fetch counts separately to avoid subquery issues
    try {
      const userCountResult = await db.prepare(`SELECT COUNT(*) as count FROM users WHERE organization_id = ? AND is_active = true`).bind(organizationId).first();
      organization.user_count = userCountResult?.count || 0;
    } catch (e) {
      console.error('Error fetching user count:', e);
      organization.user_count = 0;
    }

    try {
      const subCountResult = await db.prepare(`SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ? AND is_active = true`).bind(organizationId).first();
      organization.subsidiary_count = subCountResult?.count || 0;
    } catch (e) {
      console.error('Error fetching subsidiary count:', e);
      organization.subsidiary_count = 0;
    }

    if (!organization) {
      return c.json({ error: 'OrganizaÃ§Ã£o nÃ£o encontrada' }, 404);
    }

    return c.json({ organization });

  } catch (error: any) {
    console.error('Error fetching organization:', error);
    return c.json({
      error: 'Erro ao buscar organizaÃ§Ã£o',
      details: error.message,
      stack: error.stack
    }, 500);
  }
});

// Create new organization
app.post('/', tenantAuthMiddleware, async (c) => {
  try {
    const user = c.get('user') as ExtendedMochaUser;
    const db = getDatabase(c.env);

    // Get user profile
    const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile) {
      return c.json({ error: "User profile not found" }, 404);
    }

    // Check permissions
    if (!userProfile.can_create_organizations &&
      userProfile.role !== USER_ROLES.SYSTEM_ADMIN &&
      userProfile.role !== 'sys_admin') {
      return c.json({ error: 'PermissÃµes insuficientes para criar organizaÃ§Ãµes' }, 403);
    }

    const body = await c.req.json();
    const {
      name, type, description, contact_email, contact_phone, address,
      parent_organization_id, subscription_plan, max_users, max_subsidiaries,
      cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao,
      natureza_juridica, data_abertura, capital_social, porte_empresa,
      situacao_cadastral, numero_funcionarios, setor_industria,
      subsetor_industria, certificacoes_seguranca, data_ultima_auditoria,
      nivel_risco, contato_seguranca_nome, contato_seguranca_email,
      contato_seguranca_telefone, historico_incidentes, observacoes_compliance,
      website, faturamento_anual
    } = body;

    if (!name) {
      return c.json({ error: 'Nome da organizaÃ§Ã£o Ã© obrigatÃ³rio' }, 400);
    }

    // Determine organization level
    let orgLevel = 'company';
    let finalParentId = parent_organization_id;

    if (userProfile.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {
      // Org admin creates under their management
      finalParentId = userProfile.managed_organization_id;
      orgLevel = parent_organization_id ? 'subsidiary' : 'company';
    }

    const result = await db.prepare(`
      INSERT INTO organizations(
    name, type, description, contact_email, contact_phone, address,
    parent_organization_id, organization_level, subscription_status,
    subscription_plan, max_users, max_subsidiaries, is_active,
    cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao,
    natureza_juridica, data_abertura, capital_social, porte_empresa,
    situacao_cadastral, numero_funcionarios, setor_industria,
    subsetor_industria, certificacoes_seguranca, data_ultima_auditoria,
    nivel_risco, contato_seguranca_nome, contato_seguranca_email,
    contato_seguranca_telefone, historico_incidentes, observacoes_compliance,
    website, faturamento_anual,
    created_at, updated_at
  ) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
  RETURNING id
  `).bind(
      name,
      type || 'company',
      description || null,
      contact_email || null,
      contact_phone || null,
      address || null,
      finalParentId || null,
      orgLevel,
      'active',
      subscription_plan || 'basic',
      max_users || 50,
      max_subsidiaries || 0,
      true,
      cnpj || null,
      razao_social || null,
      nome_fantasia || null,
      cnae_principal || null,
      cnae_descricao || null,
      natureza_juridica || null,
      data_abertura || null,
      capital_social || null,
      porte_empresa || null,
      situacao_cadastral || null,
      numero_funcionarios || null,
      setor_industria || null,
      subsetor_industria || null,
      certificacoes_seguranca || null,
      data_ultima_auditoria || null,
      nivel_risco || 'medio',
      contato_seguranca_nome || null,
      contato_seguranca_email || null,
      contato_seguranca_telefone || null,
      historico_incidentes || null,
      observacoes_compliance || null,
      website || null,
      faturamento_anual || null
    ).first() as any;

    const organizationId = result?.id;

    if (!organizationId) {
      console.error('Error: Organization created but no ID returned');
      return c.json({ error: 'Erro ao obter ID da organizaÃ§Ã£o criada' }, 500);
    }

    // Log activity
    await db.prepare(`
      INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
VALUES(?, ?, ?, ?, ?, ?, NOW())
    `).bind(
      user.id,
      organizationId,
      'organization_created',
      `Criou organizaÃ§Ã£o: ${name} `,
      'organization',
      organizationId.toString()
    ).run();

    return c.json({
      id: organizationId,
      message: "OrganizaÃ§Ã£o criada com sucesso"
    });

  } catch (error) {
    console.error('Error creating organization:', error);
    return c.json({ error: error instanceof Error ? error.message : 'Erro ao criar organizaÃ§Ã£o' }, 500);
  }
});

// Update organization
app.put('/:id', tenantAuthMiddleware, async (c) => {
  try {
    const user = c.get('user') as ExtendedMochaUser;
    const db = getDatabase(c.env);
    const organizationId = parseInt(c.req.param('id'));

    if (isNaN(organizationId)) {
      return c.json({ error: 'ID de organizaÃ§Ã£o invÃ¡lido' }, 400);
    }

    // Get user profile
    const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile) {
      return c.json({ error: "User profile not found" }, 404);
    }

    // Check permissions
    let hasAccess = false;
    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {
      hasAccess = true;
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      const orgCheck = await db.prepare(`
        SELECT id FROM organizations 
        WHERE id = ? AND(id = ? OR parent_organization_id = ?)
  `).bind(organizationId, userProfile.managed_organization_id, userProfile.managed_organization_id).first();
      hasAccess = !!orgCheck;
    }

    if (!hasAccess) {
      return c.json({ error: 'PermissÃµes insuficientes para atualizar esta organizaÃ§Ã£o' }, 403);
    }

    const body = await c.req.json();

    // Build dynamic update query
    const updateFields = [];
    const updateValues = [];

    const allowedFields = [
      'name', 'type', 'description', 'contact_email', 'contact_phone', 'address',
      'subscription_plan', 'max_users', 'max_subsidiaries', 'is_active',
      'cnpj', 'razao_social', 'nome_fantasia', 'cnae_principal', 'cnae_descricao',
      'natureza_juridica', 'data_abertura', 'capital_social', 'porte_empresa',
      'situacao_cadastral', 'numero_funcionarios', 'setor_industria',
      'subsetor_industria', 'certificacoes_seguranca', 'data_ultima_auditoria',
      'nivel_risco', 'contato_seguranca_nome', 'contato_seguranca_email',
      'contato_seguranca_telefone', 'historico_incidentes', 'observacoes_compliance',
      'website', 'faturamento_anual', 'logo_url'
    ];

    for (const field of allowedFields) {
      if (body[field] !== undefined) {
        updateFields.push(`${field} = ?`);
        updateValues.push(body[field]);
      }
    }

    if (updateFields.length === 0) {
      return c.json({ message: "Nenhum campo para atualizar" }, 400);
    }

    updateFields.push("updated_at = NOW()");

    await db.prepare(`
      UPDATE organizations 
      SET ${updateFields.join(", ")}
      WHERE id = ?
  `).bind(...updateValues, organizationId).run();

    // Log activity
    await db.prepare(`
      INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
VALUES(?, ?, ?, ?, ?, ?, NOW())
    `).bind(
      user.id,
      organizationId,
      'organization_updated',
      `Atualizou organizaÃ§Ã£o: ${body.name || organizationId} `,
      'organization',
      organizationId.toString()
    ).run();

    return c.json({ message: "OrganizaÃ§Ã£o atualizada com sucesso" });

  } catch (error) {
    console.error('Error updating organization:', error);
    return c.json({ error: 'Erro ao atualizar organizaÃ§Ã£o' }, 500);
  }
});

// Delete organization
app.delete('/:id', tenantAuthMiddleware, async (c) => {
  try {
    const user = c.get('user') as ExtendedMochaUser;
    const db = getDatabase(c.env);
    const organizationId = parseInt(c.req.param('id'));

    if (isNaN(organizationId)) {
      return c.json({ error: 'ID de organizaÃ§Ã£o invÃ¡lido' }, 400);
    }

    // Get user profile
    const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile) {
      return c.json({ error: "User profile not found" }, 404);
    }

    // Check permissions - only system admin and org admin can delete
    let hasAccess = false;
    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {
      hasAccess = true;
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      const orgCheck = await db.prepare(`
        SELECT id FROM organizations 
        WHERE id = ? AND(id = ? OR parent_organization_id = ?)
  `).bind(organizationId, userProfile.managed_organization_id, userProfile.managed_organization_id).first();
      hasAccess = !!orgCheck;
    }

    if (!hasAccess) {
      return c.json({ error: 'PermissÃµes insuficientes para excluir esta organizaÃ§Ã£o' }, 403);
    }

    // Get organization to check if it exists
    const organization = await db.prepare("SELECT * FROM organizations WHERE id = ?").bind(organizationId).first() as any;

    if (!organization) {
      return c.json({ error: 'OrganizaÃ§Ã£o nÃ£o encontrada' }, 404);
    }

    // Check if organization has users or subsidiaries
    const userCount = await db.prepare("SELECT COUNT(*) as count FROM users WHERE organization_id = ? AND is_active = true").bind(organizationId).first() as any;
    const subsidiaryCount = await db.prepare("SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ? AND is_active = true").bind(organizationId).first() as any;

    if (userCount?.count > 0) {
      return c.json({
        error: `NÃ£o Ã© possÃ­vel excluir a organizaÃ§Ã£o.Ela possui ${userCount.count} usuÃ¡rio(s) ativo(s).`,
        details: 'Remova ou transfira todos os usuÃ¡rios antes de excluir a organizaÃ§Ã£o.'
      }, 400);
    }

    if (subsidiaryCount?.count > 0) {
      return c.json({
        error: `NÃ£o Ã© possÃ­vel excluir a organizaÃ§Ã£o.Ela possui ${subsidiaryCount.count} subsidiÃ¡ria(s) ativa(s).`,
        details: 'Remova ou transfira todas as subsidiÃ¡rias antes de excluir a organizaÃ§Ã£o.'
      }, 400);
    }

    // Check for inspections
    const inspectionCount = await db.prepare("SELECT COUNT(*) as count FROM inspections WHERE organization_id = ?").bind(organizationId).first() as any;

    if (inspectionCount?.count > 0) {
      return c.json({
        error: `NÃ£o Ã© possÃ­vel excluir a organizaÃ§Ã£o.Ela possui ${inspectionCount.count} inspeÃ§Ã£o(Ãµes) associada(s).`,
        details: 'Remova ou transfira todas as inspeÃ§Ãµes antes de excluir a organizaÃ§Ã£o.'
      }, 400);
    }

    // Soft delete - just mark as inactive instead of actual deletion
    await db.prepare(`
      UPDATE organizations 
      SET is_active = false, updated_at = NOW()
      WHERE id = ?
  `).bind(organizationId).run();

    // Log activity
    await db.prepare(`
      INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
VALUES(?, ?, ?, ?, ?, ?, NOW())
    `).bind(
      user.id,
      organizationId,
      'organization_deleted',
      `Excluiu organizaÃ§Ã£o: ${organization.name} `,
      'organization',
      organizationId.toString()
    ).run();

    return c.json({
      message: "OrganizaÃ§Ã£o excluÃ­da com sucesso",
      note: "A organizaÃ§Ã£o foi desativada mas seus dados foram preservados."
    });

  } catch (error) {
    console.error('Error deleting organization:', error);
    return c.json({ error: 'Erro ao excluir organizaÃ§Ã£o' }, 500);
  }
});

// Increment AI usage count for an organization
app.post('/increment-ai-usage', tenantAuthMiddleware, async (c) => {
  try {
    const user = c.get('user') as ExtendedMochaUser;
    const db = getDatabase(c.env);

    const body = await c.req.json();
    const { organization_id } = body;

    if (!organization_id) {
      return c.json({ error: 'organization_id Ã© obrigatÃ³rio' }, 400);
    }

    // Get user profile to verify access
    const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile) {
      return c.json({ error: "User profile not found" }, 404);
    }

    // Verify user belongs to this organization or is admin
    const hasAccess =
      userProfile.organization_id === organization_id ||
      userProfile.managed_organization_id === organization_id ||
      userProfile.role === USER_ROLES.SYSTEM_ADMIN ||
      userProfile.role === 'sys_admin';

    if (!hasAccess) {
      return c.json({ error: 'Acesso negado' }, 403);
    }

    // Increment the counter
    await db.prepare(`
      UPDATE organizations 
      SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1,
  updated_at = NOW()
      WHERE id = ?
  `).bind(organization_id).run();

    // Log to ai_usage_log if table exists
    try {
      await db.prepare(`
        INSERT INTO ai_usage_log(organization_id, user_id, feature_type, model_used, status, created_at)
VALUES(?, ?, 'analysis', 'gpt-4o-mini', 'success', NOW())
  `).bind(organization_id, user.id).run();
    } catch (logError) {
      console.warn('[AI-USAGE] Could not log to ai_usage_log:', logError);
    }

    console.log('[AI-USAGE] âœ… Incremented for org:', organization_id, 'by user:', user.id);

    return c.json({
      success: true,
      message: 'Uso de IA contabilizado'
    });

  } catch (error) {
    console.error('Error incrementing AI usage:', error);
    return c.json({ error: 'Erro ao contabilizar uso de IA' }, 500);
  }
});

export default app;

===END_FILE===
===FILE: supabase/functions/api/rate-limit-middleware.ts===
import { Context, Next } from 'hono';

/**
 * Rate Limit Middleware
 * Uses Postgres table `rate_limits` to track request counts using a sliding window strategy (simplified fixed window by expiry).
 * 
 * Strategy:
 * - Key: "user:{uuid}" or "ip:{ip_address}"
 * - Window: 60 seconds
 * - Fail-Open: If DB fails, allow request.
 */
export const rateLimitMiddleware = (reqPerMinute: number = 60) => {
    return async (c: Context, next: Next) => {
        const env = c.env as any;
        const db = env.DB;

        // Bypass checks if:
        // 1. DB not ready
        // 2. Request is OPTIONS (CORS preflight)
        if (!db || c.req.method === 'OPTIONS') {
            return next();
        }

        // 1. Identify Client
        const user = c.get('user');
        const ip = c.req.header('x-forwarded-for') || 'unknown';

        // Prioritize User ID, fallback to IP
        const key = user ? `user:${user.id}` : `ip:${ip}`;

        // Authenticated users get higher limit (5x base limit)
        // Public API (IP based): 60/min
        // User API (Token based): 300/min
        const effectiveLimit = user ? reqPerMinute * 5 : reqPerMinute;

        try {
            // 2. Upsert bucket in DB
            // Logic:
            // - If key exists and NOT expired: increment points
            // - If key exists and IS expired: reset points to 1, reset expiry
            // - If key does not exist: insert with points=1

            const now = new Date();
            const windowEnd = new Date(now.getTime() + 60000); // 1 minute window

            const query = `
                INSERT INTO rate_limits (key, points, expire_at)
                VALUES ($1, 1, $2)
                ON CONFLICT (key) DO UPDATE
                SET
                    points = CASE
                        WHEN rate_limits.expire_at < NOW() THEN 1
                        ELSE rate_limits.points + 1
                    END,
                    expire_at = CASE
                        WHEN rate_limits.expire_at < NOW() THEN $2
                        ELSE rate_limits.expire_at
                    END
                RETURNING points, expire_at;
            `;

            // Execute via D1 Wrapper
            const result = await db.prepare(query)
                .bind(key, windowEnd.toISOString())
                .first();

            if (result) {
                const points = result.points;
                const remaining = Math.max(0, effectiveLimit - points);

                // Set standard headers
                c.header('X-RateLimit-Limit', effectiveLimit.toString());
                c.header('X-RateLimit-Remaining', remaining.toString());
                c.header('X-RateLimit-Reset', result.expire_at);

                if (points > effectiveLimit) {
                    console.warn(`[RATE-LIMIT] Blocked ${key} (Points: ${points}/${effectiveLimit})`);
                    return c.json({
                        error: 'Too Many Requests',
                        message: 'VocÃª excedeu o limite de requisiÃ§Ãµes. O sistema possui proteÃ§Ã£o contra sobrecarga. Tente novamente em 1 minuto.'
                    }, 429);
                }
            }

        } catch (e) {
            console.error('[RATE-LIMIT] Error checking limits:', e);
            // Fail open: If rate limit DB fails, allow request to proceed to avoid downtime
        }

        await next();
    };
};
===END_FILE===
===FILE: supabase/functions/api/rbac-middleware.ts===
import { Context } from "hono";
import { USER_ROLES } from "./user-types.ts";
import {
  PROTECTED_SYSADMIN_EMAIL,
  PROTECTED_SYSADMIN_ID,
  isProtectedUser
} from "./security-protection.ts";

// DefiniÃ§Ã£o de escopos do sistema
export const SCOPES = {
  USERS_READ: 'users:read',
  USERS_WRITE: 'users:write',
  USERS_DELETE: 'users:delete',
  USERS_INVITATIONS_READ: 'users:invitations:read',
  USERS_INVITATIONS_WRITE: 'users:invitations:write',
  CHECKLIST_FOLDERS_READ: 'checklist:folders:read',
  CHECKLIST_FOLDERS_WRITE: 'checklist:folders:write',
  CHECKLIST_FOLDERS_DELETE: 'checklist:folders:delete',
  CHECKLIST_TEMPLATES_READ: 'checklist:templates:read',
  CHECKLIST_TEMPLATES_WRITE: 'checklist:templates:write',
  ORGANIZATIONS_READ: 'organizations:read',
  ORGANIZATIONS_WRITE: 'organizations:write',
  INSPECTIONS_READ: 'inspections:read',
  INSPECTIONS_WRITE: 'inspections:write',
  SYSTEM_ADMIN: 'system:admin'
} as const;

// Mapeamento de roles para escopos
const ROLE_SCOPES_MAP: Record<string, string[]> = {
  [USER_ROLES.SYSTEM_ADMIN]: Object.values(SCOPES), // Acesso total a todos os escopos
  'sys_admin': Object.values(SCOPES), // Acesso total a todos os escopos
  'admin': Object.values(SCOPES), // Compatibilidade com role admin antigo
  [USER_ROLES.ORG_ADMIN]: [
    SCOPES.USERS_READ,
    SCOPES.USERS_WRITE,
    SCOPES.USERS_INVITATIONS_READ,
    SCOPES.USERS_INVITATIONS_WRITE,
    SCOPES.CHECKLIST_FOLDERS_READ,
    SCOPES.CHECKLIST_FOLDERS_WRITE,
    SCOPES.CHECKLIST_TEMPLATES_READ,
    SCOPES.CHECKLIST_TEMPLATES_WRITE,
    SCOPES.ORGANIZATIONS_READ,
    SCOPES.ORGANIZATIONS_WRITE,
    SCOPES.INSPECTIONS_READ,
    SCOPES.INSPECTIONS_WRITE
  ],
  [USER_ROLES.MANAGER]: [
    SCOPES.USERS_READ,
    SCOPES.CHECKLIST_FOLDERS_READ,
    SCOPES.CHECKLIST_FOLDERS_WRITE,
    SCOPES.CHECKLIST_TEMPLATES_READ,
    SCOPES.CHECKLIST_TEMPLATES_WRITE,
    SCOPES.INSPECTIONS_READ,
    SCOPES.INSPECTIONS_WRITE
  ],
  [USER_ROLES.INSPECTOR]: [
    SCOPES.CHECKLIST_FOLDERS_READ,
    SCOPES.CHECKLIST_TEMPLATES_READ,
    SCOPES.INSPECTIONS_READ,
    SCOPES.INSPECTIONS_WRITE
  ],
  [USER_ROLES.CLIENT]: [
    SCOPES.INSPECTIONS_READ
  ]
};

// CONSTANTES MOVIDAS PARA security-protection.ts - PROTEÃ‡ÃƒO CENTRALIZADA

// FunÃ§Ã£o para obter escopos de um usuÃ¡rio baseado no role
export function getUserScopes(userRole: string): string[] {
  return ROLE_SCOPES_MAP[userRole] || [];
}

// FunÃ§Ã£o para verificar se usuÃ¡rio tem escopos necessÃ¡rios
export function hasRequiredScopes(userScopes: string[], requiredScopes: string[]): boolean {
  if (requiredScopes.length === 0) return true;

  // Se o usuÃ¡rio tem escopo de system admin, tem acesso a tudo
  if (userScopes.includes(SCOPES.SYSTEM_ADMIN)) {
    return true;
  }

  // Verifica se tem todos os escopos necessÃ¡rios (AND) ou pelo menos um (OR)
  // Por padrÃ£o, usa OR para ser mais flexÃ­vel
  return requiredScopes.some(scope => userScopes.includes(scope));
}

// Middleware de verificaÃ§Ã£o de escopos
export function requireScopes(...scopes: string[]) {
  return async (c: Context, next: () => Promise<void>) => {
    const user = c.get("user");

    if (!user) {
      return c.json({
        error: "unauthorized",
        message: "UsuÃ¡rio nÃ£o autenticado",
        required_scopes: scopes
      }, 401);
    }

    try {
      // OTIMIZAÃ‡ÃƒO: Primeiro tentar usar o perfil jÃ¡ carregado pelo tenantAuthMiddleware
      // Evita query redundante ao banco de dados
      let userProfile = user.role ? user : null;

      // Fallback: buscar do banco apenas se nÃ£o tiver role no contexto
      if (!userProfile || !userProfile.role) {
        const env = c.env;
        userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;
        console.log('[RBAC] Buscou perfil do banco (fallback)');
      }

      // Fallback para usuÃ¡rio demo se nÃ£o encontrar no banco
      if (!userProfile && (user as any).profile) {
        console.log('[RBAC] Usando perfil do contexto (Demo/Mock)');
        const demoUser = user as any;
        userProfile = {
          ...demoUser.profile,
          id: user.id,
          email: user.email,
          name: demoUser.name || user.email
        };
      }

      if (!userProfile) {
        return c.json({
          error: "forbidden",
          message: "Perfil de usuÃ¡rio nÃ£o encontrado",
          required_scopes: scopes
        }, 403);
      }

      // Obter escopos do usuÃ¡rio baseado no role
      const userScopes = getUserScopes(userProfile.role);

      // Verificar se tem os escopos necessÃ¡rios
      if (!hasRequiredScopes(userScopes, scopes)) {
        return c.json({
          error: "forbidden",
          message: "PermissÃµes insuficientes para acessar este recurso",
          required_scopes: scopes,
          user_scopes: userScopes
        }, 403);
      }

      // Adicionar informaÃ§Ãµes de autorizaÃ§Ã£o no contexto
      c.set("userProfile", userProfile);
      c.set("userScopes", userScopes);

      await next();
    } catch (error) {
      console.error('Error in RBAC middleware:', error);
      return c.json({
        error: "internal_error",
        message: "Erro interno na verificaÃ§Ã£o de permissÃµes",
        required_scopes: scopes
      }, 500);
    }
  };
}

// Middleware para proteger o usuÃ¡rio sysadmin especÃ­fico
export function protectSysAdmin() {
  return async (c: Context, next: () => Promise<void>) => {
    const user = c.get("user");
    const method = c.req.method;
    let body: any = {};

    // Parse body safely
    try {
      body = await c.req.json();
    } catch (error) {
      // Body is not JSON or empty
    }

    const targetUserId = c.req.param("id");

    // ProteÃ§Ã£o absoluta: Bloquear QUALQUER tentativa de modificaÃ§Ã£o do usuÃ¡rio protegido
    if (targetUserId === PROTECTED_SYSADMIN_ID ||
      (body.id && body.id === PROTECTED_SYSADMIN_ID) ||
      (body.email === PROTECTED_SYSADMIN_EMAIL)) {

      if (method === 'PUT' || method === 'PATCH' || method === 'DELETE' || method === 'POST') {
        return c.json({
          error: "forbidden",
          message: "ACESSO NEGADO: Este usuÃ¡rio de sistema estÃ¡ permanentemente protegido contra modificaÃ§Ãµes",
          protected_user: true,
          system_protection: true
        }, 403);
      }
    }

    // Impedir que qualquer usuÃ¡rio (mesmo outros admins) modifique o sysadmin protegido
    if (user && user.id !== PROTECTED_SYSADMIN_ID) {
      // Se estÃ¡ tentando modificar o usuÃ¡rio protegido por ID
      if (targetUserId === PROTECTED_SYSADMIN_ID) {
        return c.json({
          error: "forbidden",
          message: "ACESSO NEGADO: Apenas o prÃ³prio usuÃ¡rio de sistema pode acessar esta conta",
          protected_user: true,
          system_protection: true
        }, 403);
      }

      // Se estÃ¡ tentando usar o email protegido
      if (body.email === PROTECTED_SYSADMIN_EMAIL) {
        return c.json({
          error: "forbidden",
          message: "ACESSO NEGADO: Este email estÃ¡ reservado para o sistema",
          protected_user: true,
          system_protection: true
        }, 403);
      }

      // Se estÃ¡ tentando alterar role para system_admin (apenas o sysadmin protegido pode criar outros)
      if (body.role === 'system_admin' || body.role === 'sys_admin') {
        return c.json({
          error: "forbidden",
          message: "ACESSO NEGADO: Apenas o administrador principal pode gerenciar roles de sistema",
          protected_user: true,
          system_protection: true
        }, 403);
      }
    }

    await next();
  };
}

// Middleware especÃ­fico para verificar se o usuÃ¡rio Ã© o sysadmin protegido
export function requireProtectedSysAdmin() {
  return async (c: Context, next: () => Promise<void>) => {
    const user = c.get("user");

    if (!user || (user.id !== PROTECTED_SYSADMIN_ID && user.email !== PROTECTED_SYSADMIN_EMAIL)) {
      return c.json({
        error: "forbidden",
        message: "ACESSO RESTRITO: Esta operaÃ§Ã£o requer autenticaÃ§Ã£o como administrador principal do sistema",
        protected_operation: true
      }, 403);
    }

    await next();
  };
}

// FunÃ§Ã£o para verificar se o usuÃ¡rio Ã© o sysadmin protegido
export function isProtectedSysAdmin(userId: string, userEmail?: string): boolean {
  return isProtectedUser(userId, userEmail);
}

// FunÃ§Ã£o auxiliar para padronizar respostas de erro
export function createAuthErrorResponse(type: 'unauthorized' | 'forbidden', message: string, requiredScopes: string[] = []) {
  return {
    error: type,
    message,
    required_scopes: requiredScopes,
    timestamp: new Date().toISOString()
  };
}

// FunÃ§Ã£o para verificar se usuÃ¡rio Ã© admin de sistema
export function isSystemAdmin(userRole: string): boolean {
  return userRole === USER_ROLES.SYSTEM_ADMIN || userRole === 'sys_admin' || userRole === 'admin';
}

// FunÃ§Ã£o para verificar se usuÃ¡rio pode gerenciar outros usuÃ¡rios
export function canManageUsers(userRole: string): boolean {
  return isSystemAdmin(userRole) || userRole === USER_ROLES.ORG_ADMIN || userRole === 'admin';
}

// FunÃ§Ã£o para verificar se usuÃ¡rio pode gerenciar organizaÃ§Ãµes
export function canManageOrganizations(userRole: string): boolean {
  return isSystemAdmin(userRole) || userRole === USER_ROLES.ORG_ADMIN || userRole === 'admin';
}

===END_FILE===
===FILE: supabase/functions/api/reset-project.ts===
import { Hono } from "hono";

type Env = {
  DB: any;
};

const app = new Hono<{ Bindings: Env; Variables: { user: any } }>();

// Endpoint para resetar completamente o banco
app.post("/reset/database", async (c) => {
  try {
    const db = c.env.DB;

    // 1. Drop all tables if they exist
    const dropTables = [
      'DROP TABLE IF EXISTS action_plans',
      'DROP TABLE IF EXISTS inspection_items',
      'DROP TABLE IF EXISTS checklist_fields',
      'DROP TABLE IF EXISTS checklist_templates',
      'DROP TABLE IF EXISTS inspections',
      'DROP TABLE IF EXISTS user_invitations',
      'DROP TABLE IF EXISTS organizations',
      'DROP TABLE IF EXISTS users'
    ];

    for (const query of dropTables) {
      await db.prepare(query).run();
    }

    // 2. Re-create all tables with correct schema
    const createQueries = [
      // Users table
      `CREATE TABLE users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        name TEXT,
        role TEXT DEFAULT 'inspector',
        can_manage_users BOOLEAN DEFAULT 0,
        can_create_organizations BOOLEAN DEFAULT 0,
        is_active BOOLEAN DEFAULT 1,
        organization_id INTEGER,
        managed_organization_id INTEGER,
        phone TEXT,
        avatar_url TEXT,
        last_login_at DATETIME,
        password_hash TEXT,
        email_verified_at DATETIME,
        profile_completed BOOLEAN DEFAULT 0,
        invitation_token TEXT,
        invited_by TEXT,
        invitation_expires_at DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`,

      // Organizations table  
      `CREATE TABLE organizations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        razao_social TEXT,
        nome_fantasia TEXT,
        cnpj TEXT,
        type TEXT,
        contact_email TEXT,
        contact_phone TEXT,
        address TEXT,
        is_active BOOLEAN DEFAULT 1,
        parent_organization_id INTEGER,
        organization_level TEXT DEFAULT 'company',
        subscription_status TEXT DEFAULT 'active',
        subscription_plan TEXT DEFAULT 'basic',
        max_users INTEGER DEFAULT 50,
        max_subsidiaries INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`,

      // Inspections table (com as colunas de assinatura da migraÃ§Ã£o 7)
      `CREATE TABLE inspections (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        description TEXT,
        location TEXT,
        inspector_name TEXT,
        inspector_email TEXT,
        company_name TEXT,
        cep TEXT,
        address TEXT,
        latitude REAL,
        longitude REAL,
        scheduled_date DATE,
        completed_date DATE,
        status TEXT DEFAULT 'pendente',
        priority TEXT DEFAULT 'media',
        created_by TEXT,
        organization_id INTEGER,
        responsible_name TEXT,
        responsible_email TEXT,
        inspector_signature TEXT,
        responsible_signature TEXT,
        action_plan TEXT,
        action_plan_type TEXT,
        ai_assistant_id TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (organization_id) REFERENCES organizations(id)
      )`,

      // Checklist templates
      `CREATE TABLE checklist_templates (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        category TEXT,
        created_by TEXT,
        created_by_user_id INTEGER,
        organization_id INTEGER,
        is_public BOOLEAN DEFAULT 0,
        is_category_folder BOOLEAN DEFAULT 0,
        folder_color TEXT,
        folder_icon TEXT,
        parent_category_id INTEGER,
        folder_id INTEGER,
        display_order INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (organization_id) REFERENCES organizations(id)
      )`
    ];

    for (const query of createQueries) {
      await db.prepare(query).run();
    }

    // 3. Insert initial data
    await db.prepare(`
      INSERT INTO organizations (name, organization_level, subscription_status) 
      VALUES ('OrganizaÃ§Ã£o Demo', 'master', 'active')
    `).run();

    await db.prepare(`
      INSERT INTO users (email, name, role, can_manage_users, can_create_organizations, organization_id) 
      VALUES ('eng.tiagosm@gmail.com', 'Admin Sistema', 'system_admin', 1, 1, 1)
    `).run();

    await db.prepare(`
      INSERT INTO checklist_templates (name, description, is_public, organization_id, created_by) 
      VALUES ('Template Demo', 'Template bÃ¡sico para testes', 1, 1, 'eng.tiagosm@gmail.com')
    `).run();

    return c.json({
      success: true,
      message: "Banco resetado e inicializado com dados bÃ¡sicos"
    });

  } catch (error) {
    console.error('Reset error:', error);
    return c.json({
      error: "Erro ao resetar banco",
      details: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

// Endpoint para verificar status do sistema
app.get("/status", async (c) => {
  try {
    const db = c.env.DB;

    const tables = await db.prepare(`
      SELECT name FROM sqlite_master WHERE type='table' ORDER BY name
    `).all();

    const counts: Record<string, any> = {};
    for (const table of tables.results) {
      try {
        const count = await db.prepare(`SELECT COUNT(*) as count FROM ${table.name}`).first();
        counts[table.name] = count.count;
      } catch (e) {
        counts[table.name] = 'erro';
      }
    }

    return c.json({
      database_connected: true,
      tables: tables.results.map((t: any) => t.name),
      record_counts: counts,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    return c.json({
      database_connected: false,
      error: error instanceof Error ? error.message : "Erro desconhecido"
    }, 500);
  }
});

export default app;

===END_FILE===
===FILE: supabase/functions/api/role-permissions-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware as authMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";

const rolePermissionsRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/role-permissions');

// Middleware to check if user can manage role permissions
const requirePermissionAdmin = async (c: any, next: any) => {
  const user = c.get("user");
  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await c.env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile) {
    return c.json({ error: "User profile not found" }, 404);
  }

  // Only system admin can manage role permissions
  if (userProfile.role !== USER_ROLES.SYSTEM_ADMIN &&
    userProfile.role !== USER_ROLES.SYS_ADMIN &&
    userProfile.role !== 'admin') {
    return c.json({ error: "Apenas administradores do sistema podem gerenciar permissÃµes" }, 403);
  }

  return next();
};

// Get all role permissions
rolePermissionsRoutes.get("/", authMiddleware, requirePermissionAdmin, async (c) => {
  const env = c.env;

  try {
    const permissions = await env.DB.prepare(`
      SELECT * FROM role_permissions 
      ORDER BY role, permission_type
    `).all();

    return c.json({
      permissions: permissions.results || []
    });

  } catch (error) {
    console.error('Error fetching role permissions:', error);
    return c.json({ error: "Erro ao buscar permissÃµes" }, 500);
  }
});

// Update role permissions
rolePermissionsRoutes.post("/", authMiddleware, requirePermissionAdmin, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const body = await c.req.json();
    const { updates } = body;

    if (!Array.isArray(updates)) {
      return c.json({ error: "Updates deve ser um array" }, 400);
    }

    // Process each update
    for (const update of updates) {
      const { role, permission_type, is_allowed } = update;

      if (!role || !permission_type || typeof is_allowed !== 'boolean') {
        continue; // Skip invalid updates
      }

      // Check if permission already exists
      const existing = await env.DB.prepare(`
        SELECT id FROM role_permissions 
        WHERE role = ? AND permission_type = ?
      `).bind(role, permission_type).first() as any;

      if (existing) {
        // Update existing permission
        await env.DB.prepare(`
          UPDATE role_permissions 
          SET is_allowed = ?, updated_at = NOW()
          WHERE id = ?
        `).bind(is_allowed, existing.id).run();
      } else {
        // Create new permission
        await env.DB.prepare(`
          INSERT INTO role_permissions (
            role, permission_type, is_allowed, organization_id,
            created_at, updated_at
          ) VALUES (?, ?, ?, ?, NOW(), NOW())
        `).bind(role, permission_type, is_allowed, null).run();
      }
    }

    // Log activity
    await env.DB.prepare(`
      INSERT INTO activity_log (
        user_id, organization_id, action_type, action_description,
        target_type, target_id, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, NOW())
    `).bind(
      user.id,
      null,
      'permissions_updated',
      `Atualizou ${updates.length} permissÃµes de papel`,
      'role_permissions',
      'bulk_update'
    ).run();

    return c.json({
      message: "PermissÃµes atualizadas com sucesso",
      updated_count: updates.length
    });

  } catch (error) {
    console.error('Error updating role permissions:', error);
    return c.json({ error: "Erro ao atualizar permissÃµes" }, 500);
  }
});

// Get permissions for specific role
rolePermissionsRoutes.get("/role/:role", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const role = c.req.param("role");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const permissions = await env.DB.prepare(`
      SELECT permission_type, is_allowed FROM role_permissions 
      WHERE role = ?
    `).bind(role).all();

    return c.json({
      role,
      permissions: permissions.results || []
    });

  } catch (error) {
    console.error('Error fetching role permissions:', error);
    return c.json({ error: "Erro ao buscar permissÃµes do papel" }, 500);
  }
});

// Check if user has specific permission
rolePermissionsRoutes.get("/check/:permission", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const permissionType = c.req.param("permission");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const userProfile = await env.DB.prepare("SELECT role FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile) {
      return c.json({ hasPermission: false });
    }

    // System admin has all permissions
    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN) {
      return c.json({ hasPermission: true });
    }

    // Check specific permission
    const permission = await env.DB.prepare(`
      SELECT is_allowed FROM role_permissions 
      WHERE role = ? AND permission_type = ?
    `).bind(userProfile.role, permissionType).first() as any;

    return c.json({
      hasPermission: permission?.is_allowed || false
    });

  } catch (error) {
    console.error('Error checking permission:', error);
    return c.json({ hasPermission: false });
  }
});

export default rolePermissionsRoutes;

===END_FILE===
===FILE: supabase/functions/api/secure-query-helper.ts===
import { Context } from "hono";
import { TenantContext } from "./tenant-auth-middleware.ts";

/**
 * SECURE QUERY HELPER - Isolamento de Dados Multi-Tenant
 * 
 * Este mÃ³dulo fornece funÃ§Ãµes para construir queries SQL seguras
 * que FORÃ‡AM o filtro de organization_id baseado no contexto de tenant.
 * 
 * @security O organization_id Ã© SEMPRE extraÃ­do do contexto seguro,
 * NUNCA do body/params da requisiÃ§Ã£o.
 */

export interface SecureQueryOptions {
    table: string;
    columns?: string[];
    conditions?: string[];
    params?: unknown[];
    orderBy?: string;
    limit?: number;
    offset?: number;
}

/**
 * ConstrÃ³i uma clÃ¡usula WHERE segura para isolamento de tenant
 * 
 * @security Esta funÃ§Ã£o garante que:
 * - System Admin: sem filtro de organizaÃ§Ã£o (acesso total)
 * - Org Admin: filtra por organizaÃ§Ã£o + subsidiÃ¡rias
 * - Outros: filtra apenas pela prÃ³pria organizaÃ§Ã£o
 */
export function buildTenantWhereClause(
    c: Context,
    tableAlias: string = ""
): { clause: string; params: unknown[] } {
    const tenantContext = c.get("tenantContext") as TenantContext | undefined;
    const prefix = tableAlias ? `${tableAlias}.` : "";

    // Sem contexto de tenant = sem filtro (requisiÃ§Ã£o nÃ£o autenticada)
    if (!tenantContext) {
        return { clause: "", params: [] };
    }

    // System Admin: acesso total, sem filtro
    if (tenantContext.isSystemAdmin) {
        return { clause: "", params: [] };
    }

    // Org Admin e usuÃ¡rios regulares: filtrar por organizaÃ§Ãµes permitidas
    if (tenantContext.allowedOrganizationIds.length === 0) {
        // UsuÃ¡rio sem organizaÃ§Ã£o: nÃ£o pode ver nada
        return { clause: `${prefix}organization_id = -1`, params: [] };
    }

    if (tenantContext.allowedOrganizationIds.length === 1) {
        return {
            clause: `${prefix}organization_id = ?`,
            params: [tenantContext.allowedOrganizationIds[0]]
        };
    }

    // MÃºltiplas organizaÃ§Ãµes (Org Admin com subsidiÃ¡rias)
    const placeholders = tenantContext.allowedOrganizationIds.map(() => "?").join(", ");
    return {
        clause: `${prefix}organization_id IN (${placeholders})`,
        params: tenantContext.allowedOrganizationIds
    };
}

/**
 * ConstrÃ³i uma query SELECT segura com isolamento de tenant automÃ¡tico
 * 
 * @example
 * const query = buildSecureSelectQuery(c, {
 *   table: 'inspections',
 *   columns: ['id', 'title', 'status'],
 *   conditions: ['status = ?'],
 *   params: ['pendente'],
 *   orderBy: 'created_at DESC'
 * });
 * const results = await env.DB.prepare(query.sql).bind(...query.params).all();
 */
export function buildSecureSelectQuery(
    c: Context,
    options: SecureQueryOptions
): { sql: string; params: unknown[] } {
    const { table, columns = ["*"], conditions = [], params = [], orderBy, limit, offset } = options;

    const tenantWhere = buildTenantWhereClause(c);
    const allConditions = [...conditions];
    const allParams = [...params];

    // Adicionar filtro de tenant se houver
    if (tenantWhere.clause) {
        allConditions.push(tenantWhere.clause);
        allParams.push(...tenantWhere.params);
    }

    let sql = `SELECT ${columns.join(", ")} FROM ${table}`;

    if (allConditions.length > 0) {
        sql += ` WHERE ${allConditions.join(" AND ")}`;
    }

    if (orderBy) {
        sql += ` ORDER BY ${orderBy}`;
    }

    if (limit !== undefined) {
        sql += ` LIMIT ${limit}`;
        if (offset !== undefined) {
            sql += ` OFFSET ${offset}`;
        }
    }

    return { sql, params: allParams };
}

/**
 * Verifica se o usuÃ¡rio pode acessar um registro especÃ­fico
 * 
 * @security Use esta funÃ§Ã£o antes de retornar dados de um registro Ãºnico
 * @returns true se o usuÃ¡rio tem acesso, false caso contrÃ¡rio
 */
export function canAccessRecord(
    c: Context,
    recordOrgId: number | null
): boolean {
    const tenantContext = c.get("tenantContext") as TenantContext | undefined;

    if (!tenantContext) return false;
    if (tenantContext.isSystemAdmin) return true;
    if (recordOrgId === null) return false;

    return tenantContext.allowedOrganizationIds.includes(recordOrgId);
}

/**
 * Extrai o organization_id seguro para INSERT
 * 
 * @security CRÃTICO: Esta funÃ§Ã£o NUNCA usa o organization_id do body
 * O ID sempre vem do contexto de tenant (token/banco)
 */
export function getSecureOrgIdForInsert(c: Context): number | null {
    const tenantContext = c.get("tenantContext") as TenantContext | undefined;

    if (!tenantContext) {
        throw new Error("Contexto de tenant nÃ£o disponÃ­vel");
    }

    // System Admin pode especificar organizaÃ§Ã£o via parÃ¢metro especial
    // (implementaÃ§Ã£o futura com validaÃ§Ã£o adicional)

    // Para usuÃ¡rios regulares, usar a organizaÃ§Ã£o do contexto
    return tenantContext.organizationId;
}

/**
 * Valida se o organization_id do body corresponde ao contexto seguro
 * 
 * @security Use para detectar tentativas de injeÃ§Ã£o de organization_id
 * @returns true se o ID Ã© vÃ¡lido ou nÃ£o foi fornecido, false se hÃ¡ tentativa de injeÃ§Ã£o
 */
export function validateOrgIdFromBody(
    c: Context,
    bodyOrgId: number | null | undefined
): { valid: boolean; message?: string } {
    const tenantContext = c.get("tenantContext") as TenantContext | undefined;

    if (!tenantContext) {
        return { valid: false, message: "Contexto de tenant nÃ£o disponÃ­vel" };
    }

    // Se nÃ£o foi fornecido no body, estÃ¡ ok
    if (bodyOrgId === null || bodyOrgId === undefined) {
        return { valid: true };
    }

    // System Admin pode especificar qualquer organizaÃ§Ã£o
    if (tenantContext.isSystemAdmin) {
        return { valid: true };
    }

    // Verificar se o ID fornecido estÃ¡ na lista de permitidos
    if (!tenantContext.allowedOrganizationIds.includes(bodyOrgId)) {
        return {
            valid: false,
            message: "Tentativa de acesso a organizaÃ§Ã£o nÃ£o autorizada detectada"
        };
    }

    return { valid: true };
}

/**
 * Registra um log de auditoria para operaÃ§Ãµes em inspeÃ§Ãµes
 * 
 * @security ObrigatÃ³rio para conformidade com LGPD
 */
export async function logInspectionChange(
    env: Env,
    inspectionId: number,
    userId: string,
    action: "CREATE" | "UPDATE" | "DELETE" | "FINALIZE",
    fieldChanged?: string,
    oldValue?: unknown,
    newValue?: unknown,
    ipAddress?: string,
    userAgent?: string
): Promise<void> {
    try {
        await env.DB.prepare(`
      INSERT INTO inspection_logs (
        inspection_id, user_id, action, field_changed,
        old_value, new_value, ip_address, user_agent, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW())
    `).bind(
            inspectionId,
            userId,
            action,
            fieldChanged || null,
            oldValue ? JSON.stringify(oldValue) : null,
            newValue ? JSON.stringify(newValue) : null,
            ipAddress || null,
            userAgent || null
        ).run();
    } catch (error) {
        // Log de auditoria nÃ£o deve bloquear a operaÃ§Ã£o principal
        console.error("[AUDIT-LOG] Erro ao registrar log de inspeÃ§Ã£o:", error);
    }
}

===END_FILE===
===FILE: supabase/functions/api/security-endpoints.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware as authMiddleware } from "./tenant-auth-middleware.ts";
import { requireProtectedSysAdmin } from "./rbac-middleware.ts";
import {
  checkProtectedUserIntegrity,
  autoFixProtectedUser,
  PROTECTED_SYSADMIN_EMAIL,
  PROTECTED_SYSADMIN_ID,
  MASTER_ORGANIZATION_ID
} from "./security-protection.ts";
import { autoFixSystemAdmin } from "./system-admin-protection.ts";

const securityRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();

// Endpoint para verificaÃ§Ã£o manual da integridade do sistema
securityRoutes.get("/integrity-check", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const integrityResult = await checkProtectedUserIntegrity(env);

    // Verificar tambÃ©m a proteÃ§Ã£o na tabela
    const protectionRecord = await env.DB.prepare(`
      SELECT * FROM protected_users WHERE user_id = ?
    `).bind(PROTECTED_SYSADMIN_ID).first() as any;

    // Verificar organizaÃ§Ã£o master
    const masterOrg = await env.DB.prepare(`
      SELECT * FROM organizations WHERE id = ?
    `).bind(MASTER_ORGANIZATION_ID).first() as any;

    // Verificar associaÃ§Ã£o com organizaÃ§Ã£o
    const userOrgAssociation = await env.DB.prepare(`
      SELECT * FROM user_organizations 
      WHERE user_id = ? AND organization_id = ?
    `).bind(PROTECTED_SYSADMIN_ID, MASTER_ORGANIZATION_ID).first() as any;

    return c.json({
      system_integrity: {
        protected_user: integrityResult,
        protection_record: protectionRecord ? "configured" : "missing",
        master_organization: masterOrg ? "exists" : "missing",
        user_org_association: userOrgAssociation ? "linked" : "missing"
      },
      security_status: {
        overall_status: integrityResult.status === 'ok' && protectionRecord && masterOrg && userOrgAssociation ? 'secure' : 'needs_attention',
        protected_user_id: PROTECTED_SYSADMIN_ID,
        protected_user_email: PROTECTED_SYSADMIN_EMAIL,
        master_organization_id: MASTER_ORGANIZATION_ID
      },
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error checking system integrity:', error);
    return c.json({ error: "Failed to check system integrity" }, 500);
  }
});

// Endpoint para auto-correÃ§Ã£o do sistema
securityRoutes.post("/auto-fix", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const fixResult = await autoFixProtectedUser(env, user.id);

    // Garantir que existe entrada na tabela de proteÃ§Ã£o
    await env.DB.prepare(`
      INSERT OR REPLACE INTO protected_users (
        user_id, protection_level, protected_roles, protected_permissions,
        reason, created_by, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())
    `).bind(
      PROTECTED_SYSADMIN_ID,
      'maximum',
      JSON.stringify(['system_admin']),
      JSON.stringify(['can_manage_users', 'can_create_organizations']),
      'UsuÃ¡rio fundador - proteÃ§Ã£o mÃ¡xima contra modificaÃ§Ãµes nÃ£o autorizadas',
      user.id
    ).run();

    // Log da operaÃ§Ã£o de seguranÃ§a
    await env.DB.prepare(`
      INSERT INTO security_audit_log (
        user_id, target_user_id, action_type, new_value,
        blocked_reason, is_blocked, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, NOW())
    `).bind(
      user.id,
      PROTECTED_SYSADMIN_ID,
      'manual_security_fix',
      JSON.stringify(fixResult),
      'CorreÃ§Ã£o manual de seguranÃ§a executada pelo administrador',
      false
    ).run();

    return c.json({
      success: true,
      fix_result: fixResult,
      protection_updated: true,
      message: "Sistema de seguranÃ§a verificado e corrigido",
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error fixing system security:', error);
    return c.json({ error: "Failed to fix system security" }, 500);
  }
});

// Endpoint para visualizar logs de seguranÃ§a
securityRoutes.get("/audit-logs", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const limit = parseInt(c.req.query("limit") || "50");
    const offset = parseInt(c.req.query("offset") || "0");

    // Buscar logs de seguranÃ§a relacionados ao usuÃ¡rio protegido
    const securityLogs = await env.DB.prepare(`
      SELECT * FROM security_audit_log 
      WHERE target_user_id = ? OR user_id = ?
      ORDER BY created_at DESC
      LIMIT ? OFFSET ?
    `).bind(PROTECTED_SYSADMIN_ID, PROTECTED_SYSADMIN_ID, limit, offset).all();

    // Contar total de logs
    const totalCount = await env.DB.prepare(`
      SELECT COUNT(*) as count FROM security_audit_log 
      WHERE target_user_id = ? OR user_id = ?
    `).bind(PROTECTED_SYSADMIN_ID, PROTECTED_SYSADMIN_ID).first() as any;

    // Buscar tentativas bloqueadas nas Ãºltimas 24h
    const recentBlocked = await env.DB.prepare(`
      SELECT COUNT(*) as count FROM security_audit_log 
      WHERE is_blocked = 1 AND created_at >= datetime('now', '-24 hours')
    `).first() as any;

    return c.json({
      audit_logs: securityLogs.results || [],
      pagination: {
        total: totalCount?.count || 0,
        limit,
        offset,
        has_more: (totalCount?.count || 0) > (offset + limit)
      },
      security_stats: {
        recent_blocked_attempts: recentBlocked?.count || 0,
        protected_user_id: PROTECTED_SYSADMIN_ID
      }
    });

  } catch (error) {
    console.error('Error fetching audit logs:', error);
    return c.json({ error: "Failed to fetch audit logs" }, 500);
  }
});

// Endpoint para verificar se hÃ¡ usuÃ¡rios Ã³rfÃ£os ou com configuraÃ§Ãµes incorretas
securityRoutes.get("/system-health", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Verificar usuÃ¡rios com role system_admin
    const systemAdmins = await env.DB.prepare(`
      SELECT id, email, name, role, is_active, organization_id 
      FROM users 
      WHERE role = 'system_admin'
    `).all();

    // Verificar usuÃ¡rios Ã³rfÃ£os (sem organizaÃ§Ã£o)
    const orphanUsers = await env.DB.prepare(`
      SELECT COUNT(*) as count FROM users 
      WHERE organization_id IS NULL AND role != 'system_admin'
    `).first() as any;

    // Verificar organizaÃ§Ãµes sem dono
    const organizationsWithoutOwner = await env.DB.prepare(`
      SELECT o.id, o.name FROM organizations o
      LEFT JOIN user_organizations uo ON o.id = uo.organization_id AND uo.role = 'owner'
      WHERE uo.organization_id IS NULL
    `).all();

    // Verificar usuÃ¡rios com permissÃµes inconsistentes
    const inconsistentUsers = await env.DB.prepare(`
      SELECT id, email, role, can_manage_users, can_create_organizations 
      FROM users 
      WHERE (role = 'org_admin' AND (can_manage_users = 0 OR can_create_organizations = 0))
         OR (role = 'system_admin' AND (can_manage_users = 0 OR can_create_organizations = 0))
         OR (role NOT IN ('system_admin', 'org_admin') AND (can_manage_users = 1 OR can_create_organizations = 1))
    `).all();

    return c.json({
      system_health: {
        system_admins: {
          count: systemAdmins.results?.length || 0,
          users: systemAdmins.results || []
        },
        orphan_users: orphanUsers?.count || 0,
        organizations_without_owner: {
          count: organizationsWithoutOwner.results?.length || 0,
          organizations: organizationsWithoutOwner.results || []
        },
        inconsistent_permissions: {
          count: inconsistentUsers.results?.length || 0,
          users: inconsistentUsers.results || []
        }
      },
      health_status: {
        overall: "analyzing",
        issues_found: (orphanUsers?.count || 0) + (organizationsWithoutOwner.results?.length || 0) + (inconsistentUsers.results?.length || 0),
        protected_user_secure: true
      },
      recommendations: [
        "Manter apenas um usuÃ¡rio system_admin principal",
        "Associar usuÃ¡rios Ã³rfÃ£os a organizaÃ§Ãµes apropriadas",
        "Garantir que todas as organizaÃ§Ãµes tenham um proprietÃ¡rio",
        "Corrigir permissÃµes inconsistentes de usuÃ¡rios"
      ]
    });

  } catch (error) {
    console.error('Error checking system health:', error);
    return c.json({ error: "Failed to check system health" }, 500);
  }
});

// Auto-fix endpoint adicional - Corrige problemas automaticamente (versÃ£o simplificada)
securityRoutes.post('/auto-fix-simple', authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get('user');

  if (!user) {
    return c.json({ error: 'User not found' }, 401);
  }

  // Verificar se Ã© system_admin ou admin principal
  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  const isSystemAdmin = userProfile?.role === 'sys_admin' ||
    userProfile?.role === 'system_admin' ||
    user.email === 'eng.tiagosm@gmail.com';

  if (!isSystemAdmin) {
    return c.json({ error: 'Acesso negado. Apenas system_admin pode executar auto-correÃ§Ã£o.' }, 403);
  }

  try {
    console.log('[AUTO-FIX-SIMPLE] Iniciando auto-correÃ§Ã£o do sistema...');

    const result = await autoFixSystemAdmin(env);

    if (result.success) {
      return c.json({
        success: true,
        message: result.message,
        timestamp: new Date().toISOString()
      });
    } else {
      return c.json({
        success: false,
        error: result.message
      }, 500);
    }
  } catch (error) {
    console.error('[AUTO-FIX-SIMPLE] Erro na auto-correÃ§Ã£o:', error);
    return c.json({
      error: 'Erro interno na auto-correÃ§Ã£o',
      details: error instanceof Error ? error.message : 'Erro desconhecido'
    }, 500);
  }
});

export default securityRoutes;

===END_FILE===
===FILE: supabase/functions/api/security-protection.ts===
import { Context } from "hono";
import { USER_ROLES } from "./user-types.ts";

// Constantes de seguranÃ§a - NUNCA ALTERAR ESTES VALORES
export const PROTECTED_SYSADMIN_EMAIL = 'eng.tiagosm@gmail.com';
export const PROTECTED_SYSADMIN_ID = '84edf8d1-77d9-4c73-935e-d76745bc3707';
export const MASTER_ORGANIZATION_ID = 1;

// FunÃ§Ã£o para verificar se um usuÃ¡rio estÃ¡ protegido
export function isProtectedUser(userId: string, userEmail?: string): boolean {
  return userId === PROTECTED_SYSADMIN_ID || userEmail === PROTECTED_SYSADMIN_EMAIL;
}

// Middleware de proteÃ§Ã£o de usuÃ¡rios crÃ­ticos
export function criticalUserProtection() {
  return async (c: Context<{ Bindings: Env; Variables: { user: any } }>, next: () => Promise<void>) => {
    const method = c.req.method;
    const path = c.req.path;
    const targetUserId = c.req.param("id");

    // Skip GET requests (apenas proteÃ§Ã£o para mudanÃ§as)
    if (method === 'GET') {
      await next();
      return;
    }

    let body: any = {};
    try {
      body = await c.req.json();
    } catch (error) {
      // Body is not JSON or empty
    }

    // PROTEÃ‡ÃƒO ABSOLUTA: Bloquear qualquer modificaÃ§Ã£o do usuÃ¡rio protegido
    const isTargetingProtectedUser =
      targetUserId === PROTECTED_SYSADMIN_ID ||
      body.id === PROTECTED_SYSADMIN_ID ||
      body.email === PROTECTED_SYSADMIN_EMAIL ||
      body.user_id === PROTECTED_SYSADMIN_ID;

    if (isTargetingProtectedUser && (method === 'PUT' || method === 'PATCH' || method === 'DELETE')) {
      const user = c.get("user");

      // Log da tentativa de modificaÃ§Ã£o
      try {
        const env = c.env;
        await env.DB.prepare(`
          INSERT INTO security_audit_log (
            user_id, target_user_id, action_type, old_value, new_value, 
            blocked_reason, ip_address, user_agent, is_blocked, created_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
        `).bind(
          user?.id || 'anonymous',
          PROTECTED_SYSADMIN_ID,
          `blocked_${method.toLowerCase()}_attempt`,
          JSON.stringify({ path, method }),
          JSON.stringify(body),
          'Tentativa de modificar usuÃ¡rio protegido do sistema',
          c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown',
          c.req.header('user-agent') || 'unknown',
          true
        ).run();
      } catch (error) {
        console.error('Error logging security attempt:', error);
      }

      return c.json({
        error: "SISTEMA_PROTEGIDO",
        message: "ACESSO NEGADO: Este usuÃ¡rio estÃ¡ sob proteÃ§Ã£o absoluta do sistema. Tentativa registrada.",
        protected_user: true,
        system_security: true,
        contact_support: "Entre em contato com o suporte tÃ©cnico se necessÃ¡rio.",
        blocked_at: new Date().toISOString()
      }, 403);
    }

    // Impedir criaÃ§Ã£o de novos system_admin (apenas o protegido pode fazer isso)
    if (body.role === USER_ROLES.SYSTEM_ADMIN || body.role === 'sys_admin') {
      const user = c.get("user");

      if (!user || user.id !== PROTECTED_SYSADMIN_ID) {
        return c.json({
          error: "PRIVILEGIO_RESTRITO",
          message: "Apenas o administrador principal pode conceder privilÃ©gios de sistema",
          protected_operation: true
        }, 403);
      }
    }

    await next();
  };
}

// FunÃ§Ã£o para verificar integridade do usuÃ¡rio protegido
export async function checkProtectedUserIntegrity(env: any): Promise<{
  status: 'ok' | 'corrupted' | 'missing';
  details: any;
  fixed?: boolean;
}> {
  try {
    const protectedUser = await env.DB.prepare(`
      SELECT * FROM users WHERE id = ? OR email = ?
    `).bind(PROTECTED_SYSADMIN_ID, PROTECTED_SYSADMIN_EMAIL).first() as any;

    if (!protectedUser) {
      return {
        status: 'missing',
        details: { error: 'UsuÃ¡rio protegido nÃ£o encontrado no banco de dados' }
      };
    }

    const expectedConfig = {
      role: USER_ROLES.SYSTEM_ADMIN,
      can_manage_users: true,
      can_create_organizations: true,
      is_active: true,
      organization_id: MASTER_ORGANIZATION_ID
    };

    const currentConfig = {
      role: protectedUser.role,
      can_manage_users: Boolean(protectedUser.can_manage_users),
      can_create_organizations: Boolean(protectedUser.can_create_organizations),
      is_active: Boolean(protectedUser.is_active),
      organization_id: protectedUser.organization_id
    };

    const isCorrupted = Object.keys(expectedConfig).some(key =>
      expectedConfig[key as keyof typeof expectedConfig] !== currentConfig[key as keyof typeof currentConfig]
    );

    if (isCorrupted) {
      return {
        status: 'corrupted',
        details: {
          expected: expectedConfig,
          current: currentConfig,
          differences: Object.keys(expectedConfig).filter(key =>
            expectedConfig[key as keyof typeof expectedConfig] !== currentConfig[key as keyof typeof currentConfig]
          )
        }
      };
    }

    return {
      status: 'ok',
      details: { user: protectedUser, configuration: currentConfig }
    };

  } catch (error) {
    return {
      status: 'corrupted',
      details: { error: 'Erro ao verificar integridade do usuÃ¡rio protegido', details: error }
    };
  }
}

// FunÃ§Ã£o para auto-correÃ§Ã£o do usuÃ¡rio protegido
export async function autoFixProtectedUser(env: any, triggeredBy: string = 'system'): Promise<{
  success: boolean;
  action: 'created' | 'updated' | 'no_action_needed';
  details: any;
}> {
  try {
    const integrityCheck = await checkProtectedUserIntegrity(env);

    if (integrityCheck.status === 'ok') {
      return {
        success: true,
        action: 'no_action_needed',
        details: { message: 'UsuÃ¡rio protegido jÃ¡ estÃ¡ configurado corretamente' }
      };
    }

    if (integrityCheck.status === 'missing') {
      // Recriar usuÃ¡rio completamente
      await env.DB.prepare(`
        INSERT OR REPLACE INTO users (
          id, email, name, role, organization_id,
          can_manage_users, can_create_organizations, is_active,
          created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `).bind(
        PROTECTED_SYSADMIN_ID,
        PROTECTED_SYSADMIN_EMAIL,
        'Tiago dos Santos Martins - SysAdmin',
        USER_ROLES.SYSTEM_ADMIN,
        MASTER_ORGANIZATION_ID,
        true,
        true,
        true
      ).run();

      // Garantir associaÃ§Ã£o com organizaÃ§Ã£o master
      await env.DB.prepare(`
        INSERT OR REPLACE INTO user_organizations (
          user_id, organization_id, role, is_active, created_at, updated_at
        ) VALUES (?, ?, ?, ?, NOW(), NOW())
      `).bind(PROTECTED_SYSADMIN_ID, MASTER_ORGANIZATION_ID, 'owner', true).run();

      // Adicionar Ã  tabela de usuÃ¡rios protegidos
      await env.DB.prepare(`
        INSERT OR REPLACE INTO protected_users (
          user_id, protection_level, protected_roles, protected_permissions,
          reason, created_by, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())
      `).bind(
        PROTECTED_SYSADMIN_ID,
        'maximum',
        JSON.stringify([USER_ROLES.SYSTEM_ADMIN]),
        JSON.stringify(['can_manage_users', 'can_create_organizations']),
        'UsuÃ¡rio fundador do sistema - proteÃ§Ã£o mÃ¡xima permanente',
        triggeredBy
      ).run();

      return {
        success: true,
        action: 'created',
        details: { message: 'UsuÃ¡rio protegido foi recriado com configuraÃ§Ãµes de seguranÃ§a mÃ¡xima' }
      };
    }

    if (integrityCheck.status === 'corrupted') {
      // Corrigir configuraÃ§Ãµes
      await env.DB.prepare(`
        UPDATE users 
        SET role = ?, organization_id = ?, can_manage_users = ?, 
            can_create_organizations = ?, is_active = ?, updated_at = NOW()
        WHERE id = ? OR email = ?
      `).bind(
        USER_ROLES.SYSTEM_ADMIN,
        MASTER_ORGANIZATION_ID,
        true,
        true,
        true,
        PROTECTED_SYSADMIN_ID,
        PROTECTED_SYSADMIN_EMAIL
      ).run();

      // Garantir associaÃ§Ã£o correta com organizaÃ§Ã£o
      await env.DB.prepare(`
        INSERT OR REPLACE INTO user_organizations (
          user_id, organization_id, role, is_active, created_at, updated_at
        ) VALUES (?, ?, ?, ?, NOW(), NOW())
      `).bind(PROTECTED_SYSADMIN_ID, MASTER_ORGANIZATION_ID, 'owner', true).run();

      return {
        success: true,
        action: 'updated',
        details: {
          message: 'ConfiguraÃ§Ãµes do usuÃ¡rio protegido foram corrigidas',
          fixed_issues: integrityCheck.details.differences
        }
      };
    }

    return {
      success: false,
      action: 'no_action_needed',
      details: { error: 'Status de integridade desconhecido' }
    };

  } catch (error) {
    console.error('Error in autoFixProtectedUser:', error);
    return {
      success: false,
      action: 'no_action_needed',
      details: { error: 'Erro ao corrigir usuÃ¡rio protegido', details: error }
    };
  }
}

// Middleware para verificaÃ§Ã£o automÃ¡tica de integridade
export function autoIntegrityCheck() {
  return async (c: Context<{ Bindings: Env; Variables: { user: any } }>, next: () => Promise<void>) => {
    const user = c.get("user");

    // Executar verificaÃ§Ã£o apenas para requisiÃ§Ãµes do usuÃ¡rio protegido
    if (user && user.id === PROTECTED_SYSADMIN_ID) {
      try {
        const env = c.env;
        const integrityResult = await checkProtectedUserIntegrity(env);

        if (integrityResult.status !== 'ok') {
          console.warn('ALERTA DE SEGURANÃ‡A: Integridade do usuÃ¡rio protegido comprometida');

          // Auto-correÃ§Ã£o silenciosa
          const fixResult = await autoFixProtectedUser(env, user.id);

          if (fixResult.success) {
            console.log('SEGURANÃ‡A: UsuÃ¡rio protegido foi auto-corrigido', fixResult);

            // Log da correÃ§Ã£o automÃ¡tica
            await env.DB.prepare(`
              INSERT INTO security_audit_log (
                user_id, target_user_id, action_type, old_value, new_value,
                blocked_reason, is_blocked, created_at
              ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
            `).bind(
              'system',
              PROTECTED_SYSADMIN_ID,
              'auto_integrity_fix',
              JSON.stringify(integrityResult.details),
              JSON.stringify(fixResult.details),
              'CorreÃ§Ã£o automÃ¡tica de integridade do usuÃ¡rio protegido',
              false
            ).run();
          }
        }
      } catch (error) {
        console.error('Error in auto integrity check:', error);
      }
    }

    await next();
  };
}

// Middleware para logs de seguranÃ§a detalhados
export function securityAuditLogger() {
  return async (c: Context<{ Bindings: Env; Variables: { user: any } }>, next: () => Promise<void>) => {
    const startTime = Date.now();
    const method = c.req.method;
    const path = c.req.path;
    const user = c.get("user");

    // Capturar dados da requisiÃ§Ã£o para auditoria
    let requestBody: any = null;
    if (method !== 'GET') {
      try {
        requestBody = await c.req.json();
      } catch (error) {
        // Body is not JSON
      }
    }

    await next();

    const endTime = Date.now();
    const responseTime = endTime - startTime;

    // Log requisiÃ§Ãµes sensÃ­veis
    const sensitiveOperations = [
      '/api/users',
      '/api/system-admin',
      '/api/multi-tenant',
      '/api/role-permissions'
    ];

    const isSensitive = sensitiveOperations.some(op => path.includes(op));

    if (isSensitive && user) {
      try {
        const env = c.env;
        await env.DB.prepare(`
          INSERT INTO security_audit_log (
            user_id, action_type, old_value, new_value,
            ip_address, user_agent, is_blocked, created_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
        `).bind(
          user.id,
          `${method.toLowerCase()}_${path.replace('/api/', '').replace(/\//g, '_')}`,
          JSON.stringify({ method, path, responseTime }),
          requestBody ? JSON.stringify(requestBody) : null,
          c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown',
          c.req.header('user-agent') || 'unknown',
          false
        ).run();
      } catch (error) {
        console.error('Error logging security audit:', error);
      }
    }
  };
}

===END_FILE===
===FILE: supabase/functions/api/session-management.ts===
/**
 * Session Management Middleware
 * 
 * ResponsÃ¡vel por:
 * - Rastrear sessÃ£o ativa do usuÃ¡rio
 * - Invalidar sessÃµes anteriores ao fazer novo login
 * - Detectar tentativas de login simultÃ¢neo
 */

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import type { Context, Next } from 'hono';
import { v4 as uuidv4 } from 'https://esm.sh/uuid@10.0.0';

/**
 * Gera um novo session_id Ãºnico
 */
export function generateSessionId(): string {
    return uuidv4();
}

/**
 * Registra uma nova sessÃ£o para o usuÃ¡rio
 * Invalida todas as sessÃµes anteriores
 */
export async function registerSession(
    supabaseAdmin: ReturnType<typeof createClient>,
    userId: string,
    sessionId: string,
    userAgent?: string,
    ipAddress?: string
): Promise<boolean> {
    try {
        // Atualizar usuÃ¡rio com nova sessÃ£o
        const { error } = await supabaseAdmin
            .from('users')
            .update({
                current_session_id: sessionId,
                last_login_at: new Date().toISOString(),
                last_login_ip: ipAddress,
                last_login_device: userAgent?.substring(0, 255), // Limitar tamanho
            })
            .eq('id', userId);

        if (error) {
            console.error('Error registering session:', error);
            return false;
        }

        // Logar a sessÃ£o para auditoria (opcional)
        await supabaseAdmin.from('session_log').insert({
            user_id: userId,
            session_id: sessionId,
            ip_address: ipAddress,
            user_agent: userAgent?.substring(0, 500),
            created_at: new Date().toISOString(),
        }).catch(() => {
            // Ignorar erro se tabela nÃ£o existir
        });

        return true;
    } catch (error) {
        console.error('Error in registerSession:', error);
        return false;
    }
}

/**
 * Valida se a sessÃ£o atual ainda Ã© vÃ¡lida
 * Retorna false se outra sessÃ£o foi iniciada
 */
export async function validateSession(
    supabaseAdmin: ReturnType<typeof createClient>,
    userId: string,
    currentSessionId: string
): Promise<{ valid: boolean; conflictDevice?: string }> {
    try {
        const { data: user, error } = await supabaseAdmin
            .from('users')
            .select('current_session_id, last_login_device, last_login_at')
            .eq('id', userId)
            .single();

        if (error || !user) {
            return { valid: true }; // Em caso de erro, permitir
        }

        // Se nÃ£o tem sessÃ£o registrada ou Ã© a sessÃ£o atual, Ã© vÃ¡lida
        if (!user.current_session_id || user.current_session_id === currentSessionId) {
            return { valid: true };
        }

        // SessÃ£o foi substituÃ­da por outra
        return {
            valid: false,
            conflictDevice: user.last_login_device || 'Outro dispositivo',
        };
    } catch (error) {
        console.error('Error validating session:', error);
        return { valid: true }; // Em caso de erro, permitir
    }
}

/**
 * Invalida a sessÃ£o atual (logout)
 */
export async function invalidateSession(
    supabaseAdmin: ReturnType<typeof createClient>,
    userId: string
): Promise<boolean> {
    try {
        const { error } = await supabaseAdmin
            .from('users')
            .update({
                current_session_id: null,
            })
            .eq('id', userId);

        return !error;
    } catch (error) {
        console.error('Error invalidating session:', error);
        return false;
    }
}

/**
 * Middleware para validar sessÃ£o em cada requisiÃ§Ã£o
 * Adiciona informaÃ§Ãµes de validaÃ§Ã£o ao contexto
 */
export function sessionValidationMiddleware() {
    return async (c: Context, next: Next) => {
        const user = c.get('user');

        if (!user?.id) {
            return next();
        }

        // Buscar session_id do header ou cookie
        const currentSessionId = c.req.header('X-Session-Id') ||
            c.req.cookie?.('session_id');

        if (!currentSessionId) {
            // Sem session_id, continuar sem validaÃ§Ã£o
            // (serÃ¡ registrado no login)
            return next();
        }

        // Criar cliente Supabase admin
        const supabaseUrl = c.env?.SUPABASE_URL || Deno.env.get('SUPABASE_URL');
        const supabaseKey = c.env?.SUPABASE_SERVICE_ROLE_KEY || Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

        if (!supabaseUrl || !supabaseKey) {
            return next();
        }

        const supabaseAdmin = createClient(supabaseUrl, supabaseKey);

        const validation = await validateSession(supabaseAdmin, user.id, currentSessionId);

        if (!validation.valid) {
            return c.json({
                error: 'SessÃ£o invÃ¡lida',
                code: 'SESSION_CONFLICT',
                message: `Outra sessÃ£o foi iniciada em: ${validation.conflictDevice}`,
                conflictDevice: validation.conflictDevice,
            }, 401);
        }

        c.set('sessionValid', true);
        await next();
    };
}

/**
 * Endpoint handler para registrar nova sessÃ£o apÃ³s login
 */
export async function handleLoginSession(
    supabaseAdmin: ReturnType<typeof createClient>,
    userId: string,
    c: Context
): Promise<string> {
    const sessionId = generateSessionId();
    const userAgent = c.req.header('User-Agent');
    const ipAddress = c.req.header('X-Forwarded-For') ||
        c.req.header('X-Real-IP') ||
        'unknown';

    await registerSession(supabaseAdmin, userId, sessionId, userAgent, ipAddress);

    return sessionId;
}
===END_FILE===
===FILE: supabase/functions/api/share-routes.ts===
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { tenantAuthMiddleware as authMiddleware } from './tenant-auth-middleware.ts';
import { logActivity } from './audit-logger.ts';

const shareRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/share');

const CreateShareSchema = z.object({
  inspection_id: z.number(),
  permission: z.enum(['view', 'edit']),
  expires_at: z.string().optional()
});

const UpdateShareResponsesSchema = z.object({
  responses: z.array(z.object({
    field_id: z.number(),
    field_name: z.string(),
    field_type: z.string(),
    value: z.any(),
    comment: z.string().optional()
  }))
});

// Helper function to generate a simple QR code as SVG (browser-compatible)
function generateQRCodeSVG(text: string, size = 200): string {
  // Simple QR code placeholder as SVG
  return `
    <svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#ffffff"/>
      <rect x="10" y="10" width="180" height="180" fill="none" stroke="#000000" stroke-width="2"/>
      <text x="${size / 2}" y="${size / 2 - 10}" text-anchor="middle" font-family="Arial" font-size="12" fill="#000000">
        QR Code
      </text>
      <text x="${size / 2}" y="${size / 2 + 10}" text-anchor="middle" font-family="Arial" font-size="8" fill="#666666">
        ${text.length > 30 ? text.substring(0, 27) + '...' : text}
      </text>
    </svg>
  `;
}

// Create share link for inspection
shareRoutes.post('/:id/share', authMiddleware, async (c) => {
  const inspectionId = parseInt(c.req.param('id'));
  const user = c.get('user');

  if (!user) {
    return c.json({ error: 'UsuÃ¡rio nÃ£o encontrado' }, 401);
  }

  const body = await c.req.json();
  const { permission = 'view', expires_at } = body;

  // Generate unique share token
  const shareToken = Math.random().toString(36).substring(2, 15) +
    Math.random().toString(36).substring(2, 15);

  try {
    const result = await c.env.DB.prepare(`
      INSERT INTO inspection_shares (
        inspection_id, share_token, created_by, permission, expires_at, 
        is_active, access_count, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
    `).bind(
      inspectionId,
      shareToken,
      user.id,
      permission,
      expires_at || null,
      true,
      0
    ).run();

    // Generate share URL and QR Code
    const shareUrl = `${c.req.header('origin') || 'https://localhost'}/shared/${shareToken}`;
    const qrCodeSVG = generateQRCodeSVG(shareUrl);
    const qrCodeBase64 = `data:image/svg+xml;base64,${btoa(qrCodeSVG)}`;

    // Log Activity (Async)
    await logActivity(c.env, {
      userId: user.id,
      orgId: user.organization_id || null, // Best effort
      actionType: 'SHARE',
      actionDescription: `Inspection Shared: ${inspectionId}`,
      targetType: 'INSPECTION',
      targetId: inspectionId,
      metadata: { share_token: shareToken, permission },
      req: c.req
    });

    return c.json({
      id: result.meta.last_row_id,
      share_token: shareToken,
      share_url: shareUrl,
      qr_code: qrCodeBase64,
      message: 'Link de compartilhamento criado com sucesso'
    });
  } catch (error) {
    console.error('Error creating share link:', error);
    return c.json({ error: 'Erro ao criar link de compartilhamento' }, 500);
  }
});

// Get share links for inspection
shareRoutes.get('/:id/shares', authMiddleware, async (c) => {
  const inspectionId = parseInt(c.req.param('id'));

  const shares = await c.env.DB.prepare(`
    SELECT * FROM inspection_shares 
    WHERE inspection_id = ? 
    ORDER BY created_at DESC
  `).bind(inspectionId).all();

  return c.json({ shares: shares.results });
});

// Create share link (new endpoint)
shareRoutes.post('/create', zValidator('json', CreateShareSchema), authMiddleware, async (c) => {
  const { inspection_id, permission, expires_at } = c.req.valid('json');

  try {
    // Generate unique token
    const token = self.crypto.randomUUID();

    // Set expiration (default 30 days)
    const expirationDate = expires_at ? new Date(expires_at) : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);

    // Get current user
    const user = c.get('user');
    if (!user) {
      return c.json({ error: 'UsuÃ¡rio nÃ£o autenticado' }, 401);
    }

    // Create share record
    await c.env.DB.prepare(`
      INSERT INTO inspection_shares 
      (inspection_id, share_token, created_by, permission, expires_at)
      VALUES (?, ?, ?, ?, ?)
    `).bind(
      inspection_id,
      token,
      user.id,
      permission,
      expirationDate.toISOString()
    ).run();

    // Generate share URL
    const baseUrl = c.req.header('origin') || 'https://localhost';
    const shareUrl = `${baseUrl}/shared/${token}`;

    // Generate QR code as SVG
    const qrCodeSVG = generateQRCodeSVG(shareUrl);

    // Convert SVG to base64 data URL
    const qrCodeBase64 = `data:image/svg+xml;base64,${btoa(qrCodeSVG)}`;

    // Log Activity (Async)
    await logActivity(c.env, {
      userId: user.id,
      orgId: user.organization_id || null,
      actionType: 'SHARE',
      actionDescription: `Inspection Shared (New): ${inspection_id}`,
      targetType: 'INSPECTION',
      targetId: inspection_id,
      metadata: { share_token: token, permission },
      req: c.req
    });

    return c.json({
      success: true,
      share: {
        token,
        url: shareUrl,
        qr_code: qrCodeBase64,
        permission,
        expires_at: expirationDate.toISOString()
      }
    });

  } catch (error) {
    console.error('Error creating share:', error);
    return c.json({ error: 'Erro ao criar compartilhamento' }, 500);
  }
});

// Get shared inspection
shareRoutes.get('/:token', async (c) => {
  const token = c.req.param('token');

  try {
    // Get share record
    const shareResult = await c.env.DB.prepare(`
      SELECT * FROM inspection_shares 
      WHERE share_token = ? AND is_active = true
    `).bind(token).first();

    if (!shareResult) {
      return c.json({ error: 'Link nÃ£o encontrado' }, 404);
    }

    // Check if expired
    const now = new Date();
    const expiresAt = new Date(shareResult.expires_at as string);

    if (expiresAt < now) {
      return c.json({
        error: 'Link expirado',
        expired: true
      }, 410);
    }

    // Get inspection details
    const inspection = await c.env.DB.prepare(`
      SELECT i.*, u.name as inspector_name, u.email as inspector_email
      FROM inspections i
      LEFT JOIN users u ON i.created_by = u.id
      WHERE i.id = ?
    `).bind(shareResult.inspection_id).first();

    if (!inspection) {
      return c.json({ error: 'InspeÃ§Ã£o nÃ£o encontrada' }, 404);
    }

    // Get inspection items
    const items = await c.env.DB.prepare(`
      SELECT * FROM inspection_items 
      WHERE inspection_id = ?
      ORDER BY id
    `).bind(shareResult.inspection_id).all();

    // Get inspection media
    const media = await c.env.DB.prepare(`
      SELECT * FROM inspection_media 
      WHERE inspection_id = ?
      ORDER BY id
    `).bind(shareResult.inspection_id).all();

    return c.json({
      success: true,
      share: shareResult,
      inspection,
      items: items.results || [],
      media: media.results || []
    });

  } catch (error) {
    console.error('Error getting shared inspection:', error);
    return c.json({ error: 'Erro ao carregar inspeÃ§Ã£o' }, 500);
  }
});

// Get share details (for QR code generation, etc.)
shareRoutes.get('/:token/details', async (c) => {
  const token = c.req.param('token');

  try {
    const shareResult = await c.env.DB.prepare(`
      SELECT s.*, i.title as inspection_title, u.name as inviter_name,
             org.name as organization_name
      FROM inspection_shares s
      JOIN inspections i ON s.inspection_id = i.id
      LEFT JOIN users u ON s.created_by = u.id
      LEFT JOIN organizations org ON i.organization_id = org.id
      WHERE s.share_token = ? AND s.is_active = true
    `).bind(token).first();

    if (!shareResult) {
      return c.json({ error: 'Share nÃ£o encontrado' }, 404);
    }

    // Check if expired
    const now = new Date();
    const expiresAt = new Date(shareResult.expires_at as string);

    if (expiresAt < now) {
      return c.json({
        error: 'Link expirado',
        expired: true
      }, 410);
    }

    return c.json({
      success: true,
      share: shareResult
    });

  } catch (error) {
    console.error('Error getting share details:', error);
    return c.json({ error: 'Erro ao carregar detalhes do compartilhamento' }, 500);
  }
});

// Track access
shareRoutes.post('/:token/access', async (c) => {
  const token = c.req.param('token');

  try {
    await c.env.DB.prepare(`
      UPDATE inspection_shares 
      SET access_count = access_count + 1,
          updated_at = CURRENT_TIMESTAMP
      WHERE share_token = ? AND is_active = true
    `).bind(token).run();

    return c.json({ success: true });

  } catch (error) {
    console.error('Error tracking access:', error);
    return c.json({ error: 'Erro ao registrar acesso' }, 500);
  }
});

// Update shared inspection responses (for edit permission)
shareRoutes.post('/:token/responses', zValidator('json', UpdateShareResponsesSchema), async (c) => {
  const token = c.req.param('token');
  const { responses } = c.req.valid('json');

  try {
    // Get share record and check permissions
    const shareResult = await c.env.DB.prepare(`
      SELECT * FROM inspection_shares 
      WHERE share_token = ? AND is_active = true AND permission = 'edit'
    `).bind(token).first();

    if (!shareResult) {
      return c.json({ error: 'PermissÃ£o insuficiente ou link invÃ¡lido' }, 403);
    }

    // Check if expired
    const now = new Date();
    const expiresAt = new Date(shareResult.expires_at as string);

    if (expiresAt < now) {
      return c.json({ error: 'Link expirado' }, 410);
    }

    const inspectionId = shareResult.inspection_id as number;

    // Update responses in inspection_items
    for (const response of responses) {
      // Check if item already exists
      const existingItem = await c.env.DB.prepare(`
        SELECT id FROM inspection_items 
        WHERE inspection_id = ? AND template_id IS NOT NULL 
        AND JSON_EXTRACT(field_responses, '$.field_id') = ?
      `).bind(inspectionId, response.field_id).first();

      const fieldData = {
        field_id: response.field_id,
        field_type: response.field_type,
        response_value: response.value,
        comment: response.comment,
        is_required: false
      };

      if (existingItem) {
        // Update existing item
        await c.env.DB.prepare(`
          UPDATE inspection_items 
          SET field_responses = ?, updated_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).bind(
          JSON.stringify(fieldData),
          existingItem.id
        ).run();
      } else {
        // Create new item
        await c.env.DB.prepare(`
          INSERT INTO inspection_items 
          (inspection_id, category, item_description, field_responses, template_id)
          VALUES (?, ?, ?, ?, ?)
        `).bind(
          inspectionId,
          'Template Response',
          response.field_name,
          JSON.stringify(fieldData),
          1 // Placeholder template ID
        ).run();
      }
    }

    // Update inspection status
    await c.env.DB.prepare(`
      UPDATE inspections 
      SET status = 'em_andamento', updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `).bind(inspectionId).run();

    return c.json({ success: true });

  } catch (error) {
    console.error('Error updating responses:', error);
    return c.json({ error: 'Erro ao salvar respostas' }, 500);
  }
});

// List shares for an inspection (legacy endpoint)
shareRoutes.get('/inspection/:id', authMiddleware, async (c) => {
  const inspectionId = parseInt(c.req.param('id'));
  const user = c.get('user');

  if (!user) {
    return c.json({ error: 'UsuÃ¡rio nÃ£o autenticado' }, 401);
  }

  try {
    const shares = await c.env.DB.prepare(`
      SELECT s.*, u.name as created_by_name
      FROM inspection_shares s
      LEFT JOIN users u ON s.created_by = u.id
      WHERE s.inspection_id = ? AND s.is_active = true
      ORDER BY s.created_at DESC
    `).bind(inspectionId).all();

    return c.json({
      success: true,
      shares: shares.results || []
    });

  } catch (error) {
    console.error('Error listing shares:', error);
    return c.json({ error: 'Erro ao carregar compartilhamentos' }, 500);
  }
});

// Update share link
shareRoutes.put('/inspection-shares/:id', authMiddleware, async (c) => {
  const shareId = parseInt(c.req.param('id'));
  const body = await c.req.json();

  const { is_active, expires_at } = body;

  await c.env.DB.prepare(`
    UPDATE inspection_shares 
    SET is_active = ?, expires_at = ?, updated_at = NOW()
    WHERE id = ?
  `).bind(is_active, expires_at, shareId).run();

  return c.json({ message: 'Link de compartilhamento atualizado com sucesso' });
});

// Deactivate share
shareRoutes.delete('/:token', authMiddleware, async (c) => {
  const token = c.req.param('token');
  const user = c.get('user');

  if (!user) {
    return c.json({ error: 'UsuÃ¡rio nÃ£o autenticado' }, 401);
  }

  try {
    // Check if user owns this share or has permission to manage it
    const shareResult = await c.env.DB.prepare(`
      SELECT s.*, i.created_by as inspection_owner
      FROM inspection_shares s
      JOIN inspections i ON s.inspection_id = i.id
      WHERE s.share_token = ?
    `).bind(token).first();

    if (!shareResult) {
      return c.json({ error: 'Compartilhamento nÃ£o encontrado' }, 404);
    }

    if (shareResult.created_by !== user.id && shareResult.inspection_owner !== user.id) {
      return c.json({ error: 'PermissÃ£o insuficiente' }, 403);
    }

    // Deactivate share
    await c.env.DB.prepare(`
      UPDATE inspection_shares 
      SET is_active = false, updated_at = CURRENT_TIMESTAMP
      WHERE share_token = ?
    `).bind(token).run();

    return c.json({ success: true });

    // Log Deactivation (Async)
    logActivity(c.env, {
      userId: user.id,
      orgId: user.organization_id,
      actionType: 'UNSHARE',
      actionDescription: `Inspection Share Deactivated`,
      targetType: 'INSPECTION',
      targetId: shareResult.inspection_id,
      metadata: { token },
      req: c.req
    });

  } catch (error) {
    console.error('Error deactivating share:', error);
    return c.json({ error: 'Erro ao desativar compartilhamento' }, 500);
  }
});

// Delete share link
shareRoutes.delete('/inspection-shares/:id', authMiddleware, async (c) => {
  const shareId = parseInt(c.req.param('id'));

  await c.env.DB.prepare(`
    DELETE FROM inspection_shares WHERE id = ?
  `).bind(shareId).run();

  return c.json({ message: 'Link de compartilhamento excluÃ­do com sucesso' });

  // Log Deletion (Async) - Note: User might not be available in context for this admin route easily if middleware doesn't set it perfectly? Middleware writes to c.get('user').
  // We can try to get user.
  const user = c.get('user');
  if (user) {
    logActivity(c.env, {
      userId: user.id,
      orgId: user.organization_id,
      actionType: 'UNSHARE', // Admin delete
      actionDescription: `Inspection Share Deleted: ${shareId}`,
      targetType: 'INSPECTION_SHARE',
      targetId: shareId,
      req: c.req
    });
  }
});

export default shareRoutes;

===END_FILE===
===FILE: supabase/functions/api/system-admin-protection.ts===
// ProteÃ§Ã£o automÃ¡tica para o usuÃ¡rio system_admin principal
// Este mÃ³dulo garante que eng.tiagosm@gmail.com e usuÃ¡rios demo sempre tenham acesso como system_admin

export async function ensureSystemAdminAccess(env: Env): Promise<void> {
  if (!env?.DB) {
    console.log('[SYSTEM-ADMIN-PROTECTION] Database nÃ£o disponÃ­vel');
    return;
  }

  try {
    const SYSTEM_ADMIN_EMAIL = 'eng.tiagosm@gmail.com';
    const SYSTEM_ADMIN_ID = '84edf8d1-77d9-4c73-935e-d76745bc3707'; // ID real do usuÃ¡rio
    const DEMO_USER_EMAIL = 'demo@compia.test';
    const DEMO_USER_ID = 'demo-user-84edf8d1-77d9-4c73-935e-d76745bc3707'; // ID do usuÃ¡rio demo

    // Verificar se o usuÃ¡rio principal existe
    let systemAdmin = await env.DB.prepare(
      "SELECT * FROM users WHERE email = ? OR id = ?"
    ).bind(SYSTEM_ADMIN_EMAIL, SYSTEM_ADMIN_ID).first() as any;

    // Se nÃ£o existe, criar o usuÃ¡rio principal
    if (!systemAdmin) {
      console.log('[SYSTEM-ADMIN-PROTECTION] Criando usuÃ¡rio system_admin');

      await env.DB.prepare(`
        INSERT INTO users (
          id, email, name, role, can_manage_users, can_create_organizations,
          is_active, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `).bind(
        SYSTEM_ADMIN_ID,
        SYSTEM_ADMIN_EMAIL,
        'Tiago Mocha System Admin',
        'sys_admin',
        1,
        1,
        1
      ).run();

      systemAdmin = await env.DB.prepare(
        "SELECT * FROM users WHERE id = ?"
      ).bind(SYSTEM_ADMIN_ID).first() as any;
    }

    // Verificar se o usuÃ¡rio demo existe
    let demoUser = await env.DB.prepare(
      "SELECT * FROM users WHERE email = ? OR id = ?"
    ).bind(DEMO_USER_EMAIL, DEMO_USER_ID).first() as any;

    // Se nÃ£o existe, criar o usuÃ¡rio demo
    if (!demoUser) {
      console.log('[SYSTEM-ADMIN-PROTECTION] Criando usuÃ¡rio demo');

      await env.DB.prepare(`
        INSERT INTO users (
          id, email, name, role, can_manage_users, can_create_organizations,
          is_active, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `).bind(
        DEMO_USER_ID,
        DEMO_USER_EMAIL,
        'UsuÃ¡rio Demo',
        'sys_admin',
        1,
        1,
        1
      ).run();

      demoUser = await env.DB.prepare(
        "SELECT * FROM users WHERE id = ?"
      ).bind(DEMO_USER_ID).first() as any;
    }

    // Garantir que o usuÃ¡rio principal tem role sys_admin
    if (systemAdmin.role !== 'sys_admin') {
      console.log('[SYSTEM-ADMIN-PROTECTION] Corrigindo role para sys_admin');

      await env.DB.prepare(`
        UPDATE users 
        SET role = 'sys_admin', can_manage_users = 1, can_create_organizations = 1,
            is_active = 1, updated_at = NOW()
        WHERE id = ?
      `).bind(SYSTEM_ADMIN_ID).run();
    }

    // Garantir que o usuÃ¡rio demo tem role sys_admin
    if (demoUser && demoUser.role !== 'sys_admin') {
      console.log('[SYSTEM-ADMIN-PROTECTION] Corrigindo role do usuÃ¡rio demo para sys_admin');

      await env.DB.prepare(`
        UPDATE users 
        SET role = 'sys_admin', can_manage_users = 1, can_create_organizations = 1,
            is_active = 1, updated_at = NOW()
        WHERE id = ?
      `).bind(DEMO_USER_ID).run();
    }

    // Verificar se existe uma organizaÃ§Ã£o master
    let masterOrg = await env.DB.prepare(`
      SELECT * FROM organizations 
      WHERE name = 'COMPIA Master' OR name LIKE '%Master%' OR name LIKE '%COMPIA%'
      ORDER BY id ASC
      LIMIT 1
    `).first() as any;

    // Se nÃ£o existe, criar organizaÃ§Ã£o master
    if (!masterOrg) {
      console.log('[SYSTEM-ADMIN-PROTECTION] Criando organizaÃ§Ã£o master');

      const result = await env.DB.prepare(`
        INSERT INTO organizations (
          name, type, is_active, created_at, updated_at,
          organization_level, max_users, max_subsidiaries
        ) VALUES (?, ?, ?, NOW(), NOW(), ?, ?, ?)
      `).bind(
        'COMPIA Master',
        'company',
        1, // SQLite uses 1 for true
        'company',
        10000,
        1000
      ).run();

      masterOrg = {
        id: result.meta.last_row_id,
        name: 'COMPIA Master'
      };
    }

    // Garantir que o system_admin estÃ¡ associado Ã  organizaÃ§Ã£o master
    if (systemAdmin.organization_id !== masterOrg.id) {
      console.log('[SYSTEM-ADMIN-PROTECTION] Associando system_admin Ã  organizaÃ§Ã£o master');

      await env.DB.prepare(`
        UPDATE users 
        SET organization_id = ?, managed_organization_id = ?, updated_at = NOW()
        WHERE id = ?
      `).bind(masterOrg.id, masterOrg.id, SYSTEM_ADMIN_ID).run();
    }

    // Verificar se existe entrada em user_organizations
    const userOrgAssociation = await env.DB.prepare(`
      SELECT * FROM user_organizations 
      WHERE user_id = ? AND organization_id = ?
    `).bind(SYSTEM_ADMIN_ID, masterOrg.id).first();

    if (!userOrgAssociation) {
      console.log('[SYSTEM-ADMIN-PROTECTION] Criando associaÃ§Ã£o user_organizations');

      await env.DB.prepare(`
        INSERT INTO user_organizations (
          user_id, organization_id, role, is_active, created_at, updated_at
        ) VALUES (?, ?, ?, ?, NOW(), NOW())
      `).bind(SYSTEM_ADMIN_ID, masterOrg.id, 'owner', 1).run();
    }

    // Verificar se estÃ¡ protegido na tabela protected_users
    // Primeiro garantir que o usuÃ¡rio realmente existe na tabela users
    const userExists = await env.DB.prepare(`
      SELECT id FROM users WHERE id = ?
    `).bind(SYSTEM_ADMIN_ID).first();

    if (userExists) {
      const protection = await env.DB.prepare(`
        SELECT * FROM protected_users WHERE user_id = ?
      `).bind(SYSTEM_ADMIN_ID).first();

      if (!protection) {
        console.log('[SYSTEM-ADMIN-PROTECTION] Adicionando proteÃ§Ã£o de usuÃ¡rio');

        try {
          await env.DB.prepare(`
            INSERT INTO protected_users (
              user_id, protection_level, protected_roles, protected_permissions,
              reason, created_by, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())
          `).bind(
            SYSTEM_ADMIN_ID,
            'high',
            JSON.stringify(['sys_admin', 'system_admin']),
            JSON.stringify(['all']),
            'UsuÃ¡rio administrador principal do sistema COMPIA',
            'system'
          ).run();
        } catch (error) {
          console.error('[SYSTEM-ADMIN-PROTECTION] Erro ao inserir proteÃ§Ã£o:', error);
          // NÃ£o falhar completamente se nÃ£o conseguir proteger
        }
      }
    } else {
      console.log('[SYSTEM-ADMIN-PROTECTION] UsuÃ¡rio nÃ£o existe, pulando proteÃ§Ã£o');
    }

    console.log('[SYSTEM-ADMIN-PROTECTION] ProteÃ§Ãµes aplicadas com sucesso');

  } catch (error) {
    console.error('[SYSTEM-ADMIN-PROTECTION] Erro ao garantir acesso do system_admin:', error);
  }
}

// FunÃ§Ã£o para executar auto-correÃ§Ã£o via endpoint
export async function autoFixSystemAdmin(env: Env): Promise<{ success: boolean, message: string }> {
  try {
    await ensureSystemAdminAccess(env);
    return {
      success: true,
      message: 'Sistema auto-corrigido com sucesso. Acesso de system_admin restaurado.'
    };
  } catch (error) {
    console.error('[AUTO-FIX] Erro na auto-correÃ§Ã£o:', error);
    return {
      success: false,
      message: `Erro na auto-correÃ§Ã£o: ${error instanceof Error ? error.message : 'Erro desconhecido'}`
    };
  }
}

===END_FILE===
===FILE: supabase/functions/api/system-admin-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware as authMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";
import { requireProtectedSysAdmin } from "./rbac-middleware.ts";
import { autoFixSystemAdmin } from "./system-admin-protection.ts";

type Env = {
  DB: any;
};

const systemAdminRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/system-admin');

// Endpoint para garantir que o usuÃ¡rio eng.tiagosm@gmail.com seja sempre system_admin
systemAdminRoutes.post("/ensure-protected-sysadmin", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const result = await autoFixSystemAdmin(env);

    // Log adicional se necessÃ¡rio
    if (result.success) {
      await env.DB.prepare(`
          INSERT INTO activity_log (user_id, action_type, action_description, target_type, target_id, created_at)
          VALUES (?, ?, ?, ?, ?, NOW())
        `).bind(
        user.id,
        'system_security_check',
        'VerificaÃ§Ã£o e garantia de privilÃ©gios de administrador principal do sistema',
        'user',
        '84edf8d1-77d9-4c73-935e-d76745bc3707'
      ).run();
    }

    return c.json({
      success: result.success,
      message: result.message,
      user_id: 'eng.tiagosm',
      user_email: 'eng.tiagosm@gmail.com',
      timestamp: new Date().toISOString()
    });

  } catch (error: any) {
    console.error('Error ensuring protected sysadmin:', error);
    return c.json({ error: "Erro ao verificar privilÃ©gios do sistema", details: error.message }, 500);
  }
});

// Endpoint para listar tentativas de modificaÃ§Ã£o bloqueadas (auditoria)
systemAdminRoutes.get("/security-log", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Buscar logs relacionados a tentativas de modificaÃ§Ã£o de seguranÃ§a
    const securityLogs = await env.DB.prepare(`
      SELECT * FROM activity_log 
      WHERE action_type IN ('system_security_check', 'user_update_blocked', 'user_delete_blocked')
         OR action_description LIKE '%eng.tiagosm@gmail.com%'
         OR target_id = '84edf8d1-77d9-4c73-935e-d76745bc3707'
      ORDER BY created_at DESC
      LIMIT 100
    `).all();

    return c.json({
      security_logs: securityLogs.results || [],
      protected_user_id: '84edf8d1-77d9-4c73-935e-d76745bc3707',
      protected_user_email: 'eng.tiagosm@gmail.com'
    });

  } catch (error) {
    console.error('Error fetching security logs:', error);
    return c.json({ error: "Erro ao buscar logs de seguranÃ§a" }, 500);
  }
});

// Endpoint para verificar status de proteÃ§Ã£o do sistema
systemAdminRoutes.get("/protection-status", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Verificar o status atual do usuÃ¡rio protegido
    const protectedUser = await env.DB.prepare(`
      SELECT id, email, name, role, can_manage_users, can_create_organizations, is_active, created_at, updated_at
      FROM users 
      WHERE email = ? OR id = ?
    `).bind('eng.tiagosm@gmail.com', '84edf8d1-77d9-4c73-935e-d76745bc3707').first() as any;

    if (!protectedUser) {
      return c.json({
        error: "ALERTA DE SEGURANÃ‡A: UsuÃ¡rio protegido nÃ£o encontrado no sistema!",
        critical: true
      }, 404);
    }

    // Verificar se as configuraÃ§Ãµes estÃ£o corretas
    const isCorrectlyConfigured =
      protectedUser.role === USER_ROLES.SYSTEM_ADMIN &&
      protectedUser.can_manage_users === true &&
      protectedUser.can_create_organizations === true &&
      protectedUser.is_active === true;

    // Contar outros system_admins
    const otherSystemAdmins = await env.DB.prepare(`
      SELECT COUNT(*) as count 
      FROM users 
      WHERE role = ? AND email != ? AND id != ?
    `).bind(USER_ROLES.SYSTEM_ADMIN, 'eng.tiagosm@gmail.com', '84edf8d1-77d9-4c73-935e-d76745bc3707').first() as any;

    return c.json({
      protection_status: {
        protected_user_found: true,
        correctly_configured: isCorrectlyConfigured,
        current_role: protectedUser.role,
        can_manage_users: protectedUser.can_manage_users,
        can_create_organizations: protectedUser.can_create_organizations,
        is_active: protectedUser.is_active,
        last_updated: protectedUser.updated_at
      },
      system_status: {
        other_system_admins_count: otherSystemAdmins?.count || 0,
        protection_middleware_active: true,
        protected_email: 'eng.tiagosm@gmail.com',
        protected_id: '84edf8d1-77d9-4c73-935e-d76745bc3707'
      },
      security_measures: {
        role_modification_blocked: true,
        user_deletion_blocked: true,
        email_change_blocked: true,
        permission_change_blocked: true,
        api_access_restricted: true
      }
    });

  } catch (error) {
    console.error('Error checking protection status:', error);
    return c.json({ error: "Erro ao verificar status de proteÃ§Ã£o" }, 500);
  }
});

// Endpoint para forÃ§ar correÃ§Ã£o do usuÃ¡rio protegido (em caso de inconsistÃªncia)
systemAdminRoutes.post("/force-fix-protected-user", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Primeiro, verificar se o usuÃ¡rio existe
    let protectedUser = await env.DB.prepare(`
      SELECT * FROM users WHERE email = ? OR id = ?
    `).bind('eng.tiagosm@gmail.com', '84edf8d1-77d9-4c73-935e-d76745bc3707').first() as any;

    if (!protectedUser) {
      // Criar o usuÃ¡rio se nÃ£o existir (situaÃ§Ã£o de emergÃªncia)
      await env.DB.prepare(`
        INSERT INTO users (
          id, email, name, role, can_manage_users, can_create_organizations,
          is_active, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `).bind(
        '84edf8d1-77d9-4c73-935e-d76745bc3707',
        'eng.tiagosm@gmail.com',
        'Tiago dos Santos Martins - SysAdmin',
        USER_ROLES.SYSTEM_ADMIN,
        true,
        true,
        true
      ).run();

      await env.DB.prepare(`
        INSERT INTO activity_log (user_id, action_type, action_description, target_type, target_id, created_at)
        VALUES (?, ?, ?, ?, ?, NOW())
      `).bind(
        user.id,
        'emergency_user_creation',
        'EMERGÃŠNCIA: UsuÃ¡rio protegido foi recriado no sistema',
        'user',
        '84edf8d1-77d9-4c73-935e-d76745bc3707'
      ).run();

      return c.json({
        success: true,
        message: "EMERGÃŠNCIA: UsuÃ¡rio protegido foi recriado com privilÃ©gios completos",
        action: "created"
      });
    } else {
      // Corrigir configuraÃ§Ãµes se necessÃ¡rio
      await env.DB.prepare(`
        UPDATE users 
        SET role = ?, can_manage_users = ?, can_create_organizations = ?, is_active = ?, updated_at = NOW()
        WHERE email = ? OR id = ?
      `).bind(
        USER_ROLES.SYSTEM_ADMIN,
        true,
        true,
        true,
        'eng.tiagosm@gmail.com',
        '84edf8d1-77d9-4c73-935e-d76745bc3707'
      ).run();

      await env.DB.prepare(`
        INSERT INTO activity_log (user_id, action_type, action_description, target_type, target_id, created_at)
        VALUES (?, ?, ?, ?, ?, NOW())
      `).bind(
        user.id,
        'forced_user_fix',
        'CorreÃ§Ã£o forÃ§ada de privilÃ©gios do usuÃ¡rio protegido do sistema',
        'user',
        '84edf8d1-77d9-4c73-935e-d76745bc3707'
      ).run();

      return c.json({
        success: true,
        message: "UsuÃ¡rio protegido foi corrigido com privilÃ©gios completos",
        action: "updated"
      });
    }

  } catch (error) {
    console.error('Error fixing protected user:', error);
    return c.json({ error: "Erro ao corrigir usuÃ¡rio protegido" }, 500);
  }
});

// Endpoint para mÃ©tricas SAAS (Dashboard do System Admin)
systemAdminRoutes.get("/saas-metrics", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // 1. MÃ©tricas de OrganizaÃ§Ãµes
    const orgsMetrics = await env.DB.prepare(`
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN is_active = true THEN 1 ELSE 0 END) as active,
        SUM(CASE WHEN parent_organization_id IS NULL THEN 1 ELSE 0 END) as master_orgs,
        SUM(CASE WHEN parent_organization_id IS NOT NULL THEN 1 ELSE 0 END) as subsidiaries
      FROM organizations
    `).first();

    // 2. MÃ©tricas de UsuÃ¡rios
    const usersMetrics = await env.DB.prepare(`
      SELECT 
        COUNT(*) as total,
      SUM(CASE WHEN is_active = true THEN 1 ELSE 0 END) as active,
      SUM(CASE WHEN created_at > (NOW() - INTERVAL '30 days') THEN 1 ELSE 0 END) as new_last_30_days
      FROM users
      `).first();

    // 3. MÃ©tricas de InspeÃ§Ãµes (Volume Global)
    const inspectionsMetrics = await env.DB.prepare(`
    SELECT
    COUNT(*) as total,
      SUM(CASE WHEN status = 'concluida' THEN 1 ELSE 0 END) as completed,
      SUM(CASE WHEN created_at > (NOW() - INTERVAL '30 days') THEN 1 ELSE 0 END) as created_last_30_days
      FROM inspections
  `).first();

    // 4. Consumo Global de IA (Tokens e RequisiÃ§Ãµes)
    let aiMetrics = { total_tokens: 0, total_cost_est: 0, total_requests: 0 };

    try {
      const aiUsage = await env.DB.prepare(`
          SELECT SUM(total_tokens) as total_tokens 
          FROM ai_usage_logs
      `).first();

      const orgsRequests = await env.DB.prepare(`
          SELECT SUM(ai_usage_count) as total_requests 
          FROM organizations
      `).first();

      aiMetrics.total_requests = orgsRequests?.total_requests || 0;

      if (aiUsage && aiUsage.total_tokens) {
        aiMetrics.total_tokens = aiUsage.total_tokens;
        aiMetrics.total_cost_est = (aiMetrics.total_tokens / 1000) * 0.03;
      }
    } catch (e) {
      console.warn("[SAAS-METRICS] Erro ao buscar mÃ©tricas de IA:", e);
    }

    return c.json({
      organizations: {
        total: Number(orgsMetrics?.total) || 0,
        active: Number(orgsMetrics?.active) || 0,
        master: Number(orgsMetrics?.master_orgs) || 0,
        subsidiary_ratio: Number(orgsMetrics?.master_orgs) > 0 ? (Number(orgsMetrics?.subsidiaries) / Number(orgsMetrics?.master_orgs)).toFixed(1) : "0"
      },
      users: {
        total: usersMetrics?.total || 0,
        active: usersMetrics?.active || 0,
        growth_30d: usersMetrics?.new_last_30_days || 0
      },
      inspections: {
        total: inspectionsMetrics?.total || 0,
        completed: inspectionsMetrics?.completed || 0,
        volume_30d: inspectionsMetrics?.created_last_30_days || 0
      },
      ai_usage: {
        total_tokens: aiMetrics.total_tokens,
        total_requests: aiMetrics.total_requests,
        estimated_cost_usd: aiMetrics.total_cost_est
      },
      generated_at: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error fetching SaaS metrics:', error);
    return c.json({ error: "Erro ao buscar mÃ©tricas SaaS" }, 500);
  }
});

// Endpoint para mÃ©tricas de Business Intelligence (Revenue Intelligence)
systemAdminRoutes.get("/bi-analytics", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  console.log('[SystemAdmin] Accessing BI Analytics Endpoint');
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const debugErrors: any = {};

    // 0. Fetch System Goals
    const goalsMap: Record<string, number> = {};
    try {
      const goalsResult = await env.DB.prepare("SELECT metric_key, target_value FROM system_goals").all();
      if (goalsResult.results) {
        goalsResult.results.forEach((g: any) => {
          goalsMap[g.metric_key] = Number(g.target_value);
        });
      }
    } catch (e: any) {
      console.error('Error fetching goals:', e);
      debugErrors.goals = e.message;
    }

    // 1. Buscando dados da View Inteligente (Customer Health Score)
    let customers: any[] = [];
    try {
      const healthScores = await env.DB.prepare(`
        SELECT * FROM customer_health_score ORDER BY mrr_value_cents DESC
        `).all();
      customers = healthScores.results || [];
    } catch (e: any) {
      console.warn('View customer_health_score not found, using empty list');
      debugErrors.customers = e.message;
      customers = [];
    }

    // 2. Churn Risk
    const churnRisk = customers
      .filter((c: any) => c.is_at_risk === true || c.is_at_risk === 1)
      .map((c: any) => ({
        id: c.organization_id,
        name: c.org_name,
        last_activity: new Date().toISOString(), // In real app, verify audit log
        health_score: c.health_score,
        mrr: c.mrr_value_cents
      }));

    // 3. Upsell Opportunity
    const upsellOpportunity = customers
      .filter((c: any) => c.health_score > 80)
      .map((c: any) => ({
        id: c.organization_id,
        name: c.org_name,
        current_users: c.usage_score ? Math.round(c.usage_score * 0.5) : 10, // Placeholder if field missing
        max_users: 20, // Placeholder
        health_score: c.health_score
      }));

    // 4. MRR Real via View/Function
    let currentMrr = 0;
    try {
      const mrrResult = await env.DB.prepare("SELECT get_current_mrr() as mrr").first();
      currentMrr = Number(mrrResult?.mrr || 0);
    } catch (e: any) {
      try {
        const mrrCalc = await env.DB.prepare(`
                SELECT SUM(mrr_value_cents) as total 
                FROM subscriptions 
                WHERE status IN ('active', 'trial')
            `).first();
        currentMrr = Number(mrrCalc?.total || 0);
      } catch (e2: any) {
        debugErrors.mrr = e2.message;
      }
    }

    // 5. Chart Data (Historical Revenue)
    let chartData: any[] = [];
    try {
      const sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 5);
      const dateStr = sixMonthsAgo.toISOString().split('T')[0];

      // Safe query avoiding TO_CHAR if uncertain, but keeping TO_CHAR for now as it is Postgres
      const revenueHistory = await env.DB.prepare(`
            SELECT 
                TO_CHAR(paid_at, 'Mon') as name,
                DATE_TRUNC('month', paid_at) as month_date,
                SUM(amount) as revenue
            FROM invoices
            WHERE status = 'paid' AND paid_at >= ?
            GROUP BY DATE_TRUNC('month', paid_at), TO_CHAR(paid_at, 'Mon')
            ORDER BY month_date ASC
        `).bind(dateStr).all();

      chartData = revenueHistory.results || [];
    } catch (e: any) {
      console.error('Error fetching chart data:', e);
      debugErrors.chart_data = e.message;
      chartData = [];
    }

    // If no history, mock ONLY if it's a fresh install to show potential
    if (chartData.length === 0 && currentMrr === 0) {
      chartData = []; // Return empty, let frontend handle "No Data" state
    }

    // 6. AI Adoption Rate
    const totalActiveOrgs = customers.length;
    const aiActiveOrgs = customers.filter((c: any) => c.ai_usage_count > 0).length;
    const aiAdoptionRate = totalActiveOrgs > 0 ? (aiActiveOrgs / totalActiveOrgs) : 0;

    // 7. Plan Distribution (New)
    let planDistribution: any[] = [];
    try {
      const planDistResult = await env.DB.prepare(`
            SELECT subscription_plan as name, COUNT(*) as value
            FROM organizations
            WHERE is_active = true
            GROUP BY subscription_plan
        `).all();
      planDistribution = planDistResult.results || [];
    } catch (e: any) {
      debugErrors.plan_dist = e.message;
    }

    // 8. Customer Status (New)
    let customerStatus = { active: 0, inactive: 0 };
    try {
      const custStatusResult = await env.DB.prepare(`
            SELECT 
                SUM(CASE WHEN is_active = true THEN 1 ELSE 0 END) as active,
                SUM(CASE WHEN is_active = false THEN 1 ELSE 0 END) as inactive
            FROM organizations
        `).first();
      if (custStatusResult) {
        customerStatus.active = Number(custStatusResult.active || 0);
        customerStatus.inactive = Number(custStatusResult.inactive || 0);
      }
    } catch (e: any) {
      debugErrors.cust_status = e.message;
    }

    // 9. Revenue Concentration (Top 5)
    // Using health score view which already sorts by MRR
    const topClients = customers.slice(0, 5).map((c: any) => ({
      name: c.org_name,
      mrr: c.mrr_value_cents,
      percentage: currentMrr > 0 ? (c.mrr_value_cents / currentMrr) * 100 : 0
    }));

    return c.json({
      goals: goalsMap,
      churn_risk: churnRisk,
      upsell_opportunity: upsellOpportunity,
      ai_adoption: {
        total: totalActiveOrgs,
        active: aiActiveOrgs,
        rate: aiAdoptionRate
      },
      financials: {
        mrr: currentMrr,
        arpu: totalActiveOrgs > 0 ? (currentMrr / totalActiveOrgs) : 0
      },
      chart_data: chartData,
      plan_distribution: planDistribution,
      customer_status: customerStatus,
      revenue_concentration: topClients,
      _debug_errors: debugErrors
    });

  } catch (error) {
    console.error('Error fetching BI analytics:', error);
    return c.json({ error: "Erro ao buscar dados de BI" }, 500);
  }
});

// Endpoint para Atualizar Metas
systemAdminRoutes.post("/goals", authMiddleware, requireProtectedSysAdmin(), async (c) => {
  try {
    const env = c.env;
    const body = await c.req.json();
    const { metric_key, target_value } = body;

    await env.DB.prepare(`
            INSERT INTO system_goals (metric_key, target_value, updated_at)
            VALUES (?, ?, NOW())
            ON CONFLICT (metric_key) DO UPDATE SET
                target_value = excluded.target_value,
                updated_at = NOW()
        `).bind(metric_key, target_value).run();

    return c.json({ success: true });
  } catch (e: any) {
    return c.json({ error: e.message }, 500);
  }
});

export default systemAdminRoutes;
===END_FILE===
===FILE: supabase/functions/api/system-plans-routes.ts===
import { Hono } from "hono";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";

const systemPlansRoutes = new Hono().basePath('/api/system-commerce');

// Helper function to get Supabase Admin Client
const getSupabaseAdmin = () => createClient(
    Deno.env.get("SUPABASE_URL") ?? "",
    Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
);

// Middleware: Check System Admin
systemPlansRoutes.use('*', tenantAuthMiddleware, async (c, next) => {
    const user = c.get('user');
    if (!user) return c.json({ error: 'Unauthorized' }, 401);

    const supabase = getSupabaseAdmin();
    const { data: profile, error } = await supabase
        .from('users')
        .select('role')
        .eq('id', user.id)
        .single();

    if (error || (profile?.role !== 'system_admin' && profile?.role !== 'sys_admin')) {
        return c.json({ error: 'Forbidden: System Admin only' }, 403);
    }
    await next();
});

// ============================================================================
// PLANS
// ============================================================================

// GET /plans
systemPlansRoutes.get('/plans', async (c) => {
    const supabase = getSupabaseAdmin();
    const { data: plans, error } = await supabase
        .from('plans')
        .select('*')
        .order('price_cents', { ascending: true });

    if (error) return c.json({ error: error.message }, 500);

    return c.json({ plans: plans || [] });
});

// POST /plans (Create)
systemPlansRoutes.post('/plans', async (c) => {
    try {
        const body = await c.req.json();
        const {
            name, display_name, price_cents, description,
            type = 'subscription',
            billing_period = 'monthly',
            is_public = false,
            limits = {},
            features = {},
            addon_config = {}
        } = body;

        const slug = body.slug || name.toLowerCase().replace(/\s+/g, '-');
        const supabase = getSupabaseAdmin();

        const { data, error } = await supabase
            .from('plans')
            .insert({
                slug,
                name: slug, // Using slug as internal name for consistency
                display_name,
                price_cents,
                description,
                billing_period,
                type,
                limits, // Supabase handles JSON/JSONB automatically
                features,
                addon_config,
                is_active: true,
                is_public
            })
            .select()
            .single();

        if (error) throw error;

        return c.json({ success: true, id: data.id });
    } catch (e: any) {
        return c.json({ error: e.message || e.details }, 500);
    }
});

// PUT /plans/:id (Update)
systemPlansRoutes.put('/plans/:id', async (c) => {
    const id = c.req.param('id');
    try {
        const body = await c.req.json();
        const supabase = getSupabaseAdmin();

        const updateData: any = {
            updated_at: new Date().toISOString()
        };

        // Only update fields present in body
        if (body.display_name !== undefined) updateData.display_name = body.display_name;
        if (body.price_cents !== undefined) updateData.price_cents = body.price_cents;
        if (body.is_active !== undefined) updateData.is_active = body.is_active;
        if (body.is_public !== undefined) updateData.is_public = body.is_public;
        if (body.description !== undefined) updateData.description = body.description;
        if (body.features !== undefined) updateData.features = body.features;
        if (body.limits !== undefined) updateData.limits = body.limits;
        if (body.addon_config !== undefined) updateData.addon_config = body.addon_config;
        if (body.billing_period !== undefined) updateData.billing_period = body.billing_period;
        if (body.name !== undefined) updateData.slug = body.name; // Updating slug if name changes

        const { error } = await supabase
            .from('plans')
            .update(updateData)
            .eq('id', id);

        if (error) throw error;

        return c.json({ success: true });
    } catch (e: any) {
        return c.json({ error: e.message || e.details }, 500);
    }
});

// DELETE /plans/:id
systemPlansRoutes.delete('/plans/:id', async (c) => {
    const id = c.req.param('id');
    const supabase = getSupabaseAdmin();

    const { error } = await supabase
        .from('plans')
        .delete()
        .eq('id', id);

    if (error) return c.json({ error: error.message }, 500);

    return c.json({ success: true });
});


// ============================================================================
// COUPONS
// ============================================================================

// GET /coupons
systemPlansRoutes.get('/coupons', async (c) => {
    const supabase = getSupabaseAdmin();
    const { data: coupons, error } = await supabase
        .from('coupons')
        .select('*')
        .order('created_at', { ascending: false });

    if (error) return c.json({ error: error.message }, 500);

    return c.json({ coupons: coupons || [] });
});

// POST /coupons (Create)
systemPlansRoutes.post('/coupons', async (c) => {
    const user = c.get('user');
    try {
        const body = await c.req.json();
        const {
            code,
            discount_type,
            discount_value,
            max_uses,
            description,
            expires_at,
            minimum_amount_cents,
            valid_for_plans,
            is_active = true
        } = body;

        if (!code || !discount_type || !discount_value) {
            return c.json({ error: 'Campos obrigatÃ³rios: code, discount_type, discount_value' }, 400);
        }

        const normalizedCode = code.toUpperCase().trim();
        const supabase = getSupabaseAdmin();

        const { data, error } = await supabase
            .from('coupons')
            .insert({
                code: normalizedCode,
                description,
                discount_type,
                discount_value,
                max_uses: max_uses || null,
                expires_at: expires_at || null,
                minimum_amount_cents: minimum_amount_cents || null,
                valid_for_plans: valid_for_plans || null, // JSONB
                is_active
            })
            .select()
            .single();

        if (error) throw error;

        // Audit Log
        await supabase.from('activity_log').insert({
            user_id: user.id,
            action_type: 'COUPON_CREATE',
            action_description: `Criou cupom: ${normalizedCode}`,
            target_type: 'COUPON',
            target_id: data.id,
            metadata: { code: normalizedCode, discount: `${discount_value} (${discount_type})` }
        });

        return c.json({ success: true, id: data.id });
    } catch (e: any) {
        return c.json({ error: e.message || e.details }, 500);
    }
});

// PUT /coupons/:id (Update)
systemPlansRoutes.put('/coupons/:id', async (c) => {
    const user = c.get('user');
    const id = c.req.param('id');
    try {
        const body = await c.req.json();
        const supabase = getSupabaseAdmin();

        const updateData: any = {
            updated_at: new Date().toISOString()
        };

        // Bulk update fields
        const fields = [
            'code', 'discount_type', 'discount_value', 'description',
            'expires_at', 'max_uses', 'is_active', 'valid_for_plans', 'minimum_amount_cents'
        ];

        for (const field of fields) {
            if (body[field] !== undefined) updateData[field] = body[field];
        }

        const { error } = await supabase
            .from('coupons')
            .update(updateData)
            .eq('id', id);

        if (error) throw error;

        // Audit Log
        await supabase.from('activity_log').insert({
            user_id: user.id,
            action_type: 'COUPON_UPDATE',
            action_description: `Atualizou cupom ID: ${id}`,
            target_type: 'COUPON',
            target_id: id,
            metadata: body
        });

        return c.json({ success: true });
    } catch (e: any) {
        return c.json({ error: e.message || e.details }, 500);
    }
});

// DELETE /coupons/:id
systemPlansRoutes.delete('/coupons/:id', async (c) => {
    const user = c.get('user');
    const id = c.req.param('id');
    const supabase = getSupabaseAdmin();

    try {
        // Get code for audit before delete
        const { data: coupon } = await supabase
            .from('coupons')
            .select('code')
            .eq('id', id)
            .single();

        const code = coupon?.code || 'Unknown';

        const { error } = await supabase
            .from('coupons')
            .delete()
            .eq('id', id);

        if (error) throw error;

        // Audit Log
        await supabase.from('activity_log').insert({
            user_id: user.id,
            action_type: 'COUPON_DELETE',
            action_description: `Deletou cupom: ${code}`,
            target_type: 'COUPON',
            target_id: id,
            metadata: { deleted_code: code }
        });

        return c.json({ success: true });
    } catch (e: any) {
        return c.json({ error: e.message }, 500);
    }
});

export default systemPlansRoutes;
===END_FILE===
===FILE: supabase/functions/api/tenant-auth-middleware.ts===
import { Context, Next } from "hono";
import { getCookie } from "hono/cookie";
import { verify } from "https://deno.land/x/djwt@v2.9/mod.ts";
import { USER_ROLES } from "./user-types.ts";

type Env = {
    DB: any;
    JWT_SECRET?: string;
};

/**
 * TENANT AUTH MIDDLEWARE - Blindagem de SeguranÃ§a Multi-Tenant
 * 
 * Este middleware Ã© responsÃ¡vel por:
 * 1. Autenticar o usuÃ¡rio (via cookie de sessÃ£o ou JWT)
 * 2. Injetar o contexto de tenant seguro na requisiÃ§Ã£o
 * 3. CRÃTICO: O organizationId SEMPRE vem do banco/token, NUNCA do body/params
 * 
 * @security Este middleware implementa o princÃ­pio de "Least Privilege"
 */

// Tipo do contexto de tenant seguro
export interface TenantContext {
    organizationId: number | null;
    allowedOrganizationIds: number[]; // Inclui subsidiÃ¡rias para Org Admin
    isSystemAdmin: boolean;
    userId: string;
    userRole: string;
}

// Tipo do usuÃ¡rio autenticado
export interface AuthenticatedUser {
    id: string;
    email: string;
    name: string;
    role: string;
    organization_id: number | null;
    managed_organization_id: number | null;
    can_manage_users: boolean;
    can_create_organizations: boolean;
    is_active: boolean;
}

async function verifyJwtToken(token: string, secret: string) {
    const key = await crypto.subtle.importKey(
        "raw",
        new TextEncoder().encode(secret),
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["verify"]
    );

    return await verify(token, key, "HS256");
}

/**
 * Middleware principal de autenticaÃ§Ã£o e contexto de tenant
 * 
 * @security 
 * - Valida sessÃ£o via cookie ou JWT (quando configurado)
 * - Busca dados do usuÃ¡rio no banco para garantir integridade
 * - Injeta contexto de tenant seguro que NÃƒO pode ser manipulado pelo cliente
 */
export async function tenantAuthMiddleware(c: Context, next: Next) {
    const env = c.env as Env;

    // 0. Verificar se jÃ¡ existe usuÃ¡rio no contexto (injetado por Supabase Auth ou outro middleware)
    const existingUser = c.get('user');
    let userId: string | null = null;

    if (existingUser && existingUser.id) {
        userId = existingUser.id;
    }

    // 1. Extrair token de autenticaÃ§Ã£o (Cookie) se nÃ£o encontrado no contexto
    if (!userId) {
        const sessionToken = getCookie(c, "mocha-session-token") || getCookie(c, "mocha_session_token");

        // 2. Validar sessÃ£o via cookie
        // SEGURANÃ‡A: dev-session sÃ³ Ã© aceito em ambiente de desenvolvimento
        // Fail Secure: Assume produÃ§Ã£o (false) a menos que explicitamente 'development'
        const isDevelopment = Deno.env.get('ENVIRONMENT') === 'development';

        if (sessionToken && sessionToken.startsWith("dev-session-") && isDevelopment) {
            userId = sessionToken.replace("dev-session-", "");
            console.log('[TENANT-AUTH] DEV SESSION aceito (ambiente desenvolvimento)');
        } else if (sessionToken && sessionToken.startsWith("dev-session-") && !isDevelopment) {
            console.warn('[TENANT-AUTH] BLOQUEADO: Tentativa de usar dev-session em produÃ§Ã£o');
            // NÃ£o aceitar dev-session em produÃ§Ã£o - seguranÃ§a crÃ­tica
        } else if (sessionToken) {
            if (!env.DB) {
                console.warn('[TENANT-AUTH] Database nÃ£o disponÃ­vel para validar sessÃ£o.');
            } else {
                try {
                    const session = await env.DB.prepare(
                        "SELECT user_id FROM user_sessions WHERE token = ? AND expires_at > NOW()"
                    ).bind(sessionToken).first();

                    if (session?.user_id) {
                        userId = session.user_id as string;
                        console.log('[TENANT-AUTH] SessÃ£o validada via cookie.');
                    } else {
                        console.warn('[TENANT-AUTH] SessÃ£o invÃ¡lida ou expirada.');
                    }
                } catch (e) {
                    console.error('[TENANT-AUTH] Erro ao validar sessÃ£o:', e);
                }
            }
        }
    }

    // 3. Validar JWT (Authorization Header)
    const authHeader = c.req.header("Authorization");
    if (!userId && authHeader?.startsWith("Bearer ")) {
        const token = authHeader.substring(7);
        const jwtSecret = env.JWT_SECRET || Deno.env.get('JWT_SECRET') || Deno.env.get('SUPABASE_JWT_SECRET');

        if (!jwtSecret) {
            console.warn('[TENANT-AUTH] JWT_SECRET ausente. Token ignorado por seguranÃ§a.');
        } else {
            try {
                const payload: any = await verifyJwtToken(token, jwtSecret);
                if (payload?.sub) {
                    userId = payload.sub;
                    console.log('[TENANT-AUTH] JWT Token validado, user:', userId);
                }
            } catch (e) {
                console.error('[TENANT-AUTH] JWT invÃ¡lido:', e);
            }
        }
    }

    // 4. Se nÃ£o autenticado, permitir passar mas sem contexto
    // Rotas protegidas devem verificar c.get('user') e c.get('tenantContext')
    if (!userId) {
        await next();
        return;
    }

    // 5. CRÃTICO: Buscar dados do usuÃ¡rio SEMPRE do banco de dados
    // Isso garante que o organizationId Ã© confiÃ¡vel e nÃ£o pode ser manipulado
    let user: any = null;
    let dbError: any = null;
    let middlewareLog: string[] = [];

    try {
        if (!env.DB) {
            console.error("[TENANT-AUTH] Database nÃ£o disponÃ­vel");
            await next();
            return;
        }

        // Simplificado para SELECT * para evitar erros de coluna e facilitar debug
        user = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(userId).first();

        if (!user) {
            console.warn(`[TENANT-AUTH] UsuÃ¡rio nÃ£o encontrado no banco: ${userId}`);
            dbError = "User not found in public.users";
        } else {
            // VERIFICAÃ‡ÃƒO CRÃTICA
            // Converter tipos se necessÃ¡rio (ex: organization_id de string para number se o driver retornar string)
            if (user.organization_id) user.organization_id = Number(user.organization_id);
            if (user.managed_organization_id) user.managed_organization_id = Number(user.managed_organization_id);
        }

    } catch (error: any) {
        console.error("[TENANT-AUTH] Erro ao buscar usuÃ¡rio:", error);
        dbError = error.message || String(error);
    }

    if (!user) {
        console.warn(`[TENANT-AUTH] Falha crÃ­tica de autenticaÃ§Ã£o - DB Error: ${dbError}`);

        // AUTO-CADASTRO (Just-in-Time Provisioning)
        // Se temos um userId vÃ¡lido do JWT, mas ele nÃ£o estÃ¡ no banco, criamos agora.
        if (userId && (!dbError || dbError.includes('not found') || dbError.includes('no such table'))) {
            try {
                console.log(`[TENANT-AUTH] Tentando auto-cadastro JIT para: ${userId}`);

                // Precisamos dos dados do payload do JWT para preencher o cadastro
                // Vamos re-verificar o token para extrair metadados
                // (OtimizaÃ§Ã£o: poderÃ­amos ter passado o payload para cÃ¡, mas vamos extrair de novo por simplicidade local)
                const authHeader = c.req.header("Authorization");
                let jwtPayload: any = null;

                if (authHeader?.startsWith("Bearer ")) {
                    const token = authHeader.substring(7);
                    const jwtSecret = env.JWT_SECRET || Deno.env.get('JWT_SECRET') || Deno.env.get('SUPABASE_JWT_SECRET');
                    if (jwtSecret) {
                        const payload: any = await verifyJwtToken(token, jwtSecret);
                        jwtPayload = payload;
                    }
                }

                if (jwtPayload && jwtPayload.email) {
                    const email = jwtPayload.email;
                    const meta = jwtPayload.user_metadata || {};
                    const name = meta.full_name || meta.name || email.split('@')[0];
                    const avatarUrl = meta.picture || meta.avatar_url;

                    console.log(`[TENANT-AUTH] Criando usuÃ¡rio JIT: ${email}, ${name}`);

                    // Inserir na tabela users
                    await env.DB.prepare(`
                        INSERT INTO users (id, email, name, role, approval_status, avatar_url, created_at, updated_at, is_active)
                        VALUES (?, ?, ?, 'inspector', 'pending', ?, NOW(), NOW(), true)
                    `).bind(userId, email, name, avatarUrl || null).run();

                    // Buscar o usuÃ¡rio recÃ©m-criado
                    user = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(userId).first();
                    if (user) {
                        // Type conversions if needed
                        if (user.organization_id) user.organization_id = Number(user.organization_id);
                        if (user.managed_organization_id) user.managed_organization_id = Number(user.managed_organization_id);

                        console.log(`[TENANT-AUTH] Auto-cadastro realizado com sucesso! User role: ${user.role}`);

                        // NOTIFICAR ADMINS (Opcional, mas recomendado)
                        // ...
                    }
                }
            } catch (jitError) {
                console.error(`[TENANT-AUTH] Erro no auto-cadastro JIT:`, jitError);
            }
        }

        if (!user) {
            c.set("tenantAuthError", dbError || "User search failed");
            // Permitir continuar, mas inspection-routes vai bloquear
            await next();
            return;
        }
    }

    // Update last_active_at if null or > 5 min old
    try {
        const now = new Date();
        const lastActive = user.last_active_at ? new Date(user.last_active_at) : null;

        if (!lastActive || (now.getTime() - lastActive.getTime() > 5 * 60 * 1000)) {
            // Async update
            env.DB.prepare("UPDATE users SET last_active_at = NOW() WHERE id = ?").bind(userId).run().catch((e: any) => console.error("Error updating last_active_at:", e));
        }
    } catch (e) {
        console.error("Error checking activity:", e);
    }

    // 6. Construir contexto de tenant seguro
    const isSystemAdmin = user.role === USER_ROLES.SYSTEM_ADMIN ||
        user.role === 'sys_admin' ||
        user.role === 'admin';

    let allowedOrganizationIds: number[] = [];

    if (isSystemAdmin) {
        allowedOrganizationIds = []; // System Admin has access to everything effectively (handled by logic elsewhere usually)
    } else {
        // Start with organization_id (Legacy/Primary)
        const orgsSet = new Set<number>();
        if (user.organization_id) orgsSet.add(Number(user.organization_id));

        // Fetch explicit assignments from user_organizations
        try {
            middlewareLog.push(`Fetching assignments for ${userId}`);
            console.log(`[TENANT-AUTH] Fetching assignments for user ${userId}`);
            const assigned = await env.DB.prepare("SELECT organization_id FROM user_organizations WHERE user_id = ?").bind(userId).all();

            if (assigned.results) {
                middlewareLog.push(`Found ${assigned.results.length} assignments`);
                assigned.results.forEach((r: any) => {
                    orgsSet.add(Number(r.organization_id));
                });
            } else {
                middlewareLog.push(`No result object from DB`);
            }
        } catch (e: any) {
            console.error("[TENANT-AUTH] Error fetching user_organizations:", e);
            middlewareLog.push(`Error fetching assignments: ${e.message}`);
        }

        // If Org Admin, include managed org and subsidiaries
        if (user.role === USER_ROLES.ORG_ADMIN && user.managed_organization_id) {
            console.log(`[TENANT-AUTH] User is Org Admin for: ${user.managed_organization_id}`);
            orgsSet.add(Number(user.managed_organization_id));
            try {
                const subsidiaries = await env.DB.prepare("SELECT id FROM organizations WHERE parent_organization_id = ?").bind(user.managed_organization_id).all();
                if (subsidiaries.results) {
                    subsidiaries.results.forEach((s: any) => orgsSet.add(Number(s.id)));
                }
            } catch (e) {
                console.error("[TENANT-AUTH] Error fetching subsidiaries:", e);
            }
        }

        allowedOrganizationIds = Array.from(orgsSet);
    }

    // Read X-Organization-Id header for context switching (Multi-Tenant)
    let activeOrganizationId = user.organization_id;
    const requestedOrgId = c.req.header('X-Organization-Id');

    if (requestedOrgId) {
        const requestedOrgIdNum = Number(requestedOrgId);
        // System admin can access any org, others must have explicit access
        if (isSystemAdmin || allowedOrganizationIds.includes(requestedOrgIdNum)) {
            activeOrganizationId = requestedOrgIdNum;
            console.log(`[TENANT-AUTH] Context switched to org: ${requestedOrgIdNum}`);
        } else {
            console.warn(`[TENANT-AUTH] Denied context switch to org ${requestedOrgIdNum} - not in allowed list`);
        }
    }

    const tenantContext: TenantContext = {
        organizationId: activeOrganizationId,
        allowedOrganizationIds,
        isSystemAdmin,
        userId: user.id,
        userRole: user.role,
        // @ts-ignore
        _debugLog: middlewareLog
    };

    // PRESERVE GOOGLE/SUPABASE METADATA (Picture/Name)
    if (existingUser && (existingUser as any).user_metadata) {
        const metadata = (existingUser as any).user_metadata;
        if (metadata.picture || metadata.avatar_url) {
            (user as any).google_user_data = {
                picture: metadata.picture || metadata.avatar_url,
                name: metadata.full_name || metadata.name
            };
        }
    }

    // 7. Injetar no contexto da requisiÃ§Ã£o
    c.set("user", user);
    c.set("tenantContext", tenantContext);

    // RLS: Configurar variÃ¡vel de sessÃ£o no Postgres para as policies funcionarem
    // Usa variÃ¡veis padrÃ£o Supabase: request.jwt.claim.sub e role
    try {
        if (env.DB) {
            // Configurar user_id usando padrÃ£o Supabase
            await env.DB.prepare("SELECT set_config('request.jwt.claim.sub', ?, true)").bind(userId).run();
            await env.DB.prepare("SELECT set_config('role', 'authenticated', true)").bind().run();
        }
    } catch (e) {
        console.error("[TENANT-AUTH] Erro ao configurar RLS session:", e);
    }

    try {
        await next();
    } finally {
        // RLS: Limpar variÃ¡vel de sessÃ£o para evitar vazamento em conexÃµes reutilizadas
        try {
            if (env.DB) {
                // Reset usando padrÃ£o Supabase
                await env.DB.prepare("SELECT set_config('request.jwt.claim.sub', '', true)").bind().run();
                await env.DB.prepare("SELECT set_config('role', '', true)").bind().run();
            }
        } catch (e) {
            console.error("[TENANT-AUTH] Erro ao limpar RLS session:", e);
        }
    }


}

/**
 * Middleware de proteÃ§Ã£o de rota - Requer autenticaÃ§Ã£o
 * 
 * @security Use este middleware em rotas que EXIGEM usuÃ¡rio autenticado
 */
export async function requireAuth(c: Context, next: Next) {
    const user = c.get("user");

    if (!user) {
        return c.json({
            error: "unauthorized",
            message: "AutenticaÃ§Ã£o necessÃ¡ria para acessar este recurso"
        }, 401);
    }

    await next();
}

/**
 * Middleware de verificaÃ§Ã£o de roles permitidos
 * 
 * @param allowedRoles - Lista de roles que podem acessar a rota
 * @security Implementa o princÃ­pio de "Least Privilege"
 */
export function requireRoles(...allowedRoles: string[]) {
    return async (c: Context, next: Next) => {
        const user = c.get("user") as AuthenticatedUser | undefined;
        const tenantContext = c.get("tenantContext") as TenantContext | undefined;

        if (!user || !tenantContext) {
            return c.json({
                error: "unauthorized",
                message: "AutenticaÃ§Ã£o necessÃ¡ria"
            }, 401);
        }

        // System Admin sempre tem acesso
        if (tenantContext.isSystemAdmin) {
            await next();
            return;
        }

        // Verificar se o role do usuÃ¡rio estÃ¡ na lista permitida
        const userRole = user.role.toLowerCase();
        const normalizedAllowedRoles = allowedRoles.map(r => r.toLowerCase());

        if (!normalizedAllowedRoles.includes(userRole)) {
            return c.json({
                error: "forbidden",
                message: "PermissÃµes insuficientes para acessar este recurso",
                required_roles: allowedRoles,
                user_role: user.role
            }, 403);
        }

        await next();
    };
}

/**
 * Extrai o organizationId seguro do contexto de tenant
 * 
 * @security NUNCA use organization_id do body/params para usuÃ¡rios nÃ£o-admin
 * @returns O organizationId do contexto seguro ou null se nÃ£o disponÃ­vel
 */
export function getSecureOrganizationId(c: Context): number | null {
    const tenantContext = c.get("tenantContext") as TenantContext | undefined;
    return tenantContext?.organizationId ?? null;
}

/**
 * Verifica se o usuÃ¡rio tem acesso a uma organizaÃ§Ã£o especÃ­fica
 * 
 * @security Use esta funÃ§Ã£o antes de acessar dados de uma organizaÃ§Ã£o
 */
export function canAccessOrganization(c: Context, targetOrgId: number): boolean {
    const tenantContext = c.get("tenantContext") as TenantContext | undefined;

    if (!tenantContext) return false;
    if (tenantContext.isSystemAdmin) return true;

    return tenantContext.allowedOrganizationIds.includes(targetOrgId);
}

/**
 * Helper para logging de seguranÃ§a
 * 
 * @security Use para registrar tentativas de acesso nÃ£o autorizado
 */
export async function logSecurityEvent(
    env: Env,
    userId: string,
    action: string,
    details: Record<string, unknown>,
    isBlocked: boolean = false
): Promise<void> {
    try {
        await env.DB.prepare(`
      INSERT INTO security_audit_log (
        user_id, action_type, old_value, new_value,
        blocked_reason, is_blocked, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, NOW())
    `).bind(
            userId,
            action,
            JSON.stringify(details),
            null,
            isBlocked ? `Tentativa bloqueada: ${action}` : null,
            isBlocked ? 1 : 0
        ).run();
    } catch (error) {
        console.error("[SECURITY-LOG] Erro ao registrar evento:", error);
    }
}

===END_FILE===
===FILE: supabase/functions/api/test-checklist.ts===

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const supabaseUrl = Deno.env.get("SUPABASE_URL") || "";
const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || "";

console.log("Testing AI Checklist Generation...");

try {
    const response = await fetch("https://vjlvvmriqerfmztwtewa.supabase.co/functions/v1/api/checklist-templates/generate-ai-simple", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${supabaseKey}`
        },
        body: JSON.stringify({
            industry: "ConstruÃ§Ã£o",
            location_type: "Canteiro",
            template_name: "Teste AI",
            category: "SeguranÃ§a",
            num_questions: 5,
            detail_level: "basico",
            regulation: "NR-18"
        })
    });

    const status = response.status;
    const text = await response.text();

    console.log(`Status: ${status}`);
    console.log(`Response: ${text.substring(0, 500)}...`);

} catch (error) {
    console.error("Error:", error);
}
===END_FILE===
===FILE: supabase/functions/api/test-email-routes.ts===
import { Hono } from "hono";
import { EmailService } from "./email-service.ts";
import { getWelcomeTemplate, getApprovalTemplate, getAlertTemplate } from "./email-templates.ts";

const testEmailRoutes = new Hono<{ Bindings: any }>().basePath('/api/test-email');

testEmailRoutes.post("/", async (c) => {
    // Get URL parameters
    const to = c.req.query("to");
    const type = c.req.query("type") || "welcome";

    // Get API Key from environment (injected by Supabase)
    const apiKey = Deno.env.get('RESEND_API_KEY');

    if (!apiKey) {
        return c.json({ error: "Configuration Error: RESEND_API_KEY not found" }, 500);
    }

    if (!to) {
        return c.json({ error: "Missing 'to' parameter (email address)" }, 400);
    }

    const emailService = new EmailService(apiKey);
    let subject = "";
    let html = "";

    // Select Template
    switch (type) {
        case 'welcome':
            subject = "Bem-vindo ao Compia Enterprise!";
            html = getWelcomeTemplate("UsuÃ¡rio Teste", "https://compia.tech/login");
            break;
        case 'approval':
            subject = "Seu acesso ao Compia foi aprovado";
            html = getApprovalTemplate("Engenheiro Tiago", "https://compia.tech/login");
            break;
        case 'alert':
            subject = "Alerta de SeguranÃ§a: Tentativa de Login";
            html = getAlertTemplate(
                "Novo acesso detectado",
                "Detectamos um novo acesso Ã  sua conta vindo de SÃ£o Paulo/SP (Chrome/Windows). Se foi vocÃª, ignore este email.",
                "https://compia.tech/security",
                "Verificar Atividade"
            );
            break;
        default:
            return c.json({ error: "Invalid type. Use 'welcome', 'approval', or 'alert'" }, 400);
    }

    // Send
    const result = await emailService.sendEmail([to], subject, html);

    if (result.success) {
        return c.json({ success: true, id: result.id, message: `Email (${type}) sent to ${to}` });
    } else {
        return c.json({ error: "Failed to send email", details: result.error }, 500);
    }
});

export default testEmailRoutes;
===END_FILE===
===FILE: supabase/functions/api/test-orgs.ts===

import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { requireProtectedSysAdmin } from "./rbac-middleware.ts";

type Env = {
    DB: any;
};

const app = new Hono<{ Bindings: Env }>();

app.get('/', (c) => c.json({ message: 'Test connection successful' }));
app.get('/:id', (c) => c.json({ message: `Test ID: ${c.req.param('id')}` }));

// Debug endpoint to check organization address data
app.get('/debug/addresses', tenantAuthMiddleware, requireProtectedSysAdmin(), async (c) => {
    if (Deno.env.get('ENVIRONMENT') === 'production') {
        return c.json({ error: "Debug endpoints desabilitados em produÃ§Ã£o" }, 403);
    }

    try {
        const result = await c.env.DB.prepare(`
      SELECT id, name, nome_fantasia, address, contact_email 
      FROM organizations 
      LIMIT 10
    `).all();

        return c.json({
            success: true,
            organizations: result.results || [],
            message: 'Debug: Check if address column has data'
        });
    } catch (error) {
        return c.json({
            success: false,
            error: error instanceof Error ? error.message : String(error)
        }, 500);
    }
});

export default app;
===END_FILE===
===FILE: supabase/functions/api/test-rls-routes.ts===
import { Hono } from 'hono';
import { requireAuth } from './tenant-auth-middleware.ts';

const app = new Hono();

/**
 * Endpoint de teste para validar o contexto RLS
 *
 * Este endpoint verifica se as variÃ¡veis de sessÃ£o RLS estÃ£o sendo
 * configuradas corretamente pelo middleware e se as polÃ­ticas RLS
 * estÃ£o funcionando como esperado.
 *
 * Uso: GET /api/test/rls-context
 */
app.get('/rls-context', requireAuth, async (c) => {
    const user = c.get('user');
    const db = c.env.DB;

    try {
        // Teste 1: Verificar se current_user_id() retorna o ID correto
        const contextTest = await db.prepare(
            "SELECT current_user_id() as user_from_context"
        ).first();

        // Teste 2: Contar quantos usuÃ¡rios sÃ£o acessÃ­veis (RLS deve filtrar)
        const usersTest = await db.prepare(
            "SELECT COUNT(*) as accessible_users FROM users"
        ).first();

        // Teste 3: Contar quantas inspeÃ§Ãµes sÃ£o acessÃ­veis (RLS deve filtrar por org)
        const inspectionsTest = await db.prepare(
            "SELECT COUNT(*) as accessible_inspections FROM inspections"
        ).first();

        // Teste 4: Verificar se o usuÃ¡rio consegue ver seu prÃ³prio registro
        const selfTest = await db.prepare(
            "SELECT id, email, role FROM users WHERE id = ?"
        ).bind(user.id).first();

        // Verificar se o contexto RLS estÃ¡ correto
        const contextMatches = contextTest?.user_from_context === user.id;

        return c.json({
            success: true,
            rls_context: {
                authenticated_user_id: user.id,
                context_user_id: contextTest?.user_from_context,
                context_matches: contextMatches,
                context_type: contextTest?.user_from_context ? 'UUID' : 'NULL'
            },
            access_tests: {
                accessible_users_count: usersTest?.accessible_users || 0,
                accessible_inspections_count: inspectionsTest?.accessible_inspections || 0,
                can_see_self: !!selfTest
            },
            user_info: {
                id: user.id,
                email: user.email,
                role: user.role,
                organization_id: user.organization_id
            },
            message: contextMatches
                ? "âœ… RLS context is working correctly!"
                : "âŒ WARNING: RLS context mismatch detected",
            status: contextMatches ? 'healthy' : 'error'
        });
    } catch (error: any) {
        console.error('[TEST-RLS] Error during RLS context test:', error);
        return c.json({
            success: false,
            error: error.message,
            stack: error.stack,
            message: "Failed to test RLS context"
        }, 500);
    }
});

/**
 * Endpoint de teste para simular diferentes contextos de usuÃ¡rio
 *
 * Este endpoint permite que system admins simulem o contexto de outros
 * usuÃ¡rios para validar que as polÃ­ticas RLS estÃ£o isolando corretamente
 * os dados entre organizaÃ§Ãµes.
 *
 * Uso: GET /api/test/rls-simulation/:userId
 * Requer: role = sys_admin ou system_admin
 */
app.get('/rls-simulation/:userId', requireAuth, async (c) => {
    const user = c.get('user');
    const db = c.env.DB;
    const targetUserId = c.req.param('userId');

    // Apenas sys_admin pode simular outros usuÃ¡rios
    if (user.role !== 'sys_admin' && user.role !== 'system_admin') {
        return c.json({
            error: 'forbidden',
            message: 'Only system admins can simulate users'
        }, 403);
    }

    try {
        // Verificar se o usuÃ¡rio alvo existe
        const targetUser = await db.prepare(
            "SELECT id, email, role, organization_id FROM users WHERE id = ?"
        ).bind(targetUserId).first();

        if (!targetUser) {
            return c.json({
                error: 'not_found',
                message: 'Target user not found'
            }, 404);
        }

        // Simular o contexto do usuÃ¡rio alvo
        // Nota: Esta Ã© uma simulaÃ§Ã£o read-only para testes
        const result = await db.prepare(`
            WITH context_set AS (
                SELECT
                    set_config('request.jwt.claim.sub', $1, true) as config_sub,
                    set_config('role', 'authenticated', true) as config_role
            )
            SELECT
                current_user_id() as simulated_user,
                (SELECT COUNT(*) FROM inspections) as visible_inspections,
                (SELECT COUNT(*) FROM organizations) as visible_orgs,
                (SELECT COUNT(*) FROM users) as visible_users
            FROM context_set
        `).bind(targetUserId).first();

        return c.json({
            success: true,
            simulation: {
                target_user: {
                    id: targetUser.id,
                    email: targetUser.email,
                    role: targetUser.role,
                    organization_id: targetUser.organization_id
                },
                simulated_context: {
                    user_id: result?.simulated_user,
                    visible_inspections: result?.visible_inspections || 0,
                    visible_orgs: result?.visible_orgs || 0,
                    visible_users: result?.visible_users || 0
                }
            },
            message: "Simulation completed successfully"
        });
    } catch (error: any) {
        console.error('[TEST-RLS] Error during simulation:', error);
        return c.json({
            success: false,
            error: error.message,
            message: "Failed to simulate user context"
        }, 500);
    }
});

/**
 * Endpoint de teste para verificar polÃ­ticas RLS especÃ­ficas
 *
 * Testa se as polÃ­ticas RLS estÃ£o permitindo/bloqueando acesso corretamente
 * para diferentes tabelas.
 *
 * Uso: GET /api/test/rls-policies
 */
app.get('/rls-policies', requireAuth, async (c) => {
    const user = c.get('user');
    const db = c.env.DB;

    try {
        const tests = [];

        // Teste 1: Verificar RLS na tabela users
        try {
            const usersCount = await db.prepare(
                "SELECT COUNT(*) as count FROM users"
            ).first();
            tests.push({
                table: 'users',
                status: 'pass',
                accessible_records: usersCount?.count || 0,
                expected: user.role === 'sys_admin' || user.role === 'system_admin' ? 'all users' : 'own org users'
            });
        } catch (e: any) {
            tests.push({
                table: 'users',
                status: 'fail',
                error: e.message
            });
        }

        // Teste 2: Verificar RLS na tabela organizations
        try {
            const orgsCount = await db.prepare(
                "SELECT COUNT(*) as count FROM organizations"
            ).first();
            tests.push({
                table: 'organizations',
                status: 'pass',
                accessible_records: orgsCount?.count || 0,
                expected: user.role === 'sys_admin' || user.role === 'system_admin' ? 'all orgs' : 'own org only'
            });
        } catch (e: any) {
            tests.push({
                table: 'organizations',
                status: 'fail',
                error: e.message
            });
        }

        // Teste 3: Verificar RLS na tabela inspections
        try {
            const inspCount = await db.prepare(
                "SELECT COUNT(*) as count FROM inspections"
            ).first();
            tests.push({
                table: 'inspections',
                status: 'pass',
                accessible_records: inspCount?.count || 0,
                expected: user.role === 'sys_admin' || user.role === 'system_admin' ? 'all inspections' : 'own org inspections'
            });
        } catch (e: any) {
            tests.push({
                table: 'inspections',
                status: 'fail',
                error: e.message
            });
        }

        // Teste 4: Verificar RLS na tabela plans (deve ser pÃºblica)
        try {
            const plansCount = await db.prepare(
                "SELECT COUNT(*) as count FROM plans WHERE is_active = true AND is_public = true"
            ).first();
            tests.push({
                table: 'plans',
                status: 'pass',
                accessible_records: plansCount?.count || 0,
                expected: 'all public plans'
            });
        } catch (e: any) {
            tests.push({
                table: 'plans',
                status: 'fail',
                error: e.message
            });
        }

        const passedTests = tests.filter(t => t.status === 'pass').length;
        const totalTests = tests.length;

        return c.json({
            success: true,
            summary: {
                total_tests: totalTests,
                passed: passedTests,
                failed: totalTests - passedTests,
                pass_rate: `${Math.round((passedTests / totalTests) * 100)}%`
            },
            tests,
            user_context: {
                id: user.id,
                role: user.role,
                organization_id: user.organization_id
            },
            message: passedTests === totalTests
                ? "All RLS policy tests passed!"
                : `${totalTests - passedTests} test(s) failed`
        });
    } catch (error: any) {
        console.error('[TEST-RLS] Error during policy tests:', error);
        return c.json({
            success: false,
            error: error.message,
            message: "Failed to test RLS policies"
        }, 500);
    }
});

export default app;
===END_FILE===
===FILE: supabase/functions/api/user-assignment-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";

type Env = {
    DB: any;
    [key: string]: unknown;
};

const userAssignmentRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>().basePath('/api/user-assignments');

// Helper para verificar se usuÃ¡rio pode atribuir a uma organizaÃ§Ã£o
async function canAssignToOrganization(
    db: any,
    currentUser: any,
    targetOrgId: number
): Promise<boolean> {
    const role = currentUser.role?.toLowerCase() || '';

    // SysAdmin pode atribuir a qualquer organizaÃ§Ã£o
    const sysAdminRoles = ['system_admin', 'sys_admin', 'admin'];
    if (sysAdminRoles.includes(role)) {
        return true;
    }

    // OrgAdmin pode atribuir Ã  sua organizaÃ§Ã£o e subsidiÃ¡rias
    const orgAdminRoles = ['org_admin', 'admin_org', 'organization_admin'];
    if (orgAdminRoles.includes(role)) {
        const managedOrgId = currentUser.managed_organization_id || currentUser.organization_id;
        if (!managedOrgId) return false;

        // Verificar se Ã© a prÃ³pria organizaÃ§Ã£o ou subsidiÃ¡ria
        if (targetOrgId === managedOrgId) return true;

        const subsidiary = await db.prepare(`
      SELECT id FROM organizations 
      WHERE id = ? AND parent_organization_id = ?
    `).bind(targetOrgId, managedOrgId).first();

        return !!subsidiary;
    }

    return false;
}

// GET /api/user-assignments/:userId - Listar atribuiÃ§Ãµes de um usuÃ¡rio
userAssignmentRoutes.get("/:userId", tenantAuthMiddleware, async (c) => {
    const userId = c.req.param("userId");
    const currentUser = c.get("user");
    const db = c.env.DB;

    if (!currentUser) {
        return c.json({ error: "NÃ£o autorizado" }, 401);
    }

    try {
        const assignments = await db.prepare(`
      SELECT 
        uo.id,
        uo.user_id,
        uo.organization_id,
        uo.role,
        uo.permissions,
        uo.is_primary,
        uo.is_active,
        uo.assigned_by,
        uo.assigned_at,
        o.name as organization_name,
        o.type as organization_type,
        assigner.name as assigned_by_name
      FROM user_organizations uo
      JOIN organizations o ON uo.organization_id = o.id
      LEFT JOIN users assigner ON uo.assigned_by = assigner.id
      WHERE uo.user_id = ?
      ORDER BY uo.is_primary DESC, o.name ASC
    `).bind(userId).all();

        return c.json({
            assignments: assignments.results || [],
            count: assignments.results?.length || 0
        });
    } catch (error) {
        console.error("Erro ao buscar atribuiÃ§Ãµes:", error);
        return c.json({ error: "Erro ao buscar atribuiÃ§Ãµes" }, 500);
    }
});

// GET /api/user-assignments/organization/:orgId - Listar usuÃ¡rios de uma organizaÃ§Ã£o
userAssignmentRoutes.get("/organization/:orgId", tenantAuthMiddleware, async (c) => {
    const orgId = parseInt(c.req.param("orgId"));
    const currentUser = c.get("user");
    const db = c.env.DB;

    if (!currentUser) {
        return c.json({ error: "NÃ£o autorizado" }, 401);
    }

    try {
        const assignments = await db.prepare(`
      SELECT 
        uo.id,
        uo.user_id,
        uo.organization_id,
        uo.role,
        uo.permissions,
        uo.is_primary,
        uo.is_active,
        uo.assigned_at,
        u.name as user_name,
        u.email as user_email,
        u.avatar_url,
        u.approval_status
      FROM user_organizations uo
      JOIN users u ON uo.user_id = u.id
      WHERE uo.organization_id = ? AND uo.is_active = 1
      ORDER BY uo.role, u.name ASC
    `).bind(orgId).all();

        return c.json({
            assignments: assignments.results || [],
            count: assignments.results?.length || 0
        });
    } catch (error) {
        console.error("Erro ao buscar usuÃ¡rios da organizaÃ§Ã£o:", error);
        return c.json({ error: "Erro ao buscar usuÃ¡rios da organizaÃ§Ã£o" }, 500);
    }
});

// GET /api/user-assignments/available/:orgId - Listar usuÃ¡rios disponÃ­veis para atribuiÃ§Ã£o
userAssignmentRoutes.get("/available/:orgId", tenantAuthMiddleware, async (c) => {
    const orgId = parseInt(c.req.param("orgId"));
    const currentUser = c.get("user");
    const db = c.env.DB;

    if (!currentUser) {
        return c.json({ error: "NÃ£o autorizado" }, 401);
    }

    // Verificar permissÃ£o
    const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(currentUser.id).first();
    const canAssign = await canAssignToOrganization(db, userProfile, orgId);

    if (!canAssign) {
        return c.json({ error: "Sem permissÃ£o para atribuir usuÃ¡rios a esta organizaÃ§Ã£o" }, 403);
    }

    try {
        // UsuÃ¡rios aprovados que nÃ£o estÃ£o atribuÃ­dos a esta organizaÃ§Ã£o
        const availableUsers = await db.prepare(`
      SELECT 
        u.id,
        u.name,
        u.email,
        u.role as current_role,
        u.avatar_url,
        u.approval_status,
        (SELECT COUNT(*) FROM user_organizations WHERE user_id = u.id AND is_active = 1) as org_count
      FROM users u
      WHERE u.approval_status = 'approved'
        AND u.is_active = 1
        AND u.role NOT IN ('sys_admin', 'system_admin')
        AND u.id NOT IN (
          SELECT user_id FROM user_organizations 
          WHERE organization_id = ? AND is_active = 1
        )
      ORDER BY u.name ASC
    `).bind(orgId).all();

        return c.json({
            users: availableUsers.results || [],
            count: availableUsers.results?.length || 0
        });
    } catch (error) {
        console.error("Erro ao buscar usuÃ¡rios disponÃ­veis:", error);
        return c.json({ error: "Erro ao buscar usuÃ¡rios disponÃ­veis" }, 500);
    }
});

// POST /api/user-assignments - Criar nova atribuiÃ§Ã£o
userAssignmentRoutes.post("/", tenantAuthMiddleware, async (c) => {
    const currentUser = c.get("user");
    const db = c.env.DB;

    if (!currentUser) {
        return c.json({ error: "NÃ£o autorizado" }, 401);
    }

    try {
        const body = await c.req.json();
        const { user_id, organization_id, role, permissions, is_primary } = body;

        if (!user_id || !organization_id || !role) {
            return c.json({ error: "user_id, organization_id e role sÃ£o obrigatÃ³rios" }, 400);
        }

        // Verificar permissÃ£o
        const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(currentUser.id).first();
        const canAssign = await canAssignToOrganization(db, userProfile, organization_id);

        if (!canAssign) {
            return c.json({ error: "Sem permissÃ£o para atribuir usuÃ¡rios a esta organizaÃ§Ã£o" }, 403);
        }

        // Verificar se usuÃ¡rio existe e estÃ¡ aprovado
        const targetUser = await db.prepare("SELECT * FROM users WHERE id = ?").bind(user_id).first() as any;
        if (!targetUser) {
            return c.json({ error: "UsuÃ¡rio nÃ£o encontrado" }, 404);
        }
        if (targetUser.approval_status !== 'approved') {
            return c.json({ error: "UsuÃ¡rio precisa estar aprovado para ser atribuÃ­do" }, 400);
        }

        // Verificar se jÃ¡ existe atribuiÃ§Ã£o
        const existing = await db.prepare(`
      SELECT id FROM user_organizations 
      WHERE user_id = ? AND organization_id = ?
    `).bind(user_id, organization_id).first();

        if (existing) {
            return c.json({ error: "UsuÃ¡rio jÃ¡ estÃ¡ atribuÃ­do a esta organizaÃ§Ã£o" }, 409);
        }

        // Se is_primary, remover flag de outras atribuiÃ§Ãµes
        if (is_primary) {
            await db.prepare(`
        UPDATE user_organizations SET is_primary = false WHERE user_id = ?
      `).bind(user_id).run();

            // Atualizar organization_id na tabela users (retrocompatibilidade)
            await db.prepare(`
        UPDATE users SET organization_id = ?, role = ? WHERE id = ?
      `).bind(organization_id, role, user_id).run();
        }

        // Criar atribuiÃ§Ã£o
        const assignmentId = crypto.randomUUID();
        await db.prepare(`
      INSERT INTO user_organizations (
        id, user_id, organization_id, role, permissions, is_primary, is_active, assigned_by, assigned_at
      ) VALUES (?, ?, ?, ?, ?, ?, true, ?, NOW())
    `).bind(
            assignmentId,
            user_id,
            organization_id,
            role,
            JSON.stringify(permissions || {}),
            is_primary ? true : false,
            currentUser.id
        ).run();

        return c.json({
            success: true,
            message: "UsuÃ¡rio atribuÃ­do com sucesso",
            assignment_id: assignmentId
        }, 201);

    } catch (error) {
        console.error("Erro ao criar atribuiÃ§Ã£o:", error);
        return c.json({ error: "Erro ao criar atribuiÃ§Ã£o" }, 500);
    }
});

// POST /api/user-assignments/bulk - AtribuiÃ§Ã£o em massa
userAssignmentRoutes.post("/bulk", tenantAuthMiddleware, async (c) => {
    const currentUser = c.get("user");
    const db = c.env.DB;

    if (!currentUser) {
        return c.json({ error: "NÃ£o autorizado" }, 401);
    }

    try {
        const body = await c.req.json();
        const { user_id, organization_ids, role, permissions } = body;

        if (!user_id || !organization_ids || !Array.isArray(organization_ids) || organization_ids.length === 0 || !role) {
            return c.json({ error: "user_id, organization_ids (array) e role sÃ£o obrigatÃ³rios" }, 400);
        }

        // Verificar se usuÃ¡rio target existe
        const targetUser = await db.prepare("SELECT * FROM users WHERE id = ?").bind(user_id).first() as any;
        if (!targetUser) {
            return c.json({ error: "UsuÃ¡rio alvo nÃ£o encontrado" }, 404);
        }

        // Verificar permissÃµes do usuÃ¡rio atual
        const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(currentUser.id).first();

        const results = {
            success: [] as number[],
            failed: [] as { id: number, reason: string }[]
        };

        for (const orgId of organization_ids) {
            try {
                // Check permissions per org
                const canAssign = await canAssignToOrganization(db, userProfile, orgId);
                if (!canAssign) {
                    results.failed.push({ id: orgId, reason: "Sem permissÃ£o" });
                    continue;
                }

                // Check existing assignment
                const existing = await db.prepare(`
                    SELECT id FROM user_organizations 
                    WHERE user_id = ? AND organization_id = ?
                `).bind(user_id, orgId).first();

                if (existing) {
                    results.failed.push({ id: orgId, reason: "JÃ¡ atribuÃ­do" });
                    continue;
                }

                // Insert assignment
                const assignmentId = crypto.randomUUID();
                await db.prepare(`
                    INSERT INTO user_organizations (
                        id, user_id, organization_id, role, permissions, is_primary, is_active, assigned_by, assigned_at
                    ) VALUES (?, ?, ?, ?, ?, false, true, ?, NOW())
                `).bind(
                    assignmentId,
                    user_id,
                    orgId,
                    role,
                    JSON.stringify(permissions || {}),
                    currentUser.id
                ).run();

                results.success.push(orgId);

            } catch (err: any) {
                console.error(`Erro ao atribuir org ${orgId}:`, err);
                results.failed.push({ id: orgId, reason: err.message || "Erro interno" });
            }
        }

        return c.json({
            message: "Processamento concluÃ­do",
            results
        });

    } catch (error) {
        console.error("Erro na atribuiÃ§Ã£o em massa:", error);
        return c.json({ error: "Erro interno ao processar atribuiÃ§Ãµes em massa" }, 500);
    }
});

// PUT /api/user-assignments/:assignmentId - Atualizar atribuiÃ§Ã£o
userAssignmentRoutes.put("/:assignmentId", tenantAuthMiddleware, async (c) => {
    const assignmentId = c.req.param("assignmentId");
    const currentUser = c.get("user");
    const db = c.env.DB;

    if (!currentUser) {
        return c.json({ error: "NÃ£o autorizado" }, 401);
    }

    try {
        const body = await c.req.json();
        const { role, permissions, is_primary, is_active } = body;

        // Buscar atribuiÃ§Ã£o existente
        const assignment = await db.prepare(`
      SELECT * FROM user_organizations WHERE id = ?
    `).bind(assignmentId).first() as any;

        if (!assignment) {
            return c.json({ error: "AtribuiÃ§Ã£o nÃ£o encontrada" }, 404);
        }

        // Verificar permissÃ£o
        const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(currentUser.id).first();
        const canAssign = await canAssignToOrganization(db, userProfile, assignment.organization_id);

        if (!canAssign) {
            return c.json({ error: "Sem permissÃ£o para modificar esta atribuiÃ§Ã£o" }, 403);
        }

        // Se is_primary mudou para true, remover flag de outras atribuiÃ§Ãµes
        if (is_primary && !assignment.is_primary) {
            await db.prepare(`
        UPDATE user_organizations SET is_primary = 0 WHERE user_id = ?
      `).bind(assignment.user_id).run();

            // Atualizar organization_id na tabela users
            await db.prepare(`
        UPDATE users SET organization_id = ?, role = ? WHERE id = ?
      `).bind(assignment.organization_id, role || assignment.role, assignment.user_id).run();
        }

        // Atualizar atribuiÃ§Ã£o
        await db.prepare(`
      UPDATE user_organizations SET
        role = COALESCE(?, role),
        permissions = COALESCE(?, permissions),
        is_primary = COALESCE(?, is_primary),
        is_active = COALESCE(?, is_active),
        updated_at = NOW()
      WHERE id = ?
    `).bind(
            role || null,
            permissions ? JSON.stringify(permissions) : null,
            is_primary !== undefined ? (is_primary ? 1 : 0) : null,
            is_active !== undefined ? (is_active ? 1 : 0) : null,
            assignmentId
        ).run();

        return c.json({ success: true, message: "AtribuiÃ§Ã£o atualizada com sucesso" });

    } catch (error) {
        console.error("Erro ao atualizar atribuiÃ§Ã£o:", error);
        return c.json({ error: "Erro ao atualizar atribuiÃ§Ã£o" }, 500);
    }
});

// DELETE /api/user-assignments/:assignmentId - Remover atribuiÃ§Ã£o
userAssignmentRoutes.delete("/:assignmentId", tenantAuthMiddleware, async (c) => {
    const assignmentId = c.req.param("assignmentId");
    const currentUser = c.get("user");
    const db = c.env.DB;

    if (!currentUser) {
        return c.json({ error: "NÃ£o autorizado" }, 401);
    }

    try {
        // Buscar atribuiÃ§Ã£o existente
        const assignment = await db.prepare(`
      SELECT * FROM user_organizations WHERE id = ?
    `).bind(assignmentId).first() as any;

        if (!assignment) {
            return c.json({ error: "AtribuiÃ§Ã£o nÃ£o encontrada" }, 404);
        }

        // Verificar permissÃ£o
        const userProfile = await db.prepare("SELECT * FROM users WHERE id = ?").bind(currentUser.id).first();
        const canAssign = await canAssignToOrganization(db, userProfile, assignment.organization_id);

        if (!canAssign) {
            return c.json({ error: "Sem permissÃ£o para remover esta atribuiÃ§Ã£o" }, 403);
        }

        // Soft delete - apenas desativar
        await db.prepare(`
      UPDATE user_organizations SET is_active = 0, updated_at = NOW() WHERE id = ?
    `).bind(assignmentId).run();

        // Se era a atribuiÃ§Ã£o primÃ¡ria, limpar organization_id do user
        if (assignment.is_primary) {
            // Tentar encontrar outra atribuiÃ§Ã£o ativa para ser primÃ¡ria
            const nextPrimary = await db.prepare(`
        SELECT * FROM user_organizations 
        WHERE user_id = ? AND is_active = 1 AND id != ?
        ORDER BY created_at DESC
        LIMIT 1
      `).bind(assignment.user_id, assignmentId).first() as any;

            if (nextPrimary) {
                await db.prepare(`UPDATE user_organizations SET is_primary = 1 WHERE id = ?`).bind(nextPrimary.id).run();
                await db.prepare(`UPDATE users SET organization_id = ?, role = ? WHERE id = ?`)
                    .bind(nextPrimary.organization_id, nextPrimary.role, assignment.user_id).run();
            } else {
                await db.prepare(`UPDATE users SET organization_id = NULL WHERE id = ?`).bind(assignment.user_id).run();
            }
        }

        return c.json({ success: true, message: "AtribuiÃ§Ã£o removida com sucesso" });

    } catch (error) {
        console.error("Erro ao remover atribuiÃ§Ã£o:", error);
        return c.json({ error: "Erro ao remover atribuiÃ§Ã£o" }, 500);
    }
});

export default userAssignmentRoutes;

===END_FILE===
===FILE: supabase/functions/api/user-types.ts===
// Interface base definida localmente para remover dependÃªncia externa @getmocha/users-service
export interface MochaUser {
    id: string;
    email: string;
    [key: string]: any;
}

export interface UserProfile {
    id: string;
    email: string;
    name: string;
    role: string; // 'system_admin', 'org_admin', 'manager', 'inspector', 'client'
    organization_id?: number;
    phone?: string;
    avatar_url?: string;
    is_active: boolean;
    last_login_at?: string;
    created_at: string;
    updated_at: string;
    // New fields for multi-tenant support
    can_manage_users: boolean;
    can_create_organizations: boolean;
    managed_organization_id?: number;
    invitation_token?: string;
    invited_by?: string;
    invitation_expires_at?: string;
    // Email/password authentication fields
    password_hash?: string;
    email_verified_at?: string;
    profile_completed: boolean;
}

export interface Organization {
    id: number;
    name: string;
    type: string; // 'master', 'company', 'consultancy', 'client'
    description?: string;
    logo_url?: string;
    contact_email?: string;
    contact_phone?: string;
    address?: string;
    website?: string;
    is_active: boolean;
    created_at: string;
    updated_at: string;
    // New fields for hierarchy
    parent_organization_id?: number;
    organization_level: string; // 'master', 'company', 'subsidiary'
    subscription_status: string; // 'active', 'suspended', 'trial'
    subscription_plan: string; // 'basic', 'pro', 'enterprise'
    max_users: number;
    max_subsidiaries: number;
    // Runtime fields
    user_count?: number;
    subsidiary_count?: number;
    parent_organization?: Organization;
    subsidiaries?: Organization[];
    parent_organization_name?: string;
}

export interface UserInvitation {
    id: number;
    email: string;
    organization_id: number;
    role: string;
    invited_by: string;
    invitation_token: string;
    expires_at: string;
    accepted_at?: string;
    created_at: string;
    updated_at: string;
    // Runtime fields
    organization_name?: string;
    inviter_name?: string;
}

export interface OrganizationPermission {
    id: number;
    user_id: string;
    organization_id: number;
    permission_type: string; // 'view', 'edit', 'admin', 'owner'
    granted_by: string;
    granted_at: string;
    is_active: boolean;
    created_at: string;
    updated_at: string;
}

export interface ActivityLogEntry {
    id: number;
    user_id: string;
    organization_id?: number;
    action_type: string;
    action_description: string;
    target_type?: string;
    target_id?: string;
    metadata?: string;
    ip_address?: string;
    user_agent?: string;
    created_at: string;
}

export interface ExtendedMochaUser extends MochaUser {
    profile?: UserProfile;
    organizations?: Organization[];
    managed_organization?: Organization;
    permissions?: OrganizationPermission[];
}

// Role definitions for the multi-tenant system
export const USER_ROLES = {
    SYSTEM_ADMIN: 'system_admin', // Primary system admin role
    /**
     * @deprecated Use SYSTEM_ADMIN instead. Kept for backward compatibility with legacy data.
     */
    SYS_ADMIN: 'sys_admin',
    ORG_ADMIN: 'org_admin',       // Company admin who bought the system
    MANAGER: 'manager',           // Organization manager
    INSPECTOR: 'inspector',       // Technical inspector/safety professional  
    CLIENT: 'client'              // Client/viewer role
} as const;

export type UserRole = typeof USER_ROLES[keyof typeof USER_ROLES];

export const ORGANIZATION_LEVELS = {
    MASTER: 'master',       // Your master organization
    COMPANY: 'company',     // Companies that buy the system
    SUBSIDIARY: 'subsidiary' // Sub-organizations within companies
} as const;

export const SUBSCRIPTION_STATUS = {
    ACTIVE: 'active',
    SUSPENDED: 'suspended',
    TRIAL: 'trial',
    EXPIRED: 'expired'
} as const;

export const SUBSCRIPTION_PLANS = {
    BASIC: 'basic',
    PRO: 'pro',
    ENTERPRISE: 'enterprise'
} as const;
===END_FILE===
===FILE: supabase/functions/api/users-routes.ts===
import { Hono } from "hono";
import { tenantAuthMiddleware as authMiddleware } from "./tenant-auth-middleware.ts";
import { USER_ROLES } from "./user-types.ts";
import { requireScopes, protectSysAdmin, SCOPES, createAuthErrorResponse, isSystemAdmin, canManageUsers } from "./rbac-middleware.ts";

type Env = {
  DB: any;
};

const usersRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>()
  .basePath('/api/users');

// Get current user profile (alias for /profile)
usersRoutes.get("/me", authMiddleware, async (c) => {
  return c.redirect("/api/users/profile");
});

// Get user's accessible organizations for multi-tenant switcher
usersRoutes.get("/me/organizations", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user") as any;

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Check user role first
    const userProfile = await env.DB.prepare("SELECT role, organization_id FROM users WHERE id = ?").bind(user.id).first() as any;
    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin';

    let organizations = [];

    if (isSysAdmin) {
      // System Admin sees ALL active organizations
      const allOrgs = await env.DB.prepare(`
        SELECT 
          id,
          name,
          type,
          organization_level,
          logo_url
        FROM organizations
        WHERE is_active = true
        ORDER BY name ASC
      `).all();

      organizations = (allOrgs.results || []).map((org: any) => ({
        ...org,
        role: 'sys_admin',
        is_primary: org.id === userProfile.organization_id
      }));

    } else {
      // Regular users: Fetch from user_organizations join
      const orgsResult = await env.DB.prepare(`
        SELECT 
          o.id,
          o.name,
          o.type,
          o.organization_level,
          uo.role,
          uo.is_primary,
          o.logo_url
        FROM user_organizations uo
        INNER JOIN organizations o ON uo.organization_id = o.id
        WHERE uo.user_id = ? AND o.is_active = true
        ORDER BY uo.is_primary DESC, o.name ASC
      `).bind(user.id).all();

      organizations = orgsResult.results || [];

      // Fallback for legacy data (if no user_organizations entry)
      if (organizations.length === 0 && userProfile?.organization_id) {
        const legacyOrg = await env.DB.prepare(`
            SELECT id, name, type, organization_level, logo_url 
            FROM organizations 
            WHERE id = ? AND is_active = true
          `).bind(userProfile.organization_id).first() as any;

        if (legacyOrg) {
          organizations.push({
            ...legacyOrg,
            role: userProfile.role,
            is_primary: true
          });
        }
      }
    }

    return c.json({ organizations });

  } catch (error) {
    console.error('Error fetching user organizations:', error);
    return c.json({ error: "Failed to fetch organizations" }, 500);
  }
});

// Get user profile
usersRoutes.get("/profile", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user") as any;

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Get user profile from database
    let userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    if (!userProfile) {
      // Verifica se Ã© o usuÃ¡rio sys_admin protegido
      if (user.id === '01990d69-5246-733d-8605-1ed319a3f98d' || user.email === 'eng.tiagosm@gmail.com') {
        // Recria como sys_admin com configuraÃ§Ãµes completas
        await env.DB.prepare(`
          INSERT INTO users (
            id, email, name, role, can_manage_users, can_create_organizations,
            is_active, organization_id, managed_organization_id, created_at, updated_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
        `).bind(
          user.id,
          user.email,
          user.google_user_data?.name || 'Tiago Mocha System Admin',
          'sys_admin',
          true,
          true,
          true,
          1, // OrganizaÃ§Ã£o principal
          1
        ).run();
        console.log(`[USERS_PROFILE] UsuÃ¡rio sys_admin protegido ${user.email} recriado com papel sys_admin.`);

        // Criar entradas de organizaÃ§Ã£o e permissÃµes
        await env.DB.prepare(`
          INSERT OR IGNORE INTO user_organizations (user_id, organization_id, role, is_active, created_at, updated_at)
          VALUES (?, ?, ?, ?, NOW(), NOW())
        `).bind(user.id, 1, 'owner', true).run();

        await env.DB.prepare(`
          INSERT OR IGNORE INTO organization_permissions (user_id, organization_id, permission_type, granted_by, is_active, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, NOW(), NOW())
        `).bind(user.id, 1, 'owner', 'system', true).run();

      } else {
        // Para outros usuÃ¡rios, cria como inspector (padrÃ£o)
        await env.DB.prepare(`
          INSERT INTO users (
            id, email, name, role, can_manage_users, can_create_organizations, 
            is_active, created_at, updated_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
        `).bind(
          user.id,
          user.email,
          user.google_user_data?.name || user.email,
          USER_ROLES.INSPECTOR, // Default role
          false,
          false,
          true
        ).run();
        console.log(`[USERS_PROFILE] UsuÃ¡rio ${user.email} criado com papel inspector.`);
      }

      userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

      if (!userProfile) {
        return c.json({ error: "User profile not found" }, 404);
      }

      let organization = null;
      let managedOrganization = null;

      if (userProfile.organization_id) {
        organization = await env.DB.prepare("SELECT * FROM organizations WHERE id = ?").bind(userProfile.organization_id).first();
      }

      if (userProfile.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {
        managedOrganization = await env.DB.prepare("SELECT * FROM organizations WHERE id = ?").bind(userProfile.managed_organization_id).first();
      }

      return c.json({
        profile: userProfile,
        organization: organization,
        managed_organization: managedOrganization
      });
    }

    // Se o usuÃ¡rio jÃ¡ existe, buscar organizaÃ§Ã£o
    let organization = null;
    let managedOrganization = null;

    if (userProfile.organization_id) {
      organization = await env.DB.prepare("SELECT * FROM organizations WHERE id = ?").bind(userProfile.organization_id).first();
    }

    if (userProfile.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {
      managedOrganization = await env.DB.prepare("SELECT * FROM organizations WHERE id = ?").bind(userProfile.managed_organization_id).first();
    }

    return c.json({
      profile: userProfile,
      organization: organization,
      managed_organization: managedOrganization
    });

  } catch (error) {
    console.error('Error fetching user profile:', error);
    return c.json({ error: "Failed to fetch user profile" }, 500);
  }
});

// Update user profile
usersRoutes.put("/:id", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const userId = c.req.param("id");

  if (!user || user.id !== userId) {
    return c.json({ error: "Unauthorized" }, 401);
  }

  const body = await c.req.json();
  const { name, phone, organization_id } = body;

  try {
    await env.DB.prepare(`
      UPDATE users 
      SET name = ?, phone = ?, organization_id = ?, updated_at = NOW()
      WHERE id = ?
    `).bind(name, phone || null, organization_id || null, userId).run();

    return c.json({ message: "Profile updated successfully" });

  } catch (error) {
    console.error('Error updating user profile:', error);
    return c.json({ error: "Failed to update profile" }, 500);
  }
});

// Promote user to admin (for first-time setup)
usersRoutes.post("/promote-to-admin", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    // Check if there are any system admins already
    const existingAdmins = await env.DB.prepare("SELECT COUNT(*) as count FROM users WHERE role = ?").bind(USER_ROLES.SYSTEM_ADMIN).first() as any;

    if (existingAdmins.count > 0) {
      return c.json({ error: "System admin already exists. Cannot promote another user." }, 400);
    }

    // Promote user to system admin
    await env.DB.prepare(`
      UPDATE users 
      SET role = ?, can_manage_users = ?, can_create_organizations = ?, updated_at = NOW()
      WHERE id = ?
    `).bind(USER_ROLES.SYSTEM_ADMIN, true, true, user.id).run();

    // Log activity
    await env.DB.prepare(`
      INSERT INTO activity_log (user_id, action_type, action_description, target_type, target_id, created_at)
      VALUES (?, ?, ?, ?, ?, NOW())
    `).bind(
      user.id,
      'user_promoted',
      'Promoted to system administrator',
      'user',
      user.id
    ).run();

    return c.json({ message: "Successfully promoted to system administrator." });

  } catch (error) {
    console.error('Error promoting user:', error);
    return c.json({ error: "Failed to promote user." }, 500);
  }
});

// Get simple user list for dropdowns (id, name, photo)
// Accessible by authenticated users to see colleagues in their organization
usersRoutes.get("/simple-list", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  try {
    const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

    // Determine filter based on role
    let query = "SELECT id, name, email, role, avatar_url FROM users";
    const params: any[] = [];
    const whereConditions: string[] = [];

    if (isSystemAdmin(userProfile?.role)) {
      const orgId = c.req.query('organization_id');
      if (orgId) {
        whereConditions.push("organization_id = ?");
        params.push(orgId);
      }
    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN) {
      if (userProfile.managed_organization_id) {
        whereConditions.push(`(
               organization_id IN (
                 SELECT id FROM organizations 
                 WHERE id = ? OR parent_organization_id = ?
               ) OR organization_id IS NULL
             )`);
        params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
      }
    } else {
      // Regular user: can only see users in their own organization
      if (userProfile?.organization_id) {
        whereConditions.push("organization_id = ?");
        params.push(userProfile.organization_id);
      } else {
        // If no org, return just themselves
        whereConditions.push("id = ?");
        params.push(user.id);
      }
    }

    if (whereConditions.length > 0) {
      query += " WHERE " + whereConditions.join(" AND ");
    }

    query += " ORDER BY name ASC";

    const users = await env.DB.prepare(query).bind(...params).all();

    // Map to simple structure
    const simpleUsers = (users.results || []).map((u: any) => {
      return {
        id: u.id,
        name: u.name,
        email: u.email,
        avatar_url: u.avatar_url,
        role: u.role
      };
    });



    return c.json({ users: simpleUsers });

  } catch (error: any) {
    console.error('Error fetching user list:', error);
    return c.json({
      error: "Failed to fetch users",
      details: error.message,
      stack: error.stack
    }, 500);
  }
});

// Get all users (requires users:read scope)
const listUsersHandler = async (c: any) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  console.log('[LIST_USERS] Usuario requisitando lista:', user.email, 'ID:', user.id);

  // Buscar perfil do usuÃ¡rio
  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  console.log('[LIST_USERS] Perfil do usuario:', userProfile?.role || 'NAO_ENCONTRADO');

  if (!userProfile || !canManageUsers(userProfile.role)) {
    console.log('[LIST_USERS] Permissoes insuficientes. Role:', userProfile?.role);
    return c.json(createAuthErrorResponse('forbidden', 'PermissÃµes insuficientes para listar usuÃ¡rios', [SCOPES.USERS_READ]), 403);
  }

  try {
    let query = `
      SELECT u.*, o.name as organization_name,
             mo.name as managed_organization_name
      FROM users u
      LEFT JOIN organizations o ON u.organization_id = o.id
      LEFT JOIN organizations mo ON u.managed_organization_id = mo.id
    `;

    const params: any[] = [];
    const whereConditions: string[] = [];

    if (isSystemAdmin(userProfile.role)) {
      console.log('[LIST_USERS] SYSTEM_ADMIN - vendo todos os usuarios');
      // System admin vÃª todos os usuÃ¡rios sem filtros
      // No filters applied
    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      console.log('[LIST_USERS] ORG_ADMIN - organizacao gerenciada:', userProfile.managed_organization_id);
      // Org admin vÃª usuÃ¡rios da sua organizaÃ§Ã£o, subsidiÃ¡rias e usuÃ¡rios nÃ£o atribuÃ­dos
      if (userProfile.managed_organization_id) {
        whereConditions.push(`(
          u.organization_id IN (
            SELECT id FROM organizations 
            WHERE id = ? OR parent_organization_id = ?
          ) OR u.organization_id IS NULL
        )`);
        params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);
      }
    } else {
      // Other roles see only users from their organization
      if (userProfile.organization_id) {
        whereConditions.push("u.organization_id = ?");
        params.push(userProfile.organization_id);
      }
    }

    if (whereConditions.length > 0) {
      query += " WHERE " + whereConditions.join(" AND ");
    }

    query += " ORDER BY u.created_at DESC";

    console.log('[LIST_USERS] Query final:', query);
    console.log('[LIST_USERS] Parametros:', params);

    const users = await env.DB.prepare(query).bind(...params).all();

    console.log('[LIST_USERS] Usuarios encontrados:', users.results?.length || 0);

    // Debug: log first few users
    if (users.results && users.results.length > 0) {
      console.log('[LIST_USERS] Primeiros usuarios:', users.results.slice(0, 3).map((u: any) => ({
        email: u.email,
        name: u.name,
        role: u.role,
        organization_id: u.organization_id,
        organization_name: u.organization_name
      })));
    }

    return c.json({ users: users.results });

  } catch (error) {
    console.error('[LIST_USERS] Error fetching users:', error);
    return c.json({ error: "Failed to fetch users." }, 500);
  }
};

// Bind handler to both / and empty path to prevent strict routing issues
usersRoutes.get("/", authMiddleware, requireScopes(SCOPES.USERS_READ), listUsersHandler);
usersRoutes.get("", authMiddleware, requireScopes(SCOPES.USERS_READ), listUsersHandler);

// Get user statistics (for admins)
usersRoutes.get("/stats", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  // Buscar perfil do usuÃ¡rio
  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile || !canManageUsers(userProfile.role)) {
    return c.json(createAuthErrorResponse('forbidden', 'PermissÃµes insuficientes para ver convites', [SCOPES.USERS_INVITATIONS_READ]), 403);
  }

  try {
    let whereClause = "";
    let params: any[] = [];

    if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Org admin can only see stats for their organization and subsidiaries
      whereClause = `
        WHERE organization_id IN (
          SELECT id FROM organizations 
          WHERE id = ? OR parent_organization_id = ?
        )
      `;
      params = [userProfile.managed_organization_id, userProfile.managed_organization_id];
    }

    // Get total users count
    const totalUsers = await env.DB.prepare(`
      SELECT COUNT(*) as count FROM users ${whereClause}
    `).bind(...params).first() as any;

    // Get active users count
    const activeUsers = await env.DB.prepare(`
      SELECT COUNT(*) as count FROM users 
      ${whereClause}${whereClause ? ' AND' : 'WHERE'} is_active = true
    `).bind(...params).first() as any;

    // Get users by role
    const usersByRole = await env.DB.prepare(`
      SELECT 
        role,
        COUNT(*) as count
      FROM users 
      ${whereClause}
      GROUP BY role
      ORDER BY count DESC
    `).bind(...params).all();

    // Get recent user registrations (last 30 days)
    const recentRegistrations = await env.DB.prepare(`
      SELECT COUNT(*) as count FROM users 
      ${whereClause}${whereClause ? ' AND' : 'WHERE'} created_at >= datetime('now', '-30 days')
    `).bind(...params).first() as any;

    // Get users with organizations
    const usersWithOrganizations = await env.DB.prepare(`
      SELECT COUNT(*) as count FROM users 
      ${whereClause}${whereClause ? ' AND' : 'WHERE'} organization_id IS NOT NULL
    `).bind(...params).first() as any;

    return c.json({
      total_users: totalUsers?.count || 0,
      active_users: activeUsers?.count || 0,
      users_by_role: usersByRole.results || [],
      recent_registrations: recentRegistrations?.count || 0,
      users_with_organizations: usersWithOrganizations?.count || 0
    });

  } catch (error) {
    console.error('Error fetching user statistics:', error);
    return c.json({ error: "Failed to fetch user statistics." }, 500);
  }
});

// Update user by admin (requires users:write scope and protection for sysadmin)
usersRoutes.put("/admin/:id", authMiddleware, requireScopes(SCOPES.USERS_WRITE), protectSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");
  const targetUserId = c.req.param("id");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  // Buscar perfil do usuÃ¡rio
  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile || !canManageUsers(userProfile.role)) {
    return c.json(createAuthErrorResponse('forbidden', 'PermissÃµes insuficientes para editar usuÃ¡rios', [SCOPES.USERS_WRITE]), 403);
  }

  const body = await c.req.json();
  const { name, role, is_active, organization_id } = body;

  try {
    // Get target user
    const targetUser = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(targetUserId).first() as any;

    if (!targetUser) {
      return c.json({ error: "Target user not found." }, 404);
    }

    // PROTEÃ‡ÃƒO ABSOLUTA: usuÃ¡rio sysadmin eng.tiagosm@gmail.com Ã© INTOCÃVEL
    if (targetUser.email === 'eng.tiagosm@gmail.com' || targetUser.id === '84edf8d1-77d9-4c73-935e-d76745bc3707') {
      return c.json(createAuthErrorResponse('forbidden', 'SISTEMA PROTEGIDO: Este usuÃ¡rio principal nÃ£o pode ser modificado por questÃµes de seguranÃ§a', []), 403);
    }

    // Check if org admin has permission to manage this user
    if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      const canManage = targetUser.organization_id === userProfile.managed_organization_id ||
        (await env.DB.prepare(`
                         SELECT id FROM organizations 
                         WHERE id = ? AND parent_organization_id = ?
                       `).bind(targetUser.organization_id, userProfile.managed_organization_id).first());

      if (!canManage) {
        return c.json({ error: "Cannot manage users outside your organization scope." }, 403);
      }

      // Org admin cannot assign admin roles
      if (role === USER_ROLES.ORG_ADMIN || role === USER_ROLES.SYSTEM_ADMIN) {
        return c.json({ error: `Cannot assign role: ${role}.` }, 403);
      }
    }

    // Update user
    const updateFields = [];
    const updateValues = [];

    if (name !== undefined) {
      updateFields.push("name = ?");
      updateValues.push(name);
    }

    if (role !== undefined) {
      updateFields.push("role = ?");
      updateValues.push(role);

      // Update permissions based on role
      if (role === USER_ROLES.ORG_ADMIN) {
        updateFields.push("can_manage_users = ?", "can_create_organizations = ?", "managed_organization_id = ?");
        updateValues.push(true, true, organization_id || targetUser.organization_id);
      } else {
        updateFields.push("can_manage_users = ?", "can_create_organizations = ?", "managed_organization_id = ?");
        updateValues.push(false, false, null);
      }
    }

    if (is_active !== undefined) {
      updateFields.push("is_active = ?");
      updateValues.push(is_active);
    }

    if (organization_id !== undefined) {
      updateFields.push("organization_id = ?");
      updateValues.push(organization_id);
    }

    if (updateFields.length > 0) {
      updateFields.push("updated_at = NOW()");

      await env.DB.prepare(`
        UPDATE users SET ${updateFields.join(", ")} WHERE id = ?
      `).bind(...updateValues, targetUserId).run();

      // Log activity
      await env.DB.prepare(`
        INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, NOW())
      `).bind(
        user.id,
        organization_id || targetUser.organization_id,
        'user_updated',
        `Updated user: ${targetUser.email}`,
        'user',
        targetUserId
      ).run();
    }

    return c.json({ message: "User updated successfully." });

  } catch (error) {
    console.error('Error updating user:', error);
    return c.json({ error: "Failed to update user." }, 500);
  }
});

// Get pending invitations (requires users:invitations:read scope)
usersRoutes.get("/pending-invitations", authMiddleware, requireScopes(SCOPES.USERS_INVITATIONS_READ), async (c) => {
  const env = c.env;
  const user = c.get("user");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile || (!isSystemAdmin(userProfile.role) && userProfile.role !== USER_ROLES.ORG_ADMIN)) {
    return c.json({ error: "Insufficient permissions." }, 403);
  }

  try {
    let query = `
      SELECT ui.*, o.name as organization_name, u.name as inviter_name
      FROM user_invitations ui
      LEFT JOIN organizations o ON ui.organization_id = o.id
      LEFT JOIN users u ON ui.invited_by = u.id
      WHERE ui.accepted_at IS NULL
    `;

    let params: any[] = [];

    if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      // Org admin can only see invitations for their organization and subsidiaries
      query += `
        AND ui.organization_id IN (
          SELECT id FROM organizations 
          WHERE id = ? OR parent_organization_id = ?
        )
      `;
      params = [userProfile.managed_organization_id, userProfile.managed_organization_id];
    }

    query += " ORDER BY ui.created_at DESC";

    const invitations = await env.DB.prepare(query).bind(...params).all();

    return c.json({ invitations: invitations.results });

  } catch (error) {
    console.error('Error fetching pending invitations:', error);
    return c.json({ error: "Failed to fetch pending invitations." }, 500);
  }
});

// Get invitation token (admin only)
usersRoutes.get("/invitations/:id/token", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const invitationId = c.req.param("id");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile || (!isSystemAdmin(userProfile.role) && userProfile.role !== USER_ROLES.ORG_ADMIN)) {
    return c.json({ error: "Insufficient permissions." }, 403);
  }

  try {
    const invitation = await env.DB.prepare("SELECT invitation_token FROM user_invitations WHERE id = ?").bind(invitationId).first() as any;

    if (!invitation) {
      return c.json({ error: "Invitation not found." }, 404);
    }

    return c.json({ token: invitation.invitation_token });

  } catch (error) {
    console.error('Error fetching invitation token:', error);
    return c.json({ error: "Failed to fetch invitation token." }, 500);
  }
});

// Revoke invitation (admin only)
usersRoutes.put("/invitations/:id/revoke", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const invitationId = c.req.param("id");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile || (!isSystemAdmin(userProfile.role) && userProfile.role !== USER_ROLES.ORG_ADMIN)) {
    return c.json({ error: "Insufficient permissions." }, 403);
  }

  try {
    // Get the invitation details
    const invitation = await env.DB.prepare("SELECT * FROM user_invitations WHERE id = ?").bind(invitationId).first() as any;

    if (!invitation) {
      return c.json({ error: "Invitation not found." }, 404);
    }

    // Check if org admin has permission to revoke this invitation
    if (userProfile.role === USER_ROLES.ORG_ADMIN) {
      const canRevoke = invitation.organization_id === userProfile.managed_organization_id ||
        (await env.DB.prepare(`
                         SELECT id FROM organizations 
                         WHERE id = ? AND parent_organization_id = ?
                       `).bind(invitation.organization_id, userProfile.managed_organization_id).first());

      if (!canRevoke) {
        return c.json({ error: "Cannot revoke invitations outside your organization scope." }, 403);
      }
    }

    // Mark invitation as accepted with a special revoked timestamp to prevent reuse
    await env.DB.prepare(`
      UPDATE user_invitations 
      SET accepted_at = NOW(), updated_at = NOW()
      WHERE id = ?
    `).bind(invitationId).run();

    // Log activity
    await env.DB.prepare(`
      INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
      VALUES (?, ?, ?, ?, ?, ?, NOW())
    `).bind(
      user.id,
      invitation.organization_id,
      'invitation_revoked',
      `Revoked invitation for: ${invitation.email}`,
      'invitation',
      invitationId
    ).run();

    return c.json({ message: "Invitation revoked successfully." });

  } catch (error) {
    console.error('Error revoking invitation:', error);
    return c.json({ error: "Failed to revoke invitation." }, 500);
  }
});

// Delete user (system admin only)
usersRoutes.delete("/:id", authMiddleware, requireScopes(SCOPES.USERS_DELETE), protectSysAdmin(), async (c) => {
  const env = c.env;
  const user = c.get("user");
  const targetUserId = c.req.param("id");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  // Buscar perfil do usuÃ¡rio
  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  if (!userProfile || !isSystemAdmin(userProfile.role)) {
    return c.json(createAuthErrorResponse('forbidden', 'Apenas administradores de sistema podem excluir usuÃ¡rios', [SCOPES.USERS_DELETE]), 403);
  }

  // Don't allow self-deletion
  if (user.id === targetUserId) {
    return c.json({ error: "Cannot delete your own account." }, 400);
  }

  try {
    const targetUser = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(targetUserId).first() as any;

    if (!targetUser) {
      return c.json({ error: "User not found." }, 404);
    }

    // PROTEÃ‡ÃƒO ABSOLUTA: usuÃ¡rio sysadmin eng.tiagosm@gmail.com Ã© INTOCÃVEL
    if (targetUser.email === 'eng.tiagosm@gmail.com' || targetUser.id === '84edf8d1-77d9-4c73-935e-d76745bc3707') {
      return c.json(createAuthErrorResponse('forbidden', 'SISTEMA PROTEGIDO: Este usuÃ¡rio principal nÃ£o pode ser excluÃ­do por questÃµes de seguranÃ§a', []), 403);
    }

    // Delete user permanently
    await env.DB.prepare("DELETE FROM users WHERE id = ?").bind(targetUserId).run();

    // Clean up related credentials (if cascade is not set)
    await env.DB.prepare("DELETE FROM user_credentials WHERE user_id = ?").bind(targetUserId).run();

    // Log activity
    await env.DB.prepare(`
      INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
      VALUES (?, ?, ?, ?, ?, ?, NOW())
    `).bind(
      user.id,
      targetUser.organization_id,
      'user_deleted',
      `Deleted user: ${targetUser.email}`,
      'user',
      targetUserId
    ).run();

    return c.json({ message: "User deleted successfully." });

  } catch (error) {
    console.error('Error deactivating user:', error);
    return c.json({ error: "Failed to deactivate user." }, 500);
  }
});

// LGPD: Direito ao Esquecimento (AnonimizaÃ§Ã£o)
usersRoutes.post("/:id/anonymize", authMiddleware, async (c) => {
  const env = c.env;
  const user = c.get("user");
  const targetUserId = c.req.param("id");

  if (!user) {
    return c.json({ error: "User not found" }, 401);
  }

  // Apenas o prÃ³prio usuÃ¡rio ou System Admin podem solicitar anonimizaÃ§Ã£o
  const userProfile = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(user.id).first() as any;

  const isSelf = user.id === targetUserId;
  const isAdmin = isSystemAdmin(userProfile?.role);

  if (!isSelf && !isAdmin) {
    return c.json(createAuthErrorResponse('forbidden', 'Apenas o prÃ³prio usuÃ¡rio ou administradores podem solicitar anonimizaÃ§Ã£o', []), 403);
  }

  try {
    const targetUser = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(targetUserId).first() as any;

    if (!targetUser) {
      return c.json({ error: "User not found." }, 404);
    }

    // PROTEÃ‡ÃƒO ABSOLUTA: Impedir anonimizaÃ§Ã£o de contas de sistema crÃ­ticas
    if (targetUser.email === 'eng.tiagosm@gmail.com' || targetUser.role === USER_ROLES.SYSTEM_ADMIN) {
      return c.json({ error: "Contas administrativas crÃ­ticas nÃ£o podem ser anonimizadas. Contate o suporte tÃ©cnico." }, 403);
    }

    // Gerar dados anonimizados
    const anonId = crypto.randomUUID().split('-')[0];
    const anonEmail = `deleted_${targetUserId.substring(0, 8)}_${anonId}@anon.compia.local`;
    const anonName = `UsuÃ¡rio ExcluÃ­do ${anonId}`;

    // Executar AnonimizaÃ§Ã£o (Mantendo ID para integridade referencial)
    await env.DB.prepare(`
        UPDATE users 
        SET 
          name = ?, 
          email = ?, 
          phone = NULL, 
          avatar_url = NULL, 
          google_user_data = NULL,
          is_active = FALSE,
          role = 'anonymized',
          updated_at = NOW()
        WHERE id = ?
      `).bind(anonName, anonEmail, targetUserId).run();

    // Revogar todas as permissÃµes/sessÃµes (Opcional, dependendo da tabela)
    await env.DB.prepare("DELETE FROM user_credentials WHERE user_id = ?").bind(targetUserId).run();

    // Log da AÃ§Ã£o (Audit Trail deve ser preservado para provar que a aÃ§Ã£o ocorreu)
    await env.DB.prepare(`
        INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, NOW())
      `).bind(
      user.id, // Quem executou (pode ser o prÃ³prio usuÃ¡rio antes de perder o token)
      targetUser.organization_id,
      'user_anonymized',
      `LGPD Anonymization for user ID: ${targetUserId}`,
      'user',
      targetUserId
    ).run();

    return c.json({
      message: "UsuÃ¡rio anonimizado com sucesso.",
      detail: "Os dados pessoais foram removidos, mas o histÃ³rico de atividades foi preservado de forma anÃ´nima para integridade do sistema."
    });

  } catch (error) {
    console.error('Error anonymizing user:', error);
    return c.json({ error: "Failed to anonymize user." }, 500);
  }
});

export default usersRoutes;

===END_FILE===
===FILE: supabase/functions/api/verify-logs.ts===

const supabaseUrl = Deno.env.get("SUPABASE_URL") || "";
const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || "";

console.log("ðŸ” Verificando Ãºltimos logs de uso de IA...");

if (!supabaseUrl || !supabaseKey) {
  console.error("âŒ VariÃ¡veis de ambiente SUPABASE_URL ou SUPABASE_SERVICE_ROLE_KEY nÃ£o definidas.");
  Deno.exit(1);
}

try {
  const response = await fetch(`${supabaseUrl}/rest/v1/ai_usage_log?select=*&order=created_at.desc&limit=5`, {
    headers: {
      "apikey": supabaseKey,
      "Authorization": `Bearer ${supabaseKey}`,
      "Content-Type": "application/json"
    }
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status} - ${await response.text()}`);
  }

  const data = await response.json();

  if (data.length === 0) {
    console.log("âš ï¸ Nenhum log encontrado.");
  } else {
    console.log(`âœ… ${data.length} logs encontrados. Ãšltimos:`);
    // @ts-ignore
    data.forEach((log: any, index: number) => {
      console.log(`\n--- Log #${index + 1} ---`);
      console.log(`ðŸ“… Data: ${new Date(log.created_at).toLocaleString('pt-BR')}`);
      console.log(`ðŸ¤– Modelo: ${log.model_used || 'N/A'}`);
      console.log(`ðŸ’° Tokens: ${log.tokens_count}`);
      console.log(`ðŸ¢ Org ID: ${log.organization_id}`);
    });
  }

} catch (error) {
  console.error("âŒ Erro ao buscar logs:", error);
}
===END_FILE===
===FILE: supabase/functions/api/shared/checklist-types.ts===
import z from "zod";

export const ChecklistFieldTypeSchema = z.enum([
  'text',
  'textarea',
  'select',
  'multiselect',
  'radio',
  'checkbox',
  'number',
  'date',
  'time',
  'boolean',
  'rating',
  'file'
]);

export type ChecklistFieldType = z.infer<typeof ChecklistFieldTypeSchema>;

export const ChecklistFieldSchema = z.object({
  id: z.number().optional(),
  template_id: z.number(),
  field_name: z.string().min(1, "Nome do campo Ã© obrigatÃ³rio"),
  field_type: ChecklistFieldTypeSchema,
  is_required: z.boolean().default(false),
  options: z.string().optional(), // JSON string for select/radio options
  order_index: z.number().default(0),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
});

export type ChecklistField = z.infer<typeof ChecklistFieldSchema>;

export const ChecklistTemplateSchema = z.object({
  id: z.number().optional(),
  name: z.string().min(1, "Nome do template Ã© obrigatÃ³rio"),
  description: z.string().optional(),
  category: z.string().min(1, "Categoria Ã© obrigatÃ³ria"),
  created_by: z.string().optional(),
  is_public: z.boolean().default(false),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
  // Hierarchical folder support
  parent_category_id: z.number().optional(),
  folder_id: z.string().optional(),
  category_path: z.string().optional(),
  is_category_folder: z.boolean().default(false),
  folder_color: z.string().default('#3B82F6'),
  folder_icon: z.string().default('folder'),
  display_order: z.number().default(0),
});

export type ChecklistTemplate = z.infer<typeof ChecklistTemplateSchema>;

export const AIChecklistRequestSchema = z.object({
  industry: z.string().min(1, "Setor Ã© obrigatÃ³rio"),
  location_type: z.string().min(1, "Tipo de local Ã© obrigatÃ³rio"),
  specific_requirements: z.string().optional(),
  template_name: z.string().min(1, "Nome do template Ã© obrigatÃ³rio"),
  category: z.string().min(1, "Categoria Ã© obrigatÃ³ria"),

  // Advanced Configuration
  num_questions: z.number().min(5).max(50).default(20),
  detail_level: z.enum(['basico', 'intermediario', 'avancado']).default('intermediario'),
  priority_focus: z.enum(['seguranca', 'operacional', 'qualidade', 'balanceado']).default('balanceado'),
  risk_level: z.enum(['baixo', 'medio', 'alto', 'critico']).default('medio'),

  // Compliance & Standards
  regulatory_standards: z.array(z.string()).optional(),
  certifications_required: z.array(z.string()).optional(),
  company_policies: z.string().optional(),

  // Field Types Preferences
  preferred_field_types: z.array(z.string()).optional(),
  include_media_upload: z.boolean().default(true),
  include_comments: z.boolean().default(true),
  include_action_items: z.boolean().default(true),

  // Template Base
  base_template_id: z.number().optional(),
  merge_with_existing: z.boolean().default(false),

  // Documents & References
  reference_documents: z.array(z.string()).optional(),
  custom_instructions: z.string().optional(),
});

export type AIChecklistRequest = z.infer<typeof AIChecklistRequestSchema>;

export interface AITemplatePreset {
  id: string;
  name: string;
  industry: string;
  location_type: string;
  description: string;
  icon: string;
  color: string;
  default_config: Partial<AIChecklistRequest>;
  sample_fields: string[];
}

export const CSVImportSchema = z.object({
  template_name: z.string().min(1, "Nome do template Ã© obrigatÃ³rio"),
  category: z.string().min(1, "Categoria Ã© obrigatÃ³ria"),
  csv_data: z.string().min(1, "Dados CSV sÃ£o obrigatÃ³rios"),
});

export type CSVImport = z.infer<typeof CSVImportSchema>;

export interface FieldResponse {
  field_id: number;
  field_name: string;
  field_type: ChecklistFieldType;
  value: any;
  comment?: string;
  compliance_status?: string; // 'compliant' | 'non_compliant' | 'not_applicable' | 'unanswered'
}

export interface ChecklistTemplateWithFields extends ChecklistTemplate {
  fields: ChecklistField[];
  field_count?: number;
}

export interface ChecklistFolder {
  id: string;
  organization_id: number;
  parent_id: string | null;
  name: string;
  slug: string;
  path: string;
  description?: string;
  color: string;
  icon: string;
  display_order: number;
  created_at: string;
  updated_at: string;
  children?: ChecklistFolder[];
  subfolder_count?: number;
  template_count?: number;
}

export interface CategoryFolder extends ChecklistTemplate {
  children: (ChecklistTemplate | CategoryFolder)[];
  template_count: number;
}
===END_FILE===
===FILE: supabase/functions/api/shared/folder-types.ts===
import z from "zod";

export const ChecklistFolderSchema = z.object({
  id: z.string().optional(),
  organization_id: z.number(),
  parent_id: z.string().optional().nullable(),
  name: z.string().min(1, "Nome da pasta Ã© obrigatÃ³rio"),
  slug: z.string(),
  path: z.string(),
  description: z.string().optional().nullable(),
  color: z.string().default('#3B82F6'),
  icon: z.string().default('folder'),
  display_order: z.number().default(0),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
});

export type ChecklistFolder = z.infer<typeof ChecklistFolderSchema>;

export interface ChecklistFolderWithCounts extends ChecklistFolder {
  subfolder_count: number;
  template_count: number;
  children?: (ChecklistFolderWithCounts | ChecklistTemplateInFolder)[];
}

export interface ChecklistTemplateInFolder {
  id: number;
  name: string;
  description?: string;
  category: string;
  folder_id?: string;
  is_public: boolean;
  created_by?: string;
  created_at?: string;
  updated_at?: string;
  field_count?: number;
}

export interface FolderTreeNode {
  id: string;
  parent_id: string | null;
  name: string;
  slug: string;
  path: string;
  color: string;
  icon: string;
  display_order: number;
  children: FolderTreeNode[];
}

export const CreateFolderSchema = z.object({
  name: z.string().min(1, "Nome da pasta Ã© obrigatÃ³rio").max(100, "Nome muito longo"),
  description: z.string().max(500, "DescriÃ§Ã£o muito longa").optional(),
  parent_id: z.string().optional().nullable(),
  color: z.string().regex(/^#[0-9A-F]{6}$/i, "Cor invÃ¡lida").default('#3B82F6'),
  icon: z.string().min(1, "Ãcone Ã© obrigatÃ³rio").default('folder'),
});

export type CreateFolder = z.infer<typeof CreateFolderSchema>;

export const UpdateFolderSchema = z.object({
  name: z.string().min(1, "Nome da pasta Ã© obrigatÃ³rio").max(100, "Nome muito longo").optional(),
  description: z.string().max(500, "DescriÃ§Ã£o muito longa").optional().nullable(),
  parent_id: z.string().optional().nullable(),
  color: z.string().regex(/^#[0-9A-F]{6}$/i, "Cor invÃ¡lida").optional(),
  icon: z.string().min(1, "Ãcone Ã© obrigatÃ³rio").optional(),
});

export type UpdateFolder = z.infer<typeof UpdateFolderSchema>;

export const MoveItemsSchema = z.object({
  templateIds: z.array(z.number()).default([]),
  folderIds: z.array(z.string()).default([]),
});

export type MoveItems = z.infer<typeof MoveItemsSchema>;

export const DeleteFolderStrategy = z.enum(['block', 'merge', 'cascade']);
export type DeleteFolderStrategy = z.infer<typeof DeleteFolderStrategy>;

export interface MigrationResult {
  success: boolean;
  organizations_migrated: number;
  templates_migrated: number;
  details: Array<{
    organization_id: number;
    templates_migrated: number;
  }>;
}

export interface FolderBreadcrumb {
  id: string;
  name: string;
  color: string;
  icon: string;
}

// Ãcones disponÃ­veis para pastas
export const FOLDER_ICONS = [
  { value: 'folder', label: 'Pasta', icon: 'ðŸ“' },
  { value: 'shield', label: 'SeguranÃ§a', icon: 'ðŸ›¡ï¸' },
  { value: 'hard-hat', label: 'ConstruÃ§Ã£o', icon: 'â›‘ï¸' },
  { value: 'book-open', label: 'Manual', icon: 'ðŸ“–' },
  { value: 'settings', label: 'ConfiguraÃ§Ãµes', icon: 'âš™ï¸' },
  { value: 'leaf', label: 'Meio Ambiente', icon: 'ðŸŒ¿' },
  { value: 'award', label: 'Qualidade', icon: 'ðŸ†' },
  { value: 'cog', label: 'Operacional', icon: 'âš™ï¸' },
  { value: 'mountain', label: 'Industrial', icon: 'ðŸ­' },
  { value: 'shield-check', label: 'Auditoria', icon: 'âœ…' },
  { value: 'user-check', label: 'Pessoal', icon: 'ðŸ‘¤' },
  { value: 'file-text', label: 'Documentos', icon: 'ðŸ“„' },
];

// Cores disponÃ­veis para pastas
export const FOLDER_COLORS = [
  { value: '#3B82F6', label: 'Azul', hex: '#3B82F6' },
  { value: '#10B981', label: 'Verde', hex: '#10B981' },
  { value: '#F59E0B', label: 'Amarelo', hex: '#F59E0B' },
  { value: '#EF4444', label: 'Vermelho', hex: '#EF4444' },
  { value: '#8B5CF6', label: 'Roxo', hex: '#8B5CF6' },
  { value: '#06B6D4', label: 'Ciano', hex: '#06B6D4' },
  { value: '#84CC16', label: 'Lima', hex: '#84CC16' },
  { value: '#F97316', label: 'Laranja', hex: '#F97316' },
  { value: '#EC4899', label: 'Rosa', hex: '#EC4899' },
  { value: '#6B7280', label: 'Cinza', hex: '#6B7280' },
];
===END_FILE===
===FILE: supabase/functions/api/shared/logger.ts===
export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

const levelOrder: Record<LogLevel, number> = {
  debug: 10,
  info: 20,
  warn: 30,
  error: 40
};

function resolveLevel(): LogLevel {
  const raw = (Deno.env.get('LOG_LEVEL') || 'info').toLowerCase();
  if (raw === 'debug' || raw === 'info' || raw === 'warn' || raw === 'error') {
    return raw;
  }
  return 'info';
}

export function createLogger(scope: string) {
  const minLevel = resolveLevel();
  const minValue = levelOrder[minLevel];

  const log = (level: LogLevel, message: string, meta?: unknown) => {
    if (levelOrder[level] < minValue) return;

    const prefix = `[${scope}] ${message}`;
    if (meta !== undefined) {
      const payload = meta instanceof Error
        ? { message: meta.message, stack: meta.stack }
        : meta;
      // eslint-disable-next-line no-console
      console[level](prefix, payload);
    } else {
      // eslint-disable-next-line no-console
      console[level](prefix);
    }
  };

  return {
    debug: (msg: string, meta?: unknown) => log('debug', msg, meta),
    info: (msg: string, meta?: unknown) => log('info', msg, meta),
    warn: (msg: string, meta?: unknown) => log('warn', msg, meta),
    error: (msg: string, meta?: unknown) => log('error', msg, meta)
  };
}
===END_FILE===
===FILE: supabase/functions/api/shared/types.ts===
import z from "zod";

export interface Organization {
  id: number;
  name: string;
  type: 'company' | 'consultancy' | 'client';
  description?: string;
  logo_url?: string;
  contact_email?: string;
  contact_phone?: string;
  address?: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  parent_organization_id?: number;
  organization_level?: string;
  subscription_status?: string;
  subscription_plan?: string;
  max_users?: number;
  max_subsidiaries?: number;
  cnpj?: string;
  razao_social?: string;
  nome_fantasia?: string;
  website?: string;
  faturamento_anual?: number;
  cnae_principal?: string;
  cnae_descricao?: string;
  natureza_juridica?: string;
  data_abertura?: string;
  capital_social?: number;
  porte_empresa?: string;
  situacao_cadastral?: string;
  numero_funcionarios?: number;
  setor_industria?: string;
  subsetor_industria?: string;
  certificacoes_seguranca?: string;
  data_ultima_auditoria?: string;
  nivel_risco?: string;
  contato_seguranca_nome?: string;
  contato_seguranca_email?: string;
  contato_seguranca_telefone?: string;
  historico_incidentes?: string;
  observacoes_compliance?: string;
}

export const InspectionSchema = z.object({
  id: z.number().optional(),
  title: z.string().min(1, "TÃ­tulo Ã© obrigatÃ³rio"),
  description: z.string().optional(),
  location: z.string().min(1, "Local Ã© obrigatÃ³rio"),
  company_name: z.string().min(1, "Nome da empresa Ã© obrigatÃ³rio"),
  cep: z.string().optional(),
  address: z.string().optional(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  inspector_name: z.string().min(1, "Nome do inspetor Ã© obrigatÃ³rio"),
  inspector_email: z.string().email("Email invÃ¡lido").optional(),
  responsible_name: z.string().optional(),
  responsible_email: z.string().email("Email invÃ¡lido").optional(),
  status: z.enum(['pendente', 'em_andamento', 'concluida', 'cancelada']).default('pendente'),
  priority: z.enum(['baixa', 'media', 'alta', 'critica']).default('media'),
  scheduled_date: z.string().optional(),
  completed_date: z.string().optional(),
  action_plan: z.string().optional(),
  action_plan_type: z.enum(['5w2h', 'simple']).default('5w2h'),
  created_at: z.string(),
  updated_at: z.string(),
});

export type InspectionType = z.infer<typeof InspectionSchema>;

export const InspectionItemSchema = z.object({
  id: z.number().optional(),
  inspection_id: z.number(),
  category: z.string().min(1, "Categoria Ã© obrigatÃ³ria"),
  item_description: z.string().min(1, "DescriÃ§Ã£o Ã© obrigatÃ³ria"),
  is_compliant: z.boolean().optional(),
  observations: z.string().optional(),
  photo_url: z.string().optional(),
  compliance_status: z.string().optional(), // 'compliant' | 'non_compliant' | 'not_applicable' | 'unanswered'
});

export type InspectionItemType = z.infer<typeof InspectionItemSchema>;

export const InspectionReportSchema = z.object({
  id: z.number().optional(),
  inspection_id: z.number(),
  summary: z.string().optional(),
  recommendations: z.string().optional(),
  risk_level: z.enum(['baixo', 'medio', 'alto', 'critico']).optional(),
  report_url: z.string().optional(),
});

export type InspectionReportType = z.infer<typeof InspectionReportSchema>;

export const InspectionMediaSchema = z.object({
  id: z.number().optional(),
  inspection_id: z.number(),
  inspection_item_id: z.number().optional(),
  media_type: z.enum(['image', 'video', 'audio', 'document']),
  file_name: z.string().min(1, "Nome do arquivo Ã© obrigatÃ³rio"),
  file_url: z.string().min(1, "URL do arquivo Ã© obrigatÃ³ria"),
  file_size: z.number().optional(),
  mime_type: z.string().optional(),
  description: z.string().optional(),
});

export type InspectionMediaType = z.infer<typeof InspectionMediaSchema>;

export const AIAnalysisRequestSchema = z.object({
  inspection_id: z.number(),
  media_urls: z.array(z.string()),
  inspection_context: z.string(),
  non_compliant_items: z.array(z.string()),
});

export type AIAnalysisRequest = z.infer<typeof AIAnalysisRequestSchema>;
===END_FILE===
===FILE: supabase/functions/api/shared/user-types.ts===
// Interface base definida localmente para remover dependÃªncia externa @getmocha/users-service
export interface MochaUser {
  id: string;
  email: string;
  [key: string]: any;
}

export interface UserProfile {
  id: string;
  email: string;
  name: string;
  role: string; // 'system_admin', 'org_admin', 'manager', 'inspector', 'client'
  organization_id?: number;
  phone?: string;
  avatar_url?: string;
  is_active: boolean;
  last_login_at?: string;
  created_at: string;
  updated_at: string;
  // New fields for multi-tenant support
  can_manage_users: boolean;
  can_create_organizations: boolean;
  managed_organization_id?: number;
  invitation_token?: string;
  invited_by?: string;
  invitation_expires_at?: string;
  // Email/password authentication fields
  password_hash?: string;
  email_verified_at?: string;
  profile_completed: boolean;
}

export interface Organization {
  id: number;
  name: string;
  type: string; // 'master', 'company', 'consultancy', 'client'
  description?: string;
  logo_url?: string;
  contact_email?: string;
  contact_phone?: string;
  address?: string;
  website?: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  // New fields for hierarchy
  parent_organization_id?: number;
  organization_level: string; // 'master', 'company', 'subsidiary'
  subscription_status: string; // 'active', 'suspended', 'trial'
  subscription_plan: string; // 'basic', 'pro', 'enterprise'
  max_users: number;
  max_subsidiaries: number;
  // Runtime fields
  user_count?: number;
  subsidiary_count?: number;
  parent_organization?: Organization;
  subsidiaries?: Organization[];
  parent_organization_name?: string;
}

export interface UserInvitation {
  id: number;
  email: string;
  organization_id: number;
  role: string;
  invited_by: string;
  invitation_token: string;
  expires_at: string;
  accepted_at?: string;
  created_at: string;
  updated_at: string;
  // Runtime fields
  organization_name?: string;
  inviter_name?: string;
}

export interface OrganizationPermission {
  id: number;
  user_id: string;
  organization_id: number;
  permission_type: string; // 'view', 'edit', 'admin', 'owner'
  granted_by: string;
  granted_at: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface ActivityLogEntry {
  id: number;
  user_id: string;
  organization_id?: number;
  action_type: string;
  action_description: string;
  target_type?: string;
  target_id?: string;
  metadata?: string;
  ip_address?: string;
  user_agent?: string;
  created_at: string;
}

export interface ExtendedMochaUser extends MochaUser {
  profile?: UserProfile;
  organizations?: Organization[];
  managed_organization?: Organization;
  permissions?: OrganizationPermission[];
}

// Role definitions for the multi-tenant system
export const USER_ROLES = {
  SYSTEM_ADMIN: 'system_admin', // You - the creator/master admin
  SYS_ADMIN: 'sys_admin',       // Alternative system admin role
  ORG_ADMIN: 'org_admin',       // Company admin who bought the system
  MANAGER: 'manager',           // Organization manager
  INSPECTOR: 'inspector',       // Technical inspector/safety professional  
  CLIENT: 'client'              // Client/viewer role
} as const;

export type UserRole = typeof USER_ROLES[keyof typeof USER_ROLES];

export const ORGANIZATION_LEVELS = {
  MASTER: 'master',       // Your master organization
  COMPANY: 'company',     // Companies that buy the system
  SUBSIDIARY: 'subsidiary' // Sub-organizations within companies
} as const;

export const SUBSCRIPTION_STATUS = {
  ACTIVE: 'active',
  SUSPENDED: 'suspended',
  TRIAL: 'trial',
  EXPIRED: 'expired'
} as const;

export const SUBSCRIPTION_PLANS = {
  BASIC: 'basic',
  PRO: 'pro',
  ENTERPRISE: 'enterprise'
} as const;
===END_FILE===
