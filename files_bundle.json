[{"name":"action-plans-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\nimport { addXP } from \"./gamification-routes.ts\";\r\n\r\nconst actionPlansRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Get all action items across all inspections with optional organization filter\r\nactionPlansRoutes.get(\"/all\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const organizationId = c.req.query(\"organization_id\");\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    let query = `\r\n      SELECT ai.*, \r\n\r\n             i.title as inspection_title,\r\n             i.location as inspection_location,\r\n             i.company_name as inspection_company,\r\n             i.created_by as inspection_created_by,\r\n             coalesce(i.organization_id, ai.organization_id) as final_organization_id,\r\n             u.name as created_by_name,\r\n             u_assigned.name as assigned_to_name,\r\n             o.name as organization_name\r\n      FROM action_items ai\r\n      LEFT JOIN inspections i ON ai.inspection_id = i.id\r\n      LEFT JOIN users u ON ai.created_by = u.id\r\n      LEFT JOIN users u_assigned ON ai.assigned_to = u_assigned.id\r\n      LEFT JOIN organizations o ON coalesce(i.organization_id, ai.organization_id) = o.id\r\n    `;\r\n\r\n    const params: any[] = [];\r\n    const whereConditions: string[] = [];\r\n\r\n    // Type filter\r\n    const type = c.req.query(\"type\");\r\n    if (type && type !== 'all') {\r\n      whereConditions.push(\"ai.type = ?\");\r\n      params.push(type);\r\n    }\r\n\r\n    // Organization filter logic (using COALESCE to fallback to direct org_id)\r\n    if (organizationId && organizationId !== 'all') {\r\n      whereConditions.push(\"coalesce(i.organization_id, ai.organization_id) = ?\");\r\n      params.push(parseInt(organizationId));\r\n    }\r\n\r\n    // Role-based access control\r\n    if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {\r\n      // System admin sees all\r\n    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN) {\r\n      if (userProfile.managed_organization_id) {\r\n        whereConditions.push(`(\r\n          coalesce(i.organization_id, ai.organization_id) = ? OR \r\n          coalesce(i.organization_id, ai.organization_id) IN (\r\n            SELECT id FROM organizations WHERE parent_organization_id = ?\r\n          )\r\n        )`);\r\n        params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n      }\r\n    } else {\r\n      // Regular users: Created by me OR Assigned to me OR Org visible\r\n      whereConditions.push(`(ai.created_by = ? OR ai.assigned_to = ? OR coalesce(i.organization_id, ai.organization_id) = ?)`);\r\n      params.push(user.id, user.id, userProfile?.organization_id);\r\n    }\r\n\r\n    if (whereConditions.length > 0) {\r\n      query += \" WHERE \" + whereConditions.join(\" AND \");\r\n    }\r\n\r\n    query += \" ORDER BY ai.created_at DESC\";\r\n\r\n    console.log('[ACTION_PLANS] Executing query:', query);\r\n    console.log('[ACTION_PLANS] Params:', params);\r\n\r\n    const actionItems = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    return c.json({\r\n      action_items: actionItems.results || [],\r\n      total: (actionItems.results || []).length\r\n    });\r\n\r\n  } catch (error: any) {\r\n    console.error('Error fetching all action items:', error);\r\n    return c.json({\r\n      error: \"Failed to fetch action items\",\r\n      details: error.message,\r\n      stack: error.stack\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Get action items by inspection ID\r\nactionPlansRoutes.get(\"/inspection/:inspectionId\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"inspectionId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Verify access to inspection\r\n    const inspection = await env.DB.prepare(`\r\n      SELECT i.*, u.name as created_by_name\r\n      FROM inspections i\r\n      LEFT JOIN users u ON i.created_by = u.id\r\n      WHERE i.id = ?\r\n    `).bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspection not found\" }, 404);\r\n    }\r\n\r\n    // Check access permissions\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    const hasAccess = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||\r\n      userProfile?.role === 'sys_admin' ||\r\n      inspection.created_by === user.id ||\r\n      inspection.organization_id === userProfile?.organization_id ||\r\n      (userProfile?.role === USER_ROLES.ORG_ADMIN &&\r\n        (inspection.organization_id === userProfile.managed_organization_id ||\r\n          await env.DB.prepare(`\r\n                         SELECT 1 FROM organizations \r\n                         WHERE id = ? AND parent_organization_id = ?\r\n                       `).bind(inspection.organization_id, userProfile.managed_organization_id).first()));\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: \"Access denied\" }, 403);\r\n    }\r\n\r\n    // Get action items for this inspection\r\n    const actionItems = await env.DB.prepare(`\r\n      SELECT ai.*, ii.category as item_category, ii.item_description\r\n      FROM action_items ai\r\n      LEFT JOIN inspection_items ii ON ai.inspection_item_id = ii.id\r\n      WHERE ai.inspection_id = ?\r\n      ORDER BY ai.created_at DESC\r\n    `).bind(inspectionId).all();\r\n\r\n    return c.json({\r\n      inspection,\r\n      action_items: actionItems.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching inspection action items:', error);\r\n    return c.json({ error: \"Failed to fetch action items\" }, 500);\r\n  }\r\n});\r\n\r\n// Helper to create Google Calendar Event\r\nasync function createGoogleCalendarEvent(token: string, title: string, description: string, date: string): Promise<string | null> {\r\n  try {\r\n    const response = await fetch('https://www.googleapis.com/calendar/v3/calendars/primary/events', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify({\r\n        summary: title,\r\n        description: description || 'Tarefa criada via Compia',\r\n        start: { date: date }, // All-day event\r\n        end: { date: date }\r\n      })\r\n    });\r\n\r\n    if (!response.ok) {\r\n      console.error('Failed to create Google Calendar event:', await response.text());\r\n      return null;\r\n    }\r\n\r\n    const data = await response.json();\r\n    return data.id;\r\n  } catch (e) {\r\n    console.error('Error creating Google Calendar event:', e);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Create new action item\r\nactionPlansRoutes.post(\"/\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const {\r\n      title,\r\n      type = 'manual_task',\r\n      description,\r\n      priority = 'media',\r\n      status = 'pending',\r\n      when_deadline,\r\n      assignee_id,\r\n      google_token // Token passed from frontend\r\n    } = body;\r\n\r\n    if (!title) {\r\n      return c.json({ error: \"Title is required\" }, 400);\r\n    }\r\n\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    let organizationId = userProfile?.organization_id;\r\n    if (userProfile?.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {\r\n      organizationId = userProfile.managed_organization_id;\r\n    }\r\n\r\n    // Google Calendar Sync\r\n    let google_event_id: string | null = null;\r\n    if (google_token && when_deadline) {\r\n      // Format date/time if needed. Assuming when_deadline is YYYY-MM-DD.\r\n      // If type is inspection_order, maybe prefix title?\r\n      const eventTitle = type === 'inspection_order' ? `[Inspeção] ${title}` : title;\r\n      google_event_id = await createGoogleCalendarEvent(google_token, eventTitle, description || '', when_deadline);\r\n    }\r\n\r\n    const result = await env.DB.prepare(`\r\n        INSERT INTO action_items (\r\n            title, \r\n            type, \r\n            description, \r\n            priority, \r\n            status, \r\n            when_deadline, \r\n            created_by, \r\n            organization_id, \r\n            assigned_to,\r\n            source,\r\n            google_event_id,\r\n            created_at,\r\n            updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'user', ?, NOW(), NOW()) \r\n        RETURNING *\r\n    `).bind(\r\n      title,\r\n      type,\r\n      description || null,\r\n      priority,\r\n      status,\r\n      when_deadline || null,\r\n      user.id,\r\n      organizationId,\r\n      assignee_id || null,\r\n      google_event_id\r\n    ).first();\r\n\r\n    return c.json({ success: true, action_item: result }, 201);\r\n\r\n  } catch (error) {\r\n    console.error('Error creating action item:', error);\r\n    return c.json({ error: \"Failed to create action item\" }, 500);\r\n  }\r\n});\r\n\r\n// Update action item status\r\nactionPlansRoutes.put(\"/:id/status\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const actionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { status } = body;\r\n\r\n    if (!['pending', 'in_progress', 'completed'].includes(status)) {\r\n      return c.json({ error: \"Invalid status\" }, 400);\r\n    }\r\n\r\n    // Get action item for permission check\r\n    const actionItem = await env.DB.prepare(`\r\n      SELECT ai.*, i.created_by as inspection_created_by, coalesce(i.organization_id, ai.organization_id) as final_organization_id\r\n      FROM action_items ai\r\n      LEFT JOIN inspections i ON ai.inspection_id = i.id\r\n      WHERE ai.id = ?\r\n    `).bind(actionId).first() as any;\r\n\r\n    if (!actionItem) {\r\n      return c.json({ error: \"Action item not found\" }, 404);\r\n    }\r\n\r\n    // Check permissions\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    const hasAccess = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||\r\n      userProfile?.role === 'sys_admin' ||\r\n      actionItem.created_by === user.id ||\r\n      actionItem.inspection_created_by === user.id ||\r\n      actionItem.assigned_to === user.id ||\r\n      actionItem.final_organization_id === userProfile?.organization_id ||\r\n      (userProfile?.role === USER_ROLES.ORG_ADMIN &&\r\n        (actionItem.final_organization_id === userProfile.managed_organization_id ||\r\n          await env.DB.prepare(`\r\n                         SELECT 1 FROM organizations \r\n                         WHERE id = ? AND parent_organization_id = ?\r\n                       `).bind(actionItem.final_organization_id, userProfile.managed_organization_id).first()));\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: \"Access denied\" }, 403);\r\n    }\r\n\r\n    // Update status\r\n    await env.DB.prepare(`\r\n      UPDATE action_items \r\n      SET status = ?, updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(status, actionId).run();\r\n\r\n    // Gamification: Award XP if completed\r\n    if (status === 'completed') {\r\n      try {\r\n        // Basic logic: 20 XP for completion.\r\n        // Future: Check deadlin for bonus.\r\n        await addXP(user.id, 20, env.DB);\r\n      } catch (xpError) {\r\n        console.error(\"Error awarding XP:\", xpError);\r\n      }\r\n    }\r\n\r\n    return c.json({ message: \"Status updated successfully\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating action item status:', error);\r\n    return c.json({ error: \"Failed to update status\" }, 500);\r\n  }\r\n});\r\n\r\n// Get action items statistics\r\nactionPlansRoutes.get(\"/stats\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const organizationId = c.req.query(\"organization_id\");\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    let query = `\r\n      SELECT \r\n        COUNT(*) as total,\r\n        SUM(CASE WHEN ai.status = 'pending' THEN 1 ELSE 0 END) as pending,\r\n        SUM(CASE WHEN ai.status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,\r\n        SUM(CASE WHEN ai.status = 'completed' THEN 1 ELSE 0 END) as completed,\r\n        SUM(CASE WHEN ai.priority = 'alta' AND ai.status != 'completed' THEN 1 ELSE 0 END) as high_priority,\r\n        SUM(CASE WHEN ai.when_deadline < date('now') AND ai.status != 'completed' THEN 1 ELSE 0 END) as overdue\r\n      FROM action_items ai\r\n      LEFT JOIN inspections i ON ai.inspection_id = i.id\r\n    `;\r\n\r\n    const params: any[] = [];\r\n    const whereConditions: string[] = [];\r\n\r\n    // Organization filter\r\n    if (organizationId && organizationId !== 'all') {\r\n      whereConditions.push(\"coalesce(i.organization_id, ai.organization_id) = ?\");\r\n      params.push(parseInt(organizationId));\r\n    }\r\n\r\n    // Role-based access control\r\n    if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {\r\n      // System admin sees all stats\r\n    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN) {\r\n      if (userProfile.managed_organization_id) {\r\n        whereConditions.push(`(\r\n          coalesce(i.organization_id, ai.organization_id) = ? OR \r\n          coalesce(i.organization_id, ai.organization_id) IN (\r\n            SELECT id FROM organizations WHERE parent_organization_id = ?\r\n          )\r\n        )`);\r\n        params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n      }\r\n    } else {\r\n      whereConditions.push(`(ai.created_by = ? OR ai.assigned_to = ? OR coalesce(i.organization_id, ai.organization_id) = ?)`);\r\n      params.push(user.id, user.id, userProfile?.organization_id);\r\n    }\r\n\r\n    if (whereConditions.length > 0) {\r\n      query += \" WHERE \" + whereConditions.join(\" AND \");\r\n    }\r\n\r\n    const stats = await env.DB.prepare(query).bind(...params).first() as any;\r\n\r\n    return c.json({\r\n      stats: {\r\n        total: stats?.total || 0,\r\n        pending: stats?.pending || 0,\r\n        in_progress: stats?.in_progress || 0,\r\n        completed: stats?.completed || 0,\r\n        high_priority: stats?.high_priority || 0,\r\n        overdue: stats?.overdue || 0\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching action items stats:', error);\r\n    return c.json({ error: \"Failed to fetch stats\" }, 500);\r\n  }\r\n});\r\n\r\n// Delete action item\r\nactionPlansRoutes.delete(\"/:id\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const actionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get action item with inspection details for permission check\r\n    const actionItem = await env.DB.prepare(`\r\n      SELECT ai.*, i.created_by as inspection_created_by, coalesce(i.organization_id, ai.organization_id) as final_organization_id\r\n      FROM action_items ai\r\n      LEFT JOIN inspections i ON ai.inspection_id = i.id\r\n      WHERE ai.id = ?\r\n    `).bind(actionId).first() as any;\r\n\r\n    if (!actionItem) {\r\n      return c.json({ error: \"Action item not found\" }, 404);\r\n    }\r\n\r\n    // Check permissions\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    const hasAccess = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||\r\n      userProfile?.role === 'sys_admin' ||\r\n      actionItem.created_by === user.id ||\r\n      actionItem.inspection_created_by === user.id ||\r\n      actionItem.final_organization_id === userProfile?.organization_id ||\r\n      (userProfile?.role === USER_ROLES.ORG_ADMIN &&\r\n        (actionItem.final_organization_id === userProfile.managed_organization_id ||\r\n          await env.DB.prepare(`\r\n                         SELECT 1 FROM organizations \r\n                         WHERE id = ? AND parent_organization_id = ?\r\n                       `).bind(actionItem.final_organization_id, userProfile.managed_organization_id).first()));\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: \"Access denied\" }, 403);\r\n    }\r\n\r\n    // Delete action item\r\n    await env.DB.prepare(\"DELETE FROM action_items WHERE id = ?\").bind(actionId).run();\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: \"Action item deleted successfully\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error deleting action item:', error);\r\n    return c.json({ error: \"Failed to delete action item\" }, 500);\r\n  }\r\n});\r\n\r\nexport default actionPlansRoutes;\r\n\r\n"},{"name":"admin-approval-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware as authMiddleware } from './tenant-auth-middleware.ts';\r\nimport { logActivity } from './audit-logger.ts';\r\n\r\n/**\r\n * Rotas de administração para Aprovação de Usuários\r\n * @security System Admin tem acesso total\r\n * @security Org Admin pode aprovar usuários da sua organização\r\n */\r\nconst adminApprovalRoutes = new Hono<{ Bindings: Env; Variables: { user: any; tenantContext: any } }>();\r\n\r\n/**\r\n * Helper: Verificar se usuário é SysAdmin\r\n */\r\nfunction isSysAdmin(role: string): boolean {\r\n    const sysAdminRoles = ['system_admin', 'sys_admin', 'admin'];\r\n    return sysAdminRoles.includes(role?.toLowerCase() || '');\r\n}\r\n\r\n/**\r\n * Helper: Verificar se usuário é OrgAdmin\r\n */\r\nfunction isOrgAdmin(role: string): boolean {\r\n    const orgAdminRoles = ['org_admin', 'admin_org', 'organization_admin'];\r\n    return orgAdminRoles.includes(role?.toLowerCase() || '');\r\n}\r\n\r\n/**\r\n * Helper: Verificar se usuário pode aprovar (SysAdmin OU OrgAdmin)\r\n */\r\nfunction canApproveUsers(role: string): boolean {\r\n    return isSysAdmin(role) || isOrgAdmin(role);\r\n}\r\n\r\n/**\r\n * Listar usuários pendentes\r\n * GET /api/admin/pending-users\r\n */\r\nadminApprovalRoutes.get(\"/pending-users\", async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n\r\n    console.log(\"[ADMIN-APPROVAL] GET /pending-users - User:\", user?.email, \"Role:\", user?.role);\r\n\r\n    // Verificar autenticação\r\n    if (!user) {\r\n        console.log(\"[ADMIN-APPROVAL] No user found in context\");\r\n        return c.json({ error: \"unauthorized\", message: \"Autenticação necessária\" }, 401);\r\n    }\r\n\r\n    // Verificar se pode aprovar (SysAdmin OU OrgAdmin)\r\n    if (!canApproveUsers(user.role)) {\r\n        console.log(\"[ADMIN-APPROVAL] User cannot approve:\", user.role);\r\n        return c.json({ error: \"forbidden\", message: \"Apenas administradores podem acessar\" }, 403);\r\n    }\r\n\r\n    try {\r\n        const pendingUsers = await env.DB.prepare(`\r\n      SELECT id, email, name, role, organization_id, created_at \r\n      FROM users \r\n      WHERE approval_status = 'pending'\r\n      ORDER BY created_at DESC\r\n    `).all();\r\n\r\n        return c.json({\r\n            success: true,\r\n            data: pendingUsers.results || []\r\n        });\r\n    } catch (error) {\r\n        console.error('[ADMIN-APPROVAL] Erro ao listar pendentes:', error);\r\n        return c.json({ error: \"Erro ao buscar usuários pendentes\" }, 500);\r\n    }\r\n});\r\n\r\n/**\r\n * Aprovar usuário\r\n * POST /api/admin/users/:id/approve\r\n */\r\nadminApprovalRoutes.post(\"/users/:id/approve\", async (c) => {\r\n    const env = c.env;\r\n    const targetUserId = c.req.param(\"id\");\r\n    const user = c.get(\"user\");\r\n\r\n    console.log(\"[ADMIN-APPROVAL] POST /users/:id/approve\");\r\n    console.log(\"[ADMIN-APPROVAL] Target User ID:\", targetUserId);\r\n    console.log(\"[ADMIN-APPROVAL] Current User:\", JSON.stringify(user));\r\n\r\n    // Verificar autenticação\r\n    if (!user) {\r\n        console.log(\"[ADMIN-APPROVAL] FALHA: Nenhum usuário no contexto\");\r\n        return c.json({ error: \"unauthorized\", message: \"Autenticação necessária\" }, 401);\r\n    }\r\n\r\n    // SysAdmin e OrgAdmin podem aprovar\r\n    if (!canApproveUsers(user.role)) {\r\n        console.log(\"[ADMIN-APPROVAL] FALHA: Usuário não pode aprovar. Role:\", user.role);\r\n        return c.json({ error: \"forbidden\", message: \"Apenas administradores podem aprovar\" }, 403);\r\n    }\r\n\r\n    console.log(\"[ADMIN-APPROVAL] SUCESSO: Usuário autorizado\");\r\n\r\n    try {\r\n        const result = await env.DB.prepare(`\r\n      UPDATE users \r\n      SET \r\n        approval_status = 'approved',\r\n        approved_by = ?,\r\n        approved_at = NOW(),\r\n        updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(user.id, targetUserId).run();\r\n\r\n        if (result.meta.changes === 0) {\r\n            return c.json({ error: \"Usuário não encontrado\" }, 404);\r\n        }\r\n\r\n        // NOTIFICAÇÃO: Avisar usuário que foi aprovado\r\n        try {\r\n            await env.DB.prepare(`\r\n                INSERT INTO notifications (user_id, title, message, type, link) \r\n                VALUES (?, 'Conta Aprovada!', 'Seu cadastro foi aprovado. Bem-vindo ao sistema!', 'success', '/dashboard')\r\n            `).bind(targetUserId).run();\r\n        } catch (notifError) {\r\n            console.error(\"Falha ao notificar usuário aprovado:\", notifError);\r\n        }\r\n\r\n        // TRIGGER EMAIL: Send approval email\r\n        try {\r\n            // First fetch the approved user's details to get email/name\r\n            const targetUser = await env.DB.prepare(\"SELECT email, name FROM users WHERE id = ?\").bind(targetUserId).first();\r\n\r\n            const supabaseUrl = Deno.env.get('SUPABASE_URL');\r\n            const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY');\r\n\r\n            if (targetUser && supabaseUrl && supabaseAnonKey) {\r\n                fetch(`${supabaseUrl}/functions/v1/send-email`, {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                        'Authorization': `Bearer ${supabaseAnonKey}`\r\n                    },\r\n                    body: JSON.stringify({\r\n                        type: 'account_approved',\r\n                        payload: {\r\n                            email: targetUser.email,\r\n                            name: targetUser.name\r\n                        }\r\n                    })\r\n                }).catch(err => console.error(\"Failed to trigger approved email:\", err));\r\n            }\r\n\r\n            // Log de Auditoria\r\n            await logActivity(env, {\r\n                userId: user.id,\r\n                orgId: user.organization_id || null, // Quem aprovou\r\n                actionType: 'USER_APPROVED',\r\n                actionDescription: `Aprovou o usuário ${targetUser?.name || 'ID ' + targetUserId} (${targetUser?.email})`,\r\n                targetType: 'USER',\r\n                targetId: targetUserId,\r\n                metadata: {\r\n                    approved_user_email: targetUser?.email,\r\n                    approved_user_name: targetUser?.name\r\n                },\r\n                req: c.req\r\n            });\r\n\r\n        } catch (emailErr) {\r\n            console.error(\"Error triggering approved email:\", emailErr);\r\n        }\r\n\r\n        console.log(\"[ADMIN-APPROVAL] Usuário aprovado com sucesso:\", targetUserId);\r\n\r\n        return c.json({\r\n            success: true,\r\n            message: \"Usuário aprovado com sucesso\"\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('[ADMIN-APPROVAL] Erro ao aprovar usuário:', error);\r\n        return c.json({ error: \"Erro ao realizar aprovação\" }, 500);\r\n    }\r\n});\r\n\r\n/**\r\n * Rejeitar usuário\r\n * POST /api/admin/users/:id/reject\r\n */\r\nadminApprovalRoutes.post(\"/users/:id/reject\", async (c) => {\r\n    const env = c.env;\r\n    const targetUserId = c.req.param(\"id\");\r\n    const user = c.get(\"user\");\r\n    const body = await c.req.json().catch(() => ({}));\r\n    const reason = body.reason || null;\r\n\r\n    console.log(\"[ADMIN-APPROVAL] POST /users/:id/reject\");\r\n    console.log(\"[ADMIN-APPROVAL] Target User ID:\", targetUserId);\r\n    console.log(\"[ADMIN-APPROVAL] Current User:\", JSON.stringify(user));\r\n\r\n    // Verificar autenticação\r\n    if (!user) {\r\n        return c.json({ error: \"unauthorized\", message: \"Autenticação necessária\" }, 401);\r\n    }\r\n\r\n    // SysAdmin e OrgAdmin podem rejeitar\r\n    if (!canApproveUsers(user.role)) {\r\n        return c.json({ error: \"forbidden\", message: \"Apenas administradores podem rejeitar\" }, 403);\r\n    }\r\n\r\n    try {\r\n        const result = await env.DB.prepare(`\r\n      UPDATE users \r\n      SET \r\n        approval_status = 'rejected',\r\n        approved_by = ?, \r\n        rejection_reason = ?,\r\n        updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(user.id, reason, targetUserId).run();\r\n\r\n        if (result.meta.changes === 0) {\r\n            return c.json({ error: \"Usuário não encontrado\" }, 404);\r\n        }\r\n\r\n        return c.json({\r\n            success: true,\r\n            message: \"Usuário rejeitado com sucesso\"\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('[ADMIN-APPROVAL] Erro ao rejeitar usuário:', error);\r\n        return c.json({ error: \"Erro ao rejeitar usuário\" }, 500);\r\n    }\r\n});\r\n\r\nexport default adminApprovalRoutes;\r\n"},{"name":"admin-debug-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware as authMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n};\r\n\r\nconst adminDebugRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Admin bypass endpoint para verificar dados de produção (SYSTEM_ADMIN only)\r\nadminDebugRoutes.get(\"/debug/data-check\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get user profile - MUST be SYSTEM_ADMIN\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile || userProfile.role !== USER_ROLES.SYSTEM_ADMIN) {\r\n      return c.json({ error: \"Only SYSTEM_ADMIN can access debug data\" }, 403);\r\n    }\r\n\r\n    console.log(`[DEBUG-DATA] SYSTEM_ADMIN ${user.email} fazendo verificação de dados`);\r\n\r\n    // Verificar todos os dados sem filtros\r\n    const [\r\n      totalInspections,\r\n      totalUsers,\r\n      totalOrganizations,\r\n      totalTemplates,\r\n      recentInspections,\r\n      userDetails,\r\n      organizationDetails\r\n    ] = await Promise.all([\r\n      env.DB.prepare(\"SELECT COUNT(*) as count FROM inspections\").first(),\r\n      env.DB.prepare(\"SELECT COUNT(*) as count FROM users\").first(),\r\n      env.DB.prepare(\"SELECT COUNT(*) as count FROM organizations\").first(),\r\n      env.DB.prepare(\"SELECT COUNT(*) as count FROM checklist_templates\").first(),\r\n      env.DB.prepare(\"SELECT id, title, status, created_by, organization_id, created_at FROM inspections ORDER BY created_at DESC LIMIT 3\").all(),\r\n      env.DB.prepare(\"SELECT id, email, role, organization_id, is_active FROM users ORDER BY created_at DESC LIMIT 3\").all(),\r\n      env.DB.prepare(\"SELECT id, name, type, is_active FROM organizations ORDER BY created_at DESC LIMIT 3\").all()\r\n    ]);\r\n\r\n    const debugData = {\r\n      timestamp: new Date().toISOString(),\r\n      checked_by: user.email,\r\n      environment: \"development\",\r\n      database_counts: {\r\n        inspections: (totalInspections as any)?.count || 0,\r\n        users: (totalUsers as any)?.count || 0,\r\n        organizations: (totalOrganizations as any)?.count || 0,\r\n        checklist_templates: (totalTemplates as any)?.count || 0\r\n      },\r\n      sample_data: {\r\n        recent_inspections: recentInspections.results || [],\r\n        users: userDetails.results || [],\r\n        organizations: organizationDetails.results || []\r\n      },\r\n      sync_status: {\r\n        has_production_data: (totalInspections as any)?.count > 0,\r\n        has_users: (totalUsers as any)?.count > 0,\r\n        has_organizations: (totalOrganizations as any)?.count > 0,\r\n        has_templates: (totalTemplates as any)?.count > 0\r\n      }\r\n    };\r\n\r\n    console.log(`[DEBUG-DATA] Dados encontrados:`, debugData.database_counts);\r\n\r\n    return c.json(debugData);\r\n\r\n  } catch (error) {\r\n    console.error('[DEBUG-DATA] Erro na verificação de dados:', error);\r\n    return c.json({ error: \"Failed to check debug data\" }, 500);\r\n  }\r\n});\r\n\r\n// Endpoint para forçar resincronização (SYSTEM_ADMIN only)\r\nadminDebugRoutes.post(\"/debug/force-resync\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile || userProfile.role !== USER_ROLES.SYSTEM_ADMIN) {\r\n      return c.json({ error: \"Only SYSTEM_ADMIN can force resync\" }, 403);\r\n    }\r\n\r\n    console.log(`[FORCE-RESYNC] SYSTEM_ADMIN ${user.email} forçando resincronização`);\r\n\r\n    // Verificar se o usuário atual tem permissões corretas\r\n    if (userProfile.role !== USER_ROLES.SYSTEM_ADMIN) {\r\n      // Forçar upgrade para SYSTEM_ADMIN se for o usuário criador do sistema\r\n      if (user.email === 'eng.tiagosm@gmail.com') {\r\n        await env.DB.prepare(`\r\n          UPDATE users \r\n          SET role = ?, can_manage_users = ?, can_create_organizations = ?, updated_at = NOW()\r\n          WHERE id = ?\r\n        `).bind(USER_ROLES.SYSTEM_ADMIN, 1, 1, user.id).run();\r\n\r\n        console.log(`[FORCE-RESYNC] Usuário ${user.email} promovido para SYSTEM_ADMIN`);\r\n      }\r\n    }\r\n\r\n    // Verificar integridade dos dados\r\n    const dataCheck = await env.DB.prepare(`\r\n      SELECT \r\n        (SELECT COUNT(*) FROM inspections) as inspections_count,\r\n        (SELECT COUNT(*) FROM users WHERE role = 'system_admin') as admin_count,\r\n        (SELECT COUNT(*) FROM organizations) as org_count\r\n    `).first() as any;\r\n\r\n    const resyncStatus = {\r\n      timestamp: new Date().toISOString(),\r\n      performed_by: user.email,\r\n      before_resync: dataCheck,\r\n      actions_taken: [\r\n        \"Verificação de permissões do usuário\",\r\n        \"Validação de integridade dos dados\",\r\n        \"Confirmação de sincronização ativa\"\r\n      ],\r\n      sync_confirmed: true\r\n    };\r\n\r\n    console.log(`[FORCE-RESYNC] Status da resincronização:`, resyncStatus);\r\n\r\n    return c.json({\r\n      message: \"Resincronização forçada concluída com sucesso\",\r\n      status: resyncStatus\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('[FORCE-RESYNC] Erro na resincronização forçada:', error);\r\n    return c.json({ error: \"Failed to force resync\" }, 500);\r\n  }\r\n});\r\n\r\n// Import all data endpoint (SYSTEM_ADMIN only)\r\nadminDebugRoutes.post(\"/import-all-data\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get user profile - MUST be SYSTEM_ADMIN\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile || userProfile.role !== USER_ROLES.SYSTEM_ADMIN) {\r\n      return c.json({ error: \"Only SYSTEM_ADMIN can import data\" }, 403);\r\n    }\r\n\r\n    const importData = await c.req.json();\r\n\r\n    if (!importData.data || !importData.total_counts) {\r\n      return c.json({ error: \"Invalid import data format\" }, 400);\r\n    }\r\n\r\n    console.log(`[IMPORT-ALL] SYSTEM_ADMIN ${user.email} importing production data`);\r\n    console.log(`[IMPORT-ALL] Counts to import:`, importData.total_counts);\r\n\r\n    // Clear existing development data (except current user)\r\n    console.log(`[IMPORT-ALL] Clearing existing development data...`);\r\n    await env.DB.batch([\r\n      env.DB.prepare(\"DELETE FROM inspection_media\"),\r\n      env.DB.prepare(\"DELETE FROM action_items\"),\r\n      env.DB.prepare(\"DELETE FROM inspection_items\"),\r\n      env.DB.prepare(\"DELETE FROM inspections\"),\r\n      env.DB.prepare(\"DELETE FROM checklist_fields\"),\r\n      env.DB.prepare(\"DELETE FROM checklist_templates WHERE created_by_user_id != ?\").bind(user.id),\r\n      env.DB.prepare(\"DELETE FROM organizations WHERE id != (SELECT organization_id FROM users WHERE id = ?)\").bind(user.id),\r\n      env.DB.prepare(\"DELETE FROM users WHERE id != ?\").bind(user.id)\r\n    ]);\r\n\r\n    const importedCounts = {\r\n      organizations: 0,\r\n      users: 0,\r\n      checklist_templates: 0,\r\n      checklist_fields: 0,\r\n      inspections: 0,\r\n      inspection_items: 0,\r\n      action_items: 0,\r\n      inspection_media: 0\r\n    };\r\n\r\n    // Import organizations\r\n    console.log(`[IMPORT-ALL] Importing ${importData.data.organizations?.length || 0} organizations...`);\r\n    if (importData.data.organizations) {\r\n      for (const org of importData.data.organizations) {\r\n        try {\r\n          await env.DB.prepare(`\r\n            INSERT INTO organizations (\r\n              id, name, type, description, logo_url, contact_email, contact_phone, \r\n              address, is_active, parent_organization_id, organization_level, \r\n              subscription_status, subscription_plan, max_users, max_subsidiaries,\r\n              cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao,\r\n              natureza_juridica, data_abertura, capital_social, porte_empresa,\r\n              situacao_cadastral, numero_funcionarios, setor_industria, subsetor_industria,\r\n              certificacoes_seguranca, data_ultima_auditoria, nivel_risco,\r\n              contato_seguranca_nome, contato_seguranca_email, contato_seguranca_telefone,\r\n              historico_incidentes, observacoes_compliance, website, faturamento_anual,\r\n              created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            org.id, org.name, org.type || 'company', org.description, org.logo_url, org.contact_email, org.contact_phone,\r\n            org.address, org.is_active !== false ? 1 : 0, org.parent_organization_id, org.organization_level || 'company',\r\n            org.subscription_status || 'active', org.subscription_plan || 'basic', org.max_users || 50, org.max_subsidiaries || 0,\r\n            org.cnpj, org.razao_social, org.nome_fantasia, org.cnae_principal, org.cnae_descricao,\r\n            org.natureza_juridica, org.data_abertura, org.capital_social, org.porte_empresa,\r\n            org.situacao_cadastral, org.numero_funcionarios, org.setor_industria, org.subsetor_industria,\r\n            org.certificacoes_seguranca, org.data_ultima_auditoria, org.nivel_risco || 'medio',\r\n            org.contato_seguranca_nome, org.contato_seguranca_email, org.contato_seguranca_telefone,\r\n            org.historico_incidentes, org.observacoes_compliance, org.website, org.faturamento_anual,\r\n            org.created_at, org.updated_at\r\n          ).run();\r\n          importedCounts.organizations++;\r\n        } catch (error) {\r\n          console.error(`[IMPORT-ALL] Error importing organization ${org.id}:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Import users (except current system admin)\r\n    console.log(`[IMPORT-ALL] Importing ${importData.data.users?.length || 0} users...`);\r\n    if (importData.data.users) {\r\n      for (const userData of importData.data.users) {\r\n        if (userData.id === user.id) continue; // Skip current user\r\n\r\n        try {\r\n          await env.DB.prepare(`\r\n            INSERT INTO users (\r\n              id, email, name, role, organization_id, phone, avatar_url, is_active,\r\n              last_login_at, can_manage_users, can_create_organizations, managed_organization_id,\r\n              invitation_token, invited_by, invitation_expires_at, password_hash,\r\n              email_verified_at, profile_completed, created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            userData.id, userData.email, userData.name, userData.role, userData.organization_id,\r\n            userData.phone, userData.avatar_url, userData.is_active !== false ? 1 : 0,\r\n            userData.last_login_at, userData.can_manage_users || 0, userData.can_create_organizations || 0,\r\n            userData.managed_organization_id, userData.invitation_token, userData.invited_by,\r\n            userData.invitation_expires_at, userData.password_hash, userData.email_verified_at,\r\n            userData.profile_completed || 0, userData.created_at, userData.updated_at\r\n          ).run();\r\n          importedCounts.users++;\r\n        } catch (error) {\r\n          console.error(`[IMPORT-ALL] Error importing user ${userData.id}:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Import checklist templates\r\n    console.log(`[IMPORT-ALL] Importing ${importData.data.checklist_templates?.length || 0} templates...`);\r\n    if (importData.data.checklist_templates) {\r\n      for (const template of importData.data.checklist_templates) {\r\n        try {\r\n          await env.DB.prepare(`\r\n            INSERT INTO checklist_templates (\r\n              id, name, description, category, created_by, is_public, created_by_user_id,\r\n              organization_id, parent_category_id, category_path, is_category_folder,\r\n              folder_color, folder_icon, display_order, created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            template.id, template.name, template.description, template.category, template.created_by,\r\n            template.is_public || 0, template.created_by_user_id, template.organization_id,\r\n            template.parent_category_id, template.category_path, template.is_category_folder || 0,\r\n            template.folder_color || '#3B82F6', template.folder_icon || 'folder', template.display_order || 0,\r\n            template.created_at, template.updated_at\r\n          ).run();\r\n          importedCounts.checklist_templates++;\r\n        } catch (error) {\r\n          console.error(`[IMPORT-ALL] Error importing template ${template.id}:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Import checklist fields\r\n    console.log(`[IMPORT-ALL] Importing ${importData.data.checklist_fields?.length || 0} fields...`);\r\n    if (importData.data.checklist_fields) {\r\n      for (const field of importData.data.checklist_fields) {\r\n        try {\r\n          await env.DB.prepare(`\r\n            INSERT INTO checklist_fields (\r\n              id, template_id, field_name, field_type, is_required, options, order_index,\r\n              created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            field.id, field.template_id, field.field_name, field.field_type,\r\n            field.is_required || 0, field.options, field.order_index || 0,\r\n            field.created_at, field.updated_at\r\n          ).run();\r\n          importedCounts.checklist_fields++;\r\n        } catch (error) {\r\n          console.error(`[IMPORT-ALL] Error importing field ${field.id}:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Import inspections\r\n    console.log(`[IMPORT-ALL] Importing ${importData.data.inspections?.length || 0} inspections...`);\r\n    if (importData.data.inspections) {\r\n      for (const inspection of importData.data.inspections) {\r\n        try {\r\n          await env.DB.prepare(`\r\n            INSERT INTO inspections (\r\n              id, title, description, location, inspector_name, inspector_email, status,\r\n              priority, scheduled_date, completed_date, company_name, cep, address,\r\n              latitude, longitude, action_plan, action_plan_type, inspector_signature,\r\n              responsible_signature, created_by, organization_id, ai_assistant_id,\r\n              responsible_name, created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            inspection.id, inspection.title, inspection.description, inspection.location,\r\n            inspection.inspector_name, inspection.inspector_email, inspection.status,\r\n            inspection.priority, inspection.scheduled_date, inspection.completed_date,\r\n            inspection.company_name, inspection.cep, inspection.address, inspection.latitude,\r\n            inspection.longitude, inspection.action_plan, inspection.action_plan_type,\r\n            inspection.inspector_signature, inspection.responsible_signature, inspection.created_by,\r\n            inspection.organization_id, inspection.ai_assistant_id, inspection.responsible_name,\r\n            inspection.created_at, inspection.updated_at\r\n          ).run();\r\n          importedCounts.inspections++;\r\n        } catch (error) {\r\n          console.error(`[IMPORT-ALL] Error importing inspection ${inspection.id}:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Import inspection items\r\n    console.log(`[IMPORT-ALL] Importing ${importData.data.inspection_items?.length || 0} inspection items...`);\r\n    if (importData.data.inspection_items) {\r\n      for (const item of importData.data.inspection_items) {\r\n        try {\r\n          await env.DB.prepare(`\r\n            INSERT INTO inspection_items (\r\n              id, inspection_id, category, item_description, is_compliant, observations,\r\n              photo_url, template_id, field_responses, ai_action_plan, ai_pre_analysis,\r\n              created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            item.id, item.inspection_id, item.category, item.item_description,\r\n            item.is_compliant, item.observations, item.photo_url, item.template_id,\r\n            item.field_responses, item.ai_action_plan, item.ai_pre_analysis,\r\n            item.created_at, item.updated_at\r\n          ).run();\r\n          importedCounts.inspection_items++;\r\n        } catch (error) {\r\n          console.error(`[IMPORT-ALL] Error importing inspection item ${item.id}:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Import action items\r\n    console.log(`[IMPORT-ALL] Importing ${importData.data.action_items?.length || 0} action items...`);\r\n    if (importData.data.action_items) {\r\n      for (const action of importData.data.action_items) {\r\n        try {\r\n          await env.DB.prepare(`\r\n            INSERT INTO action_items (\r\n              id, inspection_id, inspection_item_id, title, what_description, where_location,\r\n              why_reason, how_method, who_responsible, when_deadline, how_much_cost,\r\n              status, priority, is_ai_generated, assigned_to, created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            action.id, action.inspection_id, action.inspection_item_id, action.title,\r\n            action.what_description, action.where_location, action.why_reason, action.how_method,\r\n            action.who_responsible, action.when_deadline, action.how_much_cost, action.status,\r\n            action.priority, action.is_ai_generated || 0, action.assigned_to,\r\n            action.created_at, action.updated_at\r\n          ).run();\r\n          importedCounts.action_items++;\r\n        } catch (error) {\r\n          console.error(`[IMPORT-ALL] Error importing action item ${action.id}:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Import inspection media\r\n    console.log(`[IMPORT-ALL] Importing ${importData.data.inspection_media?.length || 0} media files...`);\r\n    if (importData.data.inspection_media) {\r\n      for (const media of importData.data.inspection_media) {\r\n        try {\r\n          await env.DB.prepare(`\r\n            INSERT INTO inspection_media (\r\n              id, inspection_id, inspection_item_id, media_type, file_name, file_url,\r\n              file_size, mime_type, description, created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            media.id, media.inspection_id, media.inspection_item_id, media.media_type,\r\n            media.file_name, media.file_url, media.file_size, media.mime_type,\r\n            media.description, media.created_at, media.updated_at\r\n          ).run();\r\n          importedCounts.inspection_media++;\r\n        } catch (error) {\r\n          console.error(`[IMPORT-ALL] Error importing media ${media.id}:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log(`[IMPORT-ALL] Import completed:`, importedCounts);\r\n\r\n    return c.json({\r\n      message: \"Production data imported successfully\",\r\n      imported_counts: importedCounts,\r\n      timestamp: new Date().toISOString(),\r\n      imported_by: user.email\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('[IMPORT-ALL] Error importing data:', error);\r\n    return c.json({\r\n      error: \"Failed to import data\",\r\n      details: error instanceof Error ? error.message : String(error)\r\n    }, 500);\r\n  }\r\n});\r\n\r\nexport default adminDebugRoutes;\r\n\r\n"},{"name":"ai-assistant-routes.ts","content":"import { Hono } from 'hono';\r\nimport { tenantAuthMiddleware } from './tenant-auth-middleware.ts';\r\nimport { incrementAiUsage } from './ai-usage-tracker.ts';\r\n\r\nconst aiAssistant = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// System context for the AI assistant\r\nconst SYSTEM_CONTEXT = `Você é o COMPIA AI, o assistente inteligente do sistema COMPIA - uma plataforma de gestão de inspeções de segurança do trabalho.\r\n\r\nSUAS PRINCIPAIS FUNÇÕES:\r\n1. Converter dados de texto em formato CSV para importação de checklists\r\n2. Responder dúvidas sobre como usar o sistema COMPIA\r\n3. Ajudar com análise de conformidade e boas práticas\r\n\r\nSOBRE O SISTEMA COMPIA:\r\n- Sistema de gestão de inspeções de segurança do trabalho\r\n- Permite criar inspeções com checklists personalizados\r\n- Suporta análise de conformidade (Conforme, Não Conforme, N/A)\r\n- Integra IA para análise de fotos e áudios\r\n- Gera relatórios em PDF\r\n- Suporta múltiplas organizações e usuários\r\n\r\nFORMATO CSV PARA CHECKLISTS (MUITO IMPORTANTE):\r\nA primeira linha DEVE ser o cabeçalho: campo,tipo,obrigatorio,opcoes\r\nExemplo completo:\r\n\\`\\`\\`csv\r\ncampo,tipo,obrigatorio,opcoes\r\nNome do Funcionário,text,true,\r\nData da Inspeção,date,true,\r\nEPIs Adequados,boolean,true,\r\nCondição do Extintor,select,true,Bom|Regular|Ruim\r\nNível de Risco,rating,false,\r\n\\`\\`\\`\r\n\r\nTIPOS DE CAMPO DISPONÍVEIS:\r\n- text: Texto Curto (nome, identificador)\r\n- textarea: Texto Longo (observações detalhadas)\r\n- boolean: Conforme/Não Conforme (Sim ou Não)\r\n- number: Número\r\n- date: Data\r\n- time: Hora\r\n- select: Lista Suspensa (requer opções separadas por |)\r\n- radio: Escolha Única (requer opções separadas por |)\r\n- multiselect: Múltipla Escolha (requer opções separadas por |)\r\n- checkbox: Caixa de Seleção\r\n- rating: Avaliação (1-5)\r\n- file: Upload de Arquivo\r\n\r\nREGRAS DE FORMATO:\r\n1. Colunas: campo,tipo,obrigatorio,opcoes (exatamente nesta ordem)\r\n2. Obrigatório: use \"true\" ou \"false\" (sem aspas no CSV)\r\n3. Opções: apenas para select, radio ou multiselect - separe com pipe (|). Ex: \"Bom|Regular|Ruim\"\r\n4. Campos sem opções: deixe a coluna opcoes vazia\r\n\r\nCOMO IMPORTAR CHECKLIST:\r\n1. Vá para Checklists > Templates\r\n2. Clique no template desejado\r\n3. Clique em \"Importar CSV\"\r\n4. Cole ou carregue o arquivo CSV\r\n5. Confirme a importação\r\n\r\nANÁLISE DE CONFORMIDADE:\r\n- Boolean: Sim = Conforme, Não = Não Conforme (automático)\r\n- Rating: ≥4 = Conforme (automático)\r\n- Text/Arquivo: Manual (inspetor avalia)\r\n- Date/Time: Não se aplica\r\n\r\nSempre responda em português do Brasil de forma clara e objetiva.\r\nSe o usuário pedir para converter dados, SEMPRE gere o CSV completo no formato correto com o cabeçalho \"campo,tipo,obrigatorio,opcoes\".\r\n`;\r\n\r\naiAssistant.post('/chat', tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get('user');\r\n\r\n    if (!user) {\r\n        return c.json({ error: 'Usuário não autenticado' }, 401);\r\n    }\r\n\r\n    try {\r\n        const { message, history = [] } = await c.req.json();\r\n\r\n        if (!message || typeof message !== 'string') {\r\n            return c.json({ error: 'Mensagem inválida' }, 400);\r\n        }\r\n\r\n        const openaiApiKey = env.OPENAI_API_KEY || Deno.env.get('OPENAI_API_KEY');\r\n        if (!openaiApiKey) {\r\n            return c.json({ error: 'OpenAI API key não configurada' }, 500);\r\n        }\r\n\r\n        // Build messages array\r\n        const messages = [\r\n            { role: 'system', content: SYSTEM_CONTEXT },\r\n            ...history.slice(-8).map((m: any) => ({\r\n                role: m.role,\r\n                content: m.content\r\n            })),\r\n            { role: 'user', content: message }\r\n        ];\r\n\r\n        // Call OpenAI\r\n        const response = await fetch('https://api.openai.com/v1/chat/completions', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${openaiApiKey}`,\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                model: 'gpt-4o-mini',\r\n                messages,\r\n                max_tokens: 1500,\r\n                temperature: 0.7,\r\n            }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const errorData = await response.json();\r\n            console.error('OpenAI error:', errorData);\r\n            return c.json({ error: 'Erro ao processar mensagem' }, 500);\r\n        }\r\n\r\n        const data = await response.json();\r\n        const reply = data.choices?.[0]?.message?.content || 'Desculpe, não consegui processar sua solicitação.';\r\n\r\n        // Generate contextual suggestions based on the message\r\n        const suggestions = generateSuggestions(message, reply);\r\n\r\n        // Track usage\r\n        try {\r\n            const userId = user.id || (user as any).sub;\r\n            await incrementAiUsage(env.DB, userId, 'ai-assistant-chat', 'gpt-4o-mini');\r\n        } catch (err) {\r\n            console.error('[AI-ASSISTANT] Failed to track usage:', err);\r\n        }\r\n\r\n        return c.json({\r\n            reply,\r\n            suggestions,\r\n        });\r\n    } catch (error) {\r\n        console.error('AI Assistant error:', error);\r\n        return c.json({ error: 'Erro interno do servidor' }, 500);\r\n    }\r\n});\r\n\r\nfunction generateSuggestions(userMessage: string, aiReply: string): string[] {\r\n    const suggestions: string[] = [];\r\n    const lowerMessage = userMessage.toLowerCase();\r\n    const lowerReply = aiReply.toLowerCase();\r\n\r\n    // CSV-related suggestions\r\n    if (lowerReply.includes('csv') || lowerReply.includes('field_name')) {\r\n        suggestions.push('Como importo esse CSV?');\r\n        suggestions.push('Adicionar mais campos');\r\n    }\r\n\r\n    // Inspection-related suggestions\r\n    if (lowerMessage.includes('inspeção') || lowerMessage.includes('inspecao')) {\r\n        suggestions.push('Como adicionar fotos?');\r\n        suggestions.push('O que é análise de conformidade?');\r\n    }\r\n\r\n    // Checklist-related suggestions\r\n    if (lowerMessage.includes('checklist') || lowerMessage.includes('template')) {\r\n        suggestions.push('Tipos de campo disponíveis');\r\n        suggestions.push('Como duplicar um template?');\r\n    }\r\n\r\n    // Conformidade suggestions\r\n    if (lowerMessage.includes('conformidade') || lowerMessage.includes('conforme')) {\r\n        suggestions.push('Como funciona o cálculo automático?');\r\n        suggestions.push('Posso desativar a conformidade?');\r\n    }\r\n\r\n    // Limit to 3 suggestions\r\n    return suggestions.slice(0, 3);\r\n}\r\n\r\nexport default aiAssistant;\r\n"},{"name":"ai-assistants-routes.ts","content":"import { Hono } from 'hono';\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\n\r\n\r\ntype Env = {\r\n  DB: any;\r\n  OPENAI_API_KEY?: string;\r\n};\r\n\r\ntype Variables = {\r\n  user: any;\r\n};\r\n\r\nconst aiAssistantsRoutes = new Hono<{ Bindings: Env; Variables: Variables }>();\r\n\r\n// Get all AI assistants\r\n// Get all AI assistants\r\naiAssistantsRoutes.get('/', async (c) => {\r\n  try {\r\n    const env = c.env;\r\n\r\n    // Check DB availability\r\n    if (!env.DB) {\r\n      console.error('[AI-ASSISTANTS] DB connection not initialized');\r\n      return c.json({\r\n        success: false,\r\n        error: 'Database connection error',\r\n        assistants: [],\r\n        total_count: 0\r\n      }, 500);\r\n    }\r\n\r\n    const assistants = await env.DB.prepare(`\r\n      SELECT * FROM ai_assistants \r\n      WHERE is_active = TRUE \r\n      ORDER BY created_at DESC\r\n    `).all();\r\n\r\n    return c.json({\r\n      success: true,\r\n      assistants: assistants.results || [],\r\n      total_count: (assistants.results || []).length\r\n    });\r\n  } catch (error) {\r\n    console.error('[AI-ASSISTANTS] Error fetching assistants:', error);\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n    const errorStack = error instanceof Error ? error.stack : '';\r\n\r\n    return c.json({\r\n      success: false,\r\n      error: 'Erro ao buscar assistentes de IA',\r\n      details: errorMessage,\r\n      stack: errorStack,\r\n      assistants: [],\r\n      total_count: 0\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Get single AI assistant\r\naiAssistantsRoutes.get('/:id', async (c) => {\r\n  const env = c.env;\r\n  const assistantId = parseInt(c.req.param('id'));\r\n\r\n  try {\r\n    const assistant = await env.DB.prepare(`\r\n      SELECT * FROM ai_assistants \r\n      WHERE id = ? AND is_active = true\r\n    `).bind(assistantId).first();\r\n\r\n    if (!assistant) {\r\n      return c.json({\r\n        success: false,\r\n        error: 'Assistente não encontrado'\r\n      }, 404);\r\n    }\r\n\r\n    return c.json({\r\n      success: true,\r\n      assistant\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching AI assistant:', error);\r\n    return c.json({\r\n      success: false,\r\n      error: 'Erro ao buscar assistente de IA'\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Create AI assistant (admin only)\r\naiAssistantsRoutes.post('/', tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get('user');\r\n\r\n  if (!user) {\r\n    return c.json({ error: 'User not found' }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { name, description, specialization, instructions } = body;\r\n\r\n    if (!name || !specialization || !instructions) {\r\n      return c.json({\r\n        success: false,\r\n        error: 'Nome, especialização e instruções são obrigatórios'\r\n      }, 400);\r\n    }\r\n\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO ai_assistants (\r\n        name, description, specialization, instructions, is_active,\r\n        created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, NOW(), NOW())\r\n    `).bind(\r\n      name,\r\n      description || null,\r\n      specialization,\r\n      instructions,\r\n      true\r\n    ).run();\r\n\r\n    return c.json({\r\n      success: true,\r\n      id: result.meta.last_row_id,\r\n      message: 'Assistente de IA criado com sucesso'\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating AI assistant:', error);\r\n    return c.json({\r\n      success: false,\r\n      error: 'Erro ao criar assistente de IA'\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Update AI assistant (admin only)\r\naiAssistantsRoutes.put('/:id', tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get('user');\r\n  const assistantId = parseInt(c.req.param('id'));\r\n\r\n  if (!user) {\r\n    return c.json({ error: 'User not found' }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n\r\n    const updateFields = [];\r\n    const updateValues = [];\r\n\r\n    const allowedFields = ['name', 'description', 'specialization', 'instructions', 'is_active'];\r\n\r\n    for (const field of allowedFields) {\r\n      if (body[field] !== undefined) {\r\n        updateFields.push(`${field} = ?`);\r\n        updateValues.push(body[field]);\r\n      }\r\n    }\r\n\r\n    if (updateFields.length === 0) {\r\n      return c.json({\r\n        success: false,\r\n        error: 'Nenhum campo para atualizar'\r\n      }, 400);\r\n    }\r\n\r\n    updateFields.push('updated_at = datetime(\\'now\\')');\r\n\r\n    await env.DB.prepare(`\r\n      UPDATE ai_assistants \r\n      SET ${updateFields.join(', ')}\r\n      WHERE id = ?\r\n    `).bind(...updateValues, assistantId).run();\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: 'Assistente de IA atualizado com sucesso'\r\n    });\r\n  } catch (error) {\r\n    console.error('Error updating AI assistant:', error);\r\n    return c.json({\r\n      success: false,\r\n      error: 'Erro ao atualizar assistente de IA'\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Seed AI assistants - popula assistentes especialistas\r\naiAssistantsRoutes.post('/seed', async (c) => {\r\n  const env = c.env;\r\n\r\n  try {\r\n    // Verificar se já existem assistentes\r\n    const existing = await env.DB.prepare(\"SELECT COUNT(*) as count FROM ai_assistants\").first() as any;\r\n\r\n    if (existing?.count > 0) {\r\n      // Deletar existentes e recriar\r\n      await env.DB.prepare(\"DELETE FROM ai_assistants\").run();\r\n    }\r\n\r\n    const aiAssistants = [\r\n      {\r\n        name: 'Especialista NR-35 Altura',\r\n        description: 'Especialista em trabalho em altura, análise de riscos de queda e conformidade com NR-35',\r\n        specialization: 'Trabalho em Altura - NR-35',\r\n        instructions: 'Você é um especialista em segurança para trabalho em altura. Analise evidências focando em: sistemas de ancoragem, EPIs de altura (cinturão, trava-quedas), condições de acesso, sinalização de áreas elevadas, treinamento dos trabalhadores.'\r\n      },\r\n      {\r\n        name: 'Especialista NR-10 Eletricidade',\r\n        description: 'Especialista em instalações elétricas, análise de riscos elétricos e conformidade com NR-10',\r\n        specialization: 'Segurança Elétrica - NR-10',\r\n        instructions: 'Você é um especialista em segurança elétrica. Analise evidências focando em: painéis elétricos, aterramento, bloqueio/etiquetagem, EPIs isolantes, sinalização de risco elétrico, condições de instalações.'\r\n      },\r\n      {\r\n        name: 'Especialista NR-12 Máquinas',\r\n        description: 'Especialista em segurança de máquinas e equipamentos conforme NR-12',\r\n        specialization: 'Máquinas e Equipamentos - NR-12',\r\n        instructions: 'Você é um especialista em segurança de máquinas. Analise evidências focando em: proteções físicas, sistemas de parada de emergência, sinalização de pontos de risco, condições de manutenção, procedimentos operacionais.'\r\n      },\r\n      {\r\n        name: 'Especialista EPIs',\r\n        description: 'Especialista em Equipamentos de Proteção Individual e conformidade com NR-6',\r\n        specialization: 'EPIs - NR-6',\r\n        instructions: 'Você é um especialista em EPIs. Analise evidências focando em: uso correto de EPIs, condição de conservação, adequação ao risco, CA válido, armazenamento, treinamento de uso.'\r\n      },\r\n      {\r\n        name: 'Especialista Ergonomia',\r\n        description: 'Especialista em ergonomia e análise de postos de trabalho conforme NR-17',\r\n        specialization: 'Ergonomia - NR-17',\r\n        instructions: 'Você é um especialista em ergonomia. Analise evidências focando em: posturas de trabalho, mobiliário, iluminação, organização do posto de trabalho, movimentos repetitivos, levantamento de cargas.'\r\n      },\r\n      {\r\n        name: 'Especialista Incêndio',\r\n        description: 'Especialista em prevenção e combate a incêndio conforme NR-23',\r\n        specialization: 'Prevenção de Incêndio - NR-23',\r\n        instructions: 'Você é um especialista em segurança contra incêndio. Analise evidências focando em: extintores, sinalização de emergência, rotas de fuga, hidrantes, brigada de incêndio, materiais inflamáveis.'\r\n      },\r\n      {\r\n        name: 'Especialista Riscos Psicossociais',\r\n        description: 'Especialista em identificação de fatores de risco psicossocial no ambiente de trabalho e geração de planos de ação preventivos',\r\n        specialization: 'Riscos Psicossociais Ocupacionais',\r\n        instructions: `Você é um especialista em Segurança e Saúde do Trabalho focado em RISCOS PSICOSSOCIAIS OCUPACIONAIS.\r\n\r\nSEU PAPEL: Identificar fatores de risco psicossocial no AMBIENTE DE TRABALHO e gerar AÇÕES PREVENTIVAS/CORRETIVAS. NÃO faça diagnósticos clínicos.\r\n\r\nFATORES DE RISCO A ANALISAR:\r\n1. ORGANIZAÇÃO: Sobrecarga, ritmo excessivo, metas inatingíveis\r\n2. RELAÇÕES: Conflitos, assédio moral, falta de suporte\r\n3. CONTEÚDO: Monotonia, falta de autonomia, baixo reconhecimento\r\n4. AMBIENTE: Ruído, temperatura, iluminação\r\n5. TRABALHO-VIDA: Dificuldade de conciliação\r\n\r\nANÁLISE DE ÁUDIO: Tom de voz, hesitações, palavras-chave de estresse.\r\n\r\nGERE AÇÕES 5W2H: Reorganização de processos, treinamentos, canais de escuta.`\r\n      }\r\n    ];\r\n\r\n    for (const assistant of aiAssistants) {\r\n      await env.DB.prepare(`\r\n        INSERT INTO ai_assistants (name, description, specialization, instructions, is_active, created_at, updated_at)\r\n        VALUES (?, ?, ?, ?, true, NOW(), NOW())\r\n      `).bind(assistant.name, assistant.description, assistant.specialization, assistant.instructions).run();\r\n    }\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: `${aiAssistants.length} assistentes de IA criados com sucesso`,\r\n      count: aiAssistants.length\r\n    });\r\n  } catch (error) {\r\n    console.error('Error seeding AI assistants:', error);\r\n    return c.json({\r\n      success: false,\r\n      error: 'Erro ao popular assistentes de IA'\r\n    }, 500);\r\n  }\r\n});\r\n\r\nexport default aiAssistantsRoutes;\r\n\r\n\r\n"},{"name":"ai-prompts.ts","content":"/**\r\n * AI Prompts Collection\r\n * Centralizes system instructions for different AI agents (personas).\r\n */\r\n\r\n/**\r\n * Prompt for Pre-Analysis (Auditor Persona)\r\n */\r\nexport const getPreAnalysisPrompt = (\r\n    fieldName: string,\r\n    status: string,\r\n    location: string,\r\n    mediaContext: string,\r\n    userPrompt?: string\r\n) => `Auditor de Segurança (Multimodal).\r\nCONTEXTO:\r\n- Item: ${fieldName}\r\n- Status: ${status}\r\n- Local: ${location}\r\n${mediaContext}\r\n${userPrompt ? `Pedido: ${userPrompt}` : ''}\r\n\r\nINSTRUÇÃO: Analise todas as mídias (Áudio, Imagem, PDF) e forneça APENAS a conclusão técnica consolidada.\r\n- NÃO use prefixos como \"Síntese:\", \"Áudio:\", \"Visual:\", \"Conclusão:\".\r\n- Integre as evidências visualmente e auditivamente no texto de forma fluida (ex: \"A imagem confirma X, e o áudio relata Y\").\r\n- Seja direto, técnico e aponte divergências na conformidade se houver.\r\n- Responda em texto corrido (1 ou 2 parágrafos).`;\r\n\r\n/**\r\n * Prompt for Action Plan Generation (Engineer Persona)\r\n */\r\nexport const getActionPlanPrompt = (\r\n    companyName: string,\r\n    location: string,\r\n    inspectionTitle: string,\r\n    fieldName: string,\r\n    responseValue: string,\r\n    comment: string,\r\n    complianceStatus: string,\r\n    preAnalysis: string,\r\n    riskLevel: string\r\n) => `Atue como um Engenheiro de Segurança do Trabalho Sênior.\r\nAnalise o contexto abaixo e GERE UM PLANO DE AÇÃO 5W2H TÉCNICO E DETALHADO.\r\n\r\nCONTEXTO DA INSPEÇÃO:\r\n- Empresa: ${companyName}\r\n- Local/Setor: ${location}\r\n- Item Inspecionado: ${inspectionTitle} > ${fieldName}\r\n- Resposta do Inspetor: ${responseValue}\r\n- Comentário/Observação do Inspetor: ${comment}\r\n- Status da Conformidade: ${complianceStatus}\r\n- Análise Prévia (Evidências): ${preAnalysis}\r\n- Nível de Risco Identificado: ${riskLevel}\r\n\r\nDIRETRIZES PARA GERAÇÃO:\r\n1. Se o status for \"NÃO CONFORME\", você **DEVE** gerar um plano de ação (\\`requires_action: true\\`).\r\n2. Se houver riscos graves descritos na análise prévia, gere um plano de ação.\r\n3. O plano deve ser prático, técnico e focado na resolução da não conformidade.\r\n4. \"how_much\" (Custo) deve ser uma estimativa realista ou \"A cotar\".\r\n\r\nResponda APENAS em JSON no seguinte formato:\r\n{\r\n  \"requires_action\": true/false,\r\n  \"what\": \"Ação corretiva detalhada (O que fazer)\",\r\n  \"why\": \"Motivo técnico/Norma Regulamentadora (Por que fazer)\",\r\n  \"where\": \"Local específico da intervenção\",\r\n  \"when\": \"Prazo sugerido (Imediato / X dias)\",\r\n  \"who\": \"Cargo responsável (Ex: Manutenção, SESMT)\",\r\n  \"how\": \"Procedimento da correção\",\r\n  \"how_much\": \"Estimativa de custo/recurso\",\r\n  \"priority\": \"baixa/media/alta/critica\",\r\n  \"justification\": \"Breve justificativa técnica\"\r\n}`;\r\n\r\n/**\r\n * System Message for Action Plan (Engineer Persona)\r\n */\r\nexport const SYSTEM_PROMPT_ACTION_PLAN = 'Você é um especialista em segurança do trabalho. Gere um plano de ação 5W2H detalhado e prático em formato JSON.';\r\n\r\n/**\r\n * System Message for Field Response (Technical Specialist Persona)\r\n */\r\nexport const SYSTEM_PROMPT_FIELD_RESPONSE = 'Você é um especialista em segurança do trabalho especializado em análise multimodal avançada. Sua função é analisar imagens, áudios, vídeos e contexto para gerar respostas técnicas precisas e detalhadas baseadas em evidências reais. SEMPRE descreva especificamente o que observa nas imagens em relação à segurança do trabalho. Para áudios, identifique ruídos, comunicações verbais e, se for assistente psicossocial, analise tom de voz, sinais de estresse, ansiedade ou bem-estar emocional. Seja técnico, detalhado e específico sobre as evidências analisadas.';\r\n"},{"name":"ai-rate-limit.ts","content":"/**\r\n * AI Rate Limiting Middleware and Utility Functions\r\n * \r\n * Responsável por:\r\n * - Verificar limite de uso de IA por organização\r\n * - Incrementar contador após uso\r\n * - Logar uso para auditoria e billing\r\n * - Resetar contador mensalmente\r\n */\r\n\r\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\r\nimport type { Context, Next } from 'hono';\r\n\r\ninterface AIUsageResult {\r\n    allowed: boolean;\r\n    currentUsage: number;\r\n    limit: number;\r\n    remaining: number;\r\n    resetDate: string;\r\n    percentUsed: number;\r\n}\r\n\r\ninterface LogAIUsageParams {\r\n    organizationId: string;\r\n    userId: string;\r\n    featureType: 'analysis' | 'action_plan' | 'transcription' | 'chat';\r\n    modelUsed: string;\r\n    inputTokens?: number;\r\n    outputTokens?: number;\r\n    costUsd?: number;\r\n    responseTimeMs?: number;\r\n    status?: 'success' | 'error' | 'timeout';\r\n    errorMessage?: string;\r\n    inspectionId?: string;\r\n}\r\n\r\n/**\r\n * Verifica se a organização ainda tem uso de IA disponível\r\n * Retorna informações sobre o uso atual\r\n */\r\nexport async function checkAIUsage(\r\n    supabaseAdmin: ReturnType<typeof createClient>,\r\n    organizationId: string\r\n): Promise<AIUsageResult & {\r\n    alert_50_sent: boolean;\r\n    alert_80_sent: boolean;\r\n    alert_100_sent: boolean;\r\n}> {\r\n    // Buscar dados da organização\r\n    const { data: org, error } = await supabaseAdmin\r\n        .from('organizations')\r\n        .select('ai_usage_count, ai_limit, ai_reset_date, subscription_tier, alert_50_sent, alert_80_sent, alert_100_sent')\r\n        .eq('id', organizationId)\r\n        .single();\r\n\r\n    if (error || !org) {\r\n        console.error('Error fetching organization AI usage:', error);\r\n        return {\r\n            allowed: false,\r\n            currentUsage: 0,\r\n            limit: 0,\r\n            remaining: 0,\r\n            resetDate: '',\r\n            percentUsed: 100,\r\n            alert_50_sent: false,\r\n            alert_80_sent: false,\r\n            alert_100_sent: false\r\n        };\r\n    }\r\n\r\n    // Verificar se precisa resetar (novo mês)\r\n    const today = new Date();\r\n    const resetDate = new Date(org.ai_reset_date);\r\n\r\n    if (today >= resetDate) {\r\n        // Resetar contador e atualizar data de reset\r\n        const nextReset = new Date(today.getFullYear(), today.getMonth() + 1, 1);\r\n\r\n        await supabaseAdmin\r\n            .from('organizations')\r\n            .update({\r\n                ai_usage_count: 0,\r\n                ai_reset_date: nextReset.toISOString().split('T')[0],\r\n                alert_50_sent: false, // Reset alerts\r\n                alert_80_sent: false,\r\n                alert_100_sent: false\r\n            })\r\n            .eq('id', organizationId);\r\n\r\n        org.ai_usage_count = 0;\r\n        org.ai_reset_date = nextReset.toISOString().split('T')[0];\r\n        org.alert_50_sent = false;\r\n        org.alert_80_sent = false;\r\n        org.alert_100_sent = false;\r\n    }\r\n\r\n    const currentUsage = org.ai_usage_count || 0;\r\n    const limit = org.ai_limit || 100;\r\n    const remaining = Math.max(0, limit - currentUsage);\r\n    const percentUsed = Math.round((currentUsage / limit) * 100);\r\n\r\n    return {\r\n        allowed: currentUsage < limit,\r\n        currentUsage,\r\n        limit,\r\n        remaining,\r\n        resetDate: org.ai_reset_date,\r\n        percentUsed,\r\n        alert_50_sent: org.alert_50_sent || false,\r\n        alert_80_sent: org.alert_80_sent || false,\r\n        alert_100_sent: org.alert_100_sent || false,\r\n    };\r\n}\r\n\r\n/**\r\n * Incrementa o contador de uso de IA da organização\r\n * Deve ser chamado APÓS uso bem-sucedido da IA\r\n */\r\nexport async function incrementAIUsage(\r\n    supabaseAdmin: ReturnType<typeof createClient>,\r\n    organizationId: string\r\n): Promise<boolean> {\r\n    const { error } = await supabaseAdmin.rpc('increment_ai_usage', {\r\n        org_id: organizationId,\r\n    });\r\n\r\n    // Se a função RPC não existir, fazer update direto\r\n    if (error && error.code === 'PGRST202') {\r\n        const { error: updateError } = await supabaseAdmin\r\n            .from('organizations')\r\n            .update({\r\n                ai_usage_count: supabaseAdmin.rpc('coalesce', {\r\n                    value1: 'ai_usage_count + 1',\r\n                    value2: 1\r\n                }),\r\n            })\r\n            .eq('id', organizationId);\r\n\r\n        // Fallback: update direto com SQL\r\n        if (updateError) {\r\n            // Buscar valor atual e incrementar\r\n            const { data: org } = await supabaseAdmin\r\n                .from('organizations')\r\n                .select('ai_usage_count')\r\n                .eq('id', organizationId)\r\n                .single();\r\n\r\n            await supabaseAdmin\r\n                .from('organizations')\r\n                .update({ ai_usage_count: (org?.ai_usage_count || 0) + 1 })\r\n                .eq('id', organizationId);\r\n        }\r\n    }\r\n\r\n    return !error;\r\n}\r\n\r\n/**\r\n * Loga o uso de IA para auditoria e billing\r\n */\r\nexport async function logAIUsage(\r\n    supabaseAdmin: ReturnType<typeof createClient>,\r\n    params: LogAIUsageParams\r\n): Promise<void> {\r\n    try {\r\n        await supabaseAdmin.from('ai_usage_log').insert({\r\n            organization_id: params.organizationId,\r\n            user_id: params.userId,\r\n            inspection_id: params.inspectionId,\r\n            feature_type: params.featureType,\r\n            model_used: params.modelUsed,\r\n            input_tokens: params.inputTokens || 0,\r\n            output_tokens: params.outputTokens || 0,\r\n            cost_usd: params.costUsd || 0,\r\n            response_time_ms: params.responseTimeMs || 0,\r\n            status: params.status || 'success',\r\n            error_message: params.errorMessage,\r\n        });\r\n    } catch (error) {\r\n        console.error('Error logging AI usage:', error);\r\n        // Não falhar por causa do log\r\n    }\r\n}\r\n\r\n/**\r\n * Verifica e incrementa uso de IA em uma única operação\r\n * Retorna se a operação é permitida\r\n */\r\nexport async function checkAndIncrementAIUsage(\r\n    supabaseAdmin: ReturnType<typeof createClient>,\r\n    organizationId: string,\r\n    userId: string,\r\n    featureType: LogAIUsageParams['featureType'] = 'analysis'\r\n): Promise<{ allowed: boolean; usage: AIUsageResult }> {\r\n    const usage = await checkAIUsage(supabaseAdmin, organizationId);\r\n\r\n    if (!usage.allowed) {\r\n        // Logar tentativa bloqueada\r\n        await logAIUsage(supabaseAdmin, {\r\n            organizationId,\r\n            userId,\r\n            featureType,\r\n            modelUsed: 'blocked',\r\n            status: 'error',\r\n            errorMessage: 'Limite de uso de IA atingido',\r\n        });\r\n    }\r\n\r\n    return { allowed: usage.allowed, usage };\r\n}\r\n\r\n/**\r\n * Busca configurações do sistema\r\n */\r\nexport async function getSystemSettings(\r\n    supabaseAdmin: ReturnType<typeof createClient>\r\n): Promise<{\r\n    aiEnabled: boolean;\r\n    aiPrimaryProvider: string;\r\n    aiBackupProvider: string;\r\n    aiFallbackEnabled: boolean;\r\n    gamificationEnabled: boolean;\r\n}> {\r\n    const { data, error } = await supabaseAdmin\r\n        .from('system_settings')\r\n        .select('*')\r\n        .eq('id', 'global')\r\n        .single();\r\n\r\n    if (error || !data) {\r\n        // Retornar defaults\r\n        return {\r\n            aiEnabled: true,\r\n            aiPrimaryProvider: 'gemini',\r\n            aiBackupProvider: 'openai',\r\n            aiFallbackEnabled: true,\r\n            gamificationEnabled: true,\r\n        };\r\n    }\r\n\r\n    return {\r\n        aiEnabled: data.ai_enabled ?? true,\r\n        aiPrimaryProvider: data.ai_primary_provider ?? 'gemini',\r\n        aiBackupProvider: data.ai_backup_provider ?? 'openai',\r\n        aiFallbackEnabled: data.ai_fallback_enabled ?? true,\r\n        gamificationEnabled: data.gamification_enabled ?? true,\r\n    };\r\n}\r\n\r\n/**\r\n * Middleware de rate limiting para rotas de IA\r\n * Adiciona informações de uso ao contexto\r\n */\r\nexport function aiRateLimitMiddleware(featureType: LogAIUsageParams['featureType'] = 'analysis') {\r\n    return async (c: Context, next: Next) => {\r\n        const user = c.get('user');\r\n\r\n        if (!user) {\r\n            return c.json({ error: 'Usuário não autenticado' }, 401);\r\n        }\r\n\r\n        const organizationId = user.organization_id;\r\n\r\n        if (!organizationId) {\r\n            return c.json({ error: 'Usuário não associado a uma organização' }, 400);\r\n        }\r\n\r\n        // Criar cliente Supabase admin\r\n        const supabaseUrl = c.env?.SUPABASE_URL || Deno.env.get('SUPABASE_URL');\r\n        const supabaseKey = c.env?.SUPABASE_SERVICE_ROLE_KEY || Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\r\n\r\n        if (!supabaseUrl || !supabaseKey) {\r\n            console.error('Supabase credentials not configured');\r\n            return next(); // Continuar sem rate limiting se não configurado\r\n        }\r\n\r\n        const supabaseAdmin = createClient(supabaseUrl, supabaseKey);\r\n\r\n        // Verificar configurações do sistema\r\n        const settings = await getSystemSettings(supabaseAdmin);\r\n\r\n        if (!settings.aiEnabled) {\r\n            return c.json({\r\n                error: 'Serviço de IA temporariamente desabilitado pelo administrador',\r\n                code: 'AI_DISABLED'\r\n            }, 503);\r\n        }\r\n\r\n        // Verificar uso\r\n        const { allowed, usage } = await checkAndIncrementAIUsage(\r\n            supabaseAdmin,\r\n            organizationId,\r\n            user.id,\r\n            featureType\r\n        );\r\n\r\n        // Adicionar informações ao contexto\r\n        c.set('aiUsage', usage);\r\n        c.set('supabaseAdmin', supabaseAdmin);\r\n        c.set('systemSettings', settings);\r\n\r\n        if (!allowed) {\r\n            return c.json({\r\n                error: 'Limite de análises de IA atingido para este mês',\r\n                code: 'AI_LIMIT_REACHED',\r\n                usage: {\r\n                    current: usage.currentUsage,\r\n                    limit: usage.limit,\r\n                    resetDate: usage.resetDate,\r\n                },\r\n                upgrade: {\r\n                    message: 'Faça upgrade do seu plano para mais análises',\r\n                    url: '/settings/subscription',\r\n                }\r\n            }, 429);\r\n        }\r\n\r\n        // Adicionar headers de rate limit na resposta\r\n        await next();\r\n\r\n        // Após a resposta, adicionar headers\r\n        c.header('X-RateLimit-Limit', usage.limit.toString());\r\n        c.header('X-RateLimit-Remaining', usage.remaining.toString());\r\n        c.header('X-RateLimit-Reset', usage.resetDate);\r\n    };\r\n}\r\n\r\nasync function sendAlertEmail(\r\n    organizationId: string,\r\n    threshold: number,\r\n    currentUsage: number,\r\n    limit: number\r\n) {\r\n    console.log(`[ALERT] Organization ${organizationId} reached ${threshold}% usage (${currentUsage}/${limit})`);\r\n    // TODO: Implement actual email sending via SendGrid/Resend\r\n    // Example: fetch('https://api.resend.com/emails', ...)\r\n}\r\n\r\n/**\r\n * Após uso bem-sucedido de IA, finaliza o log e incrementa contador\r\n */\r\nexport async function finalizeAIUsage(\r\n    supabaseAdmin: ReturnType<typeof createClient>,\r\n    organizationId: string,\r\n    params: Omit<LogAIUsageParams, 'organizationId'>\r\n): Promise<void> {\r\n    // Incrementar contador\r\n    await incrementAIUsage(supabaseAdmin, organizationId);\r\n\r\n    // Check for alerts\r\n    try {\r\n        const usageData = await checkAIUsage(supabaseAdmin, organizationId);\r\n        const { percentUsed, alert_50_sent, alert_80_sent, alert_100_sent } = usageData;\r\n\r\n        let alertToSend = 0;\r\n        let startCondition = false;\r\n\r\n        if (percentUsed >= 100 && !alert_100_sent) {\r\n            alertToSend = 100;\r\n        } else if (percentUsed >= 80 && !alert_80_sent) {\r\n            alertToSend = 80;\r\n        } else if (percentUsed >= 50 && !alert_50_sent) {\r\n            alertToSend = 50;\r\n        }\r\n\r\n        if (alertToSend > 0) {\r\n            await sendAlertEmail(organizationId, alertToSend, usageData.currentUsage, usageData.limit);\r\n\r\n            // Update flag\r\n            const updateData: any = {};\r\n            if (alertToSend === 50) updateData.alert_50_sent = true;\r\n            if (alertToSend === 80) updateData.alert_80_sent = true;\r\n            if (alertToSend === 100) updateData.alert_100_sent = true;\r\n\r\n            await supabaseAdmin\r\n                .from('organizations')\r\n                .update(updateData)\r\n                .eq('id', organizationId);\r\n        }\r\n    } catch (e) {\r\n        console.error('Error checking usage alerts:', e);\r\n    }\r\n\r\n    // Logar uso\r\n    await logAIUsage(supabaseAdmin, {\r\n        ...params,\r\n        organizationId,\r\n    });\r\n}\r\n"},{"name":"ai-service.ts","content":"/**\r\n * AI Service Module - Gemini Primary with OpenAI Fallback\r\n * \r\n * Responsável por:\r\n * - Tentar Gemini primeiro (mais barato)\r\n * - Fazer fallback para OpenAI se Gemini falhar\r\n * - Logar qual provider foi utilizado\r\n */\r\n\r\ninterface AICompletionOptions {\r\n    systemPrompt: string;\r\n    userPrompt: string;\r\n    maxTokens?: number;\r\n    temperature?: number;\r\n    timeoutMs?: number;\r\n}\r\n\r\ninterface AICompletionResult {\r\n    success: boolean;\r\n    content: string;\r\n    provider: 'gemini' | 'openai';\r\n    model: string;\r\n    error?: string;\r\n    fallbackUsed?: boolean;\r\n    totalTokens?: number;\r\n}\r\n\r\n/**\r\n * Chama a API do Gemini (Google AI)\r\n */\r\nasync function callGemini(\r\n    apiKey: string,\r\n    options: AICompletionOptions\r\n): Promise<{ success: boolean; content?: string; error?: string; totalTokens?: number }> {\r\n    const { systemPrompt, userPrompt, maxTokens = 1500, temperature = 0.3, timeoutMs = 60000 } = options;\r\n\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\r\n\r\n    try {\r\n        const response = await fetch(\r\n            `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`,\r\n            {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({\r\n                    contents: [\r\n                        {\r\n                            role: 'user',\r\n                            parts: [\r\n                                { text: `${systemPrompt}\\n\\n${userPrompt}` }\r\n                            ]\r\n                        }\r\n                    ],\r\n                    generationConfig: {\r\n                        temperature: temperature,\r\n                        maxOutputTokens: maxTokens,\r\n                        responseMimeType: 'application/json'\r\n                    },\r\n                    safetySettings: [\r\n                        { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },\r\n                        { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },\r\n                        { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },\r\n                        { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }\r\n                    ]\r\n                }),\r\n                signal: controller.signal\r\n            }\r\n        );\r\n\r\n        clearTimeout(timeoutId);\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('[AI-SERVICE] Gemini API Error:', response.status, errorText);\r\n            return { success: false, error: `Gemini error ${response.status}: ${errorText}` };\r\n        }\r\n\r\n        const data = await response.json();\r\n\r\n        // Extract content from Gemini response\r\n        const content = data.candidates?.[0]?.content?.parts?.[0]?.text;\r\n\r\n        if (!content) {\r\n            return { success: false, error: 'Gemini returned empty response' };\r\n        }\r\n\r\n        // Extract usage\r\n        const totalTokens = data.usageMetadata?.totalTokenCount || 0;\r\n\r\n        console.log('[AI-SERVICE] Gemini success, content length:', content.length, 'Tokens:', totalTokens);\r\n        return { success: true, content, totalTokens };\r\n\r\n    } catch (error: any) {\r\n        clearTimeout(timeoutId);\r\n\r\n        if (error.name === 'AbortError') {\r\n            return { success: false, error: 'Gemini request timed out' };\r\n        }\r\n\r\n        console.error('[AI-SERVICE] Gemini exception:', error.message);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Chama a API do OpenAI\r\n */\r\nasync function callOpenAI(\r\n    apiKey: string,\r\n    options: AICompletionOptions\r\n): Promise<{ success: boolean; content?: string; error?: string; totalTokens?: number }> {\r\n    const { systemPrompt, userPrompt, maxTokens = 1500, temperature = 0.3, timeoutMs = 60000 } = options;\r\n\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\r\n\r\n    try {\r\n        const response = await fetch('https://api.openai.com/v1/chat/completions', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${apiKey}`,\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                model: 'gpt-4o-mini',\r\n                messages: [\r\n                    { role: 'system', content: systemPrompt },\r\n                    { role: 'user', content: userPrompt }\r\n                ],\r\n                max_tokens: maxTokens,\r\n                temperature: temperature\r\n            }),\r\n            signal: controller.signal\r\n        });\r\n\r\n        clearTimeout(timeoutId);\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('[AI-SERVICE] OpenAI API Error:', response.status, errorText);\r\n            return { success: false, error: `OpenAI error ${response.status}: ${errorText}` };\r\n        }\r\n\r\n        const data = await response.json();\r\n        const content = data.choices?.[0]?.message?.content;\r\n\r\n        if (!content) {\r\n            return { success: false, error: 'OpenAI returned empty response' };\r\n        }\r\n\r\n        const totalTokens = data.usage?.total_tokens || 0;\r\n\r\n        console.log('[AI-SERVICE] OpenAI success, content length:', content.length, 'Tokens:', totalTokens);\r\n        return { success: true, content, totalTokens };\r\n\r\n    } catch (error: any) {\r\n        clearTimeout(timeoutId);\r\n\r\n        if (error.name === 'AbortError') {\r\n            return { success: false, error: 'OpenAI request timed out' };\r\n        }\r\n\r\n        console.error('[AI-SERVICE] OpenAI exception:', error.message);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Função principal: tenta Gemini primeiro, depois OpenAI como fallback\r\n */\r\nexport async function generateAICompletion(\r\n    geminiKey: string | undefined,\r\n    openaiKey: string | undefined,\r\n    options: AICompletionOptions,\r\n    preferences: {\r\n        preferredProvider: 'gemini' | 'openai';\r\n        fallbackEnabled: boolean;\r\n    } = { preferredProvider: 'gemini', fallbackEnabled: true }\r\n): Promise<AICompletionResult> {\r\n\r\n    const { preferredProvider, fallbackEnabled } = preferences;\r\n    const providerOrder = preferredProvider === 'openai'\r\n        ? ['openai', 'gemini']\r\n        : ['gemini', 'openai'];\r\n\r\n    console.log(`[AI-SERVICE] Config: Primary=${preferredProvider}, Fallback=${fallbackEnabled ? 'ON' : 'OFF'}`);\r\n\r\n    for (const provider of providerOrder) {\r\n        // Skip secondary provider if fallback is disabled and we are on the second iteration\r\n        if (!fallbackEnabled && provider !== preferredProvider) {\r\n            console.log(`[AI-SERVICE] Fallback disabled, skipping ${provider}`);\r\n            continue;\r\n        }\r\n\r\n        if (provider === 'gemini') {\r\n            if (geminiKey && geminiKey.trim()) {\r\n                console.log('[AI-SERVICE] Tentando Gemini...');\r\n                const result = await callGemini(geminiKey.trim(), options);\r\n\r\n                if (result.success && result.content) {\r\n                    return {\r\n                        success: true,\r\n                        content: result.content,\r\n                        provider: 'gemini',\r\n                        model: 'gemini-1.5-flash',\r\n                        fallbackUsed: provider !== preferredProvider,\r\n                        totalTokens: result.totalTokens\r\n                    };\r\n                }\r\n                console.log('[AI-SERVICE] Gemini falhou:', result.error);\r\n            } else {\r\n                console.log('[AI-SERVICE] Gemini Key ausente ou inválida.');\r\n            }\r\n        }\r\n\r\n        if (provider === 'openai') {\r\n            if (openaiKey && openaiKey.trim()) {\r\n                console.log('[AI-SERVICE] Tentando OpenAI...');\r\n                const result = await callOpenAI(openaiKey.trim(), options);\r\n\r\n                if (result.success && result.content) {\r\n                    return {\r\n                        success: true,\r\n                        content: result.content,\r\n                        provider: 'openai',\r\n                        model: 'gpt-4o-mini',\r\n                        fallbackUsed: provider !== preferredProvider,\r\n                        totalTokens: result.totalTokens\r\n                    };\r\n                }\r\n                console.log('[AI-SERVICE] OpenAI falhou:', result.error);\r\n            } else {\r\n                console.log('[AI-SERVICE] OpenAI Key ausente ou inválida.');\r\n            }\r\n        }\r\n    }\r\n\r\n    // Se chegou aqui, ambos falharam ou não estavam configurados adequadamente\r\n    return {\r\n        success: false,\r\n        content: '',\r\n        provider: 'openai', // Default for error reporting\r\n        model: 'none',\r\n        error: 'Falha em todos os provedores configurados ou chaves ausentes.'\r\n    };\r\n}\r\n\r\n/**\r\n * Verifica status dos providers de IA\r\n */\r\nexport async function checkAIProvidersStatus(\r\n    geminiKey: string | undefined,\r\n    openaiKey: string | undefined\r\n): Promise<{ gemini: 'available' | 'unavailable' | 'error'; openai: 'available' | 'unavailable' | 'error' }> {\r\n    const status = {\r\n        gemini: 'unavailable' as 'available' | 'unavailable' | 'error',\r\n        openai: 'unavailable' as 'available' | 'unavailable' | 'error'\r\n    };\r\n\r\n    // Quick health check for Gemini\r\n    if (geminiKey) {\r\n        try {\r\n            const response = await fetch(\r\n                `https://generativelanguage.googleapis.com/v1beta/models?key=${geminiKey}`,\r\n                { method: 'GET' }\r\n            );\r\n            status.gemini = response.ok ? 'available' : 'error';\r\n        } catch {\r\n            status.gemini = 'error';\r\n        }\r\n    }\r\n\r\n    // Quick health check for OpenAI\r\n    if (openaiKey) {\r\n        try {\r\n            const response = await fetch('https://api.openai.com/v1/models', {\r\n                method: 'GET',\r\n                headers: { 'Authorization': `Bearer ${openaiKey}` }\r\n            });\r\n            status.openai = response.ok ? 'available' : 'error';\r\n        } catch {\r\n            status.openai = 'error';\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n"},{"name":"ai-usage-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\n\r\nconst aiUsageRoutes = new Hono<{ Bindings: any }>();\r\n\r\n// GET /api/organizations/:orgId/ai-usage/logs\r\naiUsageRoutes.get('/:orgId/logs', tenantAuthMiddleware, async (c) => {\r\n    const orgId = c.req.param('orgId');\r\n    const { page = '1', limit = '20', start_date, end_date, feature_type, user_id } = c.req.query();\r\n\r\n    // Permission check (must be org_admin or sys_admin)\r\n    const user = c.get('user');\r\n    // Basic check: user.organization_id == orgId OR user.role == sys_admin\r\n    // (Middleware already handles basic tenant, but let's be safe if we want strict admin only)\r\n\r\n    try {\r\n        const offset = (parseInt(page) - 1) * parseInt(limit);\r\n        const params: any[] = [orgId];\r\n        let query = `\r\n            SELECT l.*, u.email as user_email\r\n            FROM ai_usage_log l\r\n            LEFT JOIN users u ON l.user_id = u.id\r\n            WHERE l.organization_id = ?\r\n        `;\r\n\r\n        if (start_date) {\r\n            query += ` AND l.created_at >= ?`;\r\n            params.push(start_date);\r\n        }\r\n        if (end_date) {\r\n            query += ` AND l.created_at <= ?`;\r\n            params.push(end_date);\r\n        }\r\n        if (feature_type) {\r\n            query += ` AND l.feature_type = ?`;\r\n            params.push(feature_type);\r\n        }\r\n        if (user_id) {\r\n            query += ` AND l.user_id = ?`;\r\n            params.push(user_id);\r\n        }\r\n\r\n        const countQuery = `SELECT COUNT(*) as total FROM (${query}) as sub`;\r\n        // @ts-ignore\r\n        const totalResult = await c.env.DB.prepare(countQuery).bind(...params).first();\r\n\r\n        query += ` ORDER BY l.created_at DESC LIMIT ? OFFSET ?`;\r\n        params.push(parseInt(limit), offset);\r\n\r\n        // @ts-ignore\r\n        const results = await c.env.DB.prepare(query).bind(...params).all();\r\n\r\n        return c.json({\r\n            logs: results.results || [],\r\n            pagination: {\r\n                total: totalResult?.total || 0,\r\n                page: parseInt(page),\r\n                limit: parseInt(limit),\r\n                pages: Math.ceil((totalResult?.total || 0) / parseInt(limit))\r\n            }\r\n        });\r\n    } catch (e: any) {\r\n        console.error(\"Error fetching AI logs:\", e);\r\n        return c.json({ error: e.message }, 500);\r\n    }\r\n});\r\n\r\n// GET /api/organizations/:orgId/ai-usage/export\r\naiUsageRoutes.get('/:orgId/export', tenantAuthMiddleware, async (c) => {\r\n    const orgId = c.req.param('orgId');\r\n    const { start_date, end_date } = c.req.query();\r\n\r\n    try {\r\n        const params: any[] = [orgId];\r\n        let query = `\r\n            SELECT l.created_at, u.email, l.feature_type, l.model_used, l.status\r\n            FROM ai_usage_log l\r\n            LEFT JOIN users u ON l.user_id = u.id\r\n            WHERE l.organization_id = ?\r\n        `;\r\n\r\n        if (start_date) {\r\n            query += ` AND l.created_at >= ?`;\r\n            params.push(start_date);\r\n        }\r\n        if (end_date) {\r\n            query += ` AND l.created_at <= ?`;\r\n            params.push(end_date);\r\n        }\r\n        query += ` ORDER BY l.created_at DESC LIMIT 1000`; // Limit export size\r\n\r\n        // @ts-ignore\r\n        const results = await c.env.DB.prepare(query).bind(...params).all();\r\n        const logs = results.results || [];\r\n\r\n        // Generate CSV\r\n        const header = \"Data/Hora,Usuário,Funcionalidade,Modelo,Status\\n\";\r\n        const rows = logs.map((l: any) =>\r\n            `${l.created_at},${l.email || 'N/A'},${l.feature_type},${l.model_used},${l.status}`\r\n        ).join(\"\\n\");\r\n\r\n        return c.text(header + rows, 200, {\r\n            'Content-Type': 'text/csv',\r\n            'Content-Disposition': `attachment; filename=\"ai_usage_report_${orgId}.csv\"`\r\n        });\r\n\r\n    } catch (e: any) {\r\n        console.error(\"Error exporting AI logs:\", e);\r\n        return c.json({ error: e.message }, 500);\r\n    }\r\n});\r\n\r\nexport { aiUsageRoutes };\r\n"},{"name":"ai-usage-tracker.ts","content":"\r\n/**\r\n * Shared helper for AI Usage Increment across all routes.\r\n * Centralizes logic for updating organization usage counts and logging events.\r\n */\r\nexport async function incrementAiUsage(\r\n    db: any,\r\n    userId: string,\r\n    featureType: string,\r\n    modelUsed: string,\r\n    tokenCount: number = 0 // Default to 0 if not provided\r\n): Promise<{ success: boolean; debug_org_id?: number | null; error?: string }> {\r\n    try {\r\n        // Safe userId extraction\r\n        if (!userId) {\r\n            console.error('[AI-USAGE-HELPER] No userId provided');\r\n            return { success: false, error: 'no_user_id' };\r\n        }\r\n\r\n        console.log(`[AI-USAGE-HELPER] Incrementing for user: ${userId}, Feature: ${featureType}, Tokens: ${tokenCount}`);\r\n\r\n        // Get User's Organization\r\n        const userProfile = await db.prepare(\r\n            \"SELECT organization_id FROM users WHERE id = ?\"\r\n        ).bind(userId).first() as { organization_id?: number };\r\n\r\n        if (!userProfile?.organization_id) {\r\n            console.error('[AI-USAGE-HELPER] Organization ID not found for user:', userId);\r\n            return { success: false, debug_org_id: null, error: 'org_not_found' };\r\n        }\r\n\r\n        const orgId = userProfile.organization_id;\r\n\r\n        // Update Counter\r\n        await db.prepare(\r\n            \"UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?\"\r\n        ).bind(orgId).run();\r\n\r\n        // Insert Log\r\n        try {\r\n            await db.prepare(`\r\n                INSERT INTO ai_usage_logs (organization_id, user_id, feature_type, model_used, total_tokens, status, created_at)\r\n                VALUES (?, ?, ?, ?, ?, 'success', ?)\r\n            `).bind(orgId, userId, featureType, modelUsed, tokenCount, new Date().toISOString()).run();\r\n        } catch (logErr) {\r\n            console.warn('[AI-USAGE-HELPER] Log insertion failed (non-critical):', logErr);\r\n            // Non-critical, but we log it.\r\n        }\r\n\r\n        return { success: true, debug_org_id: orgId, _trace: 'fixed-syntax' };\r\n\r\n    } catch (err: any) {\r\n        console.error('[AI-USAGE-HELPER] Critical failure:', err);\r\n        return { success: false, error: err.message };\r\n    }\r\n}\r\n"},{"name":"asaas-webhook.ts","content":"import { Hono } from \"hono\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n};\r\n\r\nconst asaasWebhookRoutes = new Hono<{ Bindings: Env }>();\r\n\r\n// Define Asaas event types\r\ntype AsaasEventType =\r\n    | 'PAYMENT_CONFIRMED'\r\n    | 'PAYMENT_RECEIVED'\r\n    | 'PAYMENT_OVERDUE'\r\n    | 'PAYMENT_DELETED'\r\n    | 'PAYMENT_UPDATED'\r\n    | 'PAYMENT_REFUNDED'\r\n    | 'SUBSCRIPTION_DELETED'\r\n    | 'SUBSCRIPTION_UPDATED';\r\n\r\ninterface AsaasWebhookPayload {\r\n    id: string;\r\n    event: AsaasEventType;\r\n    payment?: {\r\n        id: string;\r\n        customer: string;\r\n        subscription?: string;\r\n        value: number;\r\n        status: string;\r\n        dueDate: string;\r\n        confirmedDate?: string;\r\n    };\r\n    subscription?: {\r\n        id: string;\r\n        customer: string;\r\n        status: string;\r\n    };\r\n}\r\n\r\n// ============================================================================\r\n// POST /webhooks/asaas - Main Asaas webhook handler\r\n// ============================================================================\r\nasaasWebhookRoutes.post(\"/\", async (c) => {\r\n    const env = c.env;\r\n\r\n    // Verificar token de autenticação do Asaas\r\n    const webhookToken = c.req.header('asaas-access-token');\r\n    const expectedToken = Deno.env.get('ASAAS_WEBHOOK_TOKEN');\r\n\r\n    // Se configurado, verificar token (em produção, sempre deve estar configurado)\r\n    if (expectedToken && webhookToken !== expectedToken) {\r\n        console.warn(\"[ASAAS-WEBHOOK] Invalid webhook token received\");\r\n        return c.json({ error: \"Unauthorized\" }, 401);\r\n    }\r\n\r\n    let payload: AsaasWebhookPayload;\r\n\r\n    try {\r\n        payload = await c.req.json();\r\n    } catch (err) {\r\n        console.error(\"[ASAAS-WEBHOOK] Failed to parse JSON payload:\", err);\r\n        return c.json({ error: \"Invalid JSON payload\" }, 400);\r\n    }\r\n\r\n    console.log(`[ASAAS-WEBHOOK] Received event: ${payload.event}, id: ${payload.id}`);\r\n\r\n    // Lei da Idempotência: Verificar se evento já foi processado\r\n    try {\r\n        const existingEvent = await env.DB.prepare(`\r\n            SELECT id FROM webhook_events \r\n            WHERE gateway = 'asaas' AND external_event_id = ?\r\n        `).bind(payload.id).first();\r\n\r\n        if (existingEvent) {\r\n            console.log(`[ASAAS-WEBHOOK] Event ${payload.id} already processed, skipping`);\r\n            return c.json({ status: \"already_processed\" });\r\n        }\r\n    } catch (err) {\r\n        console.error(\"[ASAAS-WEBHOOK] Error checking idempotency:\", err);\r\n        // Continue processing - we'll try to insert at the end\r\n    }\r\n\r\n    // Processar evento baseado no tipo\r\n    try {\r\n        switch (payload.event) {\r\n            case 'PAYMENT_CONFIRMED':\r\n            case 'PAYMENT_RECEIVED':\r\n                await handlePaymentConfirmed(env.DB, payload);\r\n                break;\r\n\r\n            case 'PAYMENT_OVERDUE':\r\n                await handlePaymentOverdue(env.DB, payload);\r\n                break;\r\n\r\n            case 'PAYMENT_REFUNDED':\r\n                await handlePaymentRefunded(env.DB, payload);\r\n                break;\r\n\r\n            case 'SUBSCRIPTION_DELETED':\r\n                await handleSubscriptionDeleted(env.DB, payload);\r\n                break;\r\n\r\n            default:\r\n                console.log(`[ASAAS-WEBHOOK] Unhandled event type: ${payload.event}`);\r\n        }\r\n\r\n        // Registrar evento processado (idempotência)\r\n        await env.DB.prepare(`\r\n            INSERT INTO webhook_events (gateway, external_event_id, event_type, payload, status)\r\n            VALUES ('asaas', ?, ?, ?, 'processed')\r\n        `).bind(\r\n            payload.id,\r\n            payload.event,\r\n            JSON.stringify(payload)\r\n        ).run();\r\n\r\n        console.log(`[ASAAS-WEBHOOK] Successfully processed event ${payload.id}`);\r\n        return c.json({ status: \"processed\" });\r\n\r\n    } catch (err: any) {\r\n        console.error(`[ASAAS-WEBHOOK] Error processing event ${payload.id}:`, err);\r\n\r\n        // Tentar registrar erro\r\n        try {\r\n            await env.DB.prepare(`\r\n                INSERT INTO webhook_events (gateway, external_event_id, event_type, payload, status, error_message)\r\n                VALUES ('asaas', ?, ?, ?, 'failed', ?)\r\n            `).bind(\r\n                payload.id,\r\n                payload.event,\r\n                JSON.stringify(payload),\r\n                err.message\r\n            ).run();\r\n        } catch (logErr) {\r\n            console.error(\"[ASAAS-WEBHOOK] Failed to log error:\", logErr);\r\n        }\r\n\r\n        return c.json({ error: \"Processing failed\", details: err.message }, 500);\r\n    }\r\n});\r\n\r\n// ============================================================================\r\n// Event Handlers\r\n// ============================================================================\r\n\r\nasync function handlePaymentConfirmed(db: any, payload: AsaasWebhookPayload) {\r\n    if (!payload.payment) return;\r\n\r\n    const { id: paymentId, subscription: subscriptionId, confirmedDate, value } = payload.payment;\r\n\r\n    console.log(`[ASAAS-WEBHOOK] Processing PAYMENT_CONFIRMED: ${paymentId}`);\r\n\r\n    // Atualizar fatura para 'paid'\r\n    const updateResult = await db.prepare(`\r\n        UPDATE invoices \r\n        SET status = 'paid', \r\n            paid_at = COALESCE(?, NOW()),\r\n            updated_at = NOW()\r\n        WHERE gateway_invoice_id = ?\r\n    `).bind(confirmedDate, paymentId).run();\r\n\r\n    console.log(`[ASAAS-WEBHOOK] Updated invoice: ${updateResult?.meta?.changes || 0} rows`);\r\n\r\n    // Se tiver subscription, atualizar status para 'active'\r\n    if (subscriptionId) {\r\n        await db.prepare(`\r\n            UPDATE subscriptions \r\n            SET status = 'active',\r\n                updated_at = NOW()\r\n            WHERE gateway_subscription_id = ? AND status IN ('past_due', 'grace_period', 'trial')\r\n        `).bind(subscriptionId).run();\r\n\r\n        console.log(`[ASAAS-WEBHOOK] Updated subscription ${subscriptionId} to active`);\r\n    }\r\n}\r\n\r\nasync function handlePaymentOverdue(db: any, payload: AsaasWebhookPayload) {\r\n    if (!payload.payment) return;\r\n\r\n    const { id: paymentId, subscription: subscriptionId } = payload.payment;\r\n\r\n    console.log(`[ASAAS-WEBHOOK] Processing PAYMENT_OVERDUE: ${paymentId}`);\r\n\r\n    // Atualizar fatura para 'overdue'\r\n    await db.prepare(`\r\n        UPDATE invoices \r\n        SET status = 'overdue', updated_at = NOW()\r\n        WHERE gateway_invoice_id = ?\r\n    `).bind(paymentId).run();\r\n\r\n    // Se tiver subscription, atualizar status para 'past_due'\r\n    if (subscriptionId) {\r\n        await db.prepare(`\r\n            UPDATE subscriptions \r\n            SET status = 'past_due',\r\n                updated_at = NOW()\r\n            WHERE gateway_subscription_id = ? AND status = 'active'\r\n        `).bind(subscriptionId).run();\r\n    }\r\n}\r\n\r\nasync function handlePaymentRefunded(db: any, payload: AsaasWebhookPayload) {\r\n    if (!payload.payment) return;\r\n\r\n    const { id: paymentId } = payload.payment;\r\n\r\n    console.log(`[ASAAS-WEBHOOK] Processing PAYMENT_REFUNDED: ${paymentId}`);\r\n\r\n    await db.prepare(`\r\n        UPDATE invoices \r\n        SET status = 'refunded', updated_at = NOW()\r\n        WHERE gateway_invoice_id = ?\r\n    `).bind(paymentId).run();\r\n}\r\n\r\nasync function handleSubscriptionDeleted(db: any, payload: AsaasWebhookPayload) {\r\n    const subscriptionId = payload.subscription?.id || payload.payment?.subscription;\r\n\r\n    if (!subscriptionId) {\r\n        console.warn(\"[ASAAS-WEBHOOK] SUBSCRIPTION_DELETED without subscription id\");\r\n        return;\r\n    }\r\n\r\n    console.log(`[ASAAS-WEBHOOK] Processing SUBSCRIPTION_DELETED: ${subscriptionId}`);\r\n\r\n    await db.prepare(`\r\n        UPDATE subscriptions \r\n        SET status = 'canceled',\r\n            canceled_at = NOW(),\r\n            updated_at = NOW()\r\n        WHERE gateway_subscription_id = ?\r\n    `).bind(subscriptionId).run();\r\n}\r\n\r\n// ============================================================================\r\n// Health check endpoint for Asaas webhook verification\r\n// ============================================================================\r\nasaasWebhookRoutes.get(\"/\", (c) => {\r\n    return c.json({\r\n        status: \"ok\",\r\n        message: \"Asaas webhook endpoint ready\",\r\n        supported_events: [\r\n            \"PAYMENT_CONFIRMED\",\r\n            \"PAYMENT_RECEIVED\",\r\n            \"PAYMENT_OVERDUE\",\r\n            \"PAYMENT_REFUNDED\",\r\n            \"SUBSCRIPTION_DELETED\"\r\n        ]\r\n    });\r\n});\r\n\r\nexport default asaasWebhookRoutes;\r\n"},{"name":"audit-logger.ts","content":"\r\nexport async function logActivity(env: any, params: {\r\n    userId: string | number,\r\n    orgId: string | number | null,\r\n    actionType: string,\r\n    actionDescription: string,\r\n    targetType: string,\r\n    targetId: string | number | null,\r\n    metadata?: any,\r\n    req?: any\r\n}) {\r\n    try {\r\n        const ip = params.req?.header('cf-connecting-ip') || params.req?.header('x-forwarded-for') || 'unknown';\r\n        const ua = params.req?.header('user-agent') || 'unknown';\r\n\r\n        // Ensure metadata is stringified if object\r\n        const metadataStr = params.metadata ?\r\n            (typeof params.metadata === 'string' ? params.metadata : JSON.stringify(params.metadata))\r\n            : null;\r\n\r\n        await env.DB.prepare(`\r\n        INSERT INTO activity_log (\r\n            user_id, organization_id, action_type, action_description, \r\n            target_type, target_id, metadata, ip_address, user_agent, created_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n            params.userId,\r\n            params.orgId,\r\n            params.actionType,\r\n            params.actionDescription,\r\n            params.targetType,\r\n            params.targetId,\r\n            metadataStr,\r\n            ip,\r\n            ua\r\n        ).run();\r\n\r\n        console.log(`[AUDIT-LOG] Logged ${params.actionType} for ${params.targetType}:${params.targetId}`);\r\n    } catch (e) {\r\n        console.error('[AUDIT-LOG] Failed to log activity:', e);\r\n    }\r\n}\r\n"},{"name":"audit-routes.ts","content":"import { Hono } from 'hono';\r\nimport { tenantAuthMiddleware as authMiddleware } from './tenant-auth-middleware.ts';\r\n\r\n\r\ntype Env = {\r\n    DB: any;\r\n    [key: string]: any;\r\n};\r\n\r\nconst auditRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Middleware to ensure user has access to audit logs (System Admin or Org Admin)\r\nconst requireAuditAccess = async (c: any, next: any) => {\r\n    const user = c.get('user');\r\n    const role = user?.role || user?.profile?.role;\r\n    console.log(`[AUDIT] Auth check - User: ${user?.email}, Role: ${role}`);\r\n\r\n    if (!role || !['system_admin', 'sys_admin', 'org_admin', 'organization_admin'].includes(role)) {\r\n        return c.json({ error: `Acesso negado. Role '${role}' não autorizada.` }, 403);\r\n    }\r\n    await next();\r\n};\r\n\r\n\r\n\r\n// GET /api/audit/logs - List audit logs with filters\r\nauditRoutes.get('/logs', authMiddleware, requireAuditAccess, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get('user');\r\n    const userRole = user?.role || user?.profile?.role;\r\n    const userOrgId = user?.organization_id || user?.profile?.organization_id;\r\n\r\n    // Parse query parameters for filters\r\n    const url = new URL(c.req.url);\r\n    const page = parseInt(url.searchParams.get('page') || '1');\r\n    const limit = Math.min(parseInt(url.searchParams.get('limit') || '50'), 100);\r\n    const offset = (page - 1) * limit;\r\n\r\n    // Filters\r\n    const startDate = url.searchParams.get('start_date');\r\n    const endDate = url.searchParams.get('end_date');\r\n    const actionType = url.searchParams.get('action_type');\r\n    const targetType = url.searchParams.get('target_type');\r\n    const userId = url.searchParams.get('user_id');\r\n    const organizationIdQuery = url.searchParams.get('organization_id');\r\n    const search = url.searchParams.get('search');\r\n\r\n    try {\r\n        // Build dynamic query with filters\r\n        let whereConditions: string[] = [];\r\n        let params: any[] = [];\r\n        // paramIndex removed - wrapper handles sequential ? automatically\r\n\r\n        // Security: If org_admin, force filter by their organization_id\r\n        if (['org_admin', 'organization_admin'].includes(userRole)) {\r\n            if (!userOrgId) {\r\n                return c.json({ error: 'Usuário sem organização vinculada' }, 400);\r\n            }\r\n            whereConditions.push('al.organization_id = ?');\r\n            params.push(userOrgId);\r\n        } else if (organizationIdQuery) {\r\n            // If system admin and supplied organization_id filter\r\n            whereConditions.push('al.organization_id = ?');\r\n            params.push(parseInt(organizationIdQuery));\r\n        }\r\n\r\n        if (startDate) {\r\n            whereConditions.push('al.created_at >= ?');\r\n            params.push(startDate);\r\n        }\r\n        if (endDate) {\r\n            whereConditions.push('al.created_at <= ?');\r\n            params.push(endDate + 'T23:59:59Z');\r\n        }\r\n        if (actionType) {\r\n            whereConditions.push('al.action_type = ?');\r\n            params.push(actionType);\r\n        }\r\n        if (targetType) {\r\n            whereConditions.push('al.target_type = ?');\r\n            params.push(targetType);\r\n        }\r\n        if (userId) {\r\n            whereConditions.push('al.user_id = ?');\r\n            params.push(userId);\r\n        }\r\n        if (search) {\r\n            whereConditions.push('(al.action_description LIKE ? OR al.target_id LIKE ?)');\r\n            params.push(`%${search}%`);\r\n            params.push(`%${search}%`);\r\n        }\r\n\r\n        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';\r\n\r\n        // Get total count\r\n        const countQuery = `SELECT COUNT(*) as total FROM activity_log al ${whereClause}`;\r\n        const countResult = await env.DB.prepare(countQuery).bind(...params).first() as any;\r\n        const total = countResult?.total || 0;\r\n\r\n        // Get logs with user info\r\n        const logsQuery = `\r\n      SELECT \r\n        al.id,\r\n        al.user_id,\r\n        al.organization_id,\r\n        al.action_type,\r\n        al.action_description,\r\n        al.target_type,\r\n        al.target_id,\r\n        al.metadata,\r\n        al.created_at,\r\n        u.email as user_email,\r\n        u.name as user_name,\r\n        o.name as organization_name\r\n      FROM activity_log al\r\n      LEFT JOIN users u ON al.user_id = u.id\r\n      LEFT JOIN organizations o ON al.organization_id = o.id\r\n      ${whereClause}\r\n      ORDER BY al.created_at DESC\r\n      LIMIT ${limit} OFFSET ${offset}\r\n    `;\r\n\r\n        const logs = await env.DB.prepare(logsQuery).bind(...params).all();\r\n\r\n        return c.json({\r\n            logs: logs.results || [],\r\n            pagination: {\r\n                page,\r\n                limit,\r\n                total,\r\n                totalPages: Math.ceil(total / limit)\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching audit logs:', error);\r\n        return c.json({ error: 'Erro ao buscar logs de auditoria' }, 500);\r\n    }\r\n});\r\n\r\n// GET /api/audit/logs/:id - Get single log detail\r\nauditRoutes.get('/logs/:id', authMiddleware, requireAuditAccess, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get('user');\r\n    const userRole = user?.role || user?.profile?.role;\r\n    const userOrgId = user?.organization_id || user?.profile?.organization_id;\r\n    const logId = parseInt(c.req.param('id'));\r\n\r\n    try {\r\n        let query = `\r\n      SELECT \r\n        al.*,\r\n        u.email as user_email,\r\n        u.name as user_name,\r\n        o.name as organization_name\r\n      FROM activity_log al\r\n      LEFT JOIN users u ON al.user_id = u.id\r\n      LEFT JOIN organizations o ON al.organization_id = o.id\r\n      WHERE al.id = ?\r\n    `;\r\n\r\n        const params = [logId];\r\n\r\n        if (['org_admin', 'organization_admin'].includes(userRole)) {\r\n            query += ' AND al.organization_id = ?';\r\n            params.push(userOrgId);\r\n        }\r\n\r\n        const log = await env.DB.prepare(query).bind(...params).first();\r\n\r\n        if (!log) {\r\n            return c.json({ error: 'Log não encontrado ou acesso não autorizado' }, 404);\r\n        }\r\n\r\n        return c.json({ log });\r\n    } catch (error) {\r\n        console.error('Error fetching audit log:', error);\r\n        return c.json({ error: 'Erro ao buscar log de auditoria' }, 500);\r\n    }\r\n});\r\n\r\n// GET /api/audit/stats - Get audit statistics\r\nauditRoutes.get('/stats', authMiddleware, requireAuditAccess, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get('user');\r\n    const userRole = user?.role || user?.profile?.role;\r\n    const userOrgId = user?.organization_id || user?.profile?.organization_id;\r\n\r\n    const url = new URL(c.req.url);\r\n    const days = parseInt(url.searchParams.get('days') || '30');\r\n\r\n    try {\r\n        const startDate = new Date();\r\n        startDate.setDate(startDate.getDate() - days);\r\n        const startDateStr = startDate.toISOString();\r\n\r\n        let orgFilter = '';\r\n        let orgFilterTop = ''; // For queries where aliases might differ or direct modification is needed\r\n        let params: any[] = [startDateStr];\r\n\r\n        if (['org_admin', 'organization_admin'].includes(userRole)) {\r\n            orgFilter = 'AND organization_id = ?';\r\n            orgFilterTop = 'AND al.organization_id = ?';\r\n            params.push(userOrgId);\r\n        }\r\n\r\n        // Total events in period\r\n        const totalResult = await env.DB.prepare(`\r\n      SELECT COUNT(*) as total FROM activity_log WHERE created_at >= ? ${orgFilter}\r\n    `).bind(...params).first() as any;\r\n\r\n        // Events by action type\r\n        const byActionType = await env.DB.prepare(`\r\n      SELECT action_type, COUNT(*) as count \r\n      FROM activity_log \r\n      WHERE created_at >= ? ${orgFilter}\r\n      GROUP BY action_type \r\n      ORDER BY count DESC\r\n    `).bind(...params).all();\r\n\r\n        // Events by target type\r\n        const byTargetType = await env.DB.prepare(`\r\n      SELECT target_type, COUNT(*) as count \r\n      FROM activity_log \r\n      WHERE created_at >= ? AND target_type IS NOT NULL ${orgFilter}\r\n      GROUP BY target_type \r\n      ORDER BY count DESC\r\n    `).bind(...params).all();\r\n\r\n        // Top users by activity\r\n        const topUsersParams = [startDateStr];\r\n        if (['org_admin', 'organization_admin'].includes(userRole)) {\r\n            topUsersParams.push(userOrgId);\r\n        }\r\n\r\n        const topUsers = await env.DB.prepare(`\r\n      SELECT \r\n        al.user_id,\r\n        u.name as user_name,\r\n        u.email as user_email,\r\n        COUNT(*) as activity_count\r\n      FROM activity_log al\r\n      LEFT JOIN users u ON al.user_id = u.id\r\n      WHERE al.created_at >= ? AND al.user_id IS NOT NULL ${orgFilterTop}\r\n      GROUP BY al.user_id, u.name, u.email\r\n      ORDER BY activity_count DESC\r\n      LIMIT 10\r\n    `).bind(...topUsersParams).all();\r\n\r\n        // Daily activity for chart\r\n        const dailyActivity = await env.DB.prepare(`\r\n      SELECT \r\n        DATE(created_at) as date,\r\n        COUNT(*) as count\r\n      FROM activity_log\r\n      WHERE created_at >= ? ${orgFilter}\r\n      GROUP BY DATE(created_at)\r\n      ORDER BY date ASC\r\n    `).bind(...params).all();\r\n\r\n        // Security events\r\n        const securityEvents = await env.DB.prepare(`\r\n      SELECT COUNT(*) as count\r\n      FROM activity_log\r\n      WHERE created_at >= ? \r\n      AND (action_type LIKE '%FAILED%' OR action_type LIKE '%DENIED%' OR action_type LIKE '%UNAUTHORIZED%')\r\n      ${orgFilter}\r\n    `).bind(...params).first() as any;\r\n\r\n        return c.json({\r\n            period: { days, start_date: startDateStr },\r\n            total_events: totalResult?.total || 0,\r\n            by_action_type: byActionType.results || [],\r\n            by_target_type: byTargetType.results || [],\r\n            top_users: topUsers.results || [],\r\n            daily_activity: dailyActivity.results || [],\r\n            security_alerts: securityEvents?.count || 0\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching audit stats:', error);\r\n        return c.json({ error: 'Erro ao buscar estatísticas de auditoria' }, 500);\r\n    }\r\n});\r\n\r\n// GET /api/audit/export - Export logs as CSV\r\nauditRoutes.get('/export', authMiddleware, requireAuditAccess, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get('user');\r\n    const userRole = user?.role || user?.profile?.role;\r\n    const userOrgId = user?.organization_id || user?.profile?.organization_id;\r\n\r\n    const url = new URL(c.req.url);\r\n    const startDate = url.searchParams.get('start_date');\r\n    const endDate = url.searchParams.get('end_date');\r\n\r\n    try {\r\n        let whereConditions: string[] = [];\r\n        const params: any[] = [];\r\n        // paramIndex removed\r\n\r\n        if (['org_admin', 'organization_admin'].includes(userRole)) {\r\n            whereConditions.push('al.organization_id = ?');\r\n            params.push(userOrgId);\r\n        }\r\n\r\n        if (startDate) {\r\n            whereConditions.push('al.created_at >= ?');\r\n            params.push(startDate);\r\n        }\r\n        if (endDate) {\r\n            whereConditions.push('al.created_at <= ?');\r\n            params.push(endDate + 'T23:59:59Z');\r\n        }\r\n\r\n        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';\r\n\r\n        const logs = await env.DB.prepare(`\r\n      SELECT \r\n        al.id,\r\n        al.created_at,\r\n        u.email as user_email,\r\n        u.name as user_name,\r\n        al.action_type,\r\n        al.action_description,\r\n        al.target_type,\r\n        al.target_id,\r\n        o.name as organization_name\r\n      FROM activity_log al\r\n      LEFT JOIN users u ON al.user_id = u.id\r\n      LEFT JOIN organizations o ON al.organization_id = o.id\r\n      ${whereClause}\r\n      ORDER BY al.created_at DESC\r\n      LIMIT 10000\r\n    `).bind(...params).all();\r\n\r\n        // Build CSV\r\n        const headers = ['ID', 'Data/Hora', 'Usuário', 'Email', 'Ação', 'Descrição', 'Tipo Recurso', 'ID Recurso', 'Organização'];\r\n        const rows = (logs.results || []).map((log: any) => [\r\n            log.id,\r\n            log.created_at,\r\n            log.user_name || '',\r\n            log.user_email || '',\r\n            log.action_type || '',\r\n            (log.action_description || '').replace(/\"/g, '\"\"'),\r\n            log.target_type || '',\r\n            log.target_id || '',\r\n            log.organization_name || ''\r\n        ].map(val => `\"${val}\"`).join(','));\r\n\r\n        const csv = [headers.join(','), ...rows].join('\\n');\r\n\r\n        return new Response(csv, {\r\n            headers: {\r\n                'Content-Type': 'text/csv; charset=utf-8',\r\n                'Content-Disposition': `attachment; filename=\"audit_logs_${new Date().toISOString().split('T')[0]}.csv\"`\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error('Error exporting audit logs:', error);\r\n        return c.json({ error: 'Erro ao exportar logs de auditoria' }, 500);\r\n    }\r\n});\r\n\r\n// GET /api/audit/action-types - Get distinct action types for filter dropdown\r\nauditRoutes.get('/action-types', authMiddleware, requireAuditAccess, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get('user');\r\n    const userRole = user?.role || user?.profile?.role;\r\n    const userOrgId = user?.organization_id || user?.profile?.organization_id;\r\n\r\n    try {\r\n        let query = 'SELECT DISTINCT action_type FROM activity_log WHERE action_type IS NOT NULL';\r\n        const params: any[] = [];\r\n\r\n        if (['org_admin', 'organization_admin'].includes(userRole)) {\r\n            query += ' AND organization_id = ?';\r\n            params.push(userOrgId);\r\n        }\r\n\r\n        query += ' ORDER BY action_type';\r\n\r\n        const result = await env.DB.prepare(query).bind(...params).all();\r\n\r\n        return c.json({ action_types: (result.results || []).map((r: any) => r.action_type) });\r\n    } catch (error) {\r\n        console.error('Error fetching action types:', error);\r\n        return c.json({ error: 'Erro ao buscar tipos de ação' }, 500);\r\n    }\r\n});\r\n\r\n// GET /api/audit/target-types - Get distinct target types for filter dropdown\r\nauditRoutes.get('/target-types', authMiddleware, requireAuditAccess, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get('user');\r\n    const userRole = user?.role || user?.profile?.role;\r\n    const userOrgId = user?.organization_id || user?.profile?.organization_id;\r\n\r\n    try {\r\n        let query = 'SELECT DISTINCT target_type FROM activity_log WHERE target_type IS NOT NULL';\r\n        const params: any[] = [];\r\n\r\n        if (['org_admin', 'organization_admin'].includes(userRole)) {\r\n            query += ' AND organization_id = ?';\r\n            params.push(userOrgId);\r\n        }\r\n\r\n        query += ' ORDER BY target_type';\r\n\r\n        const result = await env.DB.prepare(query).bind(...params).all();\r\n\r\n        return c.json({ target_types: (result.results || []).map((r: any) => r.target_type) });\r\n    } catch (error) {\r\n        console.error('Error fetching target types:', error);\r\n        return c.json({ error: 'Erro ao buscar tipos de recurso' }, 500);\r\n    }\r\n});\r\n\r\nexport { auditRoutes };\r\n"},{"name":"auth-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { setCookie, deleteCookie, getCookie } from \"hono/cookie\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\n\r\n\r\nconst authRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\nconsole.log('[AUTH-ROUTES] Auth routes module loaded, typeof:', typeof authRoutes);\r\n\r\n// Helper para hash de senha SEGURO usando PBKDF2 (recomendado para senhas)\r\n// PBKDF2 é lento por design, dificultando ataques de força bruta\r\nconst PBKDF2_ITERATIONS = 100000;\r\nconst SALT_LENGTH = 16;\r\n\r\nasync function hashPassword(password: string, existingSalt?: string): Promise<string> {\r\n    const encoder = new TextEncoder();\r\n\r\n    // Gerar salt ou usar existente (para verificação)\r\n    let salt: Uint8Array;\r\n    if (existingSalt) {\r\n        salt = new Uint8Array(existingSalt.match(/.{2}/g)!.map(byte => parseInt(byte, 16)));\r\n    } else {\r\n        salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));\r\n    }\r\n\r\n    // Importar senha como chave\r\n    const keyMaterial = await crypto.subtle.importKey(\r\n        'raw',\r\n        encoder.encode(password),\r\n        'PBKDF2',\r\n        false,\r\n        ['deriveBits']\r\n    );\r\n\r\n    // Derivar hash com PBKDF2\r\n    const hashBuffer = await crypto.subtle.deriveBits(\r\n        {\r\n            name: 'PBKDF2',\r\n            salt: salt,\r\n            iterations: PBKDF2_ITERATIONS,\r\n            hash: 'SHA-256'\r\n        },\r\n        keyMaterial,\r\n        256\r\n    );\r\n\r\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n    const saltHex = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('');\r\n    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n\r\n    // Formato: salt$hash (permite extrair salt para verificação)\r\n    return `${saltHex}$${hashHex}`;\r\n}\r\n\r\n// Função para verificar senha contra hash armazenado\r\nasync function verifyPassword(password: string, storedHash: string): Promise<boolean> {\r\n    // Hash antigo (SHA-256 puro) não tem '$'\r\n    if (!storedHash.includes('$')) {\r\n        // Compatibilidade: verificar com SHA-256 legado\r\n        const msgBuffer = new TextEncoder().encode(password);\r\n        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);\r\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n        const legacyHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n        return legacyHash === storedHash;\r\n    }\r\n\r\n    // Hash novo (PBKDF2): extrair salt e verificar\r\n    const [salt] = storedHash.split('$');\r\n    const newHash = await hashPassword(password, salt);\r\n    return newHash === storedHash;\r\n}\r\n\r\n// Debug endpoint to check permissions\r\nauthRoutes.get(\"/debug-permissions\", tenantAuthMiddleware, (c) => {\r\n    const tenantContext = c.get(\"tenantContext\");\r\n    const user = c.get(\"user\");\r\n    return c.json({\r\n        user_id: user?.id,\r\n        role: user?.role,\r\n        tenant_context: tenantContext\r\n    });\r\n});\r\n\r\n// Get current user details - supports both Supabase auth and session cookie\r\nauthRoutes.get(\"/me\", async (c) => {\r\n    const env = c.env;\r\n\r\n    // 1. Try Supabase auth user first (for Google login)\r\n    let user = c.get('user');\r\n\r\n    // 2. If no Supabase user, check session cookie (for email/password login)\r\n    // SEGURANÇA: dev-session só é aceito em ambiente de desenvolvimento\r\n    // Fail Secure: Assume produção (false) a menos que explicitamente 'development'\r\n    const isDevelopment = Deno.env.get('ENVIRONMENT') === 'development';\r\n\r\n    if (!user) {\r\n        const sessionToken = getCookie(c, 'mocha-session-token');\r\n        if (sessionToken && sessionToken.startsWith('dev-session-') && isDevelopment) {\r\n            const userId = sessionToken.replace('dev-session-', '');\r\n            // Validate session by looking up user in DB\r\n            const dbUser = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(userId).first();\r\n            if (dbUser) {\r\n                user = { id: dbUser.id, email: dbUser.email };\r\n            }\r\n        } else if (sessionToken && sessionToken.startsWith('dev-session-') && !isDevelopment) {\r\n            console.warn('[AUTH-ROUTES] BLOQUEADO: Tentativa de usar dev-session em produção');\r\n        }\r\n    }\r\n\r\n    if (!user) {\r\n        return c.json({ user: null }); // Return null user instead of 401 for session checks\r\n    }\r\n\r\n    try {\r\n        // Fetch full user details from DB to get role/name\r\n        const dbUser = await env.DB.prepare(\"SELECT * FROM users WHERE id = ? OR email = ?\").bind(user.id, user.email).first();\r\n\r\n        if (!dbUser) {\r\n            return c.json({ user: null });\r\n        }\r\n\r\n        // VERIFICAÇÃO CRÍTICA: Bloquear usuários pendentes\r\n        if (dbUser.approval_status === 'pending') {\r\n            return c.json({\r\n                error: \"Conta em análise\",\r\n                message: \"Sua conta aguarda aprovação do administrador.\",\r\n                code: \"APPROVAL_PENDING\",\r\n                approval_status: \"pending\",\r\n                user: null\r\n            }, 403);\r\n        } else if (dbUser.approval_status === 'rejected') {\r\n            return c.json({\r\n                error: \"Conta recusada\",\r\n                message: \"Sua solicitação de cadastro foi recusada.\",\r\n                code: \"APPROVAL_REJECTED\",\r\n                approval_status: \"rejected\",\r\n                user: null\r\n            }, 403);\r\n        }\r\n\r\n        // Build profile object as expected by frontend\r\n        const profile = {\r\n            id: dbUser.id,\r\n            email: dbUser.email,\r\n            name: dbUser.name,\r\n            role: dbUser.role,\r\n            organization_id: dbUser.organization_id,\r\n            can_manage_users: dbUser.can_manage_users,\r\n            can_create_organizations: dbUser.can_create_organizations,\r\n            is_active: dbUser.is_active,\r\n            managed_organization_id: dbUser.managed_organization_id,\r\n            created_at: dbUser.created_at,\r\n            updated_at: dbUser.updated_at,\r\n            profile_completed: true,\r\n            approval_status: dbUser.approval_status\r\n        };\r\n\r\n        // Helper to extract Google Data\r\n        let googleUserData = null;\r\n        console.log('[AUTH-ME] User object keys:', user ? Object.keys(user) : 'null');\r\n        console.log('[AUTH-ME] User metadata:', user ? (user as any).user_metadata : 'null');\r\n\r\n        if (user && (user as any).user_metadata) {\r\n            const meta = (user as any).user_metadata;\r\n            console.log('[AUTH-ME] Meta keys:', Object.keys(meta));\r\n            if (meta.picture || meta.avatar_url) {\r\n                googleUserData = {\r\n                    picture: meta.picture || meta.avatar_url,\r\n                    name: meta.full_name || meta.name\r\n                };\r\n                console.log('[AUTH-ME] Extracted google_user_data:', googleUserData);\r\n\r\n                // NOVO: Persistir avatar_url na tabela users se ainda não existir\r\n                if (!dbUser.avatar_url && googleUserData.picture) {\r\n                    try {\r\n                        await env.DB.prepare(`\r\n                            UPDATE users SET avatar_url = ?, updated_at = NOW() WHERE id = ?\r\n                        `).bind(googleUserData.picture, dbUser.id).run();\r\n                        console.log('[AUTH-ME] Avatar URL persistido para usuário:', dbUser.id);\r\n                    } catch (avatarErr) {\r\n                        console.error('[AUTH-ME] Erro ao persistir avatar:', avatarErr);\r\n                    }\r\n                }\r\n            }\r\n        } else if ((user as any).google_user_data) {\r\n            // Fallback if attached by middleware (though middleware might not run here)\r\n            googleUserData = (user as any).google_user_data;\r\n        }\r\n\r\n        // Fetch accessible organizations\r\n        // SYS_ADMIN gets ALL organizations, others get only their assigned ones\r\n        let accessibleOrganizations: any[] = [];\r\n        try {\r\n            const isSysAdmin = ['sys_admin', 'system_admin', 'admin'].includes(dbUser.role?.toLowerCase());\r\n\r\n            if (isSysAdmin) {\r\n                // System Admin: Get ALL active organizations\r\n                accessibleOrganizations = await env.DB.prepare(`\r\n                    SELECT o.id, o.name, o.type, o.organization_level, 'sys_admin' as role, false as is_primary\r\n                    FROM organizations o\r\n                    WHERE o.is_active = true\r\n                    ORDER BY o.name ASC\r\n                `).all().then((res: any) => res.results || []);\r\n                console.log(`[AUTH-ME] SysAdmin ${dbUser.email} has access to ${accessibleOrganizations.length} organizations`);\r\n            } else {\r\n                // Regular users: Get only assigned organizations\r\n                accessibleOrganizations = await env.DB.prepare(`\r\n                    SELECT o.id, o.name, o.type, o.organization_level, uo.role, uo.is_primary\r\n                    FROM organizations o\r\n                    JOIN user_organizations uo ON o.id = uo.organization_id\r\n                    WHERE uo.user_id = ? AND o.is_active = true\r\n                `).bind(dbUser.id).all().then((res: any) => res.results || []);\r\n            }\r\n        } catch (e) {\r\n            console.error('[AUTH-ME] Error fetching user organizations:', e);\r\n        }\r\n\r\n        return c.json({\r\n            success: true,\r\n            user: {\r\n                id: dbUser.id,\r\n                email: dbUser.email,\r\n                name: dbUser.name,\r\n                role: dbUser.role,\r\n                approval_status: dbUser.approval_status,\r\n                profile: profile, // Frontend expects user.profile.role\r\n                google_user_data: googleUserData, // Pass Verified Google Data\r\n                organizations: accessibleOrganizations // N-to-N Orgs list\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching user /me:', error);\r\n        return c.json({ error: \"Server error\" }, 500);\r\n    }\r\n});\r\n\r\n// Registro de usuário\r\nauthRoutes.post(\"/register\", async (c) => {\r\n    const env = c.env;\r\n\r\n    try {\r\n        const { email, password, name, organization_name, role } = await c.req.json();\r\n\r\n        if (!email || !password || !name) {\r\n            return c.json({ error: \"Email, senha e nome são obrigatórios\" }, 400);\r\n        }\r\n\r\n        // Database initialization removed (migrated to Postgres)\r\n\r\n        // Verificar se usuário já existe\r\n        const existingUser = await env.DB.prepare(\"SELECT id FROM users WHERE email = ?\").bind(email).first();\r\n\r\n        if (existingUser) {\r\n            return c.json({ error: \"Email já cadastrado\" }, 409);\r\n        }\r\n\r\n        // Criar ID único\r\n        const userId = crypto.randomUUID();\r\n        const passwordHash = await hashPassword(password);\r\n\r\n        // Verificar se é o usuário Admin de Bootstrap\r\n        const isBootstrapAdmin = email === 'eng.tiagosm@gmail.com';\r\n\r\n        // Definir Role Inicial\r\n        let initialRole = role || 'inspector';\r\n\r\n        // Se estiver criando organização, força ser Admin da Org\r\n        if (organization_name) {\r\n            initialRole = 'org_admin';\r\n        }\r\n\r\n        // Sanitização de segurança: Impedir criação direta de SysAdmin via API\r\n        if (initialRole === 'sys_admin' || initialRole === 'system_admin') {\r\n            if (isBootstrapAdmin) {\r\n                initialRole = 'sys_admin'; // Permitido apenas para o e-mail mestre\r\n            } else {\r\n                initialRole = 'org_admin'; // Downgrade seguro\r\n            }\r\n        }\r\n\r\n        // Definir Status: SEMPRE pendente, exceto o bootstrap admin\r\n        const initialStatus = isBootstrapAdmin ? 'approved' : 'pending';\r\n\r\n        // 1. Criar usuário (Agora com role dinâmico e status forçado)\r\n        await env.DB.prepare(`\r\n          INSERT INTO users (id, email, name, role, approval_status, created_at, updated_at)\r\n          VALUES (?, ?, ?, ?, ?, NOW(), NOW())\r\n        `).bind(userId, email, name, initialRole, initialStatus).run();\r\n\r\n        // 2. Criar credenciais\r\n        await env.DB.prepare(`\r\n          INSERT INTO user_credentials (user_id, password_hash, created_at, updated_at)\r\n          VALUES (?, ?, NOW(), NOW())\r\n        `).bind(userId, passwordHash).run();\r\n\r\n        // 3. Se forneceu nome da organização, criar e vincular\r\n        if (organization_name) {\r\n            const orgResult = await env.DB.prepare(`\r\n                INSERT INTO organizations (name, type, created_at, updated_at)\r\n                VALUES (?, 'company', NOW(), NOW())\r\n            `).bind(organization_name).run();\r\n\r\n            const orgId = orgResult.meta.last_row_id;\r\n\r\n            // Vincular usuário à organização criada\r\n            await env.DB.prepare(`\r\n                UPDATE users \r\n                SET organization_id = ?, can_manage_users = true, can_create_organizations = true\r\n                WHERE id = ?\r\n            `).bind(orgId, userId).run();\r\n        }\r\n\r\n        // NOTIFICAÇÃO: Avisar SysAdmins sobre novo cadastro urgente\r\n        try {\r\n            const sysAdmins = await env.DB.prepare(\"SELECT id FROM users WHERE role IN ('sys_admin', 'system_admin')\").all();\r\n            if (sysAdmins && sysAdmins.results) {\r\n                const notifications = sysAdmins.results.map((admin: any) => ({\r\n                    user_id: admin.id,\r\n                    title: \"Novo Cadastro Pendente\",\r\n                    message: `O usuário ${name} (${email}) se cadastrou e aguarda aprovação.`,\r\n                    type: \"info\",\r\n                    link: \"/users\"\r\n                }));\r\n\r\n                // Bulk insert or loop\r\n                for (const notif of notifications) {\r\n                    await env.DB.prepare(`\r\n                        INSERT INTO notifications (user_id, title, message, type, link) VALUES (?, ?, ?, ?, ?)\r\n                    `).bind(notif.user_id, notif.title, notif.message, notif.type, notif.link).run();\r\n                }\r\n            }\r\n        } catch (notifError) {\r\n            console.error(\"Falha ao criar notificação para admins:\", notifError);\r\n            // Non-blocking error\r\n        }\r\n\r\n        // TRIGGER EMAIL: Send welcome email (Pending Approval)\r\n        try {\r\n            const supabaseUrl = Deno.env.get('SUPABASE_URL');\r\n            const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY');\r\n\r\n            if (supabaseUrl && supabaseAnonKey) {\r\n                fetch(`${supabaseUrl}/functions/v1/send-email`, {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                        'Authorization': `Bearer ${supabaseAnonKey}`\r\n                    },\r\n                    body: JSON.stringify({\r\n                        type: 'welcome_pending',\r\n                        payload: { email, name }\r\n                    })\r\n                }).catch(err => console.error(\"Failed to trigger welcome email:\", err));\r\n            }\r\n        } catch (emailErr) {\r\n            console.error(\"Error triggering welcome email:\", emailErr);\r\n        }\r\n\r\n        return c.json({\r\n            success: true,\r\n            message: \"Conta criada com sucesso. Aguardando aprovação do administrador.\",\r\n            requires_approval: true,\r\n            user: { id: userId, email, name }\r\n        }, 201);\r\n\r\n    } catch (error) {\r\n        console.error('Erro no registro:', error);\r\n        return c.json({ error: \"Erro ao criar conta\" }, 500);\r\n    }\r\n});\r\n\r\n// Login\r\nauthRoutes.post(\"/login\", async (c) => {\r\n    const env = c.env;\r\n\r\n    try {\r\n        const { email, password } = await c.req.json();\r\n\r\n        if (!email || !password) {\r\n            return c.json({ error: \"Email e senha são obrigatórios\" }, 400);\r\n        }\r\n\r\n        // initializeDatabase(env) removed\r\n\r\n        // Buscar usuário e verificar status de aprovação\r\n        const user = await env.DB.prepare(\"SELECT * FROM users WHERE email = ?\").bind(email).first();\r\n\r\n        if (!user) {\r\n            return c.json({ error: \"Credenciais inválidas\" }, 401);\r\n        }\r\n\r\n        // VERIFICAÇÃO DE APROVAÇÃO\r\n        if (user.approval_status === 'pending') {\r\n            return c.json({\r\n                error: \"Conta em análise\",\r\n                message: \"Sua conta aguarda aprovação do administrador.\",\r\n                code: \"APPROVAL_PENDING\"\r\n            }, 403);\r\n        } else if (user.approval_status === 'rejected') {\r\n            return c.json({\r\n                error: \"Conta recusada\",\r\n                message: \"Sua solicitação de cadastro foi recusada.\",\r\n                code: \"APPROVAL_REJECTED\"\r\n            }, 403);\r\n        }\r\n\r\n        // Verificar senha\r\n        const credentials = await env.DB.prepare(\"SELECT password_hash FROM user_credentials WHERE user_id = ?\").bind(user.id).first();\r\n\r\n        if (!credentials) {\r\n            // Usuário existe mas sem senha (login social?)\r\n            return c.json({ error: \"Este usuário deve fazer login via Google\" }, 401);\r\n        }\r\n\r\n        // Verificar senha (suporta hash novo PBKDF2 e legado SHA-256)\r\n        const isValidPassword = await verifyPassword(password, credentials.password_hash as string);\r\n\r\n        if (!isValidPassword) {\r\n            return c.json({ error: \"Credenciais inválidas\" }, 401);\r\n        }\r\n\r\n\r\n        // Login sucesso\r\n        // Atualizar last_login\r\n        await env.DB.prepare(\"UPDATE user_credentials SET last_login_at = NOW() WHERE user_id = ?\").bind(user.id).run();\r\n\r\n        // SEGURANÇA: Gerar token de sessão com UUID criptográfico (não previsível)\r\n        const sessionToken = crypto.randomUUID();\r\n\r\n        // SEGURANÇA: Armazenar sessão no banco para validação futura\r\n        try {\r\n            await env.DB.prepare(`\r\n                INSERT INTO user_sessions (id, user_id, token, created_at, expires_at)\r\n                VALUES (?, ?, ?, NOW(), NOW() + INTERVAL '7 days')\r\n            `).bind(crypto.randomUUID(), user.id, sessionToken).run();\r\n        } catch (sessionErr) {\r\n            console.warn('[AUTH] Não foi possível salvar sessão no banco (tabela pode não existir):', sessionErr);\r\n        }\r\n\r\n        // SEGURANÇA: Cookie secure dinâmico baseado no ambiente\r\n        const isProduction = Deno.env.get('ENVIRONMENT') !== 'development';\r\n\r\n        setCookie(c, \"mocha-session-token\", sessionToken, {\r\n            httpOnly: true,\r\n            path: \"/\",\r\n            sameSite: \"Lax\",\r\n            secure: isProduction, // true em produção, false em dev\r\n            maxAge: 60 * 60 * 24 * 7 // 7 dias\r\n        });\r\n\r\n        return c.json({\r\n            success: true,\r\n            user: {\r\n                id: user.id,\r\n                email: user.email,\r\n                name: user.name,\r\n                role: user.role\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Erro no login:', error);\r\n        return c.json({ error: \"Erro ao realizar login\" }, 500);\r\n    }\r\n});\r\n\r\n// Logout\r\nauthRoutes.post(\"/logout\", async (c) => {\r\n    deleteCookie(c, \"mocha-session-token\");\r\n    return c.json({ success: true });\r\n});\r\n\r\nexport default authRoutes;\r\n\r\n"},{"name":"auto-organize-folders.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\n\r\nconst autoOrganizeRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Função para extrair categoria/NR do nome do checklist\r\nfunction extractFolderName(templateName: string, category?: string): string | null {\r\n    // Se categoria já existe, usar ela\r\n    if (category && category.trim() !== '') {\r\n        return category.trim();\r\n    }\r\n\r\n    // Padrões comuns de NRs no nome\r\n    const nrPatterns = [\r\n        /^(NR[-\\s]?\\d{2})/i,           // NR-06, NR 06, NR06\r\n        /^(NR[-\\s]?\\d{2}[-\\s]?[A-Z]?)/i, // NR-12-A, NR 35 A\r\n        /\\((NR[-\\s]?\\d{2})\\)/i,        // (NR-06)\r\n    ];\r\n\r\n    for (const pattern of nrPatterns) {\r\n        const match = templateName.match(pattern);\r\n        if (match) {\r\n            // Normalizar formato: \"NR-XX\"\r\n            const nr = match[1].replace(/\\s+/g, '-').toUpperCase();\r\n            return nr;\r\n        }\r\n    }\r\n\r\n    // Se não encontrou NR, tentar extrair primeira parte antes de \" - \"\r\n    const parts = templateName.split(' - ');\r\n    if (parts.length > 1 && parts[0].length < 50) {\r\n        return parts[0].trim();\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n// Função para gerar slug único\r\nfunction generateSlug(name: string, existing: string[] = []): string {\r\n    let baseSlug = name\r\n        .toLowerCase()\r\n        .normalize('NFD')\r\n        .replace(/[\\u0300-\\u036f]/g, '') // Remove acentos\r\n        .replace(/[^a-z0-9]/g, '-')\r\n        .replace(/-+/g, '-')\r\n        .replace(/^-|-$/g, '');\r\n\r\n    let slug = baseSlug;\r\n    let counter = 1;\r\n\r\n    while (existing.includes(slug)) {\r\n        slug = `${baseSlug}-${counter}`;\r\n        counter++;\r\n    }\r\n\r\n    return slug;\r\n}\r\n\r\n// Endpoint para organizar automaticamente um template em pasta\r\nautoOrganizeRoutes.post(\"/auto-organize/:templateId\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const templateId = c.req.param(\"templateId\");\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    try {\r\n        // Buscar perfil do usuário\r\n        let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n        if (!userProfile && (user as any).profile) {\r\n            userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n        }\r\n\r\n        if (!userProfile?.organization_id) {\r\n            return c.json({ error: \"Usuário não possui organização\" }, 403);\r\n        }\r\n\r\n        // Buscar template\r\n        const template = await env.DB.prepare(`\r\n      SELECT id, name, category, folder_id, organization_id\r\n      FROM checklist_templates \r\n      WHERE id = ? AND organization_id = ?\r\n    `).bind(templateId, userProfile.organization_id).first() as any;\r\n\r\n        if (!template) {\r\n            return c.json({ error: \"Template não encontrado\" }, 404);\r\n        }\r\n\r\n        // Se já está em uma pasta, não fazer nada\r\n        if (template.folder_id) {\r\n            return c.json({\r\n                message: \"Template já está organizado em pasta\",\r\n                folder_id: template.folder_id\r\n            });\r\n        }\r\n\r\n        // Extrair nome da pasta\r\n        const folderName = extractFolderName(template.name, template.category);\r\n\r\n        if (!folderName) {\r\n            return c.json({\r\n                message: \"Não foi possível determinar pasta automaticamente\",\r\n                organized: false\r\n            });\r\n        }\r\n\r\n        // Verificar se pasta já existe\r\n        let folder = await env.DB.prepare(`\r\n      SELECT id FROM checklist_folders \r\n      WHERE organization_id = ? AND name = ? AND parent_id IS NULL\r\n    `).bind(userProfile.organization_id, folderName).first() as any;\r\n\r\n        let folderId: string;\r\n\r\n        if (!folder) {\r\n            // Criar nova pasta\r\n            const existingSlugs = await env.DB.prepare(`\r\n        SELECT slug FROM checklist_folders \r\n        WHERE organization_id = ? AND parent_id IS NULL\r\n      `).bind(userProfile.organization_id).all();\r\n\r\n            const slugs = existingSlugs.results.map((r: any) => r.slug);\r\n            const slug = generateSlug(folderName, slugs);\r\n            const path = `/${slug}`;\r\n\r\n            const result = await env.DB.prepare(`\r\n        INSERT INTO checklist_folders (\r\n          organization_id, parent_id, name, slug, path, description,\r\n          color, icon, display_order, created_at, updated_at\r\n        ) VALUES (?, NULL, ?, ?, ?, ?, '#3B82F6', 'folder', 0, NOW(), NOW())\r\n      `).bind(\r\n                userProfile.organization_id,\r\n                folderName,\r\n                slug,\r\n                path,\r\n                `Pasta criada automaticamente para ${folderName}`\r\n            ).run();\r\n\r\n            folderId = result.meta.last_row_id as string;\r\n        } else {\r\n            folderId = folder.id;\r\n        }\r\n\r\n        // Mover template para a pasta\r\n        await env.DB.prepare(`\r\n      UPDATE checklist_templates \r\n      SET folder_id = ?, updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(folderId, templateId).run();\r\n\r\n        return c.json({\r\n            message: \"Template organizado automaticamente\",\r\n            folder_name: folderName,\r\n            folder_id: folderId,\r\n            organized: true\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Error auto-organizing template:', error);\r\n        return c.json({ error: \"Failed to auto-organize template\" }, 500);\r\n    }\r\n});\r\n\r\n// Endpoint para organizar TODOS os templates não organizados\r\nautoOrganizeRoutes.post(\"/auto-organize-all\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    try {\r\n        // Buscar perfil do usuário\r\n        let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n        if (!userProfile && (user as any).profile) {\r\n            userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n        }\r\n\r\n        if (!userProfile?.organization_id) {\r\n            return c.json({ error: \"Usuário não possui organização\" }, 403);\r\n        }\r\n\r\n        // Buscar todos os templates sem pasta\r\n        const templates = await env.DB.prepare(`\r\n      SELECT id, name, category\r\n      FROM checklist_templates \r\n      WHERE organization_id = ? AND folder_id IS NULL AND is_category_folder = false\r\n    `).bind(userProfile.organization_id).all();\r\n\r\n        let organized = 0;\r\n        let skipped = 0;\r\n        const foldersCreated: Set<string> = new Set();\r\n\r\n        for (const template of templates.results as any[]) {\r\n            const folderName = extractFolderName(template.name, template.category);\r\n\r\n            if (!folderName) {\r\n                skipped++;\r\n                continue;\r\n            }\r\n\r\n            // Verificar se pasta já existe\r\n            let folder = await env.DB.prepare(`\r\n        SELECT id FROM checklist_folders \r\n        WHERE organization_id = ? AND name = ? AND parent_id IS NULL\r\n      `).bind(userProfile.organization_id, folderName).first() as any;\r\n\r\n            let folderId: string;\r\n\r\n            if (!folder) {\r\n                // Criar nova pasta\r\n                const existingSlugs = await env.DB.prepare(`\r\n          SELECT slug FROM checklist_folders \r\n          WHERE organization_id = ? AND parent_id IS NULL\r\n        `).bind(userProfile.organization_id).all();\r\n\r\n                const slugs = existingSlugs.results.map((r: any) => r.slug);\r\n                const slug = generateSlug(folderName, slugs);\r\n                const path = `/${slug}`;\r\n\r\n                const result = await env.DB.prepare(`\r\n          INSERT INTO checklist_folders (\r\n            organization_id, parent_id, name, slug, path, description,\r\n            color, icon, display_order, created_at, updated_at\r\n          ) VALUES (?, NULL, ?, ?, ?, ?, '#3B82F6', 'folder', 0, NOW(), NOW())\r\n        `).bind(\r\n                    userProfile.organization_id,\r\n                    folderName,\r\n                    slug,\r\n                    path,\r\n                    `Pasta criada automaticamente para ${folderName}`\r\n                ).run();\r\n\r\n                folderId = result.meta.last_row_id as string;\r\n                foldersCreated.add(folderName);\r\n            } else {\r\n                folderId = folder.id;\r\n            }\r\n\r\n            // Mover template para a pasta\r\n            await env.DB.prepare(`\r\n        UPDATE checklist_templates \r\n        SET folder_id = ?, updated_at = NOW()\r\n        WHERE id = ?\r\n      `).bind(folderId, template.id).run();\r\n\r\n            organized++;\r\n        }\r\n\r\n        return c.json({\r\n            message: \"Organização automática concluída\",\r\n            templates_organized: organized,\r\n            templates_skipped: skipped,\r\n            folders_created: foldersCreated.size,\r\n            folder_names: Array.from(foldersCreated)\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Error auto-organizing all templates:', error);\r\n        return c.json({ error: \"Failed to auto-organize templates\" }, 500);\r\n    }\r\n});\r\n\r\nexport default autoOrganizeRoutes;\r\n\r\n"},{"name":"autosuggest-routes.ts","content":"import { Hono } from 'hono';\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\n\r\nconst autosuggest = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\ntype Env = {\r\n  DB: any;\r\n};\r\n\r\n// Companies autosuggest - now returns recent companies when search is empty\r\nautosuggest.get(\"/companies\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const search = c.req.query(\"search\") || \"\";\r\n\r\n  try {\r\n    const user = c.get(\"user\");\r\n    if (!user) {\r\n      return c.json({ suggestions: [] });\r\n    }\r\n\r\n    // Get user profile to check organization access\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    const isSystemAdmin = userProfile?.role === 'system_admin' || userProfile?.role === 'sys_admin' || userProfile?.role === 'admin';\r\n\r\n    let companies;\r\n\r\n    if (isSystemAdmin) {\r\n      // System admin can see all organizations\r\n      if (search.trim()) {\r\n        // With search term - filter by name\r\n        companies = await env.DB.prepare(`\r\n          SELECT DISTINCT \r\n            COALESCE(o.nome_fantasia, o.name) as value, \r\n            COALESCE(o.nome_fantasia, o.name) as label, \r\n            o.contact_email as email,\r\n            o.address,\r\n            o.id as org_id\r\n          FROM organizations o\r\n          WHERE (COALESCE(o.nome_fantasia, o.name) LIKE ? OR o.razao_social LIKE ?)\r\n            AND o.is_active = true\r\n          ORDER BY COALESCE(o.nome_fantasia, o.name) \r\n          LIMIT 10\r\n        `).bind(`%${search}%`, `%${search}%`).all();\r\n      } else {\r\n        // No search term - return all active companies ordered by name\r\n        companies = await env.DB.prepare(`\r\n          SELECT DISTINCT \r\n            COALESCE(o.nome_fantasia, o.name) as value, \r\n            COALESCE(o.nome_fantasia, o.name) as label, \r\n            o.contact_email as email,\r\n            o.address,\r\n            o.id as org_id\r\n          FROM organizations o\r\n          WHERE o.is_active = true\r\n          ORDER BY COALESCE(o.nome_fantasia, o.name) \r\n          LIMIT 10\r\n        `).all();\r\n      }\r\n    } else {\r\n      // Non-admin users: get organizations from user_organizations table\r\n      if (search.trim()) {\r\n        companies = await env.DB.prepare(`\r\n          SELECT DISTINCT \r\n            COALESCE(o.nome_fantasia, o.name) as value, \r\n            COALESCE(o.nome_fantasia, o.name) as label, \r\n            o.contact_email as email,\r\n            o.address,\r\n            o.id as org_id\r\n          FROM organizations o\r\n          INNER JOIN user_organizations uo ON uo.organization_id = o.id\r\n          WHERE uo.user_id = ?\r\n            AND uo.is_active = true\r\n            AND o.is_active = true\r\n            AND (COALESCE(o.nome_fantasia, o.name) LIKE ? OR o.razao_social LIKE ?)\r\n          ORDER BY COALESCE(o.nome_fantasia, o.name) \r\n          LIMIT 10\r\n        `).bind(user.id, `%${search}%`, `%${search}%`).all();\r\n      } else {\r\n        // No search - return all companies user has access to\r\n        companies = await env.DB.prepare(`\r\n          SELECT DISTINCT \r\n            COALESCE(o.nome_fantasia, o.name) as value, \r\n            COALESCE(o.nome_fantasia, o.name) as label, \r\n            o.contact_email as email,\r\n            o.address,\r\n            o.id as org_id\r\n          FROM organizations o\r\n          INNER JOIN user_organizations uo ON uo.organization_id = o.id\r\n          WHERE uo.user_id = ?\r\n            AND uo.is_active = true\r\n            AND o.is_active = true\r\n          ORDER BY COALESCE(o.nome_fantasia, o.name) \r\n          LIMIT 10\r\n        `).bind(user.id).all();\r\n      }\r\n\r\n      // If no results from user_organizations, try user's primary organization\r\n      if ((!companies.results || companies.results.length === 0) && userProfile?.organization_id) {\r\n        companies = await env.DB.prepare(`\r\n          SELECT DISTINCT \r\n            COALESCE(o.nome_fantasia, o.name) as value, \r\n            COALESCE(o.nome_fantasia, o.name) as label, \r\n            o.contact_email as email,\r\n            o.address,\r\n            o.id as org_id\r\n          FROM organizations o\r\n          WHERE o.id = ?\r\n            OR o.parent_organization_id = ?\r\n          ORDER BY COALESCE(o.nome_fantasia, o.name) \r\n          LIMIT 10\r\n        `).bind(userProfile.organization_id, userProfile.organization_id).all();\r\n      }\r\n    }\r\n\r\n    const results = (companies.results || []).slice(0, 10);\r\n    console.log('[AUTOSUGGEST] Companies results:', JSON.stringify(results));\r\n\r\n    return c.json({\r\n      suggestions: results\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching company suggestions:', error);\r\n    return c.json({ suggestions: [] });\r\n  }\r\n});\r\n\r\n\r\n// Inspector suggestions\r\nautosuggest.get('/inspectors', tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const search = c.req.query('search') || '';\r\n\r\n  try {\r\n    const user = c.get(\"user\");\r\n    if (!user) {\r\n      return c.json({ suggestions: [] });\r\n    }\r\n\r\n    // First search in registered users (high priority)\r\n    const userResults = await env.DB.prepare(\r\n      `SELECT \r\n              name as value, \r\n              name as label, \r\n              email,\r\n              100 as priority\r\n       FROM users \r\n       WHERE (name LIKE ? OR email LIKE ?) \r\n         AND name IS NOT NULL AND name != '' \r\n         AND is_active = true\r\n         AND (role = 'inspector' OR role = 'manager' OR role = 'admin' OR role = 'org_admin')\r\n       ORDER BY name ASC\r\n       LIMIT 8`\r\n    )\r\n      .bind(`%${search}%`, `%${search}%`)\r\n      .all();\r\n\r\n    // Then search in inspection data (lower priority)\r\n    const inspectionResults = await env.DB.prepare(\r\n      `SELECT DISTINCT \r\n              inspector_name as value, \r\n              inspector_name as label, \r\n              inspector_email as email, \r\n              COUNT(*) as usage_count,\r\n              50 as priority\r\n       FROM inspections \r\n       WHERE (inspector_name LIKE ? OR inspector_email LIKE ?)\r\n         AND inspector_name IS NOT NULL AND inspector_name != ''\r\n       GROUP BY inspector_name, inspector_email\r\n       ORDER BY usage_count DESC, inspector_name ASC\r\n       LIMIT 5`\r\n    )\r\n      .bind(`%${search}%`, `%${search}%`)\r\n      .all();\r\n\r\n    // Combine and remove duplicates\r\n    const allSuggestions = [\r\n      ...(userResults.results || []),\r\n      ...(inspectionResults.results || [])\r\n    ];\r\n\r\n    const uniqueSuggestions = allSuggestions.reduce((acc: any[], current: any) => {\r\n      const exists = acc.find((item: any) =>\r\n        (item.value && current.value && item.value.toLowerCase() === current.value.toLowerCase()) ||\r\n        (item.email && current.email && item.email.toLowerCase() === current.email.toLowerCase())\r\n      );\r\n      if (!exists && current.value) {\r\n        acc.push({\r\n          value: current.value,\r\n          label: current.label,\r\n          email: current.email,\r\n          priority: current.priority\r\n        });\r\n      }\r\n      return acc;\r\n    }, [] as any[]);\r\n\r\n    // Sort by priority and name\r\n    uniqueSuggestions.sort((a, b) => {\r\n      if (a.priority !== b.priority) {\r\n        return b.priority - a.priority;\r\n      }\r\n      return a.value.localeCompare(b.value);\r\n    });\r\n\r\n    return c.json({\r\n      suggestions: uniqueSuggestions.slice(0, 10)\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching inspector suggestions:', error);\r\n    return c.json({ suggestions: [] });\r\n  }\r\n});\r\n\r\n// Responsible person suggestions\r\nautosuggest.get('/responsibles', tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const search = c.req.query('search') || '';\r\n\r\n  try {\r\n    const user = c.get(\"user\");\r\n    if (!user) {\r\n      return c.json({ suggestions: [] });\r\n    }\r\n\r\n    // Search in registered users (high priority)\r\n    const userResults = await env.DB.prepare(\r\n      `SELECT \r\n              name as value, \r\n              name as label, \r\n              email,\r\n              100 as priority\r\n       FROM users \r\n       WHERE (name LIKE ? OR email LIKE ?) \r\n         AND name IS NOT NULL AND name != ''\r\n         AND is_active = true\r\n       ORDER BY name ASC\r\n       LIMIT 8`\r\n    )\r\n      .bind(`%${search}%`, `%${search}%`)\r\n      .all();\r\n\r\n    // Search from existing inspections (lower priority)\r\n    const inspectionResults = await env.DB.prepare(\r\n      `SELECT DISTINCT \r\n              responsible_name as value, \r\n              responsible_name as label, \r\n              responsible_email as email,\r\n              COUNT(*) as usage_count,\r\n              50 as priority\r\n       FROM inspections \r\n       WHERE (responsible_name LIKE ? OR responsible_email LIKE ?)\r\n         AND responsible_name IS NOT NULL AND responsible_name != ''\r\n       GROUP BY responsible_name, responsible_email\r\n       ORDER BY usage_count DESC, responsible_name ASC\r\n       LIMIT 6`\r\n    )\r\n      .bind(`%${search}%`, `%${search}%`)\r\n      .all();\r\n\r\n    // Combine results, prioritizing registered users\r\n    const allSuggestions = [\r\n      ...(userResults.results || []),\r\n      ...(inspectionResults.results || [])\r\n    ];\r\n\r\n    // Remove duplicates\r\n    const uniqueSuggestions = allSuggestions.reduce((acc: any[], current: any) => {\r\n      const exists = acc.find((item: any) =>\r\n        (item.value && current.value && item.value.toLowerCase() === current.value.toLowerCase()) ||\r\n        (item.email && current.email && item.email.toLowerCase() === current.email.toLowerCase())\r\n      );\r\n      if (!exists && current.value) {\r\n        acc.push({\r\n          value: current.value,\r\n          label: current.label,\r\n          email: current.email,\r\n          priority: current.priority\r\n        });\r\n      }\r\n      return acc;\r\n    }, [] as any[]);\r\n\r\n    // Sort by priority and name\r\n    uniqueSuggestions.sort((a, b) => {\r\n      if (a.priority !== b.priority) {\r\n        return b.priority - a.priority;\r\n      }\r\n      return a.value.localeCompare(b.value);\r\n    });\r\n\r\n    return c.json({\r\n      suggestions: uniqueSuggestions.slice(0, 10)\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching responsible suggestions:', error);\r\n    return c.json({ suggestions: [] });\r\n  }\r\n});\r\n\r\n// Locations suggestions\r\nautosuggest.get('/locations', tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const search = c.req.query('search') || '';\r\n\r\n  try {\r\n    const user = c.get(\"user\");\r\n    if (!user) {\r\n      return c.json({ suggestions: [] });\r\n    }\r\n\r\n    const results = await env.DB.prepare(\r\n      `SELECT DISTINCT location as value, location as label, COUNT(*) as usage_count\r\n       FROM inspections \r\n       WHERE location LIKE ? AND location IS NOT NULL AND location != ''\r\n       GROUP BY location\r\n       ORDER BY usage_count DESC, location ASC\r\n       LIMIT 10`\r\n    )\r\n      .bind(`%${search}%`)\r\n      .all();\r\n\r\n    return c.json({\r\n      suggestions: (results.results || []).map((item: any) => ({\r\n        value: item.value,\r\n        label: item.label\r\n      }))\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching location suggestions:', error);\r\n    return c.json({ suggestions: [] });\r\n  }\r\n});\r\n\r\n// Title suggestions for inspections\r\nautosuggest.get('/inspection-titles', tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const search = c.req.query('search') || '';\r\n\r\n  try {\r\n    const user = c.get(\"user\");\r\n    if (!user) {\r\n      return c.json({ suggestions: [] });\r\n    }\r\n\r\n    // Search existing titles\r\n    const existingTitles = await env.DB.prepare(\r\n      `SELECT DISTINCT title as value, title as label, COUNT(*) as usage_count\r\n       FROM inspections \r\n       WHERE title LIKE ? AND title IS NOT NULL AND title != ''\r\n       GROUP BY title\r\n       ORDER BY usage_count DESC, title ASC\r\n       LIMIT 8`\r\n    )\r\n      .bind(`%${search}%`)\r\n      .all();\r\n\r\n    // Add default suggestions based on common inspection types\r\n    const defaultSuggestions = [\r\n      'Inspeção de Equipamentos de Proteção Individual (EPI)',\r\n      'Inspeção de Segurança em Altura',\r\n      'Inspeção de Equipamentos de Proteção Coletiva (EPC)',\r\n      'Inspeção de Máquinas e Equipamentos',\r\n      'Inspeção de Instalações Elétricas',\r\n      'Inspeção de Ambiente de Trabalho',\r\n      'Inspeção de Sinalização de Segurança',\r\n      'Inspeção de Ergonomia e Postura',\r\n      'Inspeção de Prevenção Contra Incêndio',\r\n      'Inspeção de Produtos Químicos e FISPQ'\r\n    ].filter(suggestion =>\r\n      search === '' || suggestion.toLowerCase().includes(search.toLowerCase())\r\n    ).slice(0, 5).map(suggestion => ({\r\n      value: suggestion,\r\n      label: suggestion,\r\n      usage_count: 0,\r\n      is_default: true\r\n    }));\r\n\r\n    const allSuggestions = [\r\n      ...(existingTitles.results || []),\r\n      ...defaultSuggestions\r\n    ];\r\n\r\n    // Remove duplicates\r\n    const uniqueSuggestions = allSuggestions.reduce((acc: any[], current: any) => {\r\n      const exists = acc.find((item: any) =>\r\n        item.value.toLowerCase() === current.value.toLowerCase()\r\n      );\r\n      if (!exists) {\r\n        acc.push(current);\r\n      }\r\n      return acc;\r\n    }, [] as any[]);\r\n\r\n    return c.json({\r\n      suggestions: uniqueSuggestions.slice(0, 10)\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching title suggestions:', error);\r\n    return c.json({ suggestions: [] });\r\n  }\r\n});\r\n\r\n// Description suggestions for inspections\r\nautosuggest.get('/inspection-descriptions', tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const search = c.req.query('search') || '';\r\n\r\n  try {\r\n    const user = c.get(\"user\");\r\n    if (!user) {\r\n      return c.json({ suggestions: [] });\r\n    }\r\n\r\n    // Search existing descriptions\r\n    const existingDescriptions = await env.DB.prepare(\r\n      `SELECT DISTINCT description as value, description as label, COUNT(*) as usage_count\r\n       FROM inspections \r\n       WHERE description LIKE ? AND description IS NOT NULL AND description != '' AND LENGTH(description) > 10\r\n       GROUP BY description\r\n       ORDER BY usage_count DESC, description ASC\r\n       LIMIT 6`\r\n    )\r\n      .bind(`%${search}%`)\r\n      .all();\r\n\r\n    // Add default suggestions based on common descriptions\r\n    const defaultSuggestions = [\r\n      'Verificação de conformidade com as normas regulamentadoras de segurança do trabalho',\r\n      'Avaliação dos equipamentos de proteção individual e coletiva disponíveis',\r\n      'Inspeção das condições gerais de segurança e higiene do ambiente de trabalho',\r\n      'Verificação do cumprimento dos procedimentos de segurança estabelecidos',\r\n      'Avaliação dos riscos ocupacionais e medidas de controle implementadas',\r\n      'Inspeção preventiva para identificação de potenciais riscos à segurança',\r\n      'Verificação da adequação das instalações às normas de segurança vigentes',\r\n      'Avaliação da eficácia dos treinamentos de segurança ministrados'\r\n    ].filter(suggestion =>\r\n      search === '' || suggestion.toLowerCase().includes(search.toLowerCase())\r\n    ).slice(0, 4).map(suggestion => ({\r\n      value: suggestion,\r\n      label: suggestion,\r\n      usage_count: 0,\r\n      is_default: true\r\n    }));\r\n\r\n    const allSuggestions = [\r\n      ...(existingDescriptions.results || []),\r\n      ...defaultSuggestions\r\n    ];\r\n\r\n    // Remove duplicates\r\n    const uniqueSuggestions = allSuggestions.reduce((acc: any[], current: any) => {\r\n      const exists = acc.find((item: any) =>\r\n        item.value && current.value &&\r\n        item.value.toLowerCase().trim() === current.value.toLowerCase().trim()\r\n      );\r\n      if (!exists && current.value) {\r\n        acc.push({\r\n          value: current.value,\r\n          label: current.label,\r\n          usage_count: current.usage_count || 0,\r\n          is_default: current.is_default || false\r\n        });\r\n      }\r\n      return acc;\r\n    }, [] as any[]);\r\n\r\n    return c.json({\r\n      suggestions: uniqueSuggestions.slice(0, 8)\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching description suggestions:', error);\r\n    return c.json({ suggestions: [] });\r\n  }\r\n});\r\n\r\nexport default autosuggest;\r\n\r\n"},{"name":"calendar-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { ExtendedMochaUser, USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n};\r\n\r\nconst getDatabase = (env: any) => env.DB;\r\n\r\n/**\r\n * Chronos Lei 2: Verificação de conflito de agendamento e Lei 5: Respeito a Horários/Feriados\r\n * Retorna eventos que conflitam com o período solicitado ou violações de regras\r\n */\r\nasync function checkConflict(\r\n    db: any,\r\n    orgId: string,\r\n    startTime: string,\r\n    endTime: string,\r\n    participantEmail?: string,\r\n    excludeEventId?: string | number\r\n): Promise<{ hasConflict: boolean; conflictingEvents: any[]; violationType?: 'overlap' | 'business_hours' | 'holiday' }> {\r\n    try {\r\n        // 1. Verificar Configurações da Agenda (Feriados e Horário Comercial)\r\n        try {\r\n            // Tentar buscar configurações (pode não existir se a tabela ainda não foi criada/populada)\r\n            const settings = await db.prepare(\"SELECT * FROM calendar_settings WHERE organization_id = ?\").bind(orgId).first() as any;\r\n\r\n            if (settings) {\r\n                const holidays = JSON.parse(settings.holidays || '[]');\r\n                const businessHours = JSON.parse(settings.business_hours || '{}');\r\n                const timezone = settings.timezone || 'UTC';\r\n\r\n                const start = new Date(startTime);\r\n                const end = new Date(endTime);\r\n\r\n                // Verificar Feriados\r\n                const startStr = start.toISOString().split('T')[0];\r\n                const holiday = holidays.find((h: any) => h.date === startStr);\r\n\r\n                if (holiday) {\r\n                    return {\r\n                        hasConflict: true,\r\n                        conflictingEvents: [{\r\n                            id: 'holiday',\r\n                            title: `Feriado: ${holiday.name}`,\r\n                            start_time: `${startStr}T00:00:00Z`,\r\n                            end_time: `${startStr}T23:59:59Z`,\r\n                            event_type: 'block'\r\n                        }],\r\n                        violationType: 'holiday'\r\n                    };\r\n                }\r\n\r\n                // Verificar Horário Comercial (apenas se configurado)\r\n                if (businessHours.start && businessHours.end) {\r\n                    // Converter para minutos para facilitar comparação\r\n                    const getMinutes = (timeStr: string) => {\r\n                        const [h, m] = timeStr.split(':').map(Number);\r\n                        return h * 60 + m;\r\n                    };\r\n\r\n                    // Extrair hora do evento (assumindo que start_time está em UTC, precisaria converter para timezone da org,\r\n                    // mas por simplificação aqui vamos extrair UTC hours se timezone for UTC-3 aprox ou usar lib de data se tiver\r\n                    // Como não temos date-fns aqui, vamos fazer uma verificação simples:\r\n                    // Se o evento começa antes de businessHours.start ou termina depois de businessHours.end (em UTC ajustado)\r\n\r\n                    // TODO: Melhorar suporte a timezone real no backend. Por enquanto, focado em conflitos de OVERLAP.\r\n                }\r\n            }\r\n        } catch (e) {\r\n            // Log warning instead of silently swallowing\r\n            console.warn('[Chronos] Calendar settings check skipped:', e);\r\n        }\r\n\r\n        // 2. Verificar conflitos em calendar_events\r\n        let query = `\r\n            SELECT id, title, start_time, end_time, event_type\r\n            FROM calendar_events\r\n            WHERE organization_id = ?\r\n              AND start_time < ?\r\n              AND end_time > ?\r\n        `;\r\n        const params: any[] = [orgId, endTime, startTime];\r\n\r\n        // Excluir o próprio evento (para edições)\r\n        if (excludeEventId && !String(excludeEventId).startsWith('inspection-')) {\r\n            query += ` AND id != ?`;\r\n            params.push(excludeEventId);\r\n        }\r\n\r\n        // Filtrar por participante se fornecido\r\n        if (participantEmail) {\r\n            query += ` AND (participants::text LIKE ? OR created_by IN (SELECT id FROM users WHERE email = ?))`;\r\n            params.push(`%\"${participantEmail}\"%`, participantEmail);\r\n        }\r\n\r\n        query += ` LIMIT 5`;\r\n\r\n        const calendarConflicts = await db.prepare(query).bind(...params).all();\r\n        const conflicts = calendarConflicts.results || [];\r\n\r\n        // Verificar conflitos em inspections também\r\n        if (participantEmail) {\r\n            let inspectionQuery = `\r\n                SELECT id, title as project_name, scheduled_date, status\r\n                FROM inspections\r\n                WHERE organization_id = ?\r\n                  AND inspector_email = ?\r\n                  AND scheduled_date IS NOT NULL\r\n                  AND scheduled_date >= ?\r\n                  AND scheduled_date < ?\r\n                  AND status NOT IN ('cancelled', 'completed')\r\n            `;\r\n            const inspParams: any[] = [orgId, participantEmail, startTime, endTime];\r\n\r\n            // Excluir própria inspeção\r\n            if (excludeEventId && String(excludeEventId).startsWith('inspection-')) {\r\n                const realId = String(excludeEventId).replace('inspection-', '');\r\n                inspectionQuery += ` AND id != ?`;\r\n                inspParams.push(realId);\r\n            }\r\n\r\n            inspectionQuery += ` LIMIT 5`;\r\n\r\n            const inspectionConflicts = await db.prepare(inspectionQuery).bind(...inspParams).all();\r\n            if (inspectionConflicts.results) {\r\n                conflicts.push(...inspectionConflicts.results.map((i: any) => ({\r\n                    id: `inspection-${i.id}`,\r\n                    title: i.project_name?.startsWith('Inspeção:') ? i.project_name : `Inspeção: ${i.project_name}`,\r\n                    start_time: i.scheduled_date,\r\n                    end_time: new Date(new Date(i.scheduled_date).getTime() + 60 * 60 * 1000).toISOString(),\r\n                    event_type: 'inspection'\r\n                })));\r\n            }\r\n        }\r\n\r\n        return {\r\n            hasConflict: conflicts.length > 0,\r\n            conflictingEvents: conflicts\r\n        };\r\n    } catch (error) {\r\n        console.error('[Chronos] Error checking conflict:', error);\r\n        // Em caso de erro, não bloquear - apenas logar\r\n        return { hasConflict: false, conflictingEvents: [] };\r\n    }\r\n}\r\n\r\nconst app = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// ROTA TEMPORÁRIA PARA TESTE DE PERFORMANCE (seed)\r\napp.get('/seed-test', tenantAuthMiddleware, async (c) => {\r\n    const user = c.get('user') as ExtendedMochaUser;\r\n    const db = getDatabase(c.env);\r\n\r\n    const userProfile = await db.prepare(\"SELECT organization_id, managed_organization_id, email FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile) return c.json({ error: \"User not found\" }, 404);\r\n\r\n    const orgId = userProfile.managed_organization_id || userProfile.organization_id;\r\n    const email = userProfile.email;\r\n\r\n    // Inserir 50 eventos\r\n    const statements = [];\r\n    const baseDate = new Date(); // Hoje\r\n\r\n    for (let i = 0; i < 50; i++) {\r\n        const dayOffset = Math.floor(i / 5); // 5 eventos por dia\r\n        const hourOffset = (i % 5) + 8; // Começa as 8h\r\n\r\n        const startTime = new Date(baseDate);\r\n        startTime.setDate(baseDate.getDate() + dayOffset);\r\n        startTime.setHours(hourOffset, 0, 0, 0);\r\n\r\n        const endTime = new Date(startTime);\r\n        endTime.setHours(hourOffset + 1, 0, 0, 0);\r\n\r\n        statements.push(db.prepare(`\r\n            INSERT INTO calendar_events (\r\n                organization_id, title, description, start_time, end_time, \r\n                event_type, created_by, participants, created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))\r\n        `).bind(\r\n            orgId,\r\n            `Teste Performance ${i + 1}`,\r\n            `Evento gerado automaticamente para teste de carga #${i + 1}`,\r\n            startTime.toISOString(),\r\n            endTime.toISOString(),\r\n            i % 2 === 0 ? 'meeting' : 'focus',\r\n            user.id,\r\n            JSON.stringify([email])\r\n        ));\r\n    }\r\n\r\n    await db.batch(statements);\r\n    return c.json({ message: \"50 eventos criados com sucesso\", orgId });\r\n});\r\n\r\n// List events (Integrated with Inspections and Action Plans)\r\napp.get('/', tenantAuthMiddleware, async (c) => {\r\n    try {\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const db = getDatabase(c.env);\r\n\r\n        const startDate = c.req.query('start_date');\r\n        const endDate = c.req.query('end_date');\r\n\r\n        // Get user profile to know which organization to fetch for\r\n        const userProfile = await db.prepare(\"SELECT organization_id, managed_organization_id, role, email FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n        if (!userProfile) {\r\n            return c.json({ error: \"User profile not found\" }, 404);\r\n        }\r\n\r\n        const orgId = userProfile.managed_organization_id || userProfile.organization_id;\r\n        // User email for participation check\r\n        const userEmail = userProfile.email || user.email;\r\n\r\n        if (!orgId) {\r\n            return c.json({ error: \"User is not associated with any organization\" }, 400);\r\n        }\r\n\r\n        const events = [];\r\n\r\n        // 1. Fetch Calendar Events (Rich Manual Events)\r\n        try {\r\n            // Check for Org OR Participation\r\n            // Note: participants is stored as stringified JSON array in TEXT column usually\r\n            // We use LIKE for partial match as simple workaround. proper JSONB would be better.\r\n            let query = `\r\n          SELECT * FROM calendar_events \r\n          WHERE (organization_id = ? OR participants::text LIKE ?)\r\n        `;\r\n            const params: any[] = [orgId, `%\"${userEmail}\"%`];\r\n\r\n            if (startDate) {\r\n                query += ` AND end_time >= ?`;\r\n                params.push(startDate);\r\n            }\r\n\r\n            if (endDate) {\r\n                query += ` AND start_time <= ?`;\r\n                params.push(endDate);\r\n            }\r\n\r\n            const calendarEvents = await db.prepare(query).bind(...params).all();\r\n\r\n            if (calendarEvents.results) {\r\n                events.push(...calendarEvents.results.map((e: any) => ({\r\n                    ...e,\r\n                    source: 'calendar',\r\n                    readonly: e.organization_id !== orgId, // Readonly if not my org (simplified)\r\n                    participants: typeof e.participants === 'string' ? JSON.parse(e.participants) : (e.participants || []),\r\n                    accepted_by: typeof e.accepted_by === 'string' ? JSON.parse(e.accepted_by) : (e.accepted_by || []),\r\n                    declined_by: typeof e.declined_by === 'string' ? JSON.parse(e.declined_by) : (e.declined_by || []),\r\n                    scope_items: typeof e.scope_items === 'string' ? JSON.parse(e.scope_items) : (e.scope_items || []),\r\n                    attachments: typeof e.attachments === 'string' ? JSON.parse(e.attachments) : (e.attachments || []),\r\n                    // Preserve new fields\r\n                    location: e.location,\r\n                    meeting_link: e.meeting_link,\r\n                    google_event_id: e.google_event_id,\r\n                    notification_body: e.notification_body\r\n                })));\r\n            }\r\n        } catch (e: any) {\r\n            console.error('[CALENDAR_DEBUG] Error fetching calendar_events:', e);\r\n            throw new Error(`Failed to fetch calendar_events: ${e.message}`);\r\n        }\r\n\r\n        // 2. Fetch Inspections (System)\r\n        try {\r\n            // Fetch Org Inspections OR Assigned Inspections\r\n            let inspectionQuery = `\r\n                SELECT id, title as project_name, scheduled_date, status, 'Inspeção Prática' as inspection_type, \r\n                       company_name, client_id, address, location, organization_id, inspector_email, accepted_by, declined_by,\r\n                       cep, logradouro, numero, complemento, bairro, cidade, uf\r\n                FROM inspections\r\n                WHERE (organization_id = ? OR inspector_email = ?) \r\n                AND scheduled_date IS NOT NULL\r\n            `;\r\n            const inspectionParams: any[] = [orgId, userEmail];\r\n\r\n            if (startDate) {\r\n                inspectionQuery += ` AND scheduled_date >= ?`;\r\n                inspectionParams.push(startDate);\r\n            }\r\n            if (endDate) {\r\n                inspectionQuery += ` AND scheduled_date <= ?`;\r\n                inspectionParams.push(endDate);\r\n            }\r\n\r\n            const inspections = await db.prepare(inspectionQuery).bind(...inspectionParams).all();\r\n            if (inspections.results) {\r\n                events.push(...inspections.results.map((i: any) => ({\r\n                    id: `inspection-${i.id}`, // Virtual ID\r\n                    original_id: i.id,\r\n                    title: i.project_name?.startsWith('Inspeção:') ? i.project_name : `Inspeção: ${i.project_name}`,\r\n                    description: `Status: ${i.status}`,\r\n                    start_time: i.scheduled_date,\r\n                    end_time: new Date(new Date(i.scheduled_date).getTime() + 60 * 60 * 1000).toISOString(), // Assume 1h\r\n                    event_type: 'inspection',\r\n                    source: 'inspection',\r\n                    readonly: i.organization_id !== orgId, // Readonly if not my org\r\n                    status: i.status === 'completed' ? 'completed' : 'scheduled',\r\n                    company_name: i.company_name,\r\n                    client_id: i.client_id,\r\n                    location: i.location || i.address,\r\n                    // Granular Address Mapping for EventModal\r\n                    cep: i.cep,\r\n                    logradouro: i.logradouro,\r\n                    numero: i.numero,\r\n                    complemento: i.complemento,\r\n                    bairro: i.bairro,\r\n                    cidade: i.cidade,\r\n                    uf: i.uf,\r\n                    participants: i.inspector_email ? [i.inspector_email] : [],\r\n                    accepted_by: typeof i.accepted_by === 'string' ? JSON.parse(i.accepted_by) : (i.accepted_by || []),\r\n                    declined_by: typeof i.declined_by === 'string' ? JSON.parse(i.declined_by) : (i.declined_by || [])\r\n                })));\r\n            }\r\n        } catch (e: any) {\r\n            console.error('[CALENDAR_DEBUG] Error fetching inspections:', e);\r\n            throw new Error(`Failed to fetch inspections: ${e.message}`);\r\n        }\r\n\r\n        // 3. Fetch Action Plans (System)\r\n        try {\r\n            let actionPlanQuery = `\r\n                SELECT id, description, due_date, status, priority\r\n                FROM action_plans\r\n                WHERE organization_id = ? AND due_date IS NOT NULL\r\n            `;\r\n            const actionParams: any[] = [orgId];\r\n\r\n            if (startDate) {\r\n                actionPlanQuery += ` AND due_date >= ?`;\r\n                actionParams.push(startDate);\r\n            }\r\n            if (endDate) {\r\n                actionPlanQuery += ` AND due_date <= ?`;\r\n                actionParams.push(endDate);\r\n            }\r\n\r\n            const actionPlans = await db.prepare(actionPlanQuery).bind(...actionParams).all();\r\n            if (actionPlans.results) {\r\n                events.push(...actionPlans.results.map((a: any) => ({\r\n                    id: `action-${a.id}`, // Virtual ID\r\n                    original_id: a.id,\r\n                    title: `Plano de Ação: ${a.description.substring(0, 30)}...`,\r\n                    description: `Prioridade: ${a.priority}. Status: ${a.status}`,\r\n                    start_time: a.due_date,\r\n                    end_time: a.due_date, // Deadline is a point in time\r\n                    event_type: 'blocking', // Blocking/Deadline type\r\n                    source: 'action_plan',\r\n                    readonly: true,\r\n                    status: a.status === 'completed' ? 'completed' : 'scheduled'\r\n                })));\r\n            }\r\n        } catch (e: any) {\r\n            console.error('[CALENDAR_DEBUG] Error fetching action_plans:', e);\r\n            // If action_plans doesn't exist, ignore it for now to not block calendar\r\n            // throw new Error(`Failed to fetch action_plans: ${e.message}`);\r\n        }\r\n\r\n        // Sort by start_time\r\n        events.sort((a, b) => new Date(a.start_time).getTime() - new Date(b.start_time).getTime());\r\n\r\n        return c.json(events);\r\n\r\n    } catch (error) {\r\n        console.error('Error fetching calendar events FULL:', error);\r\n        if (error instanceof Error) {\r\n            console.error('Stack:', error.stack);\r\n            console.error('Message:', error.message);\r\n        }\r\n        return c.json({ error: 'Erro ao buscar eventos do calendário', details: String(error) }, 500);\r\n    }\r\n});\r\n\r\n// Create event (Rich + Integration Hooks + Inspection Automation)\r\napp.post('/', tenantAuthMiddleware, async (c) => {\r\n    try {\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const db = getDatabase(c.env);\r\n        const body = await c.req.json();\r\n\r\n        const {\r\n            title,\r\n            description,\r\n            start_time,\r\n            end_time,\r\n            event_type,\r\n            metadata,\r\n            // New Rich Fields\r\n            participants,\r\n            scope_items,\r\n            attachments,\r\n            location,\r\n            meeting_link,\r\n            notification_body,\r\n            // Integration Flags\r\n            create_meet,\r\n            notify_email,\r\n            // Inspection Specifics\r\n            template_id,\r\n            company_name, // or client_id\r\n            client_id\r\n        } = body;\r\n\r\n        // Validation\r\n        if (!title || !start_time || !end_time || !event_type) {\r\n            return c.json({ error: \"Campos obrigatórios: title, start_time, end_time, event_type\" }, 400);\r\n        }\r\n\r\n        // Get user profile\r\n        const userProfile = await db.prepare(\"SELECT organization_id, managed_organization_id, role, name, email FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n        if (!userProfile) {\r\n            return c.json({ error: \"User profile not found\" }, 404);\r\n        }\r\n\r\n        const orgId = userProfile.managed_organization_id || userProfile.organization_id;\r\n\r\n        if (!orgId) {\r\n            return c.json({ error: \"User is not associated with any organization\" }, 400);\r\n        }\r\n\r\n        // --- CHRONOS LEI 2: Verificação de conflito ---\r\n        // Determinar o email do participante principal para verificação\r\n        const primaryParticipant = participants && participants.length > 0\r\n            ? (typeof participants[0] === 'string' ? participants[0] : participants[0].email)\r\n            : userProfile.email;\r\n\r\n        // Verificar se força a criação mesmo com conflito\r\n        const forceCreate = body.force_conflict === true;\r\n\r\n        if (!forceCreate) {\r\n            const conflictCheck = await checkConflict(\r\n                db,\r\n                orgId,\r\n                start_time,\r\n                end_time,\r\n                primaryParticipant\r\n            );\r\n\r\n            if (conflictCheck.hasConflict) {\r\n                return c.json({\r\n                    error: \"Conflito de horário detectado\",\r\n                    conflict: true,\r\n                    conflicting_events: conflictCheck.conflictingEvents,\r\n                    message: \"Já existe um evento neste horário. Envie force_conflict=true para criar mesmo assim.\"\r\n                }, 409);\r\n            }\r\n        }\r\n\r\n        // --- INSPECTION CREATION LOGIC ---\r\n        if (event_type === 'inspection') {\r\n            console.log('[Calendar] Creating Inspection explicitly:', title);\r\n\r\n            // Extract primary inspector from participants or use current user\r\n            let inspectorName = userProfile.name;\r\n            let inspectorEmail = userProfile.email;\r\n\r\n            if (participants && participants.length > 0) {\r\n                const first = participants[0];\r\n                if (typeof first === 'string') {\r\n                    // It's an email string\r\n                    inspectorEmail = first;\r\n                    // Try to find name if possible, otherwise use email as name or keep default? \r\n                    // Ideally we should lookup the user, but for now let's use the email prefix or keep generic if we can't find it.\r\n                    // Actually, if we are assigning someone else, we might not have their name readily available in the body.\r\n                    // Let's rely on the email.\r\n                    inspectorName = first.split('@')[0];\r\n                } else if (first.email) {\r\n                    inspectorEmail = first.email;\r\n                    inspectorName = first.name || first.email.split('@')[0];\r\n                }\r\n            }\r\n\r\n            const inspectionQuery = `\r\n                INSERT INTO inspections (\r\n                    organization_id, created_by, title, scheduled_date, \r\n                    status, \r\n                    participants, location, company_name, client_id, template_id,\r\n                    inspector_name, inspector_email,\r\n                    description,\r\n                    cep, logradouro, numero, complemento, bairro, cidade, uf\r\n                ) VALUES (\r\n                    ?, ?, ?, ?, \r\n                    'scheduled',\r\n                    ?, ?, ?, ?, ?,\r\n                    ?, ?,\r\n                    ?,\r\n                    ?, ?, ?, ?, ?, ?, ?\r\n                ) RETURNING *\r\n            `;\r\n\r\n            // Use template_id if provided, otherwise null (Deferred Configuration)\r\n            const resolvedTemplateId = template_id || null;\r\n\r\n            // Extract detailed address fields from body\r\n            const { cep, logradouro, numero, complemento, bairro, cidade, uf } = body;\r\n\r\n            const inspectionResult = await db.prepare(inspectionQuery).bind(\r\n                orgId, user.id, title, start_time,\r\n                JSON.stringify(participants || []), location || '', company_name || '', client_id || null, resolvedTemplateId,\r\n                inspectorName, inspectorEmail,\r\n                description ? `${description} (Agendado por: ${userProfile.name})` : `Agendado via Agenda por: ${userProfile.name}`,\r\n                cep || null, logradouro || null, numero || null, complemento || null, bairro || null, cidade || null, uf || null\r\n            ).first();\r\n\r\n            // Log Activity\r\n            await db.prepare(`\r\n                INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n                VALUES(?, ?, ?, ?, ?, ?, NOW())\r\n            `).bind(\r\n                user.id, orgId, 'inspection_scheduled',\r\n                `Agendou inspeção: ${title}`, 'inspection', inspectionResult.id.toString()\r\n            ).run();\r\n\r\n            // Create initial history record\r\n            await db.prepare(`\r\n                INSERT INTO inspection_status_history (inspection_id, status_from, status_to, changed_by, created_at)\r\n                VALUES (?, NULL, 'scheduled', ?, NOW())\r\n            `).bind(inspectionResult.id, user.id).run();\r\n\r\n            return c.json({ ...inspectionResult, id: `inspection-${inspectionResult.id}`, original_id: inspectionResult.id, source: 'inspection', integration_status: 'created_inspection' });\r\n        }\r\n\r\n        // --- STANDARD CALENDAR EVENT ---\r\n\r\n        // Integration Logic Placeholder (Google Meet, etc)\r\n        // For V1, we just save the request.\r\n\r\n        // Insert\r\n        const query = `\r\n            INSERT INTO calendar_events (\r\n                organization_id, created_by, title, description, \r\n                start_time, end_time, event_type, metadata,\r\n                participants, scope_items, attachments, \r\n                location, meeting_link, notification_body,\r\n                company_name, client_id\r\n            ) VALUES (\r\n                ?, ?, ?, ?, ?, ?, ?, ?,\r\n                ?, ?, ?, ?, ?, ?,\r\n                ?, ?\r\n            ) RETURNING *\r\n        `;\r\n\r\n        const result = await db.prepare(query).bind(\r\n            orgId, user.id, title, description || null,\r\n            start_time, end_time, event_type, JSON.stringify(metadata || {}),\r\n            JSON.stringify(participants || []),\r\n            JSON.stringify(scope_items || []),\r\n            JSON.stringify(attachments || []),\r\n            location || null,\r\n            meeting_link || null,\r\n            notification_body || null,\r\n            company_name || null,\r\n            client_id || null\r\n        ).first();\r\n\r\n        // Log Activity\r\n        await db.prepare(`\r\n        INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n        VALUES(?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n            user.id, orgId, 'event_created',\r\n            `Criou evento: ${title}`, 'calendar_event', result.id.toString()\r\n        ).run();\r\n\r\n        return c.json({ ...result, integration_status: 'ok' });\r\n\r\n    } catch (error) {\r\n        console.error('Error creating calendar event:', error);\r\n        return c.json({ error: 'Erro ao criar evento' }, 500);\r\n    }\r\n});\r\n\r\n// Update event\r\napp.put('/:id', tenantAuthMiddleware, async (c) => {\r\n    try {\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const db = getDatabase(c.env);\r\n        const eventId = c.req.param('id');\r\n        const body = await c.req.json();\r\n\r\n        // Get user profile first as we need orgId for both branches\r\n        const userProfile = await db.prepare(\"SELECT organization_id, managed_organization_id, role FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n        if (!userProfile) return c.json({ error: \"User profile not found\" }, 404);\r\n\r\n        const orgId = userProfile.managed_organization_id || userProfile.organization_id;\r\n\r\n        // --- CHRONOS LEI 2: Verificação de conflito na edição ---\r\n        const { start_time, end_time, participants, force_conflict } = body;\r\n\r\n        if (start_time && end_time && !force_conflict) {\r\n            const primaryParticipant = participants && participants.length > 0\r\n                ? (typeof participants[0] === 'string' ? participants[0] : participants[0].email)\r\n                : userProfile.email;\r\n\r\n            const conflictCheck = await checkConflict(\r\n                db,\r\n                orgId,\r\n                start_time,\r\n                end_time,\r\n                primaryParticipant,\r\n                eventId // Excluir o próprio evento\r\n            );\r\n\r\n            if (conflictCheck.hasConflict) {\r\n                return c.json({\r\n                    error: \"Conflito de horário detectado\",\r\n                    conflict: true,\r\n                    conflicting_events: conflictCheck.conflictingEvents,\r\n                    message: \"Já existe um evento neste horário. Envie force_conflict=true para atualizar mesmo assim.\"\r\n                }, 409);\r\n            }\r\n        }\r\n\r\n        // Check if it's a virtual inspection ID\r\n        if (eventId.startsWith('inspection-')) {\r\n            const realId = eventId.replace('inspection-', '');\r\n\r\n            // Map fields back to inspection columns\r\n            const { title, start_time, company_name, client_id, description, location, participants, cep, logradouro, numero, bairro, cidade, uf, complemento } = body;\r\n\r\n            const updates = [];\r\n            const values = [];\r\n\r\n            if (title) { updates.push('title = ?'); values.push(title); }\r\n            if (start_time) { updates.push('scheduled_date = ?'); values.push(start_time); }\r\n            if (company_name) { updates.push('company_name = ?'); values.push(company_name); }\r\n            if (client_id) { updates.push('client_id = ?'); values.push(client_id); }\r\n            if (description !== undefined) { updates.push('description = ?'); values.push(description); }\r\n            if (location !== undefined) { updates.push('address = ?'); values.push(location); }\r\n\r\n            // Detailed address fields\r\n            if (cep !== undefined) { updates.push('cep = ?'); values.push(cep); }\r\n            if (logradouro !== undefined) { updates.push('logradouro = ?'); values.push(logradouro); }\r\n            if (numero !== undefined) { updates.push('numero = ?'); values.push(numero); }\r\n            if (bairro !== undefined) { updates.push('bairro = ?'); values.push(bairro); }\r\n            if (cidade !== undefined) { updates.push('cidade = ?'); values.push(cidade); }\r\n            if (uf !== undefined) { updates.push('uf = ?'); values.push(uf); }\r\n            if (complemento !== undefined) { updates.push('complemento = ?'); values.push(complemento); }\r\n\r\n            // Handle participants and inspector_email for inspections\r\n            if (participants) {\r\n                updates.push('participants = ?');\r\n                values.push(JSON.stringify(participants));\r\n\r\n                // Also update inspector_email if participants list is not empty\r\n                if (participants.length > 0) {\r\n                    // Participant is usually just an email string in this context based on frontend\r\n                    const firstParticipant = participants[0];\r\n                    // If it's an object use email property, otherwise use string\r\n                    const email = typeof firstParticipant === 'string' ? firstParticipant : firstParticipant.email;\r\n                    if (email) {\r\n                        updates.push('inspector_email = ?');\r\n                        values.push(email);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                updates.push(\"updated_at = NOW()\");\r\n                const query = `\r\n                    UPDATE inspections \r\n                    SET ${updates.join(', ')} \r\n                    WHERE id = ? AND organization_id = ?\r\n                    RETURNING *\r\n                 `;\r\n                // Add realId and orgId to values\r\n                const result = await db.prepare(query).bind(...values, realId, orgId).first();\r\n\r\n                if (!result) return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n\r\n                return c.json({\r\n                    ...result,\r\n                    id: `inspection-${result.id}`,\r\n                    start_time: result.scheduled_date,\r\n                    end_time: result.scheduled_date, // End time is same as start for inspections unless we add duration\r\n                    event_type: 'inspection',\r\n                    source: 'inspection',\r\n                    location: result.address\r\n                });\r\n            }\r\n            return c.json({ message: \"Nada para atualizar\" });\r\n        }\r\n\r\n        // Standard Calendar Event Update\r\n\r\n        // Allowed fields to update\r\n        const allowedFields = [\r\n            'title', 'description', 'start_time', 'end_time', 'event_type', 'status', 'metadata',\r\n            'participants', 'scope_items', 'attachments', 'location', 'meeting_link', 'notification_body',\r\n            'company_name', 'client_id'\r\n        ];\r\n        const updates = [];\r\n        const values = [];\r\n\r\n        for (const field of allowedFields) {\r\n            if (body[field] !== undefined) {\r\n                updates.push(`${field} = ?`);\r\n                if (['metadata', 'participants', 'scope_items', 'attachments'].includes(field)) {\r\n                    values.push(JSON.stringify(body[field]));\r\n                } else {\r\n                    values.push(body[field]);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (updates.length === 0) {\r\n            return c.json({ message: \"Nada para atualizar\" }, 200);\r\n        }\r\n\r\n        updates.push(\"updated_at = NOW()\");\r\n\r\n        const query = `\r\n            UPDATE calendar_events \r\n            SET ${updates.join(', ')} \r\n            WHERE id = ? AND organization_id = ?\r\n            RETURNING *\r\n        `;\r\n\r\n        const result = await db.prepare(query).bind(...values, eventId, orgId).first();\r\n\r\n        if (!result) {\r\n            return c.json({ error: \"Evento não encontrado ou permissão negada\" }, 404);\r\n        }\r\n\r\n        return c.json(result);\r\n\r\n    } catch (error) {\r\n        console.error('Error updating calendar event:', error);\r\n        return c.json({ error: 'Erro ao atualizar evento' }, 500);\r\n    }\r\n});\r\n\r\n// Delete event\r\napp.delete('/:id', tenantAuthMiddleware, async (c) => {\r\n    try {\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const db = getDatabase(c.env);\r\n        const eventId = c.req.param('id');\r\n\r\n        const userProfile = await db.prepare(\"SELECT organization_id, managed_organization_id, role FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n        const orgId = userProfile.managed_organization_id || userProfile.organization_id;\r\n\r\n        // Check for inspection ID\r\n        if (eventId.startsWith('inspection-')) {\r\n            const realId = eventId.replace('inspection-', '');\r\n            const result = await db.prepare(`\r\n                DELETE FROM inspections\r\n                WHERE id = ? AND organization_id = ?\r\n                RETURNING id\r\n            `).bind(realId, orgId).first();\r\n\r\n            if (!result) return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n            return c.json({ message: \"Inspeção excluída\" });\r\n        }\r\n\r\n        const result = await db.prepare(`\r\n            DELETE FROM calendar_events \r\n            WHERE id = ? AND organization_id = ?\r\n            RETURNING id\r\n        `).bind(eventId, orgId).first();\r\n\r\n        if (!result) {\r\n            return c.json({ error: \"Evento não encontrado ou permissão negada\" }, 404);\r\n        }\r\n\r\n        return c.json({ message: \"Evento excluído com sucesso\" });\r\n\r\n    } catch (error) {\r\n        console.error('Error deleting calendar event:', error);\r\n        return c.json({ error: 'Erro ao excluir evento' }, 500);\r\n    }\r\n});\r\n\r\n// Debug route to diagnose 500 errors\r\napp.get('/debug', async (c) => {\r\n    try {\r\n        const db = getDatabase(c.env);\r\n        let orgId = c.req.query('org_id');\r\n\r\n        // If no orgId provided, try to find the first one\r\n        if (!orgId) {\r\n            const firstOrg = await db.prepare(\"SELECT id FROM organizations LIMIT 1\").first();\r\n            if (firstOrg) {\r\n                orgId = firstOrg.id;\r\n            }\r\n        }\r\n\r\n        if (!orgId) return c.json({ error: 'No Org ID found and no organization in DB' });\r\n\r\n        const report: any = { orgId, checks: {} };\r\n\r\n        // Check 1: Calendar Events\r\n        try {\r\n            await db.prepare(\"SELECT * FROM calendar_events WHERE organization_id = ? LIMIT 1\").bind(orgId).all();\r\n            report.checks.calendar_events = 'OK';\r\n        } catch (e: any) {\r\n            report.checks.calendar_events = `FAILED: ${e.message}`;\r\n        }\r\n\r\n        // Check 2: Inspections (Corrected Schema)\r\n        try {\r\n            await db.prepare(\"SELECT id, title, scheduled_date, status FROM inspections WHERE organization_id = ? LIMIT 1\").bind(orgId).all();\r\n            report.checks.inspections = 'OK';\r\n        } catch (e: any) {\r\n            report.checks.inspections = `FAILED: ${e.message}`;\r\n        }\r\n\r\n        // Check 3: Action Plans\r\n        try {\r\n            await db.prepare(\"SELECT id, description, due_date, status, priority FROM action_plans WHERE organization_id = ? LIMIT 1\").bind(orgId).all();\r\n            report.checks.action_plans = 'OK';\r\n        } catch (e: any) {\r\n            report.checks.action_plans = `FAILED: ${e.message}`;\r\n        }\r\n\r\n        return c.json(report);\r\n\r\n    } catch (error: any) {\r\n        return c.json({ error: error.message, stack: error.stack });\r\n    }\r\n});\r\n\r\n// RSVP to event\r\napp.post('/:id/respond', tenantAuthMiddleware, async (c) => {\r\n    try {\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const db = getDatabase(c.env);\r\n        const eventId = c.req.param('id');\r\n        const { status } = await c.req.json(); // 'accepted' | 'declined'\r\n\r\n        if (!['accepted', 'declined'].includes(status)) {\r\n            return c.json({ error: 'Status inválido' }, 400);\r\n        }\r\n\r\n        const userProfile = await db.prepare(\"SELECT organization_id, managed_organization_id, role, email, name FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n        const orgId = userProfile.managed_organization_id || userProfile.organization_id;\r\n\r\n        const respondent = {\r\n            id: user.id,\r\n            email: userProfile.email,\r\n            name: userProfile.name,\r\n            responded_at: new Date().toISOString()\r\n        };\r\n\r\n        // Helper to update lists\r\n        const updateLists = (currentAccepted: any[], currentDeclined: any[], newStatus: string) => {\r\n            // Remove from both first\r\n            const newAccepted = currentAccepted.filter((u: any) => (typeof u === 'string' ? u : u.email) !== userProfile.email);\r\n            const newDeclined = currentDeclined.filter((u: any) => (typeof u === 'string' ? u : u.email) !== userProfile.email);\r\n\r\n            if (newStatus === 'accepted') {\r\n                newAccepted.push(respondent);\r\n            } else {\r\n                newDeclined.push(respondent);\r\n            }\r\n            return { newAccepted, newDeclined };\r\n        };\r\n\r\n        // Check for inspection\r\n        if (eventId.startsWith('inspection-')) {\r\n            const realId = eventId.replace('inspection-', '');\r\n            const current = await db.prepare(\"SELECT accepted_by, declined_by FROM inspections WHERE id = ? AND organization_id = ?\").bind(realId, orgId).first();\r\n\r\n            if (!current) return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n\r\n            const curAccepted = typeof current.accepted_by === 'string' ? JSON.parse(current.accepted_by) : (current.accepted_by || []);\r\n            const curDeclined = typeof current.declined_by === 'string' ? JSON.parse(current.declined_by) : (current.declined_by || []);\r\n\r\n            const { newAccepted, newDeclined } = updateLists(curAccepted, curDeclined, status);\r\n\r\n            await db.prepare(`\r\n                UPDATE inspections \r\n                SET accepted_by = ?, declined_by = ?, updated_at = NOW()\r\n                WHERE id = ?\r\n            `).bind(JSON.stringify(newAccepted), JSON.stringify(newDeclined), realId).run();\r\n\r\n            return c.json({ message: \"Resposta registrada\" });\r\n        }\r\n\r\n        // Standard Event\r\n        const current = await db.prepare(\"SELECT accepted_by, declined_by FROM calendar_events WHERE id = ? AND organization_id = ?\").bind(eventId, orgId).first();\r\n\r\n        if (!current) return c.json({ error: \"Evento não encontrado\" }, 404);\r\n\r\n        const curAccepted = typeof current.accepted_by === 'string' ? JSON.parse(current.accepted_by) : (current.accepted_by || []);\r\n        const curDeclined = typeof current.declined_by === 'string' ? JSON.parse(current.declined_by) : (current.declined_by || []);\r\n\r\n        const { newAccepted, newDeclined } = updateLists(curAccepted, curDeclined, status);\r\n\r\n        await db.prepare(`\r\n            UPDATE calendar_events \r\n            SET accepted_by = ?, declined_by = ?, updated_at = NOW()\r\n            WHERE id = ?\r\n        `).bind(JSON.stringify(newAccepted), JSON.stringify(newDeclined), eventId).run();\r\n\r\n        return c.json({ message: \"Resposta registrada\" });\r\n\r\n    } catch (error) {\r\n        console.error('Error responding to event:', error);\r\n        return c.json({ error: 'Erro ao responder evento' }, 500);\r\n    }\r\n});\r\n\r\nexport default app;\r\n\r\n\r\n"},{"name":"calendar-settings-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { ExtendedMochaUser, USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n};\r\n\r\nconst getDatabase = (env: any) => env.DB;\r\n\r\nconst app = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Ensure table exists helper\r\nasync function ensureTableExists(db: any) {\r\n    await db.prepare(`\r\n    CREATE TABLE IF NOT EXISTS calendar_settings (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        organization_id INTEGER NOT NULL UNIQUE,\r\n        business_hours TEXT DEFAULT '{\"start\": \"08:00\", \"end\": \"18:00\", \"days\": [1,2,3,4,5]}',\r\n        holidays TEXT DEFAULT '[]',\r\n        timezone TEXT DEFAULT 'America/Sao_Paulo',\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n    );\r\n  `).run();\r\n\r\n    // Index on organization_id for performance\r\n    try {\r\n        await db.prepare(`CREATE INDEX IF NOT EXISTS idx_calendar_settings_org ON calendar_settings(organization_id)`).run();\r\n    } catch (e) {\r\n        // Ignore if index creation fails (might be duplicate name error but IF NOT EXISTS handles most)\r\n    }\r\n}\r\n\r\n// Get Settings\r\napp.get('/', tenantAuthMiddleware, async (c) => {\r\n    try {\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const db = getDatabase(c.env);\r\n\r\n        // Ensure table exists on first access\r\n        await ensureTableExists(db);\r\n\r\n        // Get user profile\r\n        const userProfile = await db.prepare(\"SELECT organization_id, managed_organization_id FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n        if (!userProfile) return c.json({ error: \"User not found\" }, 404);\r\n\r\n        const orgId = userProfile.managed_organization_id || userProfile.organization_id;\r\n\r\n        const settings = await db.prepare(\"SELECT * FROM calendar_settings WHERE organization_id = ?\").bind(orgId).first() as any;\r\n\r\n        if (!settings) {\r\n            // Return defaults if no settings exist\r\n            return c.json({\r\n                organization_id: orgId,\r\n                business_hours: { start: \"08:00\", end: \"18:00\", days: [1, 2, 3, 4, 5] },\r\n                holidays: [],\r\n                timezone: 'America/Sao_Paulo'\r\n            });\r\n        }\r\n\r\n        return c.json({\r\n            ...settings,\r\n            business_hours: JSON.parse(settings.business_hours || '{}'),\r\n            holidays: JSON.parse(settings.holidays || '[]')\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Error fetching calendar settings:', error);\r\n        return c.json({ error: 'Erro ao buscar configurações' }, 500);\r\n    }\r\n});\r\n\r\n// Update Settings\r\napp.put('/', tenantAuthMiddleware, async (c) => {\r\n    try {\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const db = getDatabase(c.env);\r\n\r\n        // Ensure table permissions\r\n        // Only Org Admin or System Admin should update settings\r\n        const userProfile = await db.prepare(\"SELECT organization_id, managed_organization_id, role FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n        if (!userProfile) return c.json({ error: \"User not found\" }, 404);\r\n\r\n        const orgId = userProfile.managed_organization_id || userProfile.organization_id;\r\n\r\n        if (userProfile.role !== USER_ROLES.ORG_ADMIN && userProfile.role !== USER_ROLES.SYSTEM_ADMIN && userProfile.role !== 'sys_admin') {\r\n            // Allow update if user manages this org\r\n            if (!userProfile.managed_organization_id || userProfile.managed_organization_id !== orgId) {\r\n                return c.json({ error: \"Permissão negada. Apenas administradores podem alterar configurações.\" }, 403);\r\n            }\r\n        }\r\n\r\n        await ensureTableExists(db);\r\n\r\n        const body = await c.req.json();\r\n        const { business_hours, holidays, timezone } = body;\r\n\r\n        // Upsert logic\r\n        const existing = await db.prepare(\"SELECT id FROM calendar_settings WHERE organization_id = ?\").bind(orgId).first();\r\n\r\n        if (existing) {\r\n            await db.prepare(`\r\n                UPDATE calendar_settings \r\n                SET business_hours = ?, holidays = ?, timezone = ?, updated_at = datetime('now')\r\n                WHERE organization_id = ?\r\n            `).bind(\r\n                JSON.stringify(business_hours),\r\n                JSON.stringify(holidays),\r\n                timezone,\r\n                orgId\r\n            ).run();\r\n        } else {\r\n            await db.prepare(`\r\n                INSERT INTO calendar_settings (organization_id, business_hours, holidays, timezone)\r\n                VALUES (?, ?, ?, ?)\r\n            `).bind(\r\n                orgId,\r\n                JSON.stringify(business_hours),\r\n                JSON.stringify(holidays),\r\n                timezone\r\n            ).run();\r\n        }\r\n\r\n        return c.json({ message: \"Configurações atualizadas com sucesso\" });\r\n\r\n    } catch (error) {\r\n        console.error('Error updating calendar settings:', error);\r\n        return c.json({ error: 'Erro ao atualizar configurações' }, 500);\r\n    }\r\n});\r\n\r\nexport default app;\r\n"},{"name":"calendar-upload-routes.ts","content":"\r\nimport { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware as authMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\r\n\r\nconst calendarUploadRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\ntype Env = {\r\n    DB: any;\r\n    SUPABASE_URL: string;\r\n    SUPABASE_SERVICE_ROLE_KEY: string;\r\n};\r\n\r\n// File size limits in bytes (same as media-routes)\r\nconst FILE_SIZE_LIMITS = {\r\n    image: 10 * 1024 * 1024,      // 10 MB\r\n    video: 100 * 1024 * 1024,     // 100 MB\r\n    audio: 20 * 1024 * 1024,      // 20 MB\r\n    document: 50 * 1024 * 1024    // 50 MB\r\n};\r\n\r\ncalendarUploadRoutes.post(\"/upload\", authMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const {\r\n            file_name,\r\n            file_data,\r\n            file_size,\r\n            mime_type\r\n        } = body;\r\n\r\n        // Determine media type for validation\r\n        let mediaType = 'document';\r\n        if (mime_type.startsWith('image/')) mediaType = 'image';\r\n        else if (mime_type.startsWith('video/')) mediaType = 'video';\r\n        else if (mime_type.startsWith('audio/')) mediaType = 'audio';\r\n\r\n        // Validate size\r\n        const limit = FILE_SIZE_LIMITS[mediaType as keyof typeof FILE_SIZE_LIMITS];\r\n        if (file_size > limit) {\r\n            return c.json({ error: `Arquivo muito grande. Limite: ${limit / 1024 / 1024}MB` }, 400);\r\n        }\r\n\r\n        const supabaseUrl = env.SUPABASE_URL;\r\n        const supabaseServiceKey = env.SUPABASE_SERVICE_ROLE_KEY;\r\n\r\n        if (!supabaseUrl || !supabaseServiceKey) {\r\n            return c.json({ error: \"Storage not configured\" }, 500);\r\n        }\r\n\r\n        const supabase = createClient(supabaseUrl, supabaseServiceKey);\r\n\r\n        // Convert base64 to binary\r\n        const base64Data = file_data.split(',')[1];\r\n        const binaryData = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));\r\n\r\n        // Generate unique path\r\n        const timestamp = Date.now();\r\n        const sanitizedFileName = file_name.replace(/[^a-zA-Z0-9.-]/g, '_');\r\n        const filePath = `calendar_uploads/${user.organization_id}/${timestamp}_${sanitizedFileName}`;\r\n\r\n        // Upload to 'inspection-media' bucket (reusing existing bucket)\r\n        const { data: uploadData, error: uploadError } = await supabase.storage\r\n            .from('inspection-media')\r\n            .upload(filePath, binaryData, {\r\n                contentType: mime_type,\r\n                upsert: false\r\n            });\r\n\r\n        if (uploadError) {\r\n            console.error('Supabase Storage error:', uploadError);\r\n            throw new Error(uploadError.message);\r\n        }\r\n\r\n        // Get public URL\r\n        const { data: urlData } = supabase.storage\r\n            .from('inspection-media')\r\n            .getPublicUrl(filePath);\r\n\r\n        return c.json({\r\n            success: true,\r\n            file_url: urlData.publicUrl,\r\n            file_name: file_name\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Error uploading calendar attachment:', error);\r\n        return c.json({\r\n            error: \"Erro ao fazer upload\",\r\n            details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n        }, 500);\r\n    }\r\n});\r\n\r\nexport default calendarUploadRoutes;\r\n"},{"name":"cep-routes.ts","content":"import { Hono } from \"hono\";\r\n\r\nconst cepRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Helper function to perform CEP lookup with proper error handling\r\nconst performCepLookup = async (cepInput: string) => {\r\n  try {\r\n    if (!cepInput) {\r\n      return {\r\n        success: false,\r\n        error: \"CEP é obrigatório\",\r\n        status: 400\r\n      };\r\n    }\r\n\r\n    // Clean CEP (remove dots, dashes, spaces)\r\n    const cleanCep = cepInput.replace(/[-.\\s]/g, '');\r\n\r\n    // Validate CEP format (8 digits)\r\n    if (!/^\\d{8}$/.test(cleanCep)) {\r\n      return {\r\n        success: false,\r\n        error: \"CEP deve conter 8 dígitos numéricos\",\r\n        status: 400\r\n      };\r\n    }\r\n\r\n    // Call external CEP API (using ViaCEP)\r\n    const apiUrl = `https://viacep.com.br/ws/${cleanCep}/json/`;\r\n\r\n    const response = await globalThis.fetch(apiUrl, {\r\n      headers: {\r\n        'User-Agent': 'Mozilla/5.0 (compatible; InspectionApp/1.0)',\r\n      }\r\n    });\r\n\r\n    if (!response.ok) {\r\n      if (response.status === 429) {\r\n        return {\r\n          success: false,\r\n          error: \"Muitas consultas. Tente novamente em alguns minutos.\",\r\n          status: 429\r\n        };\r\n      }\r\n      return {\r\n        success: false,\r\n        error: `Erro na consulta externa: ${response.status}`,\r\n        status: 502\r\n      };\r\n    }\r\n\r\n    const cepData = await response.json() as any;\r\n\r\n    if (cepData.erro) {\r\n      return {\r\n        success: false,\r\n        error: \"CEP não encontrado\",\r\n        status: 404\r\n      };\r\n    }\r\n\r\n    // Transform data to match our address format\r\n    const addressData = {\r\n      cep: cepData.cep,\r\n      address: `${cepData.logradouro}${cepData.complemento ? ', ' + cepData.complemento : ''}, ${cepData.bairro}, ${cepData.localidade}/${cepData.uf}`,\r\n      logradouro: cepData.logradouro,\r\n      complemento: cepData.complemento,\r\n      bairro: cepData.bairro,\r\n      localidade: cepData.localidade,\r\n      uf: cepData.uf,\r\n      ibge: cepData.ibge,\r\n      gia: cepData.gia,\r\n      ddd: cepData.ddd,\r\n      siafi: cepData.siafi\r\n    };\r\n\r\n    return {\r\n      success: true,\r\n      data: addressData,\r\n      status: 200\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('CEP lookup error:', error);\r\n    return {\r\n      success: false,\r\n      error: \"Erro interno ao consultar CEP\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\",\r\n      status: 500\r\n    };\r\n  }\r\n};\r\n\r\n// CEP lookup endpoint with path parameter\r\ncepRoutes.get(\"/:cep\", async (c) => {\r\n  // Set proper JSON content type header\r\n  c.header('Content-Type', 'application/json');\r\n\r\n  const cep = c.req.param(\"cep\");\r\n  const result = await performCepLookup(cep);\r\n\r\n  if (result.success && result.data) {\r\n    return c.json({\r\n      success: true,\r\n      data: result.data,\r\n      address: result.data.address\r\n    }, 200);\r\n  } else {\r\n    return c.json({\r\n      error: result.error,\r\n      details: result.details\r\n    }, result.status as any);\r\n  }\r\n});\r\n\r\nexport default cepRoutes;\r\n\r\n"},{"name":"checklist-folders-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\nimport { requireScopes, SCOPES, createAuthErrorResponse, isSystemAdmin } from \"./rbac-middleware.ts\";\r\nimport { logActivity } from \"./audit-logger.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n};\r\n\r\nconst checklistFoldersRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Função para gerar slug único\r\nfunction generateSlug(name: string, existing: string[] = []): string {\r\n  let baseSlug = name\r\n    .toLowerCase()\r\n    .normalize('NFD')\r\n    .replace(/[\\u0300-\\u036f]/g, '') // Remove acentos\r\n    .replace(/[^a-z0-9]/g, '-')\r\n    .replace(/-+/g, '-')\r\n    .replace(/^-|-$/g, '');\r\n\r\n  let slug = baseSlug;\r\n  let counter = 1;\r\n\r\n  while (existing.includes(slug)) {\r\n    slug = `${baseSlug}-${counter}`;\r\n    counter++;\r\n  }\r\n\r\n  return slug;\r\n}\r\n\r\n// Função para construir path baseado na hierarquia\r\nasync function buildFolderPath(db: any, folderId: string): Promise<string> {\r\n  const pathParts: string[] = [];\r\n  let currentId: string | null = folderId;\r\n\r\n  while (currentId) {\r\n    const folder = await db.prepare(\"SELECT slug, parent_id FROM checklist_folders WHERE id = ?\")\r\n      .bind(currentId).first() as any;\r\n\r\n    if (!folder) break;\r\n\r\n    pathParts.unshift(folder.slug);\r\n    currentId = folder.parent_id;\r\n  }\r\n\r\n  return '/' + pathParts.join('/');\r\n}\r\n\r\n// Migração segura de categorias existentes para pastas\r\nchecklistFoldersRoutes.post(\"/migrate-categories\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Buscar perfil do usuário\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Verificar permissões - admins ou gestores da organização\r\n    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'admin';\r\n    const isOrgAdmin = userProfile?.role === USER_ROLES.ORG_ADMIN || userProfile?.role === USER_ROLES.MANAGER;\r\n\r\n    if (!isSysAdmin && (!isOrgAdmin || !userProfile?.organization_id)) {\r\n      return c.json({ error: \"Insufficient permissions for migration\" }, 403);\r\n    }\r\n\r\n    let query = `\r\n      SELECT DISTINCT organization_id \r\n      FROM checklist_templates \r\n      WHERE organization_id IS NOT NULL AND folder_id IS NULL\r\n    `;\r\n    let params: any[] = [];\r\n\r\n    // Se não for sysadmin, restringir à própria organização\r\n    if (!isSysAdmin && userProfile?.organization_id) {\r\n      query += \" AND organization_id = ?\";\r\n      params.push(userProfile.organization_id);\r\n    }\r\n\r\n    // Buscar organizações para migrar\r\n    const organizations = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    let totalMigrated = 0;\r\n    const migrationDetails: any[] = [];\r\n\r\n    for (const org of organizations.results) {\r\n      const orgId = (org as any).organization_id;\r\n\r\n      // Buscar categorias únicas nesta organização\r\n      const categories = await env.DB.prepare(`\r\n        SELECT DISTINCT category \r\n        FROM checklist_templates \r\n        WHERE organization_id = ? AND folder_id IS NULL AND is_category_folder = false\r\n      `).bind(orgId).all();\r\n\r\n      let orgMigrated = 0;\r\n\r\n      for (const cat of categories.results) {\r\n        const categoryName = (cat as any).category;\r\n\r\n        if (!categoryName || categoryName.trim() === '') continue;\r\n\r\n        // Verificar se pasta já existe\r\n        const existingFolder = await env.DB.prepare(`\r\n          SELECT id FROM checklist_folders \r\n          WHERE organization_id = ? AND name = ? AND parent_id IS NULL\r\n        `).bind(orgId, categoryName).first() as any;\r\n\r\n        let folderId: string;\r\n\r\n        if (existingFolder) {\r\n          folderId = existingFolder.id;\r\n        } else {\r\n          // Criar nova pasta para esta categoria\r\n          const existingSlugs = await env.DB.prepare(`\r\n            SELECT slug FROM checklist_folders WHERE organization_id = ? AND parent_id IS NULL\r\n          `).bind(orgId).all();\r\n\r\n          const slugs = existingSlugs.results.map((r: any) => r.slug);\r\n          const slug = generateSlug(categoryName, slugs);\r\n          const path = `/${slug}`;\r\n\r\n          const result = await env.DB.prepare(`\r\n            INSERT INTO checklist_folders (\r\n              organization_id, parent_id, name, slug, path, description,\r\n              color, icon, display_order, created_at, updated_at\r\n            ) VALUES (?, NULL, ?, ?, ?, ?, '#3B82F6', 'folder', 0, NOW(), NOW())\r\n          `).bind(\r\n            orgId,\r\n            categoryName,\r\n            slug,\r\n            path,\r\n            `Pasta criada automaticamente da categoria: ${categoryName}`\r\n          ).run();\r\n\r\n          folderId = result.meta.last_row_id as string;\r\n        }\r\n\r\n        // Migrar templates desta categoria para a pasta\r\n        const updateResult = await env.DB.prepare(`\r\n          UPDATE checklist_templates \r\n          SET folder_id = ?, updated_at = NOW()\r\n          WHERE organization_id = ? AND category = ? AND folder_id IS NULL AND is_category_folder = false\r\n        `).bind(folderId, orgId, categoryName).run();\r\n\r\n        orgMigrated += updateResult.meta.changes || 0;\r\n      }\r\n\r\n      if (orgMigrated > 0) {\r\n        migrationDetails.push({\r\n          organization_id: orgId,\r\n          templates_migrated: orgMigrated\r\n        });\r\n        totalMigrated += orgMigrated;\r\n      }\r\n    }\r\n\r\n    // Log da migração\r\n    await env.DB.prepare(`\r\n      INSERT INTO migrations_log (migration_type, details, items_migrated, created_at)\r\n      VALUES ('category_to_folder', ?, ?, NOW())\r\n    `).bind(\r\n      JSON.stringify({\r\n        organizations_migrated: migrationDetails.length,\r\n        details: migrationDetails,\r\n        total_templates: totalMigrated\r\n      }),\r\n      totalMigrated\r\n    ).run();\r\n\r\n    // Global Log Activity\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: userProfile?.organization_id || null,\r\n      actionType: 'MIGRATE',\r\n      actionDescription: `Checklist Categories Migrated to Folders`,\r\n      targetType: 'SYSTEM',\r\n      targetId: null,\r\n      metadata: { organizations_migrated: migrationDetails.length, total_templates: totalMigrated },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: `Migração concluída com sucesso`,\r\n      organizations_migrated: migrationDetails.length,\r\n      templates_migrated: totalMigrated,\r\n      details: migrationDetails\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error in category migration:', error);\r\n    return c.json({\r\n      error: \"Failed to migrate categories\",\r\n      details: error instanceof Error ? error.message : \"Unknown error\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Listar pastas com contadores (requires checklist:folders:read scope)\r\nchecklistFoldersRoutes.get(\"/folders\", tenantAuthMiddleware, requireScopes(SCOPES.CHECKLIST_FOLDERS_READ), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Buscar perfil do usuário\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n    const parentId = c.req.query('parent_id') || null;\r\n\r\n    if (!userProfile?.organization_id) {\r\n      return c.json(createAuthErrorResponse('forbidden', 'Usuário não possui organização associada', [SCOPES.CHECKLIST_FOLDERS_READ]), 403);\r\n    }\r\n\r\n    let whereClause = \"WHERE (f.organization_id = ? OR f.organization_id IS NULL)\";\r\n    let params: any[] = [userProfile?.organization_id];\r\n\r\n    if (parentId === null || parentId === 'null') {\r\n      whereClause += \" AND f.parent_id IS NULL\";\r\n    } else {\r\n      whereClause += \" AND f.parent_id = ?\";\r\n      params.push(parentId);\r\n    }\r\n\r\n    // Buscar pastas com contadores\r\n    const folders = await env.DB.prepare(`\r\n      SELECT \r\n        f.*,\r\n        COUNT(DISTINCT cf.id) as subfolder_count,\r\n        COUNT(DISTINCT ct.id) as template_count\r\n      FROM checklist_folders f\r\n      LEFT JOIN checklist_folders cf ON cf.parent_id = f.id\r\n      LEFT JOIN checklist_templates ct ON ct.folder_id = f.id AND ct.is_category_folder = false\r\n      ${whereClause}\r\n      GROUP BY f.id\r\n      ORDER BY f.display_order ASC, f.name ASC\r\n    `).bind(...params).all();\r\n\r\n    return c.json({\r\n      folders: folders.results || [],\r\n      parent_id: parentId\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching folders:', error);\r\n    return c.json({ error: error instanceof Error ? error.message : \"Failed to fetch folders\" }, 500);\r\n  }\r\n});\r\n\r\n// Obter árvore de pastas (leve para breadcrumbs)\r\nchecklistFoldersRoutes.get(\"/tree\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Buscar perfil do usuário\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Buscar todas as pastas da organização com contadores\r\n    const folders = await env.DB.prepare(`\r\n      SELECT \r\n        f.id, f.parent_id, f.name, f.slug, f.path, f.color, f.icon, f.display_order,\r\n        COUNT(DISTINCT cf.id) as subfolder_count,\r\n        COUNT(DISTINCT ct.id) as template_count\r\n      FROM checklist_folders f\r\n      LEFT JOIN checklist_folders cf ON cf.parent_id = f.id\r\n      LEFT JOIN checklist_templates ct ON ct.folder_id = f.id AND (ct.is_category_folder = false OR ct.is_category_folder IS NULL)\r\n      WHERE (f.organization_id = ? OR f.organization_id IS NULL)\r\n      GROUP BY f.id\r\n      ORDER BY f.display_order ASC, f.name ASC\r\n    `).bind(userProfile?.organization_id).all();\r\n\r\n    // Construir árvore hierárquica (limitada a 3 níveis por performance)\r\n    function buildTree(parentId: string | null = null, currentDepth = 0): any[] {\r\n      if (currentDepth >= 3) return [];\r\n\r\n      return (folders.results as any[])\r\n        .filter(f => f.parent_id === parentId)\r\n        .map(folder => ({\r\n          ...folder,\r\n          children: buildTree(folder.id, currentDepth + 1)\r\n        }));\r\n    }\r\n\r\n    const tree = buildTree();\r\n\r\n    return c.json({ tree });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching folder tree:', error);\r\n    return c.json({ error: error instanceof Error ? error.message : \"Failed to fetch folder tree\" }, 500);\r\n  }\r\n});\r\n\r\n// Get folder path/breadcrumb\r\nchecklistFoldersRoutes.get(\"/folders/:id/path\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const folderId = c.req.param(\"id\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Buscar perfil do usuário\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Build path from root to this folder\r\n    const path: any[] = [];\r\n    let currentId: string | null = folderId;\r\n\r\n    while (currentId) {\r\n      const folder = await env.DB.prepare(`\r\n        SELECT id, name, slug, parent_id, color, icon \r\n        FROM checklist_folders \r\n        WHERE id = ? AND organization_id = ?\r\n      `).bind(currentId, userProfile?.organization_id).first() as any;\r\n\r\n      if (!folder) break;\r\n\r\n      path.unshift(folder); // Add to beginning to build path from root\r\n      currentId = folder.parent_id;\r\n    }\r\n\r\n    return c.json({ path });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching folder path:', error);\r\n    return c.json({ error: \"Failed to fetch folder path\" }, 500);\r\n  }\r\n});\r\n\r\n// Criar nova pasta (requires checklist:folders:write scope)\r\nchecklistFoldersRoutes.post(\"/folders\", tenantAuthMiddleware, requireScopes(SCOPES.CHECKLIST_FOLDERS_WRITE), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { name, description, parent_id, color, icon } = body;\r\n\r\n    if (!name || name.trim() === '') {\r\n      return c.json({ error: \"Nome da pasta é obrigatório\" }, 400);\r\n    }\r\n\r\n    // Buscar perfil do usuário\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    if (!userProfile?.organization_id) {\r\n      return c.json(createAuthErrorResponse('forbidden', 'Usuário não possui organização associada', [SCOPES.CHECKLIST_FOLDERS_WRITE]), 403);\r\n    }\r\n\r\n    // Verificar se pasta pai existe (se especificada)\r\n    if (parent_id) {\r\n      const parentFolder = await env.DB.prepare(`\r\n        SELECT id FROM checklist_folders \r\n        WHERE id = ? AND organization_id = ?\r\n      `).bind(parent_id, userProfile?.organization_id).first();\r\n\r\n      if (!parentFolder) {\r\n        return c.json({ error: \"Pasta pai não encontrada\" }, 404);\r\n      }\r\n    }\r\n\r\n    // Gerar slug único\r\n    const existingSlugs = await env.DB.prepare(`\r\n      SELECT slug FROM checklist_folders \r\n      WHERE organization_id = ? AND parent_id ${parent_id ? '= ?' : 'IS NULL'}\r\n    `).bind(userProfile?.organization_id, ...(parent_id ? [parent_id] : [])).all();\r\n\r\n    const slugs = existingSlugs.results.map((r: any) => r.slug);\r\n    const slug = generateSlug(name, slugs);\r\n\r\n    // Criar pasta\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO checklist_folders (\r\n        organization_id, parent_id, name, slug, path, description,\r\n        color, icon, display_order, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, '', ?, ?, ?, 0, NOW(), NOW())\r\n    `).bind(\r\n      userProfile?.organization_id,\r\n      parent_id || null,\r\n      name.trim(),\r\n      slug,\r\n      description?.trim() || null,\r\n      color || '#3B82F6',\r\n      icon || 'folder'\r\n    ).run();\r\n\r\n    const folderId = result.meta.last_row_id as string;\r\n\r\n    // Construir e atualizar o path\r\n    const path = await buildFolderPath(env.DB, folderId);\r\n    await env.DB.prepare(\"UPDATE checklist_folders SET path = ? WHERE id = ?\")\r\n      .bind(path, folderId).run();\r\n\r\n    // Log Creation\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: userProfile?.organization_id,\r\n      actionType: 'CREATE',\r\n      actionDescription: `Checklist Folder Created: ${name}`,\r\n      targetType: 'CHECKLIST_FOLDER',\r\n      targetId: folderId,\r\n      metadata: { name, slug, path },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({\r\n      id: folderId,\r\n      message: \"Pasta criada com sucesso\",\r\n      slug,\r\n      path\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating folder:', error);\r\n    return c.json({ error: \"Failed to create folder\" }, 500);\r\n  }\r\n});\r\n\r\n// Atualizar pasta (renomear/mover) (requires checklist:folders:write scope)\r\nchecklistFoldersRoutes.patch(\"/folders/:id\", tenantAuthMiddleware, requireScopes(SCOPES.CHECKLIST_FOLDERS_WRITE), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const folderId = c.req.param(\"id\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { name, description, parent_id, color, icon } = body;\r\n\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Verificar se pasta existe\r\n    const folder = await env.DB.prepare(`\r\n      SELECT * FROM checklist_folders \r\n      WHERE id = ? AND organization_id = ?\r\n    `).bind(folderId, userProfile?.organization_id).first() as any;\r\n\r\n    if (!folder) {\r\n      return c.json({ error: \"Pasta não encontrada\" }, 404);\r\n    }\r\n\r\n    // Verificação de permissões já foi feita pelo middleware RBAC\r\n\r\n    // Verificar se novo pai não cria ciclo\r\n    if (parent_id && parent_id !== folder.parent_id) {\r\n      let currentParent = parent_id;\r\n      while (currentParent) {\r\n        if (currentParent === folderId) {\r\n          return c.json({ error: \"Não é possível mover pasta para dentro de si mesma\" }, 400);\r\n        }\r\n\r\n        const parentFolder = await env.DB.prepare(\"SELECT parent_id FROM checklist_folders WHERE id = ?\")\r\n          .bind(currentParent).first() as any;\r\n        currentParent = parentFolder?.parent_id;\r\n      }\r\n    }\r\n\r\n    let newSlug = folder.slug;\r\n\r\n    // Se nome mudou, gerar novo slug\r\n    if (name && name.trim() !== folder.name) {\r\n      const existingSlugs = await env.DB.prepare(`\r\n        SELECT slug FROM checklist_folders \r\n        WHERE organization_id = ? AND parent_id ${parent_id ? '= ?' : 'IS NULL'} AND id != ?\r\n      `).bind(userProfile?.organization_id, ...(parent_id ? [parent_id] : []), folderId).all();\r\n\r\n      const slugs = existingSlugs.results.map((r: any) => r.slug);\r\n      newSlug = generateSlug(name.trim(), slugs);\r\n    }\r\n\r\n    // Atualizar pasta\r\n    await env.DB.prepare(`\r\n      UPDATE checklist_folders SET \r\n        name = COALESCE(?, name),\r\n        description = COALESCE(?, description),\r\n        parent_id = COALESCE(?, parent_id),\r\n        slug = ?,\r\n        color = COALESCE(?, color),\r\n        icon = COALESCE(?, icon),\r\n        updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(\r\n      name?.trim(),\r\n      description?.trim(),\r\n      parent_id,\r\n      newSlug,\r\n      color,\r\n      icon,\r\n      folderId\r\n    ).run();\r\n\r\n    // Reconstruir paths se houve mudança de nome ou pai\r\n    if ((name && name.trim() !== folder.name) || (parent_id !== folder.parent_id)) {\r\n      await updateFolderPaths(env.DB, folderId);\r\n    }\r\n\r\n    return c.json({ message: \"Pasta atualizada com sucesso\" });\r\n\r\n    // Log Update (Async)\r\n    logActivity(env, {\r\n      userId: user.id,\r\n      orgId: userProfile?.organization_id,\r\n      actionType: 'UPDATE',\r\n      actionDescription: `Checklist Folder Updated: ${name || folder.name}`,\r\n      targetType: 'CHECKLIST_FOLDER',\r\n      targetId: folderId,\r\n      metadata: { name, description, parent_id },\r\n      req: c.req\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating folder:', error);\r\n    return c.json({ error: \"Failed to update folder\" }, 500);\r\n  }\r\n});\r\n\r\n// Função auxiliar para atualizar paths em cascata\r\nasync function updateFolderPaths(db: any, folderId: string) {\r\n  // Atualizar path da pasta atual\r\n  const newPath = await buildFolderPath(db, folderId);\r\n  await db.prepare(\"UPDATE checklist_folders SET path = ? WHERE id = ?\")\r\n    .bind(newPath, folderId).run();\r\n\r\n  // Atualizar subpastas recursivamente\r\n  const children = await db.prepare(\"SELECT id FROM checklist_folders WHERE parent_id = ?\")\r\n    .bind(folderId).all();\r\n\r\n  for (const child of children.results) {\r\n    await updateFolderPaths(db, (child as any).id);\r\n  }\r\n}\r\n\r\n// Excluir pasta (requires checklist:folders:delete scope)\r\nchecklistFoldersRoutes.delete(\"/folders/:id\", tenantAuthMiddleware, requireScopes(SCOPES.CHECKLIST_FOLDERS_DELETE), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const folderId = c.req.param(\"id\");\r\n  const strategy = c.req.query('strategy') || 'block';\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Verificar se pasta existe\r\n    const folder = await env.DB.prepare(`\r\n      SELECT * FROM checklist_folders \r\n      WHERE id = ? AND organization_id = ?\r\n    `).bind(folderId, userProfile?.organization_id).first() as any;\r\n\r\n    if (!folder) {\r\n      return c.json({ error: \"Pasta não encontrada\" }, 404);\r\n    }\r\n\r\n    // Verificar permissões para cascade (apenas system admin)\r\n    if (strategy === 'cascade' && !isSystemAdmin(userProfile?.role)) {\r\n      return c.json(createAuthErrorResponse('forbidden', 'Apenas administradores de sistema podem usar exclusão em cascata', [SCOPES.SYSTEM_ADMIN]), 403);\r\n    }\r\n\r\n    // Verificar conteúdo da pasta\r\n    const subfolders = await env.DB.prepare(\"SELECT COUNT(*) as count FROM checklist_folders WHERE parent_id = ?\")\r\n      .bind(folderId).first() as any;\r\n    const templates = await env.DB.prepare(\"SELECT COUNT(*) as count FROM checklist_templates WHERE folder_id = ?\")\r\n      .bind(folderId).first() as any;\r\n\r\n    const hasContent = (subfolders?.count || 0) > 0 || (templates?.count || 0) > 0;\r\n\r\n    if (strategy === 'block' && hasContent) {\r\n      return c.json({\r\n        error: \"Pasta contém itens. Use estratégia 'merge' ou 'cascade' para proceder\",\r\n        subfolders: subfolders?.count || 0,\r\n        templates: templates?.count || 0\r\n      }, 400);\r\n    }\r\n\r\n    if (strategy === 'merge') {\r\n      // Mover conteúdo para pasta pai\r\n      await env.DB.prepare(\"UPDATE checklist_folders SET parent_id = ? WHERE parent_id = ?\")\r\n        .bind(folder.parent_id, folderId).run();\r\n      await env.DB.prepare(\"UPDATE checklist_templates SET folder_id = ? WHERE folder_id = ?\")\r\n        .bind(folder.parent_id, folderId).run();\r\n\r\n      // Atualizar paths das subpastas movidas\r\n      const movedFolders = await env.DB.prepare(\"SELECT id FROM checklist_folders WHERE parent_id = ?\")\r\n        .bind(folder.parent_id).all();\r\n      for (const moved of movedFolders.results) {\r\n        await updateFolderPaths(env.DB, (moved as any).id);\r\n      }\r\n    } else if (strategy === 'cascade') {\r\n      // Excluir recursivamente (apenas system_admin)\r\n      await deleteFolder(env.DB, folderId);\r\n    }\r\n\r\n    // Excluir a pasta\r\n    await env.DB.prepare(\"DELETE FROM checklist_folders WHERE id = ?\").bind(folderId).run();\r\n\r\n    return c.json({ message: \"Pasta excluída com sucesso\" });\r\n\r\n    // Log Deletion (Async)\r\n    logActivity(env, {\r\n      userId: user.id,\r\n      orgId: userProfile?.organization_id,\r\n      actionType: 'DELETE',\r\n      actionDescription: `Checklist Folder Deleted: ${folder.name}`,\r\n      targetType: 'CHECKLIST_FOLDER',\r\n      targetId: folderId,\r\n      metadata: { name: folder.name, strategy },\r\n      req: c.req\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error deleting folder:', error);\r\n    return c.json({ error: \"Failed to delete folder\" }, 500);\r\n  }\r\n});\r\n\r\n// Função auxiliar para exclusão em cascata\r\nasync function deleteFolder(db: any, folderId: string) {\r\n  // Excluir subpastas recursivamente\r\n  const subfolders = await db.prepare(\"SELECT id FROM checklist_folders WHERE parent_id = ?\")\r\n    .bind(folderId).all();\r\n\r\n  for (const subfolder of subfolders.results) {\r\n    await deleteFolder(db, (subfolder as any).id);\r\n  }\r\n\r\n  // Excluir templates da pasta\r\n  await db.prepare(\"DELETE FROM checklist_templates WHERE folder_id = ?\").bind(folderId).run();\r\n\r\n  // Excluir pasta\r\n  await db.prepare(\"DELETE FROM checklist_folders WHERE id = ?\").bind(folderId).run();\r\n}\r\n\r\n// Mover itens em lote (requires checklist:folders:write scope)\r\nchecklistFoldersRoutes.post(\"/folders/:id/move-items\", tenantAuthMiddleware, requireScopes(SCOPES.CHECKLIST_FOLDERS_WRITE), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const targetFolderId = c.req.param(\"id\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { templateIds = [], folderIds = [] } = body;\r\n\r\n    // Buscar perfil do usuário\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Verificar se pasta destino existe (pode ser null para raiz)\r\n    if (targetFolderId && targetFolderId !== 'null') {\r\n      const targetFolder = await env.DB.prepare(`\r\n        SELECT id FROM checklist_folders \r\n        WHERE id = ? AND organization_id = ?\r\n      `).bind(targetFolderId, userProfile?.organization_id).first();\r\n\r\n      if (!targetFolder) {\r\n        return c.json({ error: \"Pasta destino não encontrada\" }, 404);\r\n      }\r\n    }\r\n\r\n    const finalTargetId = (targetFolderId === 'null') ? null : targetFolderId;\r\n    let movedCount = 0;\r\n\r\n    // Mover templates\r\n    if (templateIds.length > 0) {\r\n      for (const templateId of templateIds) {\r\n        const result = await env.DB.prepare(`\r\n          UPDATE checklist_templates \r\n          SET folder_id = ?, updated_at = NOW()\r\n          WHERE id = ? AND organization_id = ?\r\n        `).bind(finalTargetId, templateId, userProfile?.organization_id).run();\r\n\r\n        movedCount += result.meta.changes || 0;\r\n      }\r\n    }\r\n\r\n    // Mover pastas\r\n    if (folderIds.length > 0) {\r\n      for (const folderId of folderIds) {\r\n        // Verificar se não está tentando mover para dentro de si mesma\r\n        if (finalTargetId) {\r\n          let currentParent = finalTargetId;\r\n          let isCycle = false;\r\n\r\n          while (currentParent && !isCycle) {\r\n            if (currentParent === folderId) {\r\n              isCycle = true;\r\n              break;\r\n            }\r\n\r\n            const parent = await env.DB.prepare(\"SELECT parent_id FROM checklist_folders WHERE id = ?\")\r\n              .bind(currentParent).first() as any;\r\n            currentParent = parent?.parent_id;\r\n          }\r\n\r\n          if (isCycle) {\r\n            continue; // Pular esta pasta para evitar ciclo\r\n          }\r\n        }\r\n\r\n        const result = await env.DB.prepare(`\r\n          UPDATE checklist_folders \r\n          SET parent_id = ?, updated_at = NOW()\r\n          WHERE id = ? AND organization_id = ?\r\n        `).bind(finalTargetId, folderId, userProfile?.organization_id).run();\r\n\r\n        if (result.meta.changes && result.meta.changes > 0) {\r\n          // Atualizar paths em cascata\r\n          await updateFolderPaths(env.DB, folderId);\r\n          movedCount += result.meta.changes;\r\n        }\r\n      }\r\n    }\r\n\r\n    return c.json({\r\n      message: `${movedCount} itens movidos com sucesso`,\r\n      moved_count: movedCount\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error moving items:', error);\r\n    return c.json({ error: \"Failed to move items\" }, 500);\r\n  }\r\n});\r\n\r\nexport default checklistFoldersRoutes;\r\n\r\n"},{"name":"checklist-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\nimport { logActivity } from \"./audit-logger.ts\";\r\nimport { aiRateLimitMiddleware, finalizeAIUsage } from \"./ai-rate-limit.ts\";\r\nimport { generateAICompletion } from \"./ai-service.ts\";\r\nimport { incrementAiUsage } from \"./ai-usage-tracker.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n  OPENAI_API_KEY?: string;\r\n  [key: string]: any;\r\n};\r\n\r\nconst checklistRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// List all checklist templates - ENHANCED ADMIN VISIBILITY\r\n// List all checklist templates - ENHANCED ADMIN VISIBILITY\r\nchecklistRoutes.get(\"/templates\", tenantAuthMiddleware, async (c) => {\r\n  // Reuse the same logic - copy paste or function extraction would be better but for now replacing content\r\n  // Actually, I can just mount the same handler if I extracted it, but for this tool I need to careful.\r\n  // I will just change the existing route to be /templates OR keep both if I want backward compatibility.\r\n  // Given this is a new app phase, let's just CHANGE it to /templates as it is cleaner, \r\n  // BUT wait, looking at the code I see \"/checklist-templates\". I should probably just change that line to \"/templates\" \r\n  // since \"checklist\" is already in the prefix from index.ts.\r\n  // So URL will be /api/checklist/templates. Perfect.\r\n  return handleListTemplates(c);\r\n});\r\n\r\nchecklistRoutes.get(\"/checklist-templates\", tenantAuthMiddleware, async (c) => {\r\n  return handleListTemplates(c);\r\n});\r\n\r\nasync function handleListTemplates(c: any) {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  // Verificar se o banco de dados está disponível\r\n  if (!env?.DB) {\r\n    return c.json({ error: \"Database não disponível\", templates: [] }, 503);\r\n  }\r\n\r\n  try {\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    console.log(`[TEMPLATES] [PROD] Usuario ${user.email} role: ${userProfile?.role} org: ${userProfile?.organization_id}`);\r\n\r\n    let query = `\r\n      SELECT ct.*, \r\n             COUNT(cf.id) as field_count,\r\n             ct.is_category_folder as is_folder\r\n      FROM checklist_templates ct\r\n      LEFT JOIN checklist_fields cf ON ct.id = cf.template_id\r\n    `;\r\n    let params: any[] = [];\r\n    let whereClause = [\"(ct.is_category_folder = false OR ct.is_category_folder IS NULL)\"];\r\n\r\n    // ADMIN SYSTEM TEM ACESSO IRRESTRITO A TUDO\r\n    if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'admin') {\r\n      console.log(`[TEMPLATES] [PROD] ADMIN COMPLETO - TODAS as templates sem filtros aplicados`);\r\n    } else {\r\n      // Postgres boolean comparison requires true/false\r\n      let conditions = [\"ct.is_public = true\", \"ct.created_by_user_id = ?\"];\r\n      params.push(user.id);\r\n\r\n      if (userProfile?.organization_id) {\r\n        conditions.push(\"ct.organization_id = ?\");\r\n        params.push(userProfile.organization_id);\r\n      }\r\n      whereClause.push(`(${conditions.join(\" OR \")})`);\r\n    }\r\n\r\n    // Filter by folder_id\r\n    const folderId = c.req.query(\"folder_id\");\r\n    if (folderId && folderId !== 'null') {\r\n      whereClause.push(\"ct.folder_id = ?\");\r\n      params.push(folderId);\r\n    } else if (folderId === 'null') {\r\n      whereClause.push(\"ct.folder_id IS NULL\");\r\n    }\r\n\r\n    if (whereClause.length > 0) {\r\n      query += \" WHERE \" + whereClause.join(\" AND \");\r\n    }\r\n\r\n    query += \" GROUP BY ct.id ORDER BY ct.display_order ASC, ct.created_at DESC\";\r\n\r\n    console.log(`[TEMPLATES] [PROD] Query final: ${query}`);\r\n    console.log(`[TEMPLATES] [PROD] Parametros: ${JSON.stringify(params)}`);\r\n\r\n    const result = await env.DB.prepare(query).bind(...params).all();\r\n    const templates = result.results || [];\r\n\r\n    console.log(`[TEMPLATES] [PROD] Found ${templates.length} templates for user ${user.email} (role: ${userProfile?.role})`);\r\n\r\n    if (templates.length > 0) {\r\n      console.log(`[TEMPLATES] [PROD] Primeiras templates encontradas:`, templates.slice(0, 5).map((t: any) => ({\r\n        id: t.id,\r\n        name: t.name,\r\n        is_public: t.is_public,\r\n        organization_id: t.organization_id,\r\n        created_by_user_id: t.created_by_user_id,\r\n        is_folder: t.is_category_folder\r\n      })));\r\n    } else {\r\n      console.log(`[TEMPLATES] [PROD] ZERO templates encontradas - possível problema de filtros`);\r\n      console.log(`[TEMPLATES] [PROD] Debug info:`, {\r\n        userRole: userProfile?.role,\r\n        userOrgId: userProfile?.organization_id,\r\n        userId: user.id,\r\n        userEmail: user.email,\r\n        isSystemAdmin: userProfile?.role === USER_ROLES.SYSTEM_ADMIN,\r\n        isAdmin: userProfile?.role === 'admin'\r\n      });\r\n    }\r\n\r\n    return c.json({ templates });\r\n  } catch (error) {\r\n    console.error('[TEMPLATES] [PROD] Error fetching templates:', error);\r\n    return c.json({ error: error instanceof Error ? error.message : \"Failed to fetch templates\" }, 500);\r\n  }\r\n}\r\n\r\n// Get specific checklist template with fields\r\nchecklistRoutes.get(\"/checklist-templates/:id\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const templateId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get template\r\n    const template = await env.DB.prepare(\"SELECT * FROM checklist_templates WHERE id = ?\").bind(templateId).first() as any;\r\n\r\n    if (!template) {\r\n      return c.json({ error: \"Template not found\" }, 404);\r\n    }\r\n\r\n    // Check access permissions\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n    const canAccess = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||\r\n      template.is_public ||\r\n      template.created_by_user_id === user.id ||\r\n      template.organization_id === userProfile?.organization_id;\r\n\r\n    if (!canAccess) {\r\n      return c.json({ error: \"Access denied\" }, 403);\r\n    }\r\n\r\n    // Get fields\r\n    const fields = await env.DB.prepare(`\r\n      SELECT * FROM checklist_fields \r\n      WHERE template_id = ? \r\n      ORDER BY order_index ASC\r\n    `).bind(templateId).all();\r\n\r\n    return c.json({\r\n      template,\r\n      fields: fields.results || []\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching template:', error);\r\n    return c.json({ error: \"Failed to fetch template\" }, 500);\r\n  }\r\n});\r\n\r\n// Create checklist template\r\nchecklistRoutes.post(\"/checklist-templates\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { name, description, category, is_public, parent_category_id, folder_id } = body;\r\n\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO checklist_templates (\r\n        name, description, category, created_by, created_by_user_id, \r\n        organization_id, is_public, parent_category_id, folder_id,\r\n        created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW()) RETURNING id\r\n    `).bind(\r\n      name,\r\n      description || null,\r\n      category,\r\n      user.google_user_data?.name || user.email,\r\n      user.id,\r\n      userProfile?.organization_id || null,\r\n      is_public || false,\r\n      parent_category_id || null,\r\n      folder_id || null\r\n    ).run();\r\n\r\n    const newTemplateId = result.meta.last_row_id;\r\n\r\n    // Log Activity\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: userProfile?.organization_id || null,\r\n      actionType: 'CREATE',\r\n      actionDescription: `Checklist Template Created: ${name}`,\r\n      targetType: 'CHECKLIST_TEMPLATE',\r\n      targetId: newTemplateId,\r\n      metadata: { name, category, is_public },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({\r\n      id: newTemplateId,\r\n      message: \"Template created successfully\"\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating template:', error);\r\n    return c.json({ error: \"Failed to create template\" }, 500);\r\n  }\r\n});\r\n\r\n// Create checklist field\r\nchecklistRoutes.post(\"/checklist-fields\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    console.log('[CHECKLIST_FIELDS] Received body:', JSON.stringify(body));\r\n    const { template_id, field_name, field_type, is_required, options, order_index } = body;\r\n\r\n    if (!template_id || !field_name || !field_type) {\r\n      return c.json({ error: \"Missing required fields\" }, 400);\r\n    }\r\n\r\n    // Verify template ownership/access\r\n    const template = await env.DB.prepare(\"SELECT * FROM checklist_templates WHERE id = ?\").bind(template_id).first() as any;\r\n\r\n    if (!template) {\r\n      return c.json({ error: \"Template not found\" }, 404);\r\n    }\r\n\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Check permissions\r\n    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||\r\n      userProfile?.role === 'sys_admin' ||\r\n      userProfile?.role === 'admin';\r\n\r\n    if (!isSysAdmin) {\r\n      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {\r\n        return c.json({ error: \"Insufficient permissions\" }, 403);\r\n      }\r\n    }\r\n\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO checklist_fields (\r\n        template_id, field_name, field_type, is_required, options, order_index,\r\n        created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW()) RETURNING id\r\n    `).bind(\r\n      template_id,\r\n      field_name,\r\n      field_type,\r\n      is_required ? 1 : 0,\r\n      options || null,\r\n      order_index || 0\r\n    ).run();\r\n\r\n    return c.json({\r\n      id: result.meta.last_row_id,\r\n      message: \"Field created successfully\"\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating field:', error);\r\n    return c.json({ error: \"Failed to create field\" }, 500);\r\n  }\r\n});\r\n\r\n// Update checklist template\r\nchecklistRoutes.put(\"/checklist-templates/:id\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const templateId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { name, description, category, is_public, folder_id } = body;\r\n\r\n    // Check template ownership\r\n    const template = await env.DB.prepare(\"SELECT * FROM checklist_templates WHERE id = ?\").bind(templateId).first() as any;\r\n\r\n    if (!template) {\r\n      return c.json({ error: \"Template not found\" }, 404);\r\n    }\r\n\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Check permissions - SYS_ADMIN TEM ACESSO TOTAL\r\n    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||\r\n      userProfile?.role === 'sys_admin' ||\r\n      userProfile?.role === 'admin';\r\n\r\n    if (!isSysAdmin) {\r\n      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {\r\n        return c.json({ error: \"Insufficient permissions\" }, 403);\r\n      }\r\n    }\r\n\r\n    await env.DB.prepare(`\r\n      UPDATE checklist_templates \r\n      SET name = ?, description = ?, category = ?, is_public = ?, folder_id = ?, updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(name, description, category, is_public, folder_id || null, templateId).run();\r\n\r\n    // Log update\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: template.organization_id, // Use template org\r\n      actionType: 'UPDATE',\r\n      actionDescription: `Checklist Template Updated: ${name || template.name}`,\r\n      targetType: 'CHECKLIST_TEMPLATE',\r\n      targetId: templateId,\r\n      metadata: { name, category, is_public },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({ message: \"Template updated successfully\" });\r\n  } catch (error) {\r\n    console.error('Error updating template:', error);\r\n    return c.json({ error: \"Failed to update template\" }, 500);\r\n  }\r\n});\r\n\r\n// Delete checklist template\r\nchecklistRoutes.delete(\"/checklist-templates/:id\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const templateId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Check template ownership\r\n    const template = await env.DB.prepare(\"SELECT * FROM checklist_templates WHERE id = ?\").bind(templateId).first() as any;\r\n\r\n    if (!template) {\r\n      return c.json({ error: \"Template not found\" }, 404);\r\n    }\r\n\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Check permissions - SYS_ADMIN TEM ACESSO TOTAL\r\n    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||\r\n      userProfile?.role === 'sys_admin' ||\r\n      userProfile?.role === 'admin';\r\n\r\n    if (!isSysAdmin) {\r\n      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {\r\n        return c.json({ error: \"Insufficient permissions\" }, 403);\r\n      }\r\n    }\r\n\r\n    // Delete fields first\r\n    await env.DB.prepare(\"DELETE FROM checklist_fields WHERE template_id = ?\").bind(templateId).run();\r\n\r\n    // Delete template\r\n    await env.DB.prepare(\"DELETE FROM checklist_templates WHERE id = ?\").bind(templateId).run();\r\n\r\n    // Log deletion\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: template.organization_id,\r\n      actionType: 'DELETE',\r\n      actionDescription: `Checklist Template Deleted: ${template.name}`,\r\n      targetType: 'CHECKLIST_TEMPLATE',\r\n      targetId: templateId,\r\n      metadata: { name: template.name, category: template.category },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({ message: \"Template deleted successfully\" });\r\n  } catch (error) {\r\n    console.error('Error deleting template:', error);\r\n    return c.json({ error: \"Failed to delete template\" }, 500);\r\n  }\r\n});\r\n\r\n// Duplicate checklist template\r\nchecklistRoutes.post(\"/checklist-templates/:id/duplicate\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const templateId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get original template\r\n    const originalTemplate = await env.DB.prepare(\"SELECT * FROM checklist_templates WHERE id = ?\").bind(templateId).first() as any;\r\n\r\n    if (!originalTemplate) {\r\n      return c.json({ error: \"Template not found\" }, 404);\r\n    }\r\n\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Create duplicate template\r\n    const newName = `${originalTemplate.name} - Cópia`;\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO checklist_templates (\r\n        name, description, category, created_by, created_by_user_id, \r\n        organization_id, is_public, parent_category_id,\r\n        created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n    `).bind(\r\n      newName,\r\n      originalTemplate.description,\r\n      originalTemplate.category,\r\n      user.google_user_data?.name || user.email,\r\n      user.id,\r\n      userProfile?.organization_id || null,\r\n      false, // Copies are private by default\r\n      originalTemplate.parent_category_id\r\n    ).run();\r\n\r\n    const newTemplateId = result.meta.last_row_id as number;\r\n\r\n    // OPTIMIZATION: Batch Insert (fix N+1 query)\r\n    // Fetch fields first\r\n    const fields = await env.DB.prepare(\"SELECT * FROM checklist_fields WHERE template_id = ?\").bind(templateId).all();\r\n    const fieldResults = fields.results || [];\r\n    if (fieldResults.length > 0) {\r\n      const nowIso = new Date().toISOString();\r\n\r\n      let insertQuery = `\r\n        INSERT INTO checklist_fields (\r\n          template_id, field_name, field_type, is_required, options, order_index,\r\n          created_at, updated_at\r\n        ) VALUES \r\n      `;\r\n      const insertParams: any[] = [];\r\n      const placeholders: string[] = [];\r\n\r\n      for (const field of fieldResults) {\r\n        placeholders.push('(?, ?, ?, ?, ?, ?, ?, ?)');\r\n        insertParams.push(\r\n          newTemplateId,\r\n          (field as any).field_name,\r\n          (field as any).field_type,\r\n          (field as any).is_required,\r\n          (field as any).options,\r\n          (field as any).order_index,\r\n          nowIso,\r\n          nowIso\r\n        );\r\n      }\r\n\r\n      insertQuery += placeholders.join(', ');\r\n      await env.DB.prepare(insertQuery).bind(...insertParams).run();\r\n      console.log(`[DUPLICATE] Batch inserted ${fieldResults.length} fields for template ${newTemplateId}`);\r\n    }\r\n\r\n    return c.json({\r\n      id: newTemplateId,\r\n      message: \"Template duplicated successfully\"\r\n    });\r\n  } catch (error) {\r\n    console.error('Error duplicating template:', error);\r\n    return c.json({ error: \"Failed to duplicate template\" }, 500);\r\n  }\r\n});\r\n\r\n// Share checklist template\r\nchecklistRoutes.put(\"/checklist-templates/:id/share\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const templateId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { visibility, shared_with } = body;\r\n\r\n    // Check template ownership\r\n    const template = await env.DB.prepare(\"SELECT * FROM checklist_templates WHERE id = ?\").bind(templateId).first() as any;\r\n\r\n    if (!template) {\r\n      return c.json({ error: \"Template not found\" }, 404);\r\n    }\r\n\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Check permissions - only owner, org admins, or sys admins can share\r\n    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||\r\n      userProfile?.role === 'sys_admin' ||\r\n      userProfile?.role === 'admin';\r\n\r\n    if (!isSysAdmin) {\r\n      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {\r\n        return c.json({ error: \"Insufficient permissions\" }, 403);\r\n      }\r\n    }\r\n\r\n    // Validate visibility\r\n    const validVisibilities = ['private', 'public', 'shared'];\r\n    if (!validVisibilities.includes(visibility)) {\r\n      return c.json({ error: \"Invalid visibility value\" }, 400);\r\n    }\r\n\r\n    // Update is_public based on visibility\r\n    const isPublic = visibility === 'public';\r\n    const sharedWithJson = visibility === 'shared' && shared_with ? JSON.stringify(shared_with) : null;\r\n\r\n    await env.DB.prepare(`\r\n      UPDATE checklist_templates \r\n      SET visibility = ?, is_public = ?, shared_with = ?, updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(visibility, isPublic, sharedWithJson, templateId).run();\r\n\r\n    // Log sharing\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: template.organization_id,\r\n      actionType: 'SHARE',\r\n      actionDescription: `Checklist Template Shared: ${template.name}`,\r\n      targetType: 'CHECKLIST_TEMPLATE',\r\n      targetId: templateId,\r\n      metadata: { visibility, is_public: isPublic },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({ message: \"Sharing settings updated successfully\" });\r\n  } catch (error) {\r\n    console.error('Error updating share settings:', error);\r\n    return c.json({ error: \"Failed to update share settings\" }, 500);\r\n  }\r\n});\r\n\r\n// Generate AI checklist - simple version with enhanced error handling\r\n// Includes rate limiting to track usage per organization\r\nchecklistRoutes.post(\"/checklist-templates/generate-ai-simple\", tenantAuthMiddleware, aiRateLimitMiddleware('analysis'), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  console.log('[AI-CHECKLIST] Prompt Generation Route Hit - VERSION 2.2 (Stable - Fallback Active)');\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    console.log('[AI-CHECKLIST] Iniciando geração de checklist...');\r\n\r\n    const body = await c.req.json();\r\n    const { industry, location_type, template_name, category, num_questions, specific_requirements, detail_level, regulation } = body;\r\n\r\n    console.log('[AI-CHECKLIST] Parâmetros recebidos:', {\r\n      industry, location_type, template_name, category, num_questions\r\n    });\r\n\r\n    // Validate required fields\r\n    if (!industry || !location_type || !template_name || !category) {\r\n      return c.json({\r\n        success: false,\r\n        error: \"Campos obrigatórios: setor, tipo de local, nome do template e categoria\"\r\n      }, 400);\r\n    }\r\n\r\n    // Check API keys\r\n    const openAiKey = env?.OPENAI_API_KEY || Deno.env.get('OPENAI_API_KEY');\r\n    const geminiKey = env?.GEMINI_API_KEY || Deno.env.get('GEMINI_API_KEY');\r\n\r\n    if (!openAiKey && !geminiKey) {\r\n      console.error('[AI-CHECKLIST] Nenhuma chave de API (OpenAI ou Gemini) configurada');\r\n      return c.json({\r\n        success: false,\r\n        error: \"IA não configurada no sistema. Contate o suporte.\"\r\n      }, 500);\r\n    }\r\n\r\n    console.log('[AI-CHECKLIST] Iniciando chamada para AI Service (Gemini/OpenAI)...');\r\n\r\n    // Limit questions to prevent timeouts\r\n    const limitedQuestions = Math.min(num_questions || 10, 15);\r\n\r\n    // Construct context based on detail level\r\n    let detailContext = \"\";\r\n    switch (detail_level) {\r\n      case 'basico':\r\n        detailContext = \"Crie perguntas simples e diretas (Sim/Não). Foque no essencial.\";\r\n        break;\r\n      case 'avancado':\r\n        detailContext = \"Crie perguntas detalhadas e técnicas. Inclua campos para medições ou observações específicas onde aplicável.\";\r\n        break;\r\n      case 'intermediario':\r\n      default:\r\n        detailContext = \"Equilibre perguntas diretas com algumas que exijam observação.\";\r\n    }\r\n\r\n    // Construct regulation context\r\n    const regulationContext = regulation && regulation !== 'Nenhuma norma específica'\r\n      ? `Baseie as perguntas estritamente na norma ${regulation}. Cite o item da norma se possível.`\r\n      : \"Baseie-se nas melhores práticas de segurança do trabalho.\";\r\n\r\n    // Create optimized AI prompt\r\n    const prompt = `Crie um checklist de segurança com ${limitedQuestions} perguntas para:\r\n- Setor: ${industry}\r\n- Local: ${location_type}\r\n- Nome: ${template_name}\r\n- Categoria: ${category}\r\n${specific_requirements ? `- Requisitos: ${specific_requirements}` : ''}\r\n- Nível de Detalhe: ${detail_level} (${detailContext})\r\n- Norma/Regulamentação: ${regulationContext}\r\n\r\nRetorne APENAS JSON válido nesta estrutura exata:\r\n{\r\n  \"template\": {\r\n    \"name\": \"${template_name}\",\r\n    \"description\": \"Checklist de segurança para ${industry} - ${location_type}. Baseado em: ${regulation || 'Melhores práticas'}\",\r\n    \"category\": \"${category}\",\r\n    \"is_public\": false\r\n  },\r\n  \"fields\": [\r\n    {\r\n      \"field_name\": \"Pergunta sobre segurança\",\r\n      \"field_type\": \"boolean\",\r\n      \"is_required\": true,\r\n      \"options\": \"\",\r\n      \"order_index\": 0\r\n    }\r\n  ]\r\n}\r\n\r\nIMPORTANTE:\r\n- Exatamente ${limitedQuestions} campos no array fields\r\n- Use field_type: \"boolean\", \"text\", \"textarea\", \"select\", \"rating\", \"date\" ou \"file\"\r\n- Para \"select\", use options: [\"Conforme\", \"Não Conforme\", \"N/A\"]\r\n- Foque em itens práticos de segurança\r\n- Se o nível for avançado, você pode usar \"text\" para observações obrigatórias em pontos críticos\r\n- Use \"file\" para solicitar evidências fotográficas quando necessário`;\r\n\r\n    // Fetch system settings for AI preferences\r\n    let preferredProvider: 'gemini' | 'openai' = 'gemini';\r\n    let fallbackEnabled = true;\r\n\r\n    try {\r\n      const settings = await env.DB.prepare(\"SELECT ai_primary_provider, ai_fallback_enabled FROM system_settings WHERE id = 'global'\").first() as any;\r\n      if (settings) {\r\n        if (settings.ai_primary_provider === 'openai') preferredProvider = 'openai';\r\n        // default is gemini if null or 'gemini'\r\n\r\n        if (settings.ai_fallback_enabled === false || settings.ai_fallback_enabled === 0) {\r\n          fallbackEnabled = false;\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.warn('[AI-CHECKLIST] Failed to fetch settings, using defaults:', err);\r\n    }\r\n\r\n    // Call AI Service with fallback\r\n    const aiResult = await generateAICompletion(geminiKey, openAiKey, {\r\n      systemPrompt: 'Você é um especialista em segurança do trabalho. Responda SEMPRE com JSON válido, sem markdown ou texto adicional. Seja conciso e prático.',\r\n      userPrompt: prompt,\r\n      maxTokens: Math.min(1500, limitedQuestions * 100),\r\n      temperature: 0.3,\r\n      timeoutMs: 60000\r\n    }, { preferredProvider, fallbackEnabled });\r\n\r\n    if (!aiResult.success) {\r\n      console.error('[AI-CHECKLIST] Erro na geração IA:', aiResult.error);\r\n      return c.json({\r\n        success: false,\r\n        error: aiResult.error || \"Erro ao gerar checklist com IA.\"\r\n      }, 500);\r\n    }\r\n\r\n    const content = aiResult.content;\r\n\r\n    // Log which provider was used\r\n    console.log(`[AI-CHECKLIST] Sucesso via ${aiResult.provider} (${aiResult.model}). Fallback usado: ${aiResult.fallbackUsed}`);\r\n\r\n    // Parse AI response with robust error handling\r\n    let aiData;\r\n    try {\r\n      // Try direct JSON parse first\r\n      aiData = JSON.parse(content);\r\n    } catch (parseError) {\r\n      console.log('[AI-CHECKLIST] Direct parse failed, trying to extract JSON...');\r\n\r\n      // Try to extract JSON from the response\r\n      const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        try {\r\n          aiData = JSON.parse(jsonMatch[0]);\r\n        } catch (extractError) {\r\n          console.error('[AI-CHECKLIST] JSON extraction failed:', extractError);\r\n          return c.json({\r\n            success: false,\r\n            error: \"IA retornou formato inválido. Tente novamente com menos perguntas.\"\r\n          }, 500);\r\n        }\r\n      } else {\r\n        console.error('[AI-CHECKLIST] No JSON found in response');\r\n        return c.json({\r\n          success: false,\r\n          error: \"IA não retornou dados válidos. Tente reformular a solicitação.\"\r\n        }, 500);\r\n      }\r\n    }\r\n\r\n    // Validate AI response structure\r\n    if (!aiData || typeof aiData !== 'object') {\r\n      console.error('[AI-CHECKLIST] Invalid AI data structure:', typeof aiData);\r\n      return c.json({\r\n        success: false,\r\n        error: \"Estrutura de dados inválida da IA\"\r\n      }, 500);\r\n    }\r\n\r\n    if (!aiData.template || !aiData.fields || !Array.isArray(aiData.fields)) {\r\n      console.error('[AI-CHECKLIST] Missing required fields in AI response');\r\n      return c.json({\r\n        success: false,\r\n        error: \"IA não retornou template completo. Tente novamente.\"\r\n      }, 500);\r\n    }\r\n\r\n    if (aiData.fields.length === 0) {\r\n      console.error('[AI-CHECKLIST] Empty fields array');\r\n      return c.json({\r\n        success: false,\r\n        error: \"IA não gerou campos para o checklist. Tente com parâmetros diferentes.\"\r\n      }, 500);\r\n    }\r\n\r\n    console.log(`[AI-CHECKLIST] Successfully generated ${aiData.fields.length} fields`);\r\n\r\n    // Clean up and validate the fields\r\n    const cleanFields = aiData.fields\r\n      .filter((field: any) => field && typeof field === 'object' && field.field_name)\r\n      .map((field: any, index: number) => {\r\n        // Ensure valid field_type\r\n        const validTypes = ['boolean', 'text', 'textarea', 'select', 'multiselect', 'radio', 'rating', 'file'];\r\n        const fieldType = validTypes.includes(field.field_type) ? field.field_type : 'boolean';\r\n\r\n        // Process options for select/radio fields\r\n        let processedOptions = '';\r\n        if ((fieldType === 'select' || fieldType === 'radio') && field.options) {\r\n          try {\r\n            if (typeof field.options === 'string' && field.options.startsWith('[')) {\r\n              const parsed = JSON.parse(field.options);\r\n              processedOptions = JSON.stringify(Array.isArray(parsed) ? parsed : ['Conforme', 'Não Conforme', 'N/A']);\r\n            } else if (Array.isArray(field.options)) {\r\n              processedOptions = JSON.stringify(field.options);\r\n            } else {\r\n              processedOptions = JSON.stringify(['Conforme', 'Não Conforme', 'N/A']);\r\n            }\r\n          } catch (error) {\r\n            processedOptions = JSON.stringify(['Conforme', 'Não Conforme', 'N/A']);\r\n          }\r\n        }\r\n\r\n        return {\r\n          field_name: String(field.field_name).trim().substring(0, 200),\r\n          field_type: fieldType,\r\n          is_required: Boolean(field.is_required),\r\n          options: processedOptions,\r\n          order_index: index\r\n        };\r\n      })\r\n      .slice(0, limitedQuestions); // Ensure we don't exceed the limit\r\n\r\n    if (cleanFields.length === 0) {\r\n      console.error('[AI-CHECKLIST] No valid fields after cleaning');\r\n      return c.json({\r\n        success: false,\r\n        error: \"IA não gerou campos válidos. Tente com parâmetros diferentes.\"\r\n      }, 500);\r\n    }\r\n\r\n    // Ensure template has valid structure\r\n    const cleanTemplate = {\r\n      name: String(aiData.template.name || template_name).trim().substring(0, 200),\r\n      description: String(aiData.template.description || `Checklist de segurança para ${industry} - ${location_type}`).trim().substring(0, 500),\r\n      category: String(aiData.template.category || category).trim().substring(0, 100),\r\n      is_public: Boolean(aiData.template.is_public || false)\r\n    };\r\n\r\n    console.log('[AI-CHECKLIST] Checklist gerado com sucesso');\r\n\r\n    // Increment AI usage count for the organization using shared helper\r\n    let usageIncremented = false;\r\n    try {\r\n      const userId = user.id || (user as any).sub;\r\n      const usageResult = await incrementAiUsage(\r\n        env.DB,\r\n        userId,\r\n        'checklist-generation',\r\n        aiResult.model,\r\n        aiResult.totalTokens\r\n      );\r\n      usageIncremented = usageResult.success;\r\n    } catch (usageError) {\r\n      console.error('[AI-CHECKLIST] Failed to update usage:', usageError);\r\n      // Don't fail the request if usage tracking fails\r\n    }\r\n\r\n    return c.json({\r\n      success: true,\r\n      template: cleanTemplate,\r\n      fields: cleanFields,\r\n      meta: {\r\n        generated_at: new Date().toISOString(),\r\n        requested_questions: num_questions,\r\n        delivered_questions: cleanFields.length,\r\n        usage_incremented: usageIncremented\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('[AI-CHECKLIST] Erro geral:', error);\r\n\r\n    // Handle specific error types\r\n    if (error instanceof Error) {\r\n      if (error.name === 'AbortError') {\r\n        return c.json({\r\n          success: false,\r\n          error: \"Timeout na geração. Tente com menos perguntas (5-8).\"\r\n        }, 408);\r\n      } else if (error.message.includes('fetch')) {\r\n        return c.json({\r\n          success: false,\r\n          error: \"Erro de conexão com a IA. Verifique sua internet e tente novamente.\"\r\n        }, 502);\r\n      }\r\n    }\r\n\r\n    return c.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : \"Erro interno do servidor\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Save generated checklist\r\nchecklistRoutes.post(\"/checklist-templates/save-generated\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { template, fields, folder_id } = body;\r\n\r\n    // Validate user.id exists before any database operation\r\n    const userId = user.id || (user as any).user_id || (user as any).sub;\r\n    if (!userId) {\r\n      console.error('[SAVE-GENERATED] User has no ID:', JSON.stringify(user));\r\n      return c.json({\r\n        error: \"User ID not found\",\r\n        details: \"Session user does not have a valid ID\"\r\n      }, 400);\r\n    }\r\n\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(userId).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: userId, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Create template - ensure no undefined values\r\n    const createdBy = user.google_user_data?.name || user.email || 'Sistema';\r\n    const createdByUserId = userId; // Use validated userId\r\n    const orgId = userProfile?.organization_id || null;\r\n    const isPublic = template.is_public === true ? true : false;\r\n    const folderId = folder_id || null;\r\n\r\n    console.log('[SAVE-GENERATED] Creating template with:', {\r\n      name: template.name,\r\n      category: template.category,\r\n      createdBy,\r\n      createdByUserId,\r\n      orgId,\r\n      isPublic,\r\n      folderId\r\n    });\r\n\r\n    const templateResult = await env.DB.prepare(`\r\n      INSERT INTO checklist_templates (\r\n        name, description, category, created_by, created_by_user_id, \r\n        organization_id, is_public, folder_id, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n      RETURNING id\r\n    `).bind(\r\n      template.name || 'Checklist sem nome',\r\n      template.description || null,\r\n      template.category || 'Geral',\r\n      createdBy,\r\n      createdByUserId,\r\n      orgId,\r\n      isPublic,\r\n      folderId\r\n    ).first() as any;\r\n\r\n    const templateId = templateResult?.id;\r\n\r\n    if (!templateId) {\r\n      console.error('[SAVE-GENERATED] Failed to get template ID after insert:', templateResult);\r\n      return c.json({\r\n        error: \"Failed to create template\",\r\n        details: \"Template ID not returned from database\"\r\n      }, 500);\r\n    }\r\n\r\n    console.log('[SAVE-GENERATED] Template created with ID:', templateId);\r\n\r\n    // Create fields with enhanced validation\r\n    for (const field of fields) {\r\n      // Only process fields with valid names\r\n      const fieldName = field.field_name?.trim();\r\n      if (!fieldName) {\r\n        console.warn('[SAVE-GENERATED] Skipping field without name:', field);\r\n        continue;\r\n      }\r\n\r\n      // Ensure field_type is never undefined\r\n      const fieldType = field.field_type || 'text';\r\n      const isRequired = field.is_required === true;\r\n      const orderIndex = typeof field.order_index === 'number' ? field.order_index : 0;\r\n\r\n      let processedOptions: string | null = null;\r\n\r\n      // VALIDAÇÃO: Garantir que campos que precisam de opções tenham opções válidas\r\n      const fieldsRequiringOptions = ['select', 'multiselect', 'radio'];\r\n      if (fieldsRequiringOptions.includes(fieldType)) {\r\n        let validOptions: string[] = [];\r\n\r\n        if (field.options && typeof field.options === 'string' && field.options.trim() !== '') {\r\n          try {\r\n            if (field.options.startsWith('[')) {\r\n              const parsed = JSON.parse(field.options);\r\n              if (Array.isArray(parsed)) {\r\n                validOptions = parsed.filter((opt: any) => opt && String(opt).trim() !== '');\r\n              }\r\n            } else {\r\n              validOptions = field.options.split(/[|\\n]/).map((opt: string) => opt.trim()).filter((opt: string) => opt.length > 0);\r\n            }\r\n          } catch (error) {\r\n            console.warn('Error parsing field options during save:', error);\r\n          }\r\n        } else if (Array.isArray(field.options)) {\r\n          validOptions = field.options.filter((opt: any) => opt && String(opt).trim() !== '');\r\n        }\r\n\r\n        // Se não há opções válidas, usar padrão\r\n        if (validOptions.length === 0) {\r\n          switch (fieldType) {\r\n            case 'select':\r\n            case 'radio':\r\n              validOptions = ['Conforme', 'Não Conforme', 'Não Aplicável'];\r\n              break;\r\n            case 'multiselect':\r\n              validOptions = ['Adequado', 'Inadequado', 'Não Verificado', 'Não Aplicável'];\r\n              break;\r\n          }\r\n        }\r\n\r\n        processedOptions = JSON.stringify(validOptions);\r\n      } else if (field.options) {\r\n        // For non-select fields, preserve options as-is if present\r\n        processedOptions = typeof field.options === 'string' ? field.options : JSON.stringify(field.options);\r\n      }\r\n\r\n      console.log('[SAVE-GENERATED] Inserting field:', { fieldName, fieldType, isRequired, orderIndex });\r\n\r\n      await env.DB.prepare(`\r\n        INSERT INTO checklist_fields (\r\n          template_id, field_name, field_type, is_required, options, order_index,\r\n          created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(\r\n        templateId,\r\n        fieldName,\r\n        fieldType,\r\n        isRequired,\r\n        processedOptions,\r\n        orderIndex\r\n      ).run();\r\n    }\r\n\r\n    return c.json({\r\n      id: templateId,\r\n      message: \"Generated template saved successfully\"\r\n    });\r\n  } catch (error) {\r\n    console.error('Error saving generated template:', error);\r\n    return c.json({\r\n      error: \"Failed to save generated template\",\r\n      details: error instanceof Error ? error.message : \"Unknown error\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Delete template fields (for template editing)\r\nchecklistRoutes.delete(\"/checklist-templates/:id/fields\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const templateId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get user profile to check permissions\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Check if template exists\r\n    const template = await env.DB.prepare(\"SELECT * FROM checklist_templates WHERE id = ?\").bind(templateId).first() as any;\r\n\r\n    if (!template) {\r\n      return c.json({ error: \"Template not found\" }, 404);\r\n    }\r\n\r\n    // System admin can delete anything\r\n    if (userProfile?.role !== USER_ROLES.SYSTEM_ADMIN) {\r\n      // Check if user owns the template or it's in their organization\r\n      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {\r\n        return c.json({ error: \"Insufficient permissions to modify this template\" }, 403);\r\n      }\r\n    }\r\n\r\n    // Delete all fields for this template\r\n    await env.DB.prepare(\"DELETE FROM checklist_fields WHERE template_id = ?\").bind(templateId).run();\r\n\r\n    return c.json({ message: \"Template fields deleted successfully\" });\r\n  } catch (error) {\r\n    console.error('Error deleting template fields:', error);\r\n    return c.json({ error: \"Failed to delete template fields\" }, 500);\r\n  }\r\n});\r\n\r\n// Create checklist field\r\nchecklistRoutes.post(\"/checklist-fields\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { template_id, field_name, field_type, is_required, options, order_index } = body;\r\n\r\n    // VALIDAÇÃO CRÍTICA: Campos que precisam de opções DEVEM ter opções válidas\r\n    const fieldsRequiringOptions = ['select', 'multiselect', 'radio'];\r\n    if (fieldsRequiringOptions.includes(field_type)) {\r\n      let validOptions: string[] = [];\r\n\r\n      // Tentar parsear as opções\r\n      if (options && options.trim() !== '') {\r\n        try {\r\n          // Se é string JSON, parsear\r\n          if (typeof options === 'string' && options.startsWith('[')) {\r\n            const parsed = JSON.parse(options);\r\n            if (Array.isArray(parsed)) {\r\n              validOptions = parsed.filter((opt: any) => opt && opt.trim() !== '');\r\n            }\r\n          } else if (typeof options === 'string') {\r\n            // Se é string separada por | ou \\n\r\n            validOptions = options.split(/[|\\n]/).map((opt: string) => opt.trim()).filter((opt: string) => opt.length > 0);\r\n          } else if (Array.isArray(options)) {\r\n            validOptions = options.filter((opt: any) => opt && opt.trim() !== '');\r\n          }\r\n        } catch (error) {\r\n          console.warn('Error parsing field options:', error);\r\n        }\r\n      }\r\n\r\n      // Se não há opções válidas, usar padrão baseado no tipo\r\n      if (validOptions.length === 0) {\r\n        switch (field_type) {\r\n          case 'select':\r\n          case 'radio':\r\n            validOptions = ['Conforme', 'Não Conforme', 'Não Aplicável'];\r\n            break;\r\n          case 'multiselect':\r\n            validOptions = ['Adequado', 'Inadequado', 'Não Verificado', 'Não Aplicável'];\r\n            break;\r\n        }\r\n      }\r\n\r\n      // Se ainda não há opções, retornar erro\r\n      if (validOptions.length === 0) {\r\n        return c.json({\r\n          error: `Campo do tipo \"${field_type}\" requer pelo menos uma opção válida. Por favor, forneça as opções necessárias.`,\r\n          field_type,\r\n          suggested_options: ['Conforme', 'Não Conforme', 'Não Aplicável']\r\n        }, 400);\r\n      }\r\n\r\n      // Garantir que options é uma string JSON válida\r\n      body.options = JSON.stringify(validOptions);\r\n    }\r\n\r\n    // Get user profile to check permissions\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    if (!userProfile && (user as any).profile) {\r\n      userProfile = { ...(user as any).profile, id: user.id, email: user.email, name: (user as any).name };\r\n    }\r\n\r\n    // Check if template exists\r\n    const template = await env.DB.prepare(\"SELECT * FROM checklist_templates WHERE id = ?\").bind(template_id).first() as any;\r\n\r\n    if (!template) {\r\n      return c.json({ error: \"Template not found\" }, 404);\r\n    }\r\n\r\n    // System admin can edit anything\r\n    if (userProfile?.role !== USER_ROLES.SYSTEM_ADMIN) {\r\n      // Check if user owns the template or it's in their organization\r\n      if (template.created_by_user_id !== user.id && template.organization_id !== userProfile?.organization_id) {\r\n        return c.json({ error: \"Insufficient permissions to modify this template\" }, 403);\r\n      }\r\n    }\r\n\r\n    // Create field\r\n    await env.DB.prepare(`\r\n      INSERT INTO checklist_fields (\r\n        template_id, field_name, field_type, is_required, options, order_index,\r\n        created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n    `).bind(\r\n      template_id,\r\n      field_name,\r\n      field_type,\r\n      is_required || false,\r\n      options || null,\r\n      order_index || 0\r\n    ).run();\r\n\r\n    return c.json({ message: \"Field created successfully\" });\r\n  } catch (error) {\r\n    console.error('Error creating checklist field:', error);\r\n    return c.json({ error: \"Failed to create field\" }, 500);\r\n  }\r\n});\r\n\r\n// Create folder for templates\r\nchecklistRoutes.post(\"/checklist-templates/create-folder\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { name, description, category, folder_color, folder_icon, parent_category_id } = body;\r\n\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    // Create folder\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO checklist_templates (\r\n        name, description, category, is_category_folder, folder_color, folder_icon,\r\n        parent_category_id, created_by, created_by_user_id, organization_id, is_public,\r\n        created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n    `).bind(\r\n      name,\r\n      description || null,\r\n      category,\r\n      true, // is_category_folder\r\n      folder_color || '#3B82F6',\r\n      folder_icon || 'folder',\r\n      parent_category_id || null,\r\n      user.google_user_data?.name || user.email,\r\n      user.id,\r\n      userProfile?.organization_id || null,\r\n      true // public by default\r\n    ).run();\r\n\r\n    return c.json({\r\n      id: result.meta.last_row_id,\r\n      message: \"Folder created successfully\"\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating folder:', error);\r\n    return c.json({ error: \"Failed to create folder\" }, 500);\r\n  }\r\n});\r\n\r\n// Pre-analysis with AI multimodal support\r\nchecklistRoutes.post(\"/inspection-items/:itemId/pre-analysis\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  if (!env.OPENAI_API_KEY) {\r\n    return c.json({ error: \"IA não disponível\" }, 503);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { field_name, response_value, media_data, user_prompt } = body;\r\n\r\n    // Get inspection item and context\r\n    const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.location, i.company_name, i.title as inspection_title\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n    `).bind(itemId).first() as any;\r\n\r\n    if (!item) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // Prepare media context - SEMPRE mencionar se há ou não mídias\r\n    let mediaContext = '';\r\n    let hasMedia = false;\r\n\r\n    if (media_data && media_data.length > 0) {\r\n      hasMedia = true;\r\n      const mediaTypes = media_data.reduce((acc: any, media: any) => {\r\n        acc[media.media_type] = (acc[media.media_type] || 0) + 1;\r\n        return acc;\r\n      }, {});\r\n\r\n      mediaContext = `EVIDÊNCIAS DISPONÍVEIS: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} áudio(s), ${mediaTypes.video || 0} vídeo(s) foram analisados.`;\r\n    } else {\r\n      mediaContext = `EVIDÊNCIAS DISPONÍVEIS: Nenhuma mídia (foto, áudio ou vídeo) foi anexada. Análise baseada apenas na resposta do inspetor.`;\r\n    }\r\n\r\n    // Create comprehensive and detailed prompt for deeper analysis\r\n    const prompt = `Você é um especialista sênior em segurança do trabalho e saúde ocupacional, com vasta experiência em análise de conformidade regulatória e gestão de riscos.\r\n\r\nCONTEXTO DETALHADO DA INSPEÇÃO:\r\n- Local da Inspeção: ${item.location}\r\n- Empresa Inspecionada: ${item.company_name}\r\n- Título da Inspeção: ${item.inspection_title}\r\n\r\nITEM ESPECÍFICO EM ANÁLISE:\r\n- Campo Inspecionado: ${field_name}\r\n- Categoria do Item: ${item.category}\r\n- Descrição Completa do Item: ${item.item_description}\r\n- Resposta Fornecida pelo Inspetor: ${response_value !== null && response_value !== undefined ? response_value : 'Não respondido'}\r\n- Observações Adicionais do Inspetor: ${item.observations || 'Nenhuma observação prévia'}\r\n\r\n${mediaContext}\r\n\r\n${user_prompt ? `FOCO PRINCIPAL FORNECIDO PELO USUÁRIO: ${user_prompt}. Priorize esta informação em sua análise detalhada.` : ''}\r\n\r\nSUA TAREFA:\r\nRealize uma **análise técnica aprofundada e abrangente** deste item inspecionado considerando:\r\n\r\n1. **Observações Detalhadas**: Descreva minuciosamente o que foi observado e como se relaciona com as evidências disponíveis\r\n2. **Análise de Conformidade**: Avalie claramente se o item está conforme ou não conforme com as normas de segurança aplicáveis (cite NRs específicas quando relevante)\r\n3. **Identificação de Riscos**: Detalhe os riscos potenciais associados à condição atual do item, incluindo consequências de curto e longo prazo\r\n4. **Causa Raiz**: Identifique possíveis causas fundamentais da não conformidade (se aplicável)\r\n5. **Implicações Regulatórias**: Mencione possíveis implicações com órgãos fiscalizadores se relevante\r\n6. **Urgência e Prioridade**: Indique claramente a urgência de uma ação corretiva (Baixa, Média, Alta, Crítica) e justifique\r\n7. **Recomendação Específica**: Sugira claramente se uma ação corretiva é necessária e qual a natureza geral dessa ação\r\n\r\nForneça uma análise estruturada e técnica (máximo 600 caracteres) em texto corrido simples. NÃO use markdown, asteriscos, negrito, itálico, listas ou qualquer formatação especial. Seja direto, objetivo e tecnicamente preciso.`;\r\n\r\n    // Call OpenAI API\r\n    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'gpt-4o-mini',\r\n        messages: [\r\n          {\r\n            role: 'system',\r\n            content: 'Você é um especialista em segurança do trabalho. Forneça análises técnicas objetivas e concisas em texto simples. Seja específico sobre evidências disponíveis e necessidade de ações.'\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: prompt\r\n          }\r\n        ],\r\n        max_tokens: 800,\r\n        temperature: 0.4\r\n      })\r\n    });\r\n\r\n    if (!openaiResponse.ok) {\r\n      const errorText = await openaiResponse.text();\r\n      console.error('OpenAI API Error:', openaiResponse.status, errorText);\r\n      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status}`);\r\n    }\r\n\r\n    // Robust JSON parsing with HTML error handling\r\n    let openaiResult;\r\n    try {\r\n      const responseText = await openaiResponse.text();\r\n\r\n      // Check if response is HTML (common error response format)\r\n      if (responseText.trim().startsWith('<')) {\r\n        console.error('OpenAI returned HTML instead of JSON:', responseText);\r\n        throw new Error('API da OpenAI retornou resposta inválida (HTML). Verifique a chave da API e tente novamente.');\r\n      }\r\n\r\n      openaiResult = JSON.parse(responseText);\r\n    } catch (parseError) {\r\n      console.error('Failed to parse OpenAI response:', parseError);\r\n      throw new Error('Erro ao processar resposta da IA. Tente novamente.');\r\n    }\r\n\r\n    const analysis = openaiResult.choices?.[0]?.message?.content;\r\n\r\n    if (!analysis) {\r\n      throw new Error('Resposta inválida da IA');\r\n    }\r\n\r\n    // Clean up analysis - remove markdown and excessive formatting\r\n    const cleanAnalysis = analysis\r\n      .replace(/\\*\\*/g, '')\r\n      .replace(/\\*/g, '')\r\n      .replace(/#{1,6}\\s/g, '')\r\n      .replace(/`/g, '')\r\n      .replace(/^\\s*-\\s*/gm, '• ')\r\n      .replace(/\\n{3,}/g, '\\n\\n')\r\n      .trim();\r\n\r\n    // Update the inspection item with the analysis\r\n    await env.DB.prepare(`\r\n      UPDATE inspection_items \r\n      SET ai_pre_analysis = ?, updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(cleanAnalysis, itemId).run();\r\n\r\n    return c.json({\r\n      success: true,\r\n      analysis: cleanAnalysis,\r\n      pre_analysis: cleanAnalysis,\r\n      media_analyzed: hasMedia ? media_data.length : 0,\r\n      item_id: itemId,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error in pre-analysis:', error);\r\n    return c.json({\r\n      error: \"Erro ao fazer pré-análise\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Generate field response with AI multimodal analysis\r\nchecklistRoutes.post(\"/inspection-items/:itemId/generate-field-response\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  if (!env.OPENAI_API_KEY) {\r\n    return c.json({ error: \"IA não disponível\" }, 503);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { field_name, field_type, current_response, media_data, field_options } = body;\r\n\r\n    // Get inspection item and context\r\n    const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.location, i.company_name, i.title as inspection_title\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n    `).bind(itemId).first() as any;\r\n\r\n    if (!item) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // Parse field options\r\n    let availableOptions: string[] = [];\r\n    if (field_options) {\r\n      try {\r\n        if (typeof field_options === 'string' && field_options.startsWith('[')) {\r\n          availableOptions = JSON.parse(field_options);\r\n        } else if (typeof field_options === 'string') {\r\n          availableOptions = field_options.split('|').map(opt => opt.trim()).filter(opt => opt);\r\n        } else if (Array.isArray(field_options)) {\r\n          availableOptions = field_options;\r\n        }\r\n      } catch (error) {\r\n        console.error('Error parsing field options:', error);\r\n      }\r\n    }\r\n\r\n    // Prepare media analysis content - SEMPRE mencionar status das mídias\r\n    let mediaAnalysisContent = '';\r\n    if (media_data && media_data.length > 0) {\r\n      const mediaTypes = media_data.reduce((acc: any, media: any) => {\r\n        acc[media.media_type] = (acc[media.media_type] || 0) + 1;\r\n        return acc;\r\n      }, {});\r\n\r\n      mediaAnalysisContent = `EVIDÊNCIAS DISPONÍVEIS: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} áudio(s), ${mediaTypes.video || 0} vídeo(s) analisados para gerar resposta.`;\r\n    } else {\r\n      mediaAnalysisContent = `EVIDÊNCIAS DISPONÍVEIS: Nenhuma mídia anexada. Resposta baseada no contexto da inspeção e conhecimento técnico.`;\r\n    }\r\n\r\n    // Create specialized prompt based on field type\r\n    let responseInstructions = '';\r\n    switch (field_type) {\r\n      case 'boolean':\r\n        responseInstructions = `\r\nRESPOSTA ESPERADA: true (Conforme) ou false (Não Conforme)\r\nCRITÉRIO: Avalie se o item está em conformidade com as normas de segurança.`;\r\n        break;\r\n      case 'select':\r\n      case 'radio':\r\n        if (availableOptions.length > 0) {\r\n          responseInstructions = `\r\nRESPOSTA ESPERADA: Uma das opções disponíveis: ${availableOptions.join(', ')}\r\nCRITÉRIO: Escolha a opção que melhor descreve a situação observada.`;\r\n        } else {\r\n          responseInstructions = `\r\nRESPOSTA ESPERADA: Uma descrição textual da condição observada.`;\r\n        }\r\n        break;\r\n      case 'multiselect':\r\n        if (availableOptions.length > 0) {\r\n          responseInstructions = `\r\nRESPOSTA ESPERADA: Array com uma ou mais opções: ${availableOptions.join(', ')}\r\nCRITÉRIO: Selecione todas as opções que se aplicam à situação.`;\r\n        }\r\n        break;\r\n      case 'rating':\r\n        responseInstructions = `\r\nRESPOSTA ESPERADA: Número de 1 a 5 (1 = Inadequado, 5 = Excelente)\r\nCRITÉRIO: Avalie a qualidade/conformidade do item observado.`;\r\n        break;\r\n      case 'text':\r\n      case 'textarea':\r\n        responseInstructions = `\r\nRESPOSTA ESPERADA: Descrição textual detalhada\r\nCRITÉRIO: Descreva o que foi observado de forma objetiva e técnica.`;\r\n        break;\r\n      default:\r\n        responseInstructions = `\r\nRESPOSTA ESPERADA: Valor adequado para o tipo de campo solicitado.`;\r\n    }\r\n\r\n    const prompt = `Você é um especialista sênior em segurança do trabalho e saúde ocupacional, com vasta experiência em análise de conformidade regulatória e gestão de riscos industriais.\r\n\r\nCONTEXTO DETALHADO DA INSPEÇÃO:\r\n- Local da Inspeção: ${item.location}\r\n- Empresa Inspecionada: ${item.company_name}\r\n- Título da Inspeção: ${item.inspection_title}\r\n\r\nITEM ESPECÍFICO EM ANÁLISE:\r\n- Campo Inspecionado: ${field_name}\r\n- Tipo de Campo: ${field_type}\r\n- Categoria do Item: ${item.category}\r\n- Descrição Completa do Item: ${item.item_description}\r\n- Observações Existentes: ${item.observations || 'Nenhuma observação prévia'}\r\n- Resposta Atual: ${current_response !== null && current_response !== undefined ? current_response : 'Não respondido'}\r\n\r\n${mediaAnalysisContent}\r\n\r\n${responseInstructions}\r\n\r\nSUA TAREFA ESPECIALIZADA:\r\nComo especialista em segurança, analise profundamente as evidências disponíveis e forneça:\r\n\r\n1. **Análise Técnica das Evidências**: Considere todos os aspectos técnicos, normativos e de risco\r\n2. **Resposta Baseada em Evidências**: Gere uma resposta precisa baseada na análise das evidências disponíveis\r\n3. **Comentário Técnico Detalhado**: Forneça um comentário técnico abrangente (máximo 400 caracteres) que inclua:\r\n   - O que foi especificamente observado nas evidências\r\n   - Referência às normas aplicáveis (NRs, se relevante)\r\n   - Justificativa técnica para a resposta gerada\r\n   - Identificação de riscos ou não conformidades\r\n   - Urgência de ação corretiva (se aplicável)\r\n\r\n4. **Avaliação de Confiança**: Baseie sua confiança na qualidade e quantidade das evidências analisadas\r\n\r\nResponda APENAS em formato JSON:\r\n{\r\n  \"generated_response\": <valor_da_resposta>,\r\n  \"generated_comment\": \"Comentário técnico detalhado incluindo observações específicas das evidências, conformidade normativa, riscos identificados e justificativa da resposta\",\r\n  \"confidence\": \"alta|media|baixa\",\r\n  \"media_analyzed\": ${media_data ? media_data.length : 0},\r\n  \"technical_analysis\": \"Análise técnica específica das evidências observadas\",\r\n  \"regulatory_compliance\": \"Status de conformidade com normas aplicáveis\"\r\n}\r\n\r\nSeja tecnicamente preciso, detalhado e específico sobre as evidências analisadas.`;\r\n\r\n    // Call OpenAI API\r\n    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'gpt-4o-mini',\r\n        messages: [\r\n          {\r\n            role: 'system',\r\n            content: 'Você é um especialista em segurança do trabalho. Analise evidências e forneça respostas técnicas precisas. Responda sempre em JSON válido.'\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: prompt\r\n          }\r\n        ],\r\n        max_tokens: 1200,\r\n        temperature: 0.4\r\n      })\r\n    });\r\n\r\n    if (!openaiResponse.ok) {\r\n      const errorText = await openaiResponse.text();\r\n      console.error('OpenAI API Error:', openaiResponse.status, errorText);\r\n      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status}`);\r\n    }\r\n\r\n    // Robust JSON parsing with HTML error handling\r\n    let openaiResult;\r\n    try {\r\n      const responseText = await openaiResponse.text();\r\n\r\n      // Check if response is HTML (common error response format)\r\n      if (responseText.trim().startsWith('<')) {\r\n        console.error('OpenAI returned HTML instead of JSON:', responseText);\r\n        throw new Error('API da OpenAI retornou resposta inválida (HTML). Verifique a chave da API e tente novamente.');\r\n      }\r\n\r\n      openaiResult = JSON.parse(responseText);\r\n    } catch (parseError) {\r\n      console.error('Failed to parse OpenAI response:', parseError);\r\n      throw new Error('Erro ao processar resposta da IA. Tente novamente.');\r\n    }\r\n\r\n    const content = openaiResult.choices?.[0]?.message?.content;\r\n\r\n    if (!content) {\r\n      throw new Error('Resposta inválida da IA');\r\n    }\r\n\r\n    // Parse AI response\r\n    let aiResult;\r\n    try {\r\n      aiResult = JSON.parse(content);\r\n    } catch (parseError) {\r\n      // Try to extract JSON from the response\r\n      const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        aiResult = JSON.parse(jsonMatch[0]);\r\n      } else {\r\n        throw new Error('Falha ao parsear resposta da IA como JSON');\r\n      }\r\n    }\r\n\r\n    // Validate and clean response based on field type\r\n    let finalResponse = aiResult.generated_response;\r\n\r\n    if (field_type === 'boolean') {\r\n      if (typeof finalResponse === 'string') {\r\n        finalResponse = finalResponse.toLowerCase() === 'true' || finalResponse === '1';\r\n      } else if (typeof finalResponse !== 'boolean') {\r\n        finalResponse = null;\r\n      }\r\n    } else if (field_type === 'multiselect') {\r\n      if (!Array.isArray(finalResponse)) {\r\n        if (typeof finalResponse === 'string') {\r\n          finalResponse = [finalResponse];\r\n        } else {\r\n          finalResponse = [];\r\n        }\r\n      }\r\n      // Filter to only valid options if available\r\n      if (availableOptions.length > 0) {\r\n        finalResponse = finalResponse.filter((opt: string) => availableOptions.includes(opt));\r\n      }\r\n    } else if ((field_type === 'select' || field_type === 'radio') && availableOptions.length > 0) {\r\n      // Ensure response is one of the available options\r\n      if (!availableOptions.includes(finalResponse)) {\r\n        finalResponse = availableOptions[0]; // Default to first option\r\n      }\r\n    } else if (field_type === 'rating') {\r\n      const numResponse = parseInt(finalResponse);\r\n      if (isNaN(numResponse) || numResponse < 1 || numResponse > 5) {\r\n        finalResponse = 3; // Default to middle rating\r\n      } else {\r\n        finalResponse = numResponse;\r\n      }\r\n    }\r\n\r\n    return c.json({\r\n      success: true,\r\n      generated_response: finalResponse,\r\n      generated_comment: aiResult.generated_comment || '',\r\n      confidence: aiResult.confidence || 'media',\r\n      media_analyzed: aiResult.media_analyzed || 0,\r\n      item_id: itemId,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error generating field response:', error);\r\n    return c.json({\r\n      error: \"Erro ao gerar resposta do campo\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Create AI-generated action item for inspection item\r\nchecklistRoutes.post(\"/inspection-items/:itemId/create-action\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  if (!env.OPENAI_API_KEY) {\r\n    return c.json({ error: \"IA não disponível\" }, 503);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { field_name, field_type, response_value, pre_analysis, media_data, user_prompt } = body;\r\n\r\n    // Get inspection item and context\r\n    const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n    `).bind(itemId).first() as any;\r\n\r\n    if (!item) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // CORRIGIDO: Lógica melhorada para determinar necessidade de ação\r\n    // Agora considera análise prévia, evidências de mídia e respostas\r\n    let needsAction = false;\r\n    let riskLevel = 'baixo';\r\n    let actionReason = '';\r\n\r\n    // 1. Verificar resposta direta de não conformidade\r\n    if (field_type === 'boolean' && response_value === false) {\r\n      needsAction = true;\r\n      riskLevel = 'alto';\r\n      actionReason = 'Item marcado como não conforme';\r\n    } else if (field_type === 'rating' && response_value <= 2) {\r\n      needsAction = true;\r\n      riskLevel = response_value === 1 ? 'critica' : 'alta';\r\n      actionReason = `Avaliação baixa (${response_value}/5)`;\r\n    } else if (field_type === 'select' && response_value) {\r\n      const valueStr = response_value.toLowerCase();\r\n      if (valueStr.includes('não conforme') || valueStr.includes('inadequado') ||\r\n        valueStr.includes('não aplicável') === false && valueStr.includes('conforme') === false) {\r\n        needsAction = true;\r\n        riskLevel = 'media';\r\n        actionReason = `Resposta indica não conformidade: ${response_value}`;\r\n      }\r\n    }\r\n\r\n    // 2. Verificar análise prévia para identificar riscos (NOVO)\r\n    if (pre_analysis && !needsAction) {\r\n      const analysisText = pre_analysis.toLowerCase();\r\n      const riskKeywords = [\r\n        'não conforme', 'inadequado', 'risco', 'perigo', 'incorreto', 'falha',\r\n        'violação', 'infração', 'necessário', 'corrigir', 'ajustar', 'melhorar',\r\n        'ação', 'problema', 'deficiência', 'insuficiente'\r\n      ];\r\n\r\n      const foundRisks = riskKeywords.filter(keyword => analysisText.includes(keyword));\r\n      if (foundRisks.length >= 2) {\r\n        needsAction = true;\r\n        riskLevel = 'media';\r\n        actionReason = `Análise prévia identificou riscos: ${foundRisks.slice(0, 3).join(', ')}`;\r\n      }\r\n    }\r\n\r\n    // 3. Se ainda não identificou necessidade, deixar a IA decidir baseada em evidências\r\n    if (!needsAction && (media_data?.length > 0 || pre_analysis)) {\r\n      needsAction = true; // Permitir que a IA analise e decida\r\n      riskLevel = 'media';\r\n      actionReason = 'Análise inteligente das evidências disponíveis';\r\n    }\r\n\r\n    // ÚLTIMA VALIDAÇÃO: Se realmente não há nada para analisar\r\n    if (!needsAction && !response_value && !pre_analysis && (!media_data || media_data.length === 0)) {\r\n      return c.json({\r\n        success: true,\r\n        action: {\r\n          requires_action: false,\r\n          message: \"Não há evidências suficientes (resposta, análise ou mídias) para determinar necessidade de ação. Adicione mais informações para análise.\"\r\n        }\r\n      });\r\n    }\r\n\r\n    // CORRIGIDO: Preparar análise multimodal real das evidências\r\n    let mediaContext = '';\r\n    let mediaAnalysisMessages = [];\r\n\r\n    if (media_data && media_data.length > 0) {\r\n      const mediaTypes = media_data.reduce((acc: any, media: any) => {\r\n        acc[media.media_type] = (acc[media.media_type] || 0) + 1;\r\n        return acc;\r\n      }, {});\r\n\r\n      mediaContext = `EVIDÊNCIAS MULTIMODAIS ANALISADAS: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} áudio(s), ${mediaTypes.video || 0} vídeo(s).`;\r\n\r\n      // Preparar imagens para análise visual (máximo 3 para evitar timeout)\r\n      const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);\r\n      for (const img of imageMedia) {\r\n        if (img.file_url) {\r\n          mediaAnalysisMessages.push({\r\n            type: \"image_url\",\r\n            image_url: {\r\n              url: img.file_url,\r\n              detail: \"high\" // Para análise detalhada com gpt-4o-mini\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      // Adicionar descrição de áudios/vídeos se existirem\r\n      const audioCount = mediaTypes.audio || 0;\r\n      const videoCount = mediaTypes.video || 0;\r\n      if (audioCount > 0 || videoCount > 0) {\r\n        mediaContext += ` Inclui ${audioCount} áudio(s) e ${videoCount} vídeo(s) que podem conter evidências sonoras de não conformidades.`;\r\n      }\r\n    } else {\r\n      mediaContext = `EVIDÊNCIAS DISPONÍVEIS: Nenhuma mídia anexada. Ação baseada na resposta e análise prévia.`;\r\n    }\r\n\r\n    // Construir mensagens para OpenAI incluindo análise visual\r\n    const systemMessage = {\r\n      role: 'system',\r\n      content: 'Você é um especialista em segurança do trabalho especializado em análise multimodal. Analise imagens, textos e contexto para criar planos de ação 5W2H precisos baseados em evidências reais.'\r\n    };\r\n\r\n    const userMessage = {\r\n      role: 'user',\r\n      content: [\r\n        {\r\n          type: \"text\",\r\n          text: `Analise as evidências e determine se é necessária uma ação corretiva.\r\n\r\nCONTEXTO DA INSPEÇÃO:\r\n- Local: ${item.location}\r\n- Empresa: ${item.company_name}\r\n- Item: ${field_name} (${item.category})\r\n- Descrição: ${item.item_description}\r\n- Resposta do Inspetor: ${response_value || 'Não respondido'}\r\n- Motivo da Análise: ${actionReason}\r\n- Nível de Risco Inicial: ${riskLevel}\r\n- Observações: ${item.observations || 'Nenhuma'}\r\n\r\n${mediaContext}\r\n\r\n${pre_analysis ? `ANÁLISE PRÉVIA DA IA:\r\n${pre_analysis}\r\n\r\nIMPORTANTE: Sua decisão deve ser coerente com esta análise prévia.` : ''}\r\n\r\n${user_prompt ? `FOCO ESPECÍFICO: ${user_prompt}` : ''}\r\n\r\nINSTRUÇÕES DETALHADAS PARA ANÁLISE ESPECIALIZADA:\r\n1. **Análise Multimodal Completa**: Examine minuciosamente todas as evidências disponíveis (imagens, análise prévia, resposta do inspetor, contexto)\r\n2. **Avaliação de Conformidade Técnica**: Determine conformidade com normas regulamentadoras aplicáveis (NRs, ABNT, ISO)\r\n3. **Análise de Causa Raiz**: Identifique causas fundamentais de não conformidades\r\n4. **Avaliação de Riscos**: Determine riscos de segurança, saúde, ambientais e legais\r\n5. **Tomada de Decisão**: Se ação corretiva é necessária, crie plano 5W2H detalhado e específico\r\n6. **Justificativa Técnica**: Explique claramente a fundamentação técnica da decisão\r\n\r\nResponda APENAS em formato JSON:\r\n{\r\n  \"requires_action\": true/false,\r\n  \"title\": \"Título específico da ação ou motivo técnico de não necessidade\",\r\n  \"what_description\": \"Descrição detalhada e específica do que deve ser feito, incluindo etapas claras e objetivos mensuráveis\",\r\n  \"where_location\": \"Local específico da ação com detalhes do ambiente\",\r\n  \"why_reason\": \"Justificativa técnica abrangente baseada em análise de riscos, conformidade regulatória e evidências observadas\",\r\n  \"how_method\": \"Metodologia detalhada de execução incluindo recursos necessários, procedimentos e padrões técnicos\",\r\n  \"who_responsible\": \"Responsável específico com qualificação técnica adequada\",\r\n  \"when_deadline\": \"Prazo em dias baseado na criticidade e urgência técnica\",\r\n  \"how_much_cost\": \"Estimativa detalhada incluindo recursos, materiais e mão de obra\",\r\n  \"priority\": \"baixa|media|alta|critica\",\r\n  \"evidence_analysis\": \"Análise técnica detalhada das evidências observadas incluindo aspectos críticos de segurança\",\r\n  \"visual_findings\": \"Descrição específica e técnica do que foi observado nas imagens com foco em não conformidades\",\r\n  \"regulatory_compliance\": \"Status de conformidade com normas aplicáveis e implicações regulatórias\",\r\n  \"risk_assessment\": \"Avaliação detalhada dos riscos identificados e suas consequências potenciais\",\r\n  \"root_cause_analysis\": \"Análise das causas fundamentais do problema identificado\"\r\n}`\r\n        },\r\n        ...mediaAnalysisMessages\r\n      ]\r\n    };\r\n\r\n    const messages = [systemMessage, userMessage];\r\n\r\n    // CORRIGIDO: Call OpenAI API com análise multimodal\r\n    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'gpt-4o-mini', // Mudança solicitada para gpt-4o-mini\r\n        messages: messages,\r\n        max_tokens: 2000, // Aumentado para análise mais detalhada\r\n        temperature: 0.3 // Reduzido para mais consistência\r\n      })\r\n    });\r\n\r\n    if (!openaiResponse.ok) {\r\n      const errorText = await openaiResponse.text();\r\n      console.error('OpenAI API Error:', openaiResponse.status, errorText);\r\n      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status}`);\r\n    }\r\n\r\n    // Robust JSON parsing with HTML error handling\r\n    let openaiResult;\r\n    try {\r\n      const responseText = await openaiResponse.text();\r\n\r\n      // Check if response is HTML (common error response format)\r\n      if (responseText.trim().startsWith('<')) {\r\n        console.error('OpenAI returned HTML instead of JSON:', responseText);\r\n        throw new Error('API da OpenAI retornou resposta inválida (HTML). Verifique a chave da API e tente novamente.');\r\n      }\r\n\r\n      openaiResult = JSON.parse(responseText);\r\n    } catch (parseError) {\r\n      console.error('Failed to parse OpenAI response:', parseError);\r\n      throw new Error('Erro ao processar resposta da IA. Tente novamente.');\r\n    }\r\n\r\n    const content = openaiResult.choices?.[0]?.message?.content;\r\n\r\n    if (!content) {\r\n      throw new Error('Resposta inválida da IA');\r\n    }\r\n\r\n    // Parse AI response\r\n    let actionPlan;\r\n    try {\r\n      actionPlan = JSON.parse(content);\r\n    } catch (parseError) {\r\n      // Try to extract JSON from the response\r\n      const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        actionPlan = JSON.parse(jsonMatch[0]);\r\n      } else {\r\n        throw new Error('Falha ao parsear resposta da IA como JSON');\r\n      }\r\n    }\r\n\r\n    if (actionPlan.requires_action) {\r\n      // Calculate deadline\r\n      const deadlineDays = parseInt(actionPlan.when_deadline) || 30;\r\n      const deadlineDate = new Date();\r\n      deadlineDate.setDate(deadlineDate.getDate() + deadlineDays);\r\n\r\n      // Create action item in database\r\n      const result = await env.DB.prepare(`\r\n        INSERT INTO action_items (\r\n          inspection_id, inspection_item_id, title, what_description, where_location,\r\n          why_reason, how_method, who_responsible, when_deadline, how_much_cost,\r\n          status, priority, is_ai_generated, assigned_to, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(\r\n        item.inspection_id,\r\n        itemId,\r\n        actionPlan.title,\r\n        actionPlan.what_description,\r\n        actionPlan.where_location,\r\n        actionPlan.why_reason,\r\n        actionPlan.how_method,\r\n        actionPlan.who_responsible,\r\n        deadlineDate.toISOString().split('T')[0],\r\n        actionPlan.how_much_cost,\r\n        'pending',\r\n        actionPlan.priority || 'media',\r\n        true,\r\n        actionPlan.who_responsible,\r\n      ).run();\r\n\r\n      // Update action plan in inspection item with enhanced analysis\r\n      const enhancedPlan = {\r\n        ...actionPlan,\r\n        evidence_analysis: actionPlan.evidence_analysis || 'Análise baseada em evidências disponíveis',\r\n        visual_findings: actionPlan.visual_findings || 'Nenhuma análise visual específica',\r\n        media_analyzed: media_data ? media_data.length : 0,\r\n        analysis_type: mediaAnalysisMessages.length > 0 ? 'multimodal' : 'textual'\r\n      };\r\n\r\n      await env.DB.prepare(`\r\n        UPDATE inspection_items \r\n        SET ai_action_plan = ?, updated_at = NOW()\r\n        WHERE id = ?\r\n      `).bind(JSON.stringify(enhancedPlan), itemId).run();\r\n\r\n      actionPlan.id = result.meta.last_row_id;\r\n      actionPlan.evidence_analysis = enhancedPlan.evidence_analysis;\r\n      actionPlan.visual_findings = enhancedPlan.visual_findings;\r\n    }\r\n\r\n    return c.json({\r\n      success: true,\r\n      action: actionPlan,\r\n      item_id: itemId,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating action with AI:', error);\r\n    return c.json({\r\n      error: \"Erro ao criar ação com IA\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Delete pre-analysis for an inspection item\r\nchecklistRoutes.delete(\"/inspection-items/:itemId/pre-analysis\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Update the inspection item to remove pre-analysis\r\n    await env.DB.prepare(`\r\n      UPDATE inspection_items \r\n      SET ai_pre_analysis = NULL, updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(itemId).run();\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: \"Pré-análise removida com sucesso\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error deleting pre-analysis:', error);\r\n    return c.json({\r\n      error: \"Erro ao remover pré-análise\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Get actions for specific inspection item\r\nchecklistRoutes.get(\"/inspection-items/:itemId/actions\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get inspection item to verify access\r\n    const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.created_by, i.organization_id\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n    `).bind(itemId).first() as any;\r\n\r\n    if (!item) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // Get actions for this item\r\n    const actions = await env.DB.prepare(`\r\n      SELECT * FROM action_items \r\n      WHERE inspection_item_id = ?\r\n      ORDER BY created_at DESC\r\n    `).bind(itemId).all();\r\n\r\n    return c.json({\r\n      actions: actions.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching inspection item actions:', error);\r\n    return c.json({ error: \"Erro ao buscar ações do item\" }, 500);\r\n  }\r\n});\r\n\r\n// ================================\r\n// ACTION ITEMS MANAGEMENT ENDPOINTS\r\n// ================================\r\n\r\n// Get action plan for inspection\r\nchecklistRoutes.get(\"/inspections/:id/action-plan\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get inspection to verify access\r\n    const inspection = await env.DB.prepare(`\r\n      SELECT i.*, u.role as user_role, u.organization_id as user_org_id\r\n      FROM inspections i\r\n      JOIN users u ON u.id = ?\r\n      WHERE i.id = ?\r\n    `).bind(user.id, inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Check access permissions\r\n    const hasAccess = inspection.created_by === user.id ||\r\n      inspection.organization_id === inspection.user_org_id ||\r\n      inspection.user_role === 'system_admin';\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: \"Acesso negado\" }, 403);\r\n    }\r\n\r\n    // Get action items for this inspection\r\n    const actionItems = await env.DB.prepare(`\r\n      SELECT ai.*, ii.category as item_category, ii.item_description\r\n      FROM action_items ai\r\n      LEFT JOIN inspection_items ii ON ai.inspection_item_id = ii.id\r\n      WHERE ai.inspection_id = ?\r\n      ORDER BY ai.created_at DESC\r\n    `).bind(inspectionId).all();\r\n\r\n    return c.json({\r\n      inspection: {\r\n        id: inspection.id,\r\n        title: inspection.title,\r\n        location: inspection.location,\r\n        company_name: inspection.company_name,\r\n        status: inspection.status\r\n      },\r\n      action_items: actionItems.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching action plan:', error);\r\n    return c.json({ error: \"Erro ao carregar plano de ação\" }, 500);\r\n  }\r\n});\r\n\r\n// Create manual action item\r\nchecklistRoutes.post(\"/inspections/:inspectionId/action-items\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"inspectionId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const {\r\n      title,\r\n      what_description,\r\n      where_location,\r\n      why_reason,\r\n      how_method,\r\n      who_responsible,\r\n      when_deadline,\r\n      how_much_cost,\r\n      priority = 'media',\r\n      assigned_to,\r\n      inspection_item_id\r\n    } = body;\r\n\r\n    // Validate required fields\r\n    if (!title || !what_description || !who_responsible) {\r\n      return c.json({\r\n        error: \"Campos obrigatórios: título, descrição do que fazer e responsável\"\r\n      }, 400);\r\n    }\r\n\r\n    // Get inspection to verify access and context\r\n    const inspection = await env.DB.prepare(`\r\n      SELECT i.*, u.role as user_role, u.organization_id as user_org_id\r\n      FROM inspections i\r\n      JOIN users u ON u.id = ?\r\n      WHERE i.id = ?\r\n    `).bind(user.id, inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Check permissions to create actions\r\n    const canCreate = inspection.created_by === user.id ||\r\n      inspection.organization_id === inspection.user_org_id ||\r\n      inspection.user_role === 'system_admin';\r\n\r\n    if (!canCreate) {\r\n      return c.json({ error: \"Sem permissão para criar ações nesta inspeção\" }, 403);\r\n    }\r\n\r\n    // Parse and validate deadline\r\n    let deadlineDate = null;\r\n    if (when_deadline) {\r\n      try {\r\n        deadlineDate = new Date(when_deadline).toISOString().split('T')[0];\r\n      } catch (error) {\r\n        return c.json({ error: \"Data de prazo inválida\" }, 400);\r\n      }\r\n    }\r\n\r\n    // Create action item\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO action_items (\r\n        inspection_id, inspection_item_id, title, what_description, where_location,\r\n        why_reason, how_method, who_responsible, when_deadline, how_much_cost,\r\n        status, priority, is_ai_generated, assigned_to, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, false, ?, NOW(), NOW())\r\n    `).bind(\r\n      inspectionId,\r\n      inspection_item_id || null,\r\n      title,\r\n      what_description,\r\n      where_location || inspection.location,\r\n      why_reason || 'Ação manual criada pelo inspetor',\r\n      how_method || 'A definir',\r\n      who_responsible,\r\n      deadlineDate,\r\n      how_much_cost || 'A definir',\r\n      priority,\r\n      assigned_to || who_responsible\r\n    ).run();\r\n\r\n    return c.json({\r\n      id: result.meta.last_row_id,\r\n      message: \"Ação criada com sucesso\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating manual action item:', error);\r\n    return c.json({ error: \"Erro ao criar ação manual\" }, 500);\r\n  }\r\n});\r\n\r\n// Update action item\r\nchecklistRoutes.put(\"/action-items/:id\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const actionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const {\r\n      title,\r\n      what_description,\r\n      where_location,\r\n      why_reason,\r\n      how_method,\r\n      who_responsible,\r\n      when_deadline,\r\n      how_much_cost,\r\n      priority,\r\n      status,\r\n      assigned_to\r\n    } = body;\r\n\r\n    // Get action item to verify access\r\n    const action = await env.DB.prepare(`\r\n      SELECT ai.*, i.created_by as inspection_created_by, \r\n             i.organization_id as inspection_org_id, u.role as user_role,\r\n             u.organization_id as user_org_id\r\n      FROM action_items ai\r\n      JOIN inspections i ON ai.inspection_id = i.id\r\n      JOIN users u ON u.id = ?\r\n      WHERE ai.id = ?\r\n    `).bind(user.id, actionId).first() as any;\r\n\r\n    if (!action) {\r\n      return c.json({ error: \"Ação não encontrada\" }, 404);\r\n    }\r\n\r\n    // Check permissions to edit\r\n    const canEdit = action.inspection_created_by === user.id ||\r\n      action.inspection_org_id === action.user_org_id ||\r\n      action.user_role === 'system_admin' ||\r\n      action.assigned_to === user.email;\r\n\r\n    if (!canEdit) {\r\n      return c.json({ error: \"Sem permissão para editar esta ação\" }, 403);\r\n    }\r\n\r\n    // Parse deadline if provided\r\n    let deadlineDate = action.when_deadline;\r\n    if (when_deadline !== undefined) {\r\n      if (when_deadline) {\r\n        try {\r\n          deadlineDate = new Date(when_deadline).toISOString().split('T')[0];\r\n        } catch (error) {\r\n          return c.json({ error: \"Data de prazo inválida\" }, 400);\r\n        }\r\n      } else {\r\n        deadlineDate = null;\r\n      }\r\n    }\r\n\r\n    // Update action item\r\n    await env.DB.prepare(`\r\n      UPDATE action_items SET \r\n        title = COALESCE(?, title),\r\n        what_description = COALESCE(?, what_description),\r\n        where_location = COALESCE(?, where_location),\r\n        why_reason = COALESCE(?, why_reason),\r\n        how_method = COALESCE(?, how_method),\r\n        who_responsible = COALESCE(?, who_responsible),\r\n        when_deadline = COALESCE(?, when_deadline),\r\n        how_much_cost = COALESCE(?, how_much_cost),\r\n        priority = COALESCE(?, priority),\r\n        status = COALESCE(?, status),\r\n        assigned_to = COALESCE(?, assigned_to),\r\n        updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(\r\n      title,\r\n      what_description,\r\n      where_location,\r\n      why_reason,\r\n      how_method,\r\n      who_responsible,\r\n      deadlineDate,\r\n      how_much_cost,\r\n      priority,\r\n      status,\r\n      assigned_to,\r\n      actionId\r\n    ).run();\r\n\r\n    return c.json({ message: \"Ação atualizada com sucesso\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating action item:', error);\r\n    return c.json({ error: \"Erro ao atualizar ação\" }, 500);\r\n  }\r\n});\r\n\r\n// Delete action item\r\nchecklistRoutes.delete(\"/action-items/:id\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const actionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get action item to verify access\r\n    const action = await env.DB.prepare(`\r\n      SELECT ai.*, i.created_by as inspection_created_by, \r\n             i.organization_id as inspection_org_id, u.role as user_role,\r\n             u.organization_id as user_org_id\r\n      FROM action_items ai\r\n      JOIN inspections i ON ai.inspection_id = i.id\r\n      JOIN users u ON u.id = ?\r\n      WHERE ai.id = ?\r\n    `).bind(user.id, actionId).first() as any;\r\n\r\n    if (!action) {\r\n      return c.json({ error: \"Ação não encontrada\" }, 404);\r\n    }\r\n\r\n    // Check permissions to delete\r\n    const canDelete = action.inspection_created_by === user.id ||\r\n      action.inspection_org_id === action.user_org_id ||\r\n      action.user_role === 'system_admin';\r\n\r\n    if (!canDelete) {\r\n      return c.json({ error: \"Sem permissão para excluir esta ação\" }, 403);\r\n    }\r\n\r\n    // Delete action item\r\n    await env.DB.prepare(\"DELETE FROM action_items WHERE id = ?\").bind(actionId).run();\r\n\r\n    return c.json({ message: \"Ação excluída com sucesso\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error deleting action item:', error);\r\n    return c.json({ error: \"Erro ao excluir ação\" }, 500);\r\n  }\r\n});\r\n\r\nexport default checklistRoutes;\r\n\r\n"},{"name":"cnpj-routes.ts","content":"import { Hono } from \"hono\";\r\n\r\nconst cnpjRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Helper function to perform CNPJ lookup with proper error handling\r\nconst performCnpjLookup = async (cnpjInput: string) => {\r\n    try {\r\n        if (!cnpjInput) {\r\n            return {\r\n                success: false,\r\n                error: \"CNPJ é obrigatório\",\r\n                status: 400\r\n            };\r\n        }\r\n\r\n        // Clean CNPJ (remove dots, dashes, slashes, spaces)\r\n        const cleanCnpj = cnpjInput.replace(/[.\\-/\\s]/g, '');\r\n\r\n        // Validate CNPJ format (14 digits)\r\n        if (!/^\\d{14}$/.test(cleanCnpj)) {\r\n            return {\r\n                success: false,\r\n                error: \"CNPJ deve conter 14 dígitos numéricos\",\r\n                status: 400\r\n            };\r\n        }\r\n\r\n        // Call external CNPJ API (using ReceitaWS - API gratuita)\r\n        const apiUrl = `https://receitaws.com.br/v1/cnpj/${cleanCnpj}`;\r\n\r\n        const response = await globalThis.fetch(apiUrl, {\r\n            headers: {\r\n                'User-Agent': 'Mozilla/5.0 (compatible; InspectionApp/1.0)',\r\n                'Accept': 'application/json'\r\n            }\r\n        });\r\n\r\n        if (!response.ok) {\r\n            if (response.status === 429) {\r\n                return {\r\n                    success: false,\r\n                    error: \"Muitas consultas. Tente novamente em alguns minutos. (Limite da API gratuita: 3/minuto)\",\r\n                    status: 429\r\n                };\r\n            }\r\n            return {\r\n                success: false,\r\n                error: `Erro na consulta externa: ${response.status}`,\r\n                status: 502\r\n            };\r\n        }\r\n\r\n        const cnpjData = await response.json() as any;\r\n\r\n        if (cnpjData.status === 'ERROR') {\r\n            return {\r\n                success: false,\r\n                error: cnpjData.message || \"CNPJ não encontrado\",\r\n                status: 404\r\n            };\r\n        }\r\n\r\n        // Transform data to match our organization format\r\n        const companyData = {\r\n            cnpj: cnpjData.cnpj,\r\n            razao_social: cnpjData.nome,\r\n            nome_fantasia: cnpjData.fantasia || cnpjData.nome,\r\n            nome: cnpjData.fantasia || cnpjData.nome,\r\n            cnae_principal: cnpjData.atividade_principal?.[0]?.code || '',\r\n            cnae_descricao: cnpjData.atividade_principal?.[0]?.text || '',\r\n            natureza_juridica: cnpjData.natureza_juridica || '',\r\n            data_abertura: cnpjData.abertura || '',\r\n            capital_social: parseFloat(cnpjData.capital_social?.replace(/[. ]/g, '').replace(',', '.')) || 0,\r\n            porte_empresa: cnpjData.porte || '',\r\n            situacao_cadastral: cnpjData.situacao || '',\r\n            address: cnpjData.logradouro\r\n                ? `${cnpjData.logradouro}, ${cnpjData.numero}${cnpjData.complemento ? ' - ' + cnpjData.complemento : ''}, ${cnpjData.bairro}, ${cnpjData.municipio}/${cnpjData.uf}, CEP: ${cnpjData.cep}`\r\n                : '',\r\n            contact_email: cnpjData.email || '',\r\n            contact_phone: cnpjData.telefone || '',\r\n            website: '',\r\n            // Additional fields for reference\r\n            logradouro: cnpjData.logradouro,\r\n            numero: cnpjData.numero,\r\n            complemento: cnpjData.complemento,\r\n            bairro: cnpjData.bairro,\r\n            municipio: cnpjData.municipio,\r\n            uf: cnpjData.uf,\r\n            cep: cnpjData.cep,\r\n            atividades_secundarias: cnpjData.atividades_secundarias || [],\r\n            qsa: cnpjData.qsa || [] // Quadro de sócios\r\n        };\r\n\r\n        return {\r\n            success: true,\r\n            data: companyData,\r\n            status: 200\r\n        };\r\n\r\n    } catch (error) {\r\n        console.error('CNPJ lookup error:', error);\r\n        return {\r\n            success: false,\r\n            error: \"Erro interno ao consultar CNPJ\",\r\n            details: error instanceof Error ? error.message : \"Erro desconhecido\",\r\n            status: 500\r\n        };\r\n    }\r\n};\r\n\r\n// CNPJ lookup endpoint with path parameter\r\ncnpjRoutes.get(\"/:cnpj\", async (c) => {\r\n    // Set proper JSON content type header\r\n    c.header('Content-Type', 'application/json');\r\n\r\n    const cnpj = c.req.param(\"cnpj\");\r\n    const result = await performCnpjLookup(cnpj);\r\n\r\n    if (result.success && result.data) {\r\n        return c.json({\r\n            success: true,\r\n            data: result.data\r\n        }, 200);\r\n    } else {\r\n        return c.json({\r\n            success: false,\r\n            error: result.error,\r\n            details: result.details\r\n        }, result.status as any);\r\n    }\r\n});\r\n\r\nexport default cnpjRoutes;\r\n"},{"name":"crm-routes.ts","content":"\r\nimport { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { ExtendedMochaUser, USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n};\r\n\r\nconst getDatabase = (env: any) => env.DB;\r\n\r\nconst app = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Require System Admin Middleware\r\nconst requireSysAdmin = async (c: any, next: any) => {\r\n    const user = c.get('user');\r\n    // Check both potential locations for role (depending on how user was populated)\r\n    const userRole = user?.role || user?.profile?.role;\r\n\r\n    if (userRole !== USER_ROLES.SYSTEM_ADMIN && userRole !== 'sys_admin') {\r\n        return c.json({ error: 'Acesso negado. Apenas System Admins.' }, 403);\r\n    }\r\n    await next();\r\n};\r\n\r\napp.use('*', tenantAuthMiddleware);\r\napp.use('*', requireSysAdmin);\r\n\r\n// List Leads (with Pagination)\r\napp.get('/leads', async (c) => {\r\n    try {\r\n        const db = getDatabase(c.env);\r\n        const { page = '1', limit = '50', search = '', status = 'all' } = c.req.query();\r\n\r\n        const offset = (parseInt(page) - 1) * parseInt(limit);\r\n        const limitVal = parseInt(limit);\r\n\r\n        let query = \"SELECT * FROM leads\";\r\n        let countQuery = \"SELECT COUNT(*) as total FROM leads\";\r\n        const params: any[] = [];\r\n        const conditions: string[] = [];\r\n\r\n        // Apply filters\r\n        if (search) {\r\n            conditions.push(\"(company_name LIKE ? OR contact_name LIKE ? OR email LIKE ?)\");\r\n            const term = `%${search}%`;\r\n            params.push(term, term, term);\r\n        }\r\n\r\n        if (status !== 'all') {\r\n            conditions.push(\"status = ?\");\r\n            params.push(status);\r\n        }\r\n\r\n        if (conditions.length > 0) {\r\n            const whereClause = \" WHERE \" + conditions.join(\" AND \");\r\n            query += whereClause;\r\n            countQuery += whereClause;\r\n        }\r\n\r\n        query += \" ORDER BY created_at DESC LIMIT ? OFFSET ?\";\r\n\r\n        // Execute queries\r\n        const { results: leads } = await db.prepare(query).bind(...params, limitVal, offset).all();\r\n        const { total } = await db.prepare(countQuery).bind(...params).first() || { total: 0 };\r\n\r\n        return c.json({\r\n            leads,\r\n            total,\r\n            page: parseInt(page),\r\n            totalPages: Math.ceil(total / limitVal)\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching leads:', error);\r\n        return c.json({ error: 'Erro ao buscar leads' }, 500);\r\n    }\r\n});\r\n\r\n// Create Lead\r\napp.post('/leads', async (c) => {\r\n    try {\r\n        const db = getDatabase(c.env);\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n\r\n        const body = await c.req.json();\r\n        const {\r\n            company_name, contact_name, email, phone, status, source, notes,\r\n            deal_value, probability,\r\n            cnpj, razao_social, nome_fantasia, website,\r\n            cep, logradouro, numero, complemento, bairro, cidade, uf\r\n        } = body;\r\n\r\n        const result = await db.prepare(`\r\n      INSERT INTO leads (\r\n          company_name, contact_name, email, phone, status, source, notes, \r\n          deal_value, probability, owner_id,\r\n          cnpj, razao_social, nome_fantasia, website,\r\n          cep, logradouro, numero, complemento, bairro, cidade, uf\r\n      )\r\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      RETURNING *\r\n    `).bind(\r\n            company_name,\r\n            contact_name || null,\r\n            email || null,\r\n            phone || null,\r\n            status || 'new',\r\n            source || null,\r\n            notes || null,\r\n            deal_value || 0,\r\n            probability || 0,\r\n            user.id,\r\n            cnpj || null,\r\n            razao_social || null,\r\n            nome_fantasia || null,\r\n            website || null,\r\n            cep || null,\r\n            logradouro || null,\r\n            numero || null,\r\n            complemento || null,\r\n            bairro || null,\r\n            cidade || null,\r\n            uf || null\r\n        ).first();\r\n\r\n        return c.json({ lead: result });\r\n    } catch (error) {\r\n        console.error('Error creating lead:', error);\r\n        return c.json({ error: 'Erro ao criar lead' }, 500);\r\n    }\r\n});\r\n\r\n// Update Lead\r\napp.put('/leads/:id', async (c) => {\r\n    try {\r\n        const db = getDatabase(c.env);\r\n        const leadId = c.req.param('id');\r\n        const body = await c.req.json();\r\n\r\n        // Dynamic Update\r\n        const fields = [];\r\n        const values = [];\r\n        const allowed = [\r\n            'company_name', 'contact_name', 'email', 'phone', 'status', 'source', 'notes',\r\n            'deal_value', 'probability',\r\n            'cnpj', 'razao_social', 'nome_fantasia', 'website',\r\n            'cep', 'logradouro', 'numero', 'complemento', 'bairro', 'cidade', 'uf'\r\n        ];\r\n\r\n        for (const key of allowed) {\r\n            if (body[key] !== undefined) {\r\n                fields.push(`${key} = ?`);\r\n                values.push(body[key]);\r\n            }\r\n        }\r\n\r\n        if (fields.length === 0) return c.json({ message: 'Nothing to update' });\r\n\r\n        // Auto-log Status Change & Update status_updated_at\r\n        if (body.status) {\r\n            const currentLead = await db.prepare(\"SELECT status FROM leads WHERE id = ?\").bind(leadId).first();\r\n            if (currentLead && currentLead.status !== body.status) {\r\n                // Log Activity\r\n                await db.prepare(`\r\n                    INSERT INTO crm_activities (lead_id, type, title, description, created_by) \r\n                    VALUES (?, 'status_change', 'Alteração de Status', ?, ?)\r\n                 `).bind(\r\n                    leadId,\r\n                    `Status alterado de ${currentLead.status.toUpperCase()} para ${body.status.toUpperCase()}`,\r\n                    (c.get('user') as any).id\r\n                ).run();\r\n\r\n                // Update status timestamp\r\n                fields.push(\"status_updated_at = NOW()\");\r\n            }\r\n        }\r\n\r\n        fields.push(\"updated_at = NOW()\");\r\n\r\n        await db.prepare(`UPDATE leads SET ${fields.join(', ')} WHERE id = ?`)\r\n            .bind(...values, leadId)\r\n            .run();\r\n\r\n        return c.json({ success: true });\r\n    } catch (error) {\r\n        console.error('Error updating lead:', error);\r\n        return c.json({ error: 'Erro ao atualizar lead' }, 500);\r\n    }\r\n});\r\n\r\n// List Activities\r\napp.get('/leads/:id/activities', async (c) => {\r\n    try {\r\n        const db = getDatabase(c.env);\r\n        const leadId = c.req.param('id');\r\n\r\n        const { results } = await db.prepare(`\r\n            SELECT a.*, u.email as user_email \r\n            FROM crm_activities a\r\n            LEFT JOIN auth.users u ON a.created_by = u.id \r\n            WHERE lead_id = ? \r\n            ORDER BY created_at DESC\r\n        `).bind(leadId).all();\r\n\r\n        return c.json(results || []);\r\n    } catch (error) {\r\n        console.error('Error fetching activities:', error);\r\n        return c.json({ error: 'Erro ao buscar atividades' }, 500);\r\n    }\r\n});\r\n\r\n// Create Activity\r\napp.post('/leads/:id/activities', async (c) => {\r\n    try {\r\n        const db = getDatabase(c.env);\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const leadId = c.req.param('id');\r\n        const body = await c.req.json();\r\n\r\n        const { type, title, description } = body;\r\n\r\n        await db.prepare(`\r\n            INSERT INTO crm_activities (lead_id, type, title, description, created_by)\r\n            VALUES (?, ?, ?, ?, ?)\r\n        `).bind(leadId, type, title, description, user.id).run();\r\n\r\n        return c.json({ success: true });\r\n    } catch (error) {\r\n        console.error('Error creating activity:', error);\r\n        return c.json({ error: 'Erro ao criar atividade' }, 500);\r\n    }\r\n});\r\n\r\n// Delete Lead\r\napp.delete('/leads/:id', async (c) => {\r\n    try {\r\n        const db = getDatabase(c.env);\r\n        const leadId = c.req.param('id');\r\n        await db.prepare(\"DELETE FROM leads WHERE id = ?\").bind(leadId).run();\r\n        return c.json({ success: true });\r\n    } catch (error) {\r\n        return c.json({ error: 'Erro ao deletar lead' }, 500);\r\n    }\r\n});\r\n\r\n// ✨ CONVERT LEAD TO ORGANIZATION ✨\r\napp.post('/leads/:id/convert', async (c) => {\r\n    try {\r\n        const db = getDatabase(c.env);\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const leadId = c.req.param('id');\r\n\r\n        // 1. Get Lead Data\r\n        const lead = await db.prepare(\"SELECT * FROM leads WHERE id = ?\").bind(leadId).first();\r\n        if (!lead) return c.json({ error: 'Lead not found' }, 404);\r\n        if (lead.converted_organization_id) return c.json({ error: 'Lead já convertido' }, 400);\r\n\r\n        // Get Body for Overrides\r\n        let body: any = {};\r\n        try { body = await c.req.json(); } catch (e) { }\r\n\r\n        // 2. Prepare Organization Data\r\n        // Map Lead fields to Organizations fields (Prefer Body, fallback to Lead)\r\n        const orgName = body.name || lead.nome_fantasia || lead.company_name;\r\n\r\n        // Insert Organization\r\n        const orgResult = await db.prepare(`\r\n            INSERT INTO organizations(\r\n                name, \r\n                type, \r\n                description,\r\n                contact_email, \r\n                contact_phone, \r\n                \r\n                -- Address (Composite address string)\r\n                address, \r\n                \r\n                -- Fiscal / Details\r\n                cnpj, \r\n                razao_social, \r\n                nome_fantasia, \r\n                website,\r\n                \r\n                -- Organization Config\r\n                organization_level,\r\n                parent_organization_id,\r\n                subscription_status,\r\n                subscription_plan,\r\n                max_users,\r\n                max_subsidiaries,\r\n                \r\n                -- Business Details\r\n                cnae_principal, cnae_descricao, natureza_juridica, \r\n                data_abertura, capital_social, porte_empresa,\r\n                situacao_cadastral, numero_funcionarios, setor_industria,\r\n                faturamento_anual, logo_url,\r\n\r\n                is_active,\r\n                created_at,\r\n                updated_at\r\n            ) VALUES(\r\n                ?, ?, ?, ?, ?, ?, \r\n                ?, ?, ?, ?, \r\n                ?, ?, 'active', ?, ?, ?, \r\n                ?, ?, ?, \r\n                ?, ?, ?, \r\n                ?, ?, ?, \r\n                ?, ?, \r\n                true, NOW(), NOW()\r\n            )\r\n            RETURNING id\r\n        `).bind(\r\n            orgName,\r\n            body.type || 'company',\r\n            body.description || null,\r\n            body.contact_email || lead.email,\r\n            body.contact_phone || lead.phone,\r\n\r\n            // Address String (Composite or explicit from Body)\r\n            body.address || [lead.logradouro, lead.numero, lead.bairro, lead.cidade, lead.uf].filter(Boolean).join(', ') || 'Endereço não informado',\r\n\r\n            // Fiscal\r\n            body.cnpj || lead.cnpj,\r\n            body.razao_social || lead.razao_social,\r\n            body.nome_fantasia || lead.nome_fantasia,\r\n            body.website || lead.website,\r\n\r\n            // Config\r\n            body.organization_level || 'company',\r\n            body.parent_organization_id || null,\r\n            body.subscription_plan || 'basic',\r\n            body.max_users || 50,\r\n            body.max_subsidiaries || 0,\r\n\r\n            // Business (New Fields)\r\n            body.cnae_principal || null,\r\n            body.cnae_descricao || null,\r\n            body.natureza_juridica || null,\r\n            body.data_abertura || null,\r\n            body.capital_social || null,\r\n            body.porte_empresa || null,\r\n            body.situacao_cadastral || null,\r\n            body.numero_funcionarios || null,\r\n            body.setor_industria || null,\r\n            body.faturamento_anual || null,\r\n            body.logo_url || null\r\n        ).first();\r\n\r\n        const newOrgId = orgResult?.id;\r\n\r\n        if (!newOrgId) throw new Error(\"Failed to create organization\");\r\n\r\n        // 3. Update Lead Status\r\n        await db.prepare(`\r\n            UPDATE leads \r\n            SET status = 'won', \r\n                converted_organization_id = ?,\r\n                updated_at = NOW()\r\n            WHERE id = ?\r\n        `).bind(newOrgId, leadId).run();\r\n\r\n        // 4. Log Activity\r\n        await db.prepare(`\r\n            INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n            VALUES(?, ?, 'lead_converted', ?, 'lead', ?, NOW())\r\n        `).bind(\r\n            user.id,\r\n            newOrgId,\r\n            `Lead convertido em organização: ${orgName}`,\r\n            leadId\r\n        ).run();\r\n\r\n        return c.json({\r\n            success: true,\r\n            organization_id: newOrgId,\r\n            message: 'Lead convertido com sucesso!'\r\n        });\r\n\r\n    } catch (error: any) {\r\n        console.error('Error converting lead:', error);\r\n        return c.json({ error: 'Erro ao converter lead: ' + error.message }, 500);\r\n    }\r\n});\r\n\r\n\r\nexport default app;\r\n"},{"name":"d1-wrapper.ts","content":"import postgres from 'postgres'\r\n\r\n// Cache for single connection per worker\r\nlet sqlInstance: ReturnType<typeof postgres> | null = null;\r\n\r\nexport function createD1Wrapper(connectionString: string) {\r\n    // Use single connection with very aggressive settings for Edge Functions\r\n    // Edge Functions are short-lived, so we minimize connection overhead\r\n    if (!sqlInstance) {\r\n        sqlInstance = postgres(connectionString, {\r\n            max: 3,                    // Up to 3 connections per worker\r\n            idle_timeout: 5,           // Close idle connections quickly\r\n            connect_timeout: 10,       // Fast connection timeout\r\n            max_lifetime: 30,          // Max connection lifetime 30 seconds\r\n            fetch_types: false,        // Disable type fetching for speed\r\n        })\r\n    }\r\n    const sql = sqlInstance;\r\n\r\n    return {\r\n        prepare: (query: string) => {\r\n            let paramCount = 0;\r\n            const pgQuery = query.replace(/\\?/g, () => `$${++paramCount}`);\r\n\r\n            const createExecutionMethods = (params: any[]) => ({\r\n                bind: (...newParams: any[]) => createExecutionMethods(newParams),\r\n                first: async () => {\r\n                    try {\r\n                        const sanitizedParams = params.map(p => p === undefined ? null : p);\r\n                        const result = await sql.unsafe(pgQuery, sanitizedParams);\r\n                        return result[0] || null;\r\n                    } catch (error) {\r\n                        const errObj = error instanceof Error ?\r\n                            { name: error.name, message: error.message, stack: error.stack } :\r\n                            error;\r\n                        console.error('[D1-WRAPPER] Error in first():', JSON.stringify(errObj), 'Query:', pgQuery.substring(0, 100));\r\n                        throw error;\r\n                    }\r\n                },\r\n                run: async () => {\r\n                    try {\r\n                        const sanitizedParams = params.map(p => p === undefined ? null : p);\r\n                        const result = await sql.unsafe(pgQuery, sanitizedParams);\r\n                        return { success: true, meta: { changes: result.count, last_row_id: result[0]?.id }, id: result[0]?.id };\r\n                    } catch (error) {\r\n                        const errObj = error instanceof Error ?\r\n                            { name: error.name, message: error.message, stack: error.stack } :\r\n                            error;\r\n                        console.error('[D1-WRAPPER] Error in run():', JSON.stringify(errObj), 'Query:', pgQuery.substring(0, 100));\r\n                        throw error;\r\n                    }\r\n                },\r\n                all: async () => {\r\n                    try {\r\n                        const sanitizedParams = params.map(p => p === undefined ? null : p);\r\n                        const result = await sql.unsafe(pgQuery, sanitizedParams);\r\n                        return { results: result };\r\n                    } catch (error) {\r\n                        const errObj = error instanceof Error ?\r\n                            { name: error.name, message: error.message, stack: error.stack } :\r\n                            error;\r\n                        console.error('[D1-WRAPPER] Error in all():', JSON.stringify(errObj), 'Query:', pgQuery.substring(0, 100));\r\n                        throw error;\r\n                    }\r\n                },\r\n                raw: async () => {\r\n                    try {\r\n                        const sanitizedParams = params.map(p => p === undefined ? null : p);\r\n                        const result = await sql.unsafe(pgQuery, sanitizedParams);\r\n                        return result;\r\n                    } catch (error) {\r\n                        const errObj = error instanceof Error ?\r\n                            { name: error.name, message: error.message, stack: error.stack } :\r\n                            error;\r\n                        console.error('[D1-WRAPPER] Error in raw():', JSON.stringify(errObj), 'Query:', pgQuery.substring(0, 100));\r\n                        throw error;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return createExecutionMethods([]);\r\n        }\r\n    }\r\n}\r\n\r\n"},{"name":"dashboard-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n};\r\n\r\nconst dashboardRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// GET estatísticas gerais do dashboard\r\ndashboardRoutes.get(\"/stats\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const organizationId = c.req.query(\"organization_id\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"Usuário não autenticado\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    let whereClause = \"\";\r\n    let params: any[] = [];\r\n\r\n    const isAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin';\r\n\r\n    if (organizationId) {\r\n      // Se um organization_id for fornecido na query, filtre por ele.\r\n      // O middleware de autenticação (AuthGuard) já garante que o usuário\r\n      // tenha acesso ao scope desta organização.\r\n      whereClause = \"WHERE organization_id = ?\";\r\n      params.push(organizationId);\r\n    } else if (isAdmin) {\r\n      // SYSTEM_ADMIN vê tudo (sem filtro)\r\n      whereClause = \"\";\r\n      params = [];\r\n    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {\r\n      // Para Org Admins, se nenhum organization_id específico for fornecido,\r\n      // filtre pela organização gerenciada e suas subsidiárias\r\n      whereClause = `\r\n        WHERE organization_id IN (\r\n          SELECT id FROM organizations \r\n          WHERE id = ? OR parent_organization_id = ?\r\n        )\r\n      `;\r\n      params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n    } else {\r\n      // Para usuários comuns (não-admin), filtre pela sua organização OU atribuições\r\n      const userEmail = userProfile.email || user.email;\r\n      whereClause = \"WHERE (organization_id = ? OR inspector_email = ?)\";\r\n      // Ensure no undefined values are pushed\r\n      params.push(userProfile.organization_id || 0, userEmail || '');\r\n    }\r\n\r\n    const total = await env.DB.prepare(`SELECT COUNT(*) as count FROM inspections ${whereClause}`).bind(...params).first() as any;\r\n    const pending = await env.DB.prepare(`SELECT COUNT(*) as count FROM inspections ${whereClause}${whereClause ? ' AND' : ' WHERE'} status = 'pendente'`).bind(...params).first() as any;\r\n    const inProgress = await env.DB.prepare(`SELECT COUNT(*) as count FROM inspections ${whereClause}${whereClause ? ' AND' : ' WHERE'} status = 'em_andamento'`).bind(...params).first() as any;\r\n    const completed = await env.DB.prepare(`SELECT COUNT(*) as count FROM inspections ${whereClause}${whereClause ? ' AND' : ' WHERE'} status = 'concluida'`).bind(...params).first() as any;\r\n\r\n    return c.json({\r\n      total: total?.count || 0,\r\n      pending: pending?.count || 0,\r\n      inProgress: inProgress?.count || 0,\r\n      completed: completed?.count || 0,\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('[DASHBOARD-STATS] Erro ao buscar estatísticas:', error);\r\n    // Return empty stats instead of error 500\r\n    return c.json({\r\n      total: 0,\r\n      pending: 0,\r\n      inProgress: 0,\r\n      completed: 0\r\n    });\r\n  }\r\n});\r\n\r\n// GET sumário do plano de ação do dashboard\r\ndashboardRoutes.get(\"/action-plan-summary\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const organizationId = c.req.query(\"organization_id\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"Usuário não autenticado\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    let whereClause = \"\";\r\n    let params: any[] = [];\r\n\r\n    const isAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin';\r\n\r\n    if (organizationId) {\r\n      whereClause = \"WHERE i.organization_id = ?\";\r\n      params.push(organizationId);\r\n    } else if (isAdmin) {\r\n      // SYSTEM_ADMIN vê tudo (sem filtro)\r\n      whereClause = \"\";\r\n      params = [];\r\n    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {\r\n      whereClause = `\r\n        WHERE i.organization_id IN (\r\n          SELECT id FROM organizations \r\n          WHERE id = ? OR parent_organization_id = ?\r\n        )\r\n      `;\r\n      params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n    } else {\r\n      const userEmail = userProfile.email || user.email;\r\n      whereClause = \"WHERE (i.organization_id = ? OR i.inspector_email = ?)\";\r\n      params.push(userProfile.organization_id || 0, userEmail || '');\r\n    }\r\n\r\n    const allActions = await env.DB.prepare(`\r\n      SELECT \r\n        ai.status, \r\n        ai.priority, \r\n        ai.when_deadline, \r\n        ai.is_ai_generated \r\n      FROM action_items ai\r\n      JOIN inspections i ON ai.inspection_id = i.id\r\n      ${whereClause}\r\n    `).bind(...params).all() as any;\r\n\r\n    const actions = allActions.results || [];\r\n    const now = new Date();\r\n\r\n    const summary = actions.reduce((acc: any, action: any) => {\r\n      acc.total_actions++;\r\n      if (action.status === 'pending') acc.pending_actions++;\r\n      if (action.status === 'in_progress') acc.in_progress_actions++;\r\n      if (action.status === 'completed') acc.completed_actions++;\r\n      if (action.is_ai_generated) acc.ai_generated_count++;\r\n\r\n      if (action.when_deadline) {\r\n        const deadlineDate = new Date(action.when_deadline);\r\n        if (action.status !== 'completed' && deadlineDate < now) {\r\n          acc.overdue_actions++;\r\n        }\r\n        if (action.status !== 'completed' && deadlineDate > now && (deadlineDate.getTime() - now.getTime()) < (7 * 24 * 60 * 60 * 1000)) {\r\n          acc.upcoming_deadline++;\r\n        }\r\n      }\r\n      if (action.status !== 'completed' && action.priority === 'alta') {\r\n        acc.high_priority_pending++;\r\n      }\r\n      return acc;\r\n    }, {\r\n      total_actions: 0,\r\n      pending_actions: 0,\r\n      in_progress_actions: 0,\r\n      completed_actions: 0,\r\n      upcoming_deadline: 0,\r\n      overdue_actions: 0,\r\n      high_priority_pending: 0,\r\n      ai_generated_count: 0\r\n    });\r\n\r\n    return c.json(summary);\r\n\r\n  } catch (error) {\r\n    console.error('[DASHBOARD-ACTIONS] Erro ao buscar sumário do plano de ação:', error);\r\n    // Return empty summary instead of error 500\r\n    return c.json({\r\n      total_actions: 0,\r\n      pending_actions: 0,\r\n      in_progress_actions: 0,\r\n      completed_actions: 0,\r\n      upcoming_deadline: 0,\r\n      overdue_actions: 0,\r\n      high_priority_pending: 0,\r\n      ai_generated_count: 0\r\n    });\r\n  }\r\n});\r\n\r\n\r\n// GET BI Analytics (Proactive Insights)\r\ndashboardRoutes.get(\"/bi-analytics\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  // Only System Admins or Org Admins can see this\r\n  if (!user) return c.json({ error: \"Unauthorized\" }, 401);\r\n\r\n  try {\r\n    // --- 1. CHURN RISK (Organizations inactive > 30 days) ---\r\n    // Definition: Active organizations that haven't created an inspection in 30 days\r\n    const churnRiskQuery = `\r\n            SELECT o.id, o.name, MAX(i.created_at) as last_activity\r\n            FROM organizations o\r\n            LEFT JOIN inspections i ON o.id = i.organization_id\r\n            WHERE o.is_active = true \r\n            AND o.type = 'company'\r\n            GROUP BY o.id, o.name\r\n            HAVING MAX(i.created_at) < (NOW() - INTERVAL '30 days') OR MAX(i.created_at) IS NULL\r\n            LIMIT 5\r\n        `;\r\n    const churnRisk = await env.DB.prepare(churnRiskQuery).all();\r\n\r\n    // --- 2. UPSELL OPPORTUNITY (Close to limits) ---\r\n    // Definition: Organizations where user count > 80% of max_users\r\n    // Note: Assuming 'max_users' column exists in organizations (from create_organization logic)\r\n    // If not, we fall back to a fixed number (e.g. 5)\r\n    const upsellQuery = `\r\n            SELECT \r\n                o.id, \r\n                o.name, \r\n                COUNT(u.id) as current_users,\r\n                COALESCE(o.max_users, 5) as max_users\r\n            FROM organizations o\r\n            LEFT JOIN users u ON o.id = u.organization_id\r\n            WHERE o.is_active = true\r\n            GROUP BY o.id, o.name, o.max_users\r\n            HAVING COUNT(u.id) >= (COALESCE(o.max_users, 5) * 0.8)\r\n            LIMIT 5\r\n        `;\r\n    const upsellOpp = await env.DB.prepare(upsellQuery).all();\r\n\r\n    // --- 3. AI ADOPTION (Stickiness) ---\r\n    // Definition: % of inspections created in last 30 days that have AI Action Items\r\n    const aiAdoptionQuery = `\r\n            SELECT \r\n                COUNT(DISTINCT i.id) as total_inspections,\r\n                COUNT(DISTINCT CASE WHEN ai.is_ai_generated = true THEN i.id END) as ai_inspections\r\n            FROM inspections i\r\n            LEFT JOIN action_items ai ON i.id = ai.inspection_id\r\n            WHERE i.created_at > (NOW() - INTERVAL '30 days')\r\n        `;\r\n    const aiAdoption = await env.DB.prepare(aiAdoptionQuery).first();\r\n\r\n    // --- 4. LEAD VELOCITY (Sales Efficiency) ---\r\n    // Definition: Avg days between created_at and updated_at for WON leads\r\n    // Only considers leads won in the last 60 days to be relevant\r\n    const leadVelocityQuery = `\r\n            SELECT AVG(EXTRACT(EPOCH FROM (updated_at - created_at)) / 86400) as avg_days\r\n            FROM leads\r\n            WHERE status = 'won'\r\n            AND updated_at > (NOW() - INTERVAL '60 days')\r\n        `;\r\n    const leadVelocity = await env.DB.prepare(leadVelocityQuery).first();\r\n\r\n\r\n    return c.json({\r\n      churn_risk: churnRisk.results || [],\r\n      upsell_opportunity: upsellOpp.results || [],\r\n      ai_adoption: {\r\n        total: aiAdoption?.total_inspections || 0,\r\n        active: aiAdoption?.ai_inspections || 0,\r\n        rate: aiAdoption?.total_inspections ? (aiAdoption.ai_inspections / aiAdoption.total_inspections) : 0\r\n      },\r\n      lead_velocity: {\r\n        avg_days: Math.round(leadVelocity?.avg_days || 0)\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('[BI-ANALYTICS] Error:', error);\r\n    return c.json({ error: 'Failed to fetch BI analytics' }, 500);\r\n  }\r\n\r\n});\r\n\r\n// GET Org Admin Analytics (Productivity & Quality)\r\ndashboardRoutes.get(\"/org-admin-analytics\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const organizationId = c.req.query(\"organization_id\");\r\n\r\n  if (!user) return c.json({ error: \"Unauthorized\" }, 401);\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    let targetOrgId = organizationId;\r\n    if (!targetOrgId) {\r\n      if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n        targetOrgId = userProfile.managed_organization_id || userProfile.organization_id;\r\n      } else {\r\n        targetOrgId = userProfile.organization_id;\r\n      }\r\n    }\r\n\r\n    if (!targetOrgId) return c.json({ error: \"Organization ID required\" }, 400);\r\n\r\n    // 1. Productivity (Inspections by Inspector)\r\n    const productivityParam = targetOrgId; // bind param\r\n    const productivityQuery = `\r\n      SELECT \r\n        inspector_name, \r\n        COUNT(*) as total_inspections \r\n      FROM inspections \r\n      WHERE organization_id = ? \r\n      AND created_at > (NOW() - INTERVAL '30 days')\r\n      GROUP BY inspector_name \r\n      ORDER BY total_inspections DESC \r\n      LIMIT 10\r\n    `;\r\n    const productivity = await env.DB.prepare(productivityQuery).bind(productivityParam).all();\r\n\r\n    // 2. Action Plan Bottlenecks (Overdue by Responsible/Area)\r\n    // Note: 'department' or 'responsible' might not be normalized, using inspector_email as proxy for now if needed, \r\n    // or better, just grouping by priority/status for this org.\r\n    const bottlenecksQuery = `\r\n      SELECT \r\n        priority,\r\n        COUNT(*) as count\r\n      FROM action_items \r\n      JOIN inspections ON action_items.inspection_id = inspections.id\r\n      WHERE inspections.organization_id = ?\r\n      AND action_items.status = 'pending'\r\n      AND (action_items.when_deadline < NOW() OR action_items.priority = 'alta')\r\n      GROUP BY priority\r\n    `;\r\n    const bottlenecks = await env.DB.prepare(bottlenecksQuery).bind(targetOrgId).all();\r\n\r\n    // 3. Quality Risks (Fast inspections or Many Non-Conformities)\r\n    // For now, let's just count average non-conformities per inspection\r\n    // assuming we have a way to count items. Since we don't have 'items' table joined easily here without complexity,\r\n    // we will return a placeholder or simple metric like \"Avg Action Items per Inspection\"\r\n    const qualityQuery = `\r\n      SELECT \r\n        AVG(sub.action_count) as avg_actions_per_inspection\r\n      FROM (\r\n        SELECT inspection_id, COUNT(*) as action_count\r\n        FROM action_items ai\r\n        JOIN inspections i ON ai.inspection_id = i.id\r\n        WHERE i.organization_id = ?\r\n        GROUP BY inspection_id\r\n      ) sub\r\n    `;\r\n    const quality = await env.DB.prepare(qualityQuery).bind(targetOrgId).first();\r\n\r\n    return c.json({\r\n      productivity: productivity.results || [],\r\n      bottlenecks: bottlenecks.results || [],\r\n      quality: {\r\n        avg_actions: Math.round(Number(quality?.avg_actions_per_inspection || 0))\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('[ORG-ADMIN-ANALYTICS] Error:', error);\r\n    return c.json({ error: 'Failed to fetch analytics' }, 500);\r\n  }\r\n});\r\n\r\n\r\n\r\n// GET Inspector Personal Analytics (My Performance)\r\ndashboardRoutes.get(\"/inspector-analytics\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const organizationId = c.req.query(\"organization_id\");\r\n\r\n  if (!user) return c.json({ error: \"Unauthorized\" }, 401);\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    // For inspector analytics, we strictly use the logged-in user's email/id\r\n    const inspectorEmail = userProfile.email || user.email;\r\n    const targetOrgId = organizationId || userProfile.organization_id;\r\n\r\n    if (!targetOrgId) return c.json({ error: \"Organization context required\" }, 400);\r\n\r\n    // 1. My Inspections (This Month vs Total)\r\n    const statsQuery = `\r\n      SELECT \r\n        COUNT(*) as total,\r\n        SUM(CASE WHEN created_at > DATE('now', 'start of month') THEN 1 ELSE 0 END) as this_month,\r\n        SUM(CASE WHEN status = 'concluida' THEN 1 ELSE 0 END) as completed\r\n      FROM inspections\r\n      WHERE organization_id = ? AND inspector_email = ?\r\n    `;\r\n    const stats = await env.DB.prepare(statsQuery).bind(targetOrgId, inspectorEmail).first();\r\n\r\n    // 2. My Pending Actions ( Assigned to me or My Inspections)\r\n    const pendingActionsQuery = `\r\n      SELECT COUNT(*) as count\r\n      FROM action_items ai\r\n      JOIN inspections i ON ai.inspection_id = i.id\r\n      WHERE i.organization_id = ? \r\n      AND i.inspector_email = ?\r\n      AND ai.status = 'pending'\r\n    `;\r\n    const pendingActions = await env.DB.prepare(pendingActionsQuery).bind(targetOrgId, inspectorEmail).first();\r\n\r\n    // 3. Motivational Feedback\r\n    let feedback = \"Continue o bom trabalho!\";\r\n    const monthlyCount = Number(stats?.this_month || 0);\r\n    if (monthlyCount > 10) feedback = \"🔥 Incrível! Você está voando baixo este mês!\";\r\n    else if (monthlyCount > 5) feedback = \"Ótimo ritmo! Continue assim.\";\r\n    else if (monthlyCount === 0) feedback = \"Que tal iniciar sua primeira inspeção do mês hoje?\";\r\n\r\n    return c.json({\r\n      my_stats: {\r\n        total: stats?.total || 0,\r\n        this_month: stats?.this_month || 0,\r\n        completed: stats?.completed || 0,\r\n        pending_actions: pendingActions?.count || 0\r\n      },\r\n      feedback_message: feedback\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('[INSPECTOR-ANALYTICS] Error:', error);\r\n    return c.json({ error: 'Failed to fetch personal analytics' }, 500);\r\n  }\r\n});\r\n\r\n\r\nexport default dashboardRoutes;\r\n\r\n\r\n"},{"name":"database-debug-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { requireProtectedSysAdmin } from \"./rbac-middleware.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n};\r\n\r\nconst app = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// SEGURANÇA: Verificar se estamos em produção - bloquear debug endpoints\r\nconst isProduction = Deno.env.get('ENVIRONMENT') === 'production';\r\n\r\n// Endpoint para consultar dados do banco\r\n// PROTEGIDO: Apenas SysAdmin pode acessar, e bloqueado em produção\r\napp.get(\"/debug/query\", requireProtectedSysAdmin(), async (c) => {\r\n  // Bloquear completamente em produção\r\n  if (isProduction) {\r\n    console.warn('[DEBUG-ROUTES] BLOQUEADO: Tentativa de acesso a debug em produção');\r\n    return c.json({ error: \"Debug endpoints desabilitados em produção\" }, 403);\r\n  }\r\n  const { table, limit = \"10\" } = c.req.query();\r\n\r\n  if (!table) {\r\n    return c.json({ error: \"Parâmetro 'table' é obrigatório\" }, 400);\r\n  }\r\n\r\n  try {\r\n    // Lista de tabelas permitidas por segurança\r\n    const allowedTables = [\r\n      'users', 'organizations', 'checklist_templates',\r\n      'inspections', 'action_plans', 'checklist_folders',\r\n      'inspection_items', 'action_plan_items'\r\n    ];\r\n\r\n    if (!allowedTables.includes(table)) {\r\n      return c.json({\r\n        error: \"Tabela não permitida\",\r\n        allowedTables\r\n      }, 400);\r\n    }\r\n\r\n    const query = `SELECT * FROM ${table} LIMIT ?`;\r\n    const result = await c.env.DB.prepare(query).bind(limit).all();\r\n\r\n    return c.json({\r\n      table,\r\n      count: result.results?.length || 0,\r\n      data: result.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Database query error:', error);\r\n    return c.json({\r\n      error: \"Erro ao consultar banco\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Endpoint para obter estrutura das tabelas (Postgres compatible)\r\n// PROTEGIDO: Apenas SysAdmin pode acessar, e bloqueado em produção\r\napp.get(\"/debug/schema\", requireProtectedSysAdmin(), async (c) => {\r\n  if (isProduction) {\r\n    return c.json({ error: \"Debug endpoints desabilitados em produção\" }, 403);\r\n  }\r\n  try {\r\n    const tableParam = c.req.query('table');\r\n\r\n    if (tableParam) {\r\n      // Query specific columns for a table\r\n      const result = await c.env.DB.prepare(`\r\n           SELECT column_name, data_type, is_nullable\r\n           FROM information_schema.columns\r\n           WHERE table_name = ?\r\n           ORDER BY ordinal_position\r\n        `).bind(tableParam).all();\r\n\r\n      return c.json({\r\n        table: tableParam,\r\n        columns: result.results || []\r\n      });\r\n    }\r\n\r\n    const result = await c.env.DB.prepare(`\r\n      SELECT table_name as name \r\n      FROM information_schema.tables \r\n      WHERE table_schema = 'public'\r\n      ORDER BY table_name\r\n    `).all();\r\n\r\n    return c.json({\r\n      tables: result.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Schema query error:', error);\r\n    return c.json({\r\n      error: \"Erro ao obter schema\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Endpoint para contar registros\r\n// PROTEGIDO: Apenas SysAdmin pode acessar, e bloqueado em produção\r\napp.get(\"/debug/counts\", requireProtectedSysAdmin(), async (c) => {\r\n  if (isProduction) {\r\n    return c.json({ error: \"Debug endpoints desabilitados em produção\" }, 403);\r\n  }\r\n  try {\r\n    const tables = ['users', 'organizations', 'checklist_templates', 'inspections', 'action_plans'];\r\n    const counts: Record<string, any> = {};\r\n\r\n    for (const table of tables) {\r\n      try {\r\n        const result = await c.env.DB.prepare(`SELECT COUNT(*) as count FROM ${table}`).first() as any;\r\n        counts[table] = result?.count || 0;\r\n      } catch (err) {\r\n        counts[table] = 'Tabela não existe ou erro';\r\n      }\r\n    }\r\n\r\n    return c.json({ counts });\r\n\r\n  } catch (error) {\r\n    console.error('Counts query error:', error);\r\n    return c.json({\r\n      error: \"Erro ao contar registros\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\nexport default app;\r\n\r\n"},{"name":"deno.json","content":"{\r\n    \"tasks\": {\r\n        \"start\": \"deno run --allow-net --allow-env --watch index.ts\"\r\n    },\r\n    \"imports\": {\r\n        \"hono\": \"https://esm.sh/hono@4.6.14\",\r\n        \"hono/\": \"https://esm.sh/hono@4.6.14/\",\r\n        \"@supabase/supabase-js\": \"jsr:@supabase/supabase-js@^2.0.0\",\r\n        \"postgres\": \"https://deno.land/x/postgresjs@v3.4.4/mod.js\",\r\n        \"std/\": \"https://deno.land/std@0.208.0/\",\r\n        \"zod\": \"https://esm.sh/zod@3.23.8\",\r\n        \"@hono/zod-validator\": \"https://esm.sh/@hono/zod-validator@0.4.1\",\r\n        \"@/\": \"./\"\r\n    }\r\n}"},{"name":"financial-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n};\r\n\r\nconst financialRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// ============================================================================\r\n// GET /plans - Lista todos os planos ativos (público para autenticados)\r\n// ============================================================================\r\nfinancialRoutes.get(\"/plans\", async (c) => {\r\n    const env = c.env;\r\n\r\n    try {\r\n        const plans = await env.DB.prepare(`\r\n            SELECT \r\n                id, name, display_name, slug, description,\r\n                price_cents, currency, billing_period,\r\n                limits, features, is_active\r\n            FROM plans \r\n            WHERE is_active = true\r\n            ORDER BY price_cents ASC\r\n        `).all();\r\n\r\n        // Formatar preço para exibição\r\n        const formattedPlans = (plans?.results || []).map((plan: any) => ({\r\n            ...plan,\r\n            limits: typeof plan.limits === 'string' ? JSON.parse(plan.limits) : plan.limits,\r\n            features: typeof plan.features === 'string' ? JSON.parse(plan.features) : plan.features,\r\n            price_display: plan.price_cents > 0\r\n                ? `R$ ${(plan.price_cents / 100).toFixed(2).replace('.', ',')}`\r\n                : 'Sob consulta'\r\n        }));\r\n\r\n        return c.json({ plans: formattedPlans });\r\n    } catch (error: any) {\r\n        console.error(\"[FINANCIAL] Error fetching plans:\", error);\r\n        return c.json({ error: \"Erro ao buscar planos\", details: error.message }, 500);\r\n    }\r\n});\r\n\r\n// ============================================================================\r\n// GET /current - Retorna a assinatura atual da organização\r\n// ============================================================================\r\nfinancialRoutes.get(\"/current\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const organizationId = c.req.query(\"organization_id\");\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"Usuário não autenticado\" }, 401);\r\n    }\r\n\r\n    try {\r\n        // Verificar permissão (OrgAdmin ou SysAdmin)\r\n        const userProfile = await env.DB.prepare(\r\n            \"SELECT role, managed_organization_id FROM users WHERE id = ?\"\r\n        ).bind(user.id).first() as any;\r\n\r\n        const isAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN ||\r\n            userProfile?.role === 'sys_admin' ||\r\n            userProfile?.role === USER_ROLES.ORG_ADMIN;\r\n\r\n        if (!isAdmin) {\r\n            return c.json({ error: \"Apenas administradores podem acessar informações de billing\" }, 403);\r\n        }\r\n\r\n        // Determinar qual org buscar\r\n        const targetOrgId = organizationId || userProfile?.managed_organization_id;\r\n\r\n        if (!targetOrgId) {\r\n            return c.json({ error: \"Organização não especificada\" }, 400);\r\n        }\r\n\r\n        // Buscar assinatura ativa\r\n        const subscription = await env.DB.prepare(`\r\n            SELECT \r\n                s.id, s.status, s.gateway_name,\r\n                s.current_period_start, s.current_period_end,\r\n                s.trial_ends_at, s.canceled_at,\r\n                s.mrr_value_cents,\r\n                p.name as plan_name, p.display_name as plan_display_name,\r\n                p.price_cents, p.limits, p.features\r\n            FROM subscriptions s\r\n            JOIN plans p ON s.plan_id = p.id\r\n            WHERE s.organization_id = ?\r\n            AND s.status NOT IN ('canceled')\r\n            ORDER BY s.created_at DESC\r\n            LIMIT 1\r\n        `).bind(targetOrgId).first() as any;\r\n\r\n        // Buscar uso atual (última métrica)\r\n        const usage = await env.DB.prepare(`\r\n            SELECT \r\n                active_users_count, inspections_count, \r\n                ai_analyses_count, storage_used_mb, date\r\n            FROM usage_metrics\r\n            WHERE organization_id = ?\r\n            ORDER BY date DESC\r\n            LIMIT 1\r\n        `).bind(targetOrgId).first() as any;\r\n\r\n        // Buscar faturas recentes\r\n        const invoices = await env.DB.prepare(`\r\n            SELECT id, amount_cents, status, due_date, paid_at, payment_link\r\n            FROM invoices\r\n            WHERE organization_id = ?\r\n            ORDER BY due_date DESC\r\n            LIMIT 5\r\n        `).bind(targetOrgId).all();\r\n\r\n        // Formatar resposta\r\n        const billingInfo = {\r\n            subscription: subscription ? {\r\n                ...subscription,\r\n                limits: typeof subscription.limits === 'string'\r\n                    ? JSON.parse(subscription.limits)\r\n                    : subscription.limits,\r\n                features: typeof subscription.features === 'string'\r\n                    ? JSON.parse(subscription.features)\r\n                    : subscription.features,\r\n                price_display: subscription.price_cents > 0\r\n                    ? `R$ ${(subscription.price_cents / 100).toFixed(2).replace('.', ',')}`\r\n                    : 'Sob consulta'\r\n            } : null,\r\n            usage: usage || {\r\n                active_users_count: 0,\r\n                inspections_count: 0,\r\n                ai_analyses_count: 0,\r\n                storage_used_mb: 0\r\n            },\r\n            invoices: (invoices?.results || []).map((inv: any) => ({\r\n                ...inv,\r\n                amount_display: `R$ ${(inv.amount_cents / 100).toFixed(2).replace('.', ',')}`\r\n            })),\r\n            has_active_subscription: !!subscription\r\n        };\r\n\r\n        return c.json(billingInfo);\r\n    } catch (error: any) {\r\n        console.error(\"[FINANCIAL] Error fetching billing info:\", error);\r\n        return c.json({ error: \"Erro ao buscar informações de billing\", details: error.message }, 500);\r\n    }\r\n});\r\n\r\n// ============================================================================\r\n// GET /usage - Retorna o uso atual vs limites do plano\r\n// ============================================================================\r\nfinancialRoutes.get(\"/usage\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const organizationId = c.req.query(\"organization_id\");\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"Usuário não autenticado\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const userProfile = await env.DB.prepare(\r\n            \"SELECT role, managed_organization_id FROM users WHERE id = ?\"\r\n        ).bind(user.id).first() as any;\r\n\r\n        const targetOrgId = organizationId || userProfile?.managed_organization_id;\r\n\r\n        if (!targetOrgId) {\r\n            return c.json({ error: \"Organização não especificada\" }, 400);\r\n        }\r\n\r\n        // Buscar limites do plano\r\n        // 1. Fetch Subscription first (most recent active)\r\n        const subscription = await env.DB.prepare(`\r\n            SELECT plan_id, current_period_start, created_at, status\r\n            FROM subscriptions \r\n            WHERE organization_id = ? AND status NOT IN ('canceled')\r\n            ORDER BY created_at DESC\r\n            LIMIT 1\r\n        `).bind(targetOrgId).first() as any;\r\n\r\n        let limits: any = null;\r\n\r\n        if (subscription && subscription.plan_id) {\r\n            // 2. Fetch Plan details\r\n            const plan = await env.DB.prepare(`\r\n                SELECT limits FROM plans WHERE id = ?\r\n             `).bind(subscription.plan_id).first() as any;\r\n\r\n            if (plan?.limits) {\r\n                try {\r\n                    limits = typeof plan.limits === 'string' ? JSON.parse(plan.limits) : plan.limits;\r\n                } catch (e) {\r\n                    console.error(\"[FINANCIAL] Failed to parse limits:\", e);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 3. Fallback if no subscription or plan found\r\n        const finalLimits = limits || { users: 2, storage_gb: 5, inspections_monthly: 100 }; // Default free tier\r\n\r\n        // Contar uso atual\r\n        const userCount = await env.DB.prepare(`\r\n            SELECT COUNT(*) as count FROM user_organizations WHERE organization_id = ?\r\n        `).bind(targetOrgId).first() as any;\r\n\r\n        const currentPeriodStart = subscription?.current_period_start || new Date().toISOString().slice(0, 7) + '-01'; // Fallback to start of month\r\n\r\n        const inspectionsThisMonth = await env.DB.prepare(`\r\n            SELECT COUNT(*) as count FROM inspections \r\n            WHERE organization_id = ? \r\n            AND created_at >= ?\r\n        `).bind(targetOrgId, currentPeriodStart).first() as any;\r\n\r\n        // Calcular porcentagens\r\n        // Calcular porcentagens\r\n        const usage = {\r\n            users: {\r\n                current: userCount?.count || 0,\r\n                limit: finalLimits.users || 999,\r\n                percentage: Math.round(((userCount?.count || 0) / (finalLimits.users || 1)) * 100)\r\n            },\r\n            inspections: {\r\n                current: inspectionsThisMonth?.count || 0,\r\n                limit: finalLimits.inspections_monthly || 999,\r\n                percentage: Math.round(((inspectionsThisMonth?.count || 0) / (finalLimits.inspections_monthly || 1)) * 100)\r\n            },\r\n            storage: {\r\n                current: 0, // TODO: Calcular storage real\r\n                limit: finalLimits.storage_gb || 5,\r\n                percentage: 0\r\n            }\r\n        };\r\n\r\n        // Alertas\r\n        const alerts = [];\r\n        if (usage.users.percentage >= 80) alerts.push({ type: 'users', level: usage.users.percentage >= 100 ? 'critical' : 'warning' });\r\n        if (usage.inspections.percentage >= 80) alerts.push({ type: 'inspections', level: usage.inspections.percentage >= 100 ? 'critical' : 'warning' });\r\n\r\n        return c.json({ usage, alerts, has_subscription: !!subscription });\r\n    } catch (error: any) {\r\n        console.error(\"[FINANCIAL] Error fetching usage:\", error);\r\n        return c.json({ error: \"Erro ao buscar uso\", details: error.message }, 500);\r\n    }\r\n});\r\n\r\n// ============================================================================\r\n// POST /checkout - Inicia o processo de checkout (cria link de pagamento)\r\n// ============================================================================\r\nfinancialRoutes.post(\"/checkout\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"Usuário não autenticado\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const { plan_id, organization_id } = body;\r\n\r\n        if (!plan_id) {\r\n            return c.json({ error: \"Plano é obrigatório\" }, 400);\r\n        }\r\n\r\n        // Get user profile to confirm role\r\n        const userProfile = await env.DB.prepare(\r\n            \"SELECT role, managed_organization_id FROM users WHERE id = ?\"\r\n        ).bind(user.id).first() as any;\r\n\r\n        const targetOrgId = organization_id || userProfile?.managed_organization_id;\r\n\r\n        if (!targetOrgId) {\r\n            return c.json({ error: \"Organização não especificada\" }, 400);\r\n        }\r\n\r\n        // Get Plan details\r\n        const plan = await env.DB.prepare(\"SELECT * FROM plans WHERE id = ?\").bind(plan_id).first() as any;\r\n        if (!plan) {\r\n            return c.json({ error: \"Plano não encontrado\" }, 404);\r\n        }\r\n\r\n        // TODO: Call Asaas/Stripe API here\r\n        // For now, we simulate a successful payment link creation\r\n        // and create a pending subscription\r\n\r\n        const result = await env.DB.prepare(`\r\n            INSERT INTO subscriptions (\r\n                organization_id, plan_id, status, \r\n                current_period_start, current_period_end, \r\n                gateway_name, gateway_subscription_id,\r\n                created_at, updated_at\r\n            ) VALUES (\r\n                ?, ?, 'active',\r\n                NOW(), NOW() + INTERVAL '30 days',\r\n                'asaas', ?,\r\n                NOW(), NOW()\r\n            )\r\n            RETURNING id\r\n        `).bind(\r\n            targetOrgId, plan_id,\r\n            `mock_sub_${Date.now()}`\r\n        ).first() as any;\r\n\r\n        const subscriptionId = result?.id;\r\n\r\n        // Return mock URL\r\n        return c.json({\r\n            url: `https://www.compia.tech/billing?status=success&subscription_id=${subscriptionId || 'new'}`,\r\n            mock: true\r\n        });\r\n\r\n    } catch (error: any) {\r\n        console.error(\"[FINANCIAL] Error in checkout:\", error);\r\n        return c.json({ error: \"Erro ao processar checkout\", details: error.message }, 500);\r\n    }\r\n});\r\n\r\n// ============================================================================\r\n// GET /debug-limits - DEBUG APENAS\r\n// ============================================================================\r\nfinancialRoutes.get(\"/debug-limits\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const organizationId = c.req.query(\"organization_id\");\r\n\r\n    // Determine Org ID similar to /usage\r\n    const userProfile = await env.DB.prepare(\r\n        \"SELECT role, managed_organization_id FROM users WHERE id = ?\"\r\n    ).bind(user.id).first() as any;\r\n    const targetOrgId = organizationId || userProfile?.managed_organization_id;\r\n\r\n    if (!targetOrgId) {\r\n        return c.json({ error: \"No org id\" });\r\n    }\r\n\r\n    // Run the Logic Query\r\n    const subscription = await env.DB.prepare(`\r\n        SELECT s.id, s.status, s.gateway_name, s.current_period_start, p.name as plan_name, p.limits, p.limits as debug_limits_raw\r\n        FROM subscriptions s\r\n        JOIN plans p ON s.plan_id = p.id\r\n        WHERE s.organization_id = ? AND s.status NOT IN ('canceled')\r\n        ORDER BY s.created_at DESC\r\n        LIMIT 1\r\n    `).bind(targetOrgId).first() as any;\r\n\r\n    // Check parsing\r\n    let parsedLimits = null;\r\n    let parseError = null;\r\n    if (subscription?.limits) {\r\n        try {\r\n            parsedLimits = typeof subscription.limits === 'string' ? JSON.parse(subscription.limits) : subscription.limits;\r\n        } catch (e: any) {\r\n            parseError = e.message;\r\n        }\r\n    }\r\n\r\n    // Raw Usage Query\r\n    const currentPeriodStart = subscription?.current_period_start || new Date().toISOString().slice(0, 7) + '-01';\r\n    const inspectionsThisMonth = await env.DB.prepare(`\r\n        SELECT COUNT(*) as count FROM inspections \r\n        WHERE organization_id = ? \r\n        AND created_at >= ?\r\n    `).bind(targetOrgId, currentPeriodStart).first() as any;\r\n\r\n    return c.json({\r\n        targetOrgId,\r\n        subscription,\r\n        parsedLimits,\r\n        parseError,\r\n        inspectionsCount: inspectionsThisMonth,\r\n        currentPeriodStart\r\n    });\r\n});\r\n\r\nexport default financialRoutes;\r\n"},{"name":"gamification-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware as authMiddleware } from \"./tenant-auth-middleware.ts\";\r\n\r\nconst gamificationRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Helper to calculate level based on XP\r\n// Level = floor(sqrt(XP / 50)) + 1\r\nfunction calculateLevel(xp: number): number {\r\n    return Math.floor(Math.sqrt(xp / 50)) + 1;\r\n}\r\n\r\n// Helper to add XP (internal use)\r\nexport async function addXP(userId: string, amount: number, db: any) {\r\n    try {\r\n        // Get current stats\r\n        const current = await db.prepare(\"SELECT current_xp, level FROM user_gamification WHERE user_id = ?\").bind(userId).first();\r\n\r\n        if (!current) {\r\n            // Should exist due to seed, but handle case\r\n            await db.prepare(\"INSERT INTO user_gamification (user_id, current_xp, points_this_month) VALUES (?, ?, ?)\")\r\n                .bind(userId, amount, amount).run();\r\n            return { leveledUp: false, newLevel: 1 };\r\n        }\r\n\r\n        const newXP = (current.current_xp || 0) + amount;\r\n        const newLevel = calculateLevel(newXP);\r\n        const leveledUp = newLevel > (current.level || 1);\r\n\r\n        // Update DB\r\n        await db.prepare(`\r\n            UPDATE user_gamification \r\n            SET current_xp = ?, \r\n            level = ?, \r\n            points_this_month = points_this_month + ?,\r\n            updated_at = NOW()\r\n            WHERE user_id = ?\r\n        `).bind(newXP, newLevel, amount, userId).run();\r\n\r\n        return { leveledUp, newLevel, xpEarned: amount };\r\n    } catch (e) {\r\n        console.error(\"Failed to add XP\", e);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Get My Gamification Stats\r\ngamificationRoutes.get(\"/me\", authMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n\r\n    try {\r\n        const stats = await env.DB.prepare(`\r\n            SELECT ug.*, \r\n                (SELECT count(*) FROM user_achievements WHERE user_id = ug.user_id) as achievements_count\r\n            FROM user_gamification ug \r\n            WHERE ug.user_id = ?\r\n        `).bind(user.id).first();\r\n\r\n        if (!stats) {\r\n            // Initialize if missing (e.g. new user)\r\n            await env.DB.prepare(\"INSERT INTO user_gamification (user_id) VALUES (?)\").bind(user.id).run();\r\n            return c.json({ current_xp: 0, level: 1, points_this_month: 0, achievements_count: 0 });\r\n        }\r\n\r\n        // Calculate next level progress\r\n        const currentLevel = stats.level;\r\n        const nextLevelStart = 50 * Math.pow(currentLevel, 2); // Inverse of sqrt(xp/50) -> xp = 50 * (level-1)^2 ? No, level = sqrt(xp/50)+1 => level-1 = sqrt(xp/50) => (level-1)^2 = xp/50 => xp = 50*(level-1)^2\r\n        // Wait, calculateLevel(xp) = floor(sqrt(xp/50)) + 1.\r\n        // XP for Level L: 50 * (L-1)^2.\r\n        // XP for Level L+1: 50 * (L)^2.\r\n\r\n        const currentLevelXPStart = 50 * Math.pow(stats.level - 1, 2);\r\n        const nextLevelXPStart = 50 * Math.pow(stats.level, 2);\r\n\r\n        const progress = {\r\n            current: stats.current_xp,\r\n            min: currentLevelXPStart,\r\n            max: nextLevelXPStart,\r\n            percentage: Math.min(100, Math.max(0, ((stats.current_xp - currentLevelXPStart) / (nextLevelXPStart - currentLevelXPStart)) * 100))\r\n        };\r\n\r\n        return c.json({ ...stats, progress });\r\n    } catch (error) {\r\n        console.error(\"Error fetching gamification stats:\", error);\r\n        return c.json({ error: \"Failed to fetch stats\" }, 500);\r\n    }\r\n});\r\n\r\n// Get Leaderboard (Top 10 by Organization)\r\ngamificationRoutes.get(\"/leaderboard\", authMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n\r\n    try {\r\n        // Get user's org\r\n        const userProfile = await env.DB.prepare(\"SELECT organization_id FROM users WHERE id = ?\").bind(user.id).first();\r\n        const orgId = userProfile?.organization_id;\r\n\r\n        if (!orgId) return c.json({ leaderboard: [] });\r\n\r\n        const leaderboard = await env.DB.prepare(`\r\n            SELECT ug.user_id, ug.current_xp, ug.level, u.name, u.google_user_data\r\n            FROM user_gamification ug\r\n            JOIN users u ON ug.user_id = u.id\r\n            WHERE u.organization_id = ?\r\n            ORDER BY ug.current_xp DESC\r\n            LIMIT 10\r\n        `).bind(orgId).all();\r\n\r\n        // Process avatars\r\n        const processed = (leaderboard.results || []).map((entry: any) => {\r\n            let avatar = null;\r\n            try {\r\n                if (entry.google_user_data) {\r\n                    const data = JSON.parse(entry.google_user_data);\r\n                    avatar = data.picture;\r\n                }\r\n            } catch (e) { }\r\n            return {\r\n                user_id: entry.user_id,\r\n                name: entry.name,\r\n                current_xp: entry.current_xp,\r\n                level: entry.level,\r\n                avatar_url: avatar\r\n            };\r\n        });\r\n\r\n        return c.json({ leaderboard: processed });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching leaderboard:\", error);\r\n        return c.json({ error: \"Failed to fetch leaderboard\" }, 500);\r\n    }\r\n});\r\n\r\nexport default gamificationRoutes;\r\n"},{"name":"index.ts","content":"import { Hono } from 'hono'\r\nimport { cors } from 'hono/cors'\r\nimport { createClient } from '@supabase/supabase-js'\r\n\r\n// Import wrapper para compatibilidade\r\nimport { createD1Wrapper } from './d1-wrapper.ts'\r\n\r\n// Importar rotas\r\nimport usersRoutes from \"./users-routes.ts\";\r\nimport kanbanRoutes from \"./kanban-routes.ts\";\r\nimport organizationsRoutes from \"./organizations-routes.ts\";\r\nimport inspectionRoutes from \"./inspection-routes.ts\";\r\nimport checklistRoutes from \"./checklist-routes.ts\";\r\nimport authRoutes from \"./auth-routes.ts\";\r\nimport aiAssistantsRoutes from \"./ai-assistants-routes.ts\";\r\nimport checklistFoldersRoutes from \"./checklist-folders-routes.ts\";\r\nimport dashboardRoutes from \"./dashboard-routes.ts\";\r\nimport shareRoutes from \"./share-routes.ts\";\r\nimport adminApprovalRoutes from \"./admin-approval-routes.ts\";\r\nimport userAssignmentRoutes from \"./user-assignment-routes.ts\";\r\nimport multiTenantRoutes from \"./multi-tenant-routes.ts\";\r\nimport systemAdminRoutes from \"./system-admin-routes.ts\";\r\nimport rolePermissionsRoutes from \"./role-permissions-routes.ts\";\r\nimport cepRoutes from \"./cep-routes.ts\";\r\nimport cnpjRoutes from \"./cnpj-routes.ts\";\r\nimport mediaRoutes from \"./media-routes.ts\";\r\nimport adminDebugRoutes from \"./admin-debug-routes.ts\";\r\nimport databaseDebugRoutes from \"./database-debug-routes.ts\";\r\nimport autoOrganizeFolders from \"./auto-organize-folders.ts\";\r\nimport autosuggestRoutes from \"./autosuggest-routes.ts\";\r\nimport { aiUsageRoutes } from \"./ai-usage-routes.ts\";\r\nimport securityEndpoints from \"./security-endpoints.ts\";\r\nimport actionPlansRoutes from \"./action-plans-routes.ts\";\r\nimport resetProjectRoutes from \"./reset-project.ts\";\r\nimport notificationsRoutes from \"./notifications-routes.ts\";\r\nimport financialRoutes from \"./financial-routes.ts\";\r\nimport asaasWebhookRoutes from \"./asaas-webhook.ts\";\r\nimport inspectionItemRoutes from \"./inspection-item-routes.ts\";\r\nimport gamificationRoutes from \"./gamification-routes.ts\";\r\nimport aiAssistantRoutes from \"./ai-assistant-routes.ts\";\r\nimport { auditRoutes } from \"./audit-routes.ts\";\r\nimport calendarRoutes from \"./calendar-routes.ts\";\r\nimport calendarSettingsRoutes from \"./calendar-settings-routes.ts\";\r\nimport testOrgsRoutes from \"./test-orgs.ts\";\r\nimport integrationsRoutes from \"./integrations-routes.ts\";\r\nimport calendarUploadRoutes from \"./calendar-upload-routes.ts\";\r\nimport crmRoutes from \"./crm-routes.ts\";\r\n\r\nconst app = new Hono()\r\n\r\n// GLOBAL ERROR HANDLER (Sentinela Security Pattern)\r\napp.onError((err, c) => {\r\n    console.error('[GLOBAL-ERROR] Uncaught exception:', err);\r\n\r\n    // Fail Secure: Não vazar stack trace em produção\r\n    const isDev = Deno.env.get('ENVIRONMENT') === 'development';\r\n\r\n    return c.json({\r\n        error: \"Internal Server Error\",\r\n        message: isDev ? err.message : \"Ocorreu um erro interno. Nossa equipe já foi notificada.\",\r\n        code: \"INTERNAL_ERROR\",\r\n        // Stack apenas em dev\r\n        stack: isDev ? err.stack : undefined\r\n    }, 500);\r\n});\r\n\r\napp.use('/*', cors({\r\n    origin: (origin) => {\r\n        const allowed = ['https://compia.tech', 'https://www.compia.tech', 'http://localhost:3000', 'http://localhost:5173', 'https://compia-06092520-aqb5140o0-tiagossms-projects.vercel.app'];\r\n        // Allow Vercel preview URLs dynamically\r\n        if (origin && (allowed.includes(origin) || origin.endsWith('.vercel.app'))) {\r\n            return origin;\r\n        }\r\n        // SEGURANÇA: Não permitir origens desconhecidas (retorna null = bloqueio CORS)\r\n        return null;\r\n    },\r\n\r\n    allowHeaders: ['authorization', 'x-client-info', 'apikey', 'content-type'],\r\n    allowMethods: ['POST', 'GET', 'OPTIONS', 'PUT', 'DELETE'],\r\n    exposedHeaders: ['Content-Length', 'X-Kuma-Revision'],\r\n    maxAge: 600,\r\n    credentials: true,\r\n}))\r\n\r\n// Middleware para injetar DB wrapper e User\r\napp.use('*', async (c, next) => {\r\n    const dbUrl = Deno.env.get('SUPABASE_DB_URL')\r\n    // @ts-ignore\r\n    c.env = c.env || {}\r\n\r\n    if (dbUrl) {\r\n        // @ts-ignore\r\n        c.env.DB = createD1Wrapper(dbUrl)\r\n    }\r\n\r\n    // Inject OPENAI_API_KEY from Deno.env so routes can access it\r\n    // @ts-ignore\r\n    c.env.OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY') || ''\r\n    // @ts-ignore - Gemini API key for AI fallback\r\n    c.env.GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY') || ''\r\n    // @ts-ignore\r\n    c.env.SUPABASE_URL = Deno.env.get('SUPABASE_URL') || ''\r\n    // @ts-ignore\r\n    c.env.SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY') || ''\r\n    // @ts-ignore - Required for Supabase Storage uploads\r\n    c.env.SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || ''\r\n\r\n    const path = c.req.path;\r\n    console.log(`[AUTH-DEBUG] ===== Request: ${c.req.method} ${path} =====`);\r\n\r\n    // Rotas públicas que não precisam de autenticação\r\n    const publicPaths = ['/api/health', '/api/', '/api/shared', '/api/test-orgs/debug', '/test-orgs/debug', '/api/calendar/debug', '/api/debug-usage'];\r\n    const isPublicRoute = publicPaths.some(p => path === p || path.startsWith(p + '/'));\r\n\r\n    if (isPublicRoute) {\r\n        console.log(`[AUTH-DEBUG] Public route, skipping auth: ${path}`);\r\n        await next();\r\n        return;\r\n    }\r\n\r\n    // Verificar se já tem user (algumas rotas públicas não precisam)\r\n    if (!c.get('user')) {\r\n        let user = null;\r\n\r\n        // 1. Primeiro, tentar via Supabase Auth (para Google login)\r\n        const authHeader = c.req.header('Authorization');\r\n        console.log(`[AUTH-DEBUG] Authorization header: ${authHeader ? 'present (' + authHeader.substring(0, 30) + '...)' : 'absent'}`);\r\n\r\n        if (authHeader) {\r\n            const supabaseClient = createClient(\r\n                Deno.env.get('SUPABASE_URL') ?? '',\r\n                Deno.env.get('SUPABASE_ANON_KEY') ?? '',\r\n                { global: { headers: { Authorization: authHeader } } }\r\n            )\r\n            const { data, error } = await supabaseClient.auth.getUser()\r\n            user = data?.user;\r\n            console.log(`[AUTH-DEBUG] Supabase Auth: ${user ? 'found user ' + user.email : 'no user'}, error: ${error?.message || 'none'}`);\r\n\r\n            // AUTO-SYNC: If user from Supabase Auth doesn't exist in DB, create them\r\n            if (user && user.email && c.env?.DB) {\r\n                const existingDbUser = await c.env.DB.prepare(\"SELECT id, role FROM users WHERE id = ? OR email = ?\").bind(user.id, user.email).first();\r\n                if (!existingDbUser) {\r\n                    const userName = user.user_metadata?.full_name || user.user_metadata?.name || user.email?.split('@')[0] || 'User';\r\n                    console.log(`[AUTH-DEBUG] Creating new user in DB for Google user: ${user.email}`);\r\n                    try {\r\n                        await c.env.DB.prepare(`\r\n                            INSERT INTO users (id, email, name, role, is_active, approval_status, created_at, updated_at)\r\n                            VALUES (?, ?, ?, 'inspector', true, 'pending', NOW(), NOW())\r\n                        `).bind(user.id, user.email, userName).run();\r\n                        console.log(`[AUTH-DEBUG] Created new user: ${user.email} with pending approval`);\r\n                    } catch (insertError) {\r\n                        console.error('[AUTH-DEBUG] Error creating user:', insertError);\r\n                    }\r\n                } else {\r\n                    // Enrich user object with DB role\r\n                    (user as any).role = (existingDbUser as any).role;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        if (!user) {\r\n            const cookies = c.req.header('Cookie') || '';\r\n            const sessionMatch = cookies.match(/mocha-session-token=([^;]+)/);\r\n            console.log(`[AUTH-DEBUG] Cookie session: ${sessionMatch ? 'found token' : 'no token'}`);\r\n            if (sessionMatch) {\r\n                const sessionToken = sessionMatch[1];\r\n                if (sessionToken && sessionToken.startsWith('dev-session-')) {\r\n                    const userId = sessionToken.replace('dev-session-', '');\r\n                    // Buscar usuário no DB\r\n                    if (c.env?.DB) {\r\n                        const dbUser = await c.env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(userId).first();\r\n                        console.log(`[AUTH-DEBUG] Cookie user lookup: ${dbUser ? 'found ' + (dbUser as any).email : 'not found'}`);\r\n                        if (dbUser) {\r\n                            user = {\r\n                                id: (dbUser as any).id,\r\n                                email: (dbUser as any).email,\r\n                                role: (dbUser as any).role,\r\n                                user_metadata: { name: (dbUser as any).name }\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        console.log(`[AUTH-DEBUG] Final user: ${user ? (user as any).email + ' (role: ' + (user as any).role + ')' : 'NONE'}`);\r\n        c.set('user', user)\r\n    } else {\r\n        console.log(`[AUTH-DEBUG] User already in context: ${(c.get('user') as any)?.email}`);\r\n    }\r\n\r\n    await next()\r\n})\r\n\r\n// Criar sub-app para as rotas da API\r\nconst apiRoutes = new Hono();\r\n\r\n// Middleware para propagar contexto de autenticação do app pai para o sub-app\r\napiRoutes.use('*', async (c, next) => {\r\n    // O contexto já foi preenchido pelo middleware do app principal\r\n    // Mas precisamos garantir que o user está acessível\r\n    console.log(`[SUBROUTES] Path: ${c.req.path}, User in context: ${c.get('user') ? (c.get('user') as any).email : 'NONE'}`);\r\n    await next();\r\n});\r\n\r\n// Rotas básicas no sub-app\r\napiRoutes.get('/', (c) => {\r\n    return c.text('COMPIA API running on Supabase Edge Functions with Postgres Wrapper! Status: Online v2')\r\n})\r\n\r\napiRoutes.get('/health', async (c) => {\r\n    const dbUrl = Deno.env.get('SUPABASE_DB_URL');\r\n    let dbStatus = 'unknown';\r\n    let dbError = null;\r\n    let orgAddresses = null;\r\n\r\n    if (c.env?.DB) {\r\n        try {\r\n            await c.env.DB.prepare('SELECT 1').bind().first();\r\n            dbStatus = 'connected';\r\n\r\n            // Debug: Check organization addresses\r\n            const orgsResult = await c.env.DB.prepare(`\r\n                SELECT id, name, nome_fantasia, address, contact_email \r\n                FROM organizations \r\n                LIMIT 5\r\n            `).all();\r\n            orgAddresses = orgsResult.results || [];\r\n        } catch (e) {\r\n            dbStatus = 'error';\r\n            dbError = e instanceof Error ? e.message : String(e);\r\n        }\r\n    } else {\r\n        dbStatus = 'not_configured';\r\n        dbError = !dbUrl ? 'Missing SUPABASE_DB_URL env var' : 'DB wrapper failed to initialize';\r\n    }\r\n\r\n    return c.json({\r\n        status: dbStatus === 'connected' ? 'online' : 'degraded',\r\n        database: dbStatus,\r\n        db_error: dbError,\r\n        env_vars: {\r\n            SUPABASE_DB_URL: dbUrl ? 'present' : 'missing',\r\n        },\r\n        debug_org_addresses: orgAddresses,\r\n        timestamp: new Date().toISOString()\r\n    }, dbStatus === 'connected' ? 200 : 503)\r\n})\r\n\r\n// Debug middleware for apiRoutes\r\napiRoutes.use('*', async (c, next) => {\r\n    console.log('[API_ROUTER] Method:', c.req.method, 'Path:', c.req.path);\r\n    await next();\r\n});\r\n\r\n// Registrar todas as rotas no sub-app (sem prefixos, pois serão montadas)\r\napiRoutes.route('/users', usersRoutes);\r\nconsole.log('Registering /organizations route');\r\napiRoutes.route('/organizations', organizationsRoutes);\r\napiRoutes.route('/test-orgs', testOrgsRoutes);\r\napiRoutes.route('/inspections', inspectionRoutes);\r\napiRoutes.route('/checklist', checklistRoutes);\r\napiRoutes.route('/auth', authRoutes);\r\napiRoutes.route('/ai-assistants', aiAssistantsRoutes);\r\napiRoutes.route('/checklist', checklistFoldersRoutes);\r\napiRoutes.route('/dashboard', dashboardRoutes);\r\napiRoutes.route('/share', shareRoutes);\r\napiRoutes.route('/notifications', notificationsRoutes);\r\napiRoutes.route('/admin', adminApprovalRoutes);\r\napiRoutes.route('/user-assignments', userAssignmentRoutes);\r\napiRoutes.route('/multi-tenant', multiTenantRoutes);\r\napiRoutes.route('/ai-usage', aiUsageRoutes);\r\napiRoutes.route('/system-admin', systemAdminRoutes);\r\napiRoutes.route('/role-permissions', rolePermissionsRoutes);\r\napiRoutes.route('/cep', cepRoutes);\r\napiRoutes.route('/cnpj', cnpjRoutes);\r\n// Mount routes\r\napiRoutes.route('/inspection-items', inspectionItemRoutes);\r\napiRoutes.route('/media', mediaRoutes);\r\napiRoutes.route('/gamification', gamificationRoutes);\r\napiRoutes.route('/action-plans', actionPlansRoutes);\r\napiRoutes.route('/action-items', actionPlansRoutes); // Alias\r\napiRoutes.route('/autosuggest', autosuggestRoutes);\r\napiRoutes.route('/ai-assistant', aiAssistantRoutes);\r\n\r\napiRoutes.route('/kanban', kanbanRoutes);\r\napiRoutes.route('/audit', auditRoutes);\r\napiRoutes.route('/audit', auditRoutes);\r\napiRoutes.route('/calendar', calendarRoutes);\r\napiRoutes.route('/calendar-settings', calendarSettingsRoutes);\r\napiRoutes.route('/calendar-upload', calendarUploadRoutes);\r\napiRoutes.route('/integrations', integrationsRoutes);\r\napiRoutes.route('/crm', crmRoutes);\r\napiRoutes.route('/financial', financialRoutes);\r\napiRoutes.route('/billing', financialRoutes); // Alias for easier frontend access\r\napiRoutes.route('/webhooks/asaas', asaasWebhookRoutes); // Asaas payment gateway webhooks\r\n\r\n\r\n// TEMPORARY DEBUG ROUTE\r\napiRoutes.get('/debug-usage/:orgId', async (c) => {\r\n    const orgId = c.req.param('orgId');\r\n    try {\r\n        // @ts-ignore\r\n        const result = await c.env.DB.prepare('SELECT id, name, ai_usage_count FROM organizations WHERE id = ?').bind(orgId).first();\r\n        return c.json(result || { error: 'Not found' });\r\n    } catch (e: any) {\r\n        return c.json({ error: e.message }, 500);\r\n    }\r\n});\r\n\r\n// App principal monta o sub-app em dois lugares:\r\n// 1. Na raiz '/' (para chamadas diretas ou sem prefixo)\r\n// 2. Em '/api' (para chamadas vindo do Vercel que faz rewrite mantendo o path)\r\napp.route('/', apiRoutes);\r\napp.route('/api', apiRoutes);\r\n\r\n// CRITICAL FIX: Explicitly mount organizations route to ensure visibility\r\n// This bypasses any nested routing issues in apiRoutes\r\nconsole.log('Explicitly mounting /organizations on root app');\r\napp.route('/organizations', organizationsRoutes);\r\napp.route('/orgs', organizationsRoutes); // ALIAS for testing\r\napp.route('/api/organizations', organizationsRoutes);\r\n\r\nDeno.serve(app.fetch)\r\n\r\n"},{"name":"inspection-item-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { incrementAiUsage } from \"./ai-usage-tracker.ts\";\r\nimport {\r\n    getPreAnalysisPrompt,\r\n    getActionPlanPrompt,\r\n    SYSTEM_PROMPT_FIELD_RESPONSE\r\n} from \"./ai-prompts.ts\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n    MOCHA_USERS_SERVICE_API_URL: string;\r\n    MOCHA_USERS_SERVICE_API_KEY: string;\r\n    OPENAI_API_KEY: string;\r\n    GOOGLE_CLIENT_ID: string;\r\n    GEMINI_API_KEY: string;\r\n};\r\n\r\nconst inspectionItemRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Robust helper for AI Usage Increment\r\n// incrementAiUsage moved to ai-usage-tracker.ts\r\n\r\n\r\n// Get actions for specific inspection item\r\n// Path: /api/inspection-items/:itemId/actions\r\ninspectionItemRoutes.get(\"/:itemId/actions\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.created_by, i.organization_id\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n    `).bind(itemId).first() as any;\r\n\r\n        if (!item) {\r\n            return c.json({ error: \"Item de inspeção não encontrado\", actions: [] }, 200);\r\n        }\r\n\r\n        const actions = await env.DB.prepare(`\r\n      SELECT * FROM action_items \r\n      WHERE inspection_item_id = ?\r\n      ORDER BY created_at DESC\r\n    `).bind(itemId).all();\r\n\r\n        return c.json({\r\n            actions: actions.results || []\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Error fetching item actions:', error);\r\n        return c.json({ error: \"Erro ao buscar ações\", actions: [] }, 200);\r\n    }\r\n});\r\n\r\n// Pre-analysis with AI - POST\r\ninspectionItemRoutes.post(\"/:itemId/pre-analysis\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n    // Gemini API Key - Security Best Practice\r\n    const GEMINI_API_KEY = c.req.header('x-gemini-key') || c.env.GEMINI_API_KEY;\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const { field_name, response_value, user_prompt, inspection_id } = body;\r\n        let { media_data } = body;\r\n\r\n        // Increment AI Usage MOVED to after response to capture token count\r\n        const userId = user.id || (user as any).sub;\r\n\r\n\r\n        // Fetch Item\r\n        let item = await env.DB.prepare(`\r\n            SELECT ii.*, i.location, i.company_name, i.title as inspection_title\r\n            FROM inspection_items ii\r\n            JOIN inspections i ON ii.inspection_id = i.id\r\n            WHERE ii.id = ?\r\n        `).bind(itemId).first() as any;\r\n\r\n        if (!item && inspection_id && field_name) {\r\n            item = await env.DB.prepare(`\r\n                SELECT ii.*, i.location, i.company_name, i.title as inspection_title\r\n                FROM inspection_items ii\r\n                JOIN inspections i ON ii.inspection_id = i.id\r\n                WHERE ii.inspection_id = ? AND ii.item_description = ?\r\n            `).bind(inspection_id, field_name).first() as any;\r\n        }\r\n\r\n        if (!item) {\r\n            return c.json({ success: true, analysis: \"Erro: Item de inspeção não encontrado.\" });\r\n        }\r\n\r\n        let mediaContext = '';\r\n        const geminiParts: any[] = [];\r\n        const mediaCounts = { image: 0, audio: 0, document: 0 };\r\n        let warningMsg = '';\r\n\r\n        if (media_data && media_data.length > 0) {\r\n            // LIMIT MAX FILES (5) to prevent timeout/OOM\r\n            if (media_data.length > 5) {\r\n                warningMsg = `(Analisando apenas as 5 primeiras mídias de ${media_data.length})`;\r\n                media_data = media_data.slice(0, 5);\r\n            }\r\n\r\n            console.log(`[PRE-ANALYSIS] Processing ${media_data.length} media items`);\r\n\r\n            const mediaPromises = media_data.map(async (media: any) => {\r\n                try {\r\n                    let mimeType = 'application/octet-stream';\r\n                    let category = 'other';\r\n\r\n                    if (media.media_type === 'image') {\r\n                        mimeType = media.mime_type || 'image/jpeg';\r\n                        category = 'image';\r\n                    } else if (media.media_type === 'audio') {\r\n                        mimeType = media.mime_type || 'audio/mp3';\r\n                        if (mimeType.includes('webm')) mimeType = 'audio/mp3'; // Gemini hint\r\n                        category = 'audio';\r\n                    } else if (media.file_name?.toLowerCase().endsWith('.pdf')) {\r\n                        mimeType = 'application/pdf';\r\n                        category = 'document';\r\n                    } else {\r\n                        return null; // Skip unsupported\r\n                    }\r\n\r\n                    // Get/Fetch Data\r\n                    let base64Data = media.file_data;\r\n                    if (!base64Data && media.file_url) {\r\n                        try {\r\n                            const controller = new AbortController();\r\n                            const timeoutId = setTimeout(() => controller.abort(), 3000); // 3s Timeout\r\n                            const fetchRes = await globalThis.fetch(media.file_url, { signal: controller.signal });\r\n                            clearTimeout(timeoutId);\r\n\r\n                            if (fetchRes.ok) {\r\n                                const arrBuf = await fetchRes.arrayBuffer();\r\n                                const bytes = new Uint8Array(arrBuf);\r\n\r\n                                // SIZE LIMIT: 2.5MB per file\r\n                                if (bytes.byteLength > 2.5 * 1024 * 1024) {\r\n                                    console.warn(`Skipping large file: ${media.file_name}`);\r\n                                    return null;\r\n                                }\r\n\r\n                                // Chunked conversion\r\n                                let binary = '';\r\n                                const CHUNK_SIZE = 8192;\r\n                                for (let i = 0; i < bytes.byteLength; i += CHUNK_SIZE) {\r\n                                    binary += String.fromCharCode(...bytes.subarray(i, i + CHUNK_SIZE));\r\n                                }\r\n                                base64Data = btoa(binary);\r\n\r\n                                const hMime = fetchRes.headers.get('content-type');\r\n                                if (hMime && !media.mime_type) mimeType = hMime;\r\n                            }\r\n                        } catch (err) { console.error('Fetch error:', err); return null; }\r\n                    } else if (base64Data?.includes(',')) {\r\n                        base64Data = base64Data.split(',')[1];\r\n                    }\r\n\r\n                    if (base64Data) {\r\n                        return { inlineData: { mimeType, data: base64Data }, category };\r\n                    }\r\n                    return null;\r\n                } catch (e) { return null; }\r\n            });\r\n\r\n            const results = await Promise.all(mediaPromises);\r\n            results.forEach(res => {\r\n                if (res) {\r\n                    geminiParts.push({ inlineData: res.inlineData });\r\n                    if (res.category === 'image') mediaCounts.image++;\r\n                    if (res.category === 'audio') mediaCounts.audio++;\r\n                    if (res.category === 'document') mediaCounts.document++;\r\n                }\r\n            });\r\n\r\n            mediaContext = `MÍDIAS: ${mediaCounts.image} Img, ${mediaCounts.audio} Áudios, ${mediaCounts.document} Docs. ${warningMsg}`;\r\n        } else {\r\n            mediaContext = \"Sem mídias.\";\r\n        }\r\n\r\n        const promptText = getPreAnalysisPrompt(\r\n            field_name,\r\n            response_value === false ? 'NÃO CONFORME' : 'CONFORME',\r\n            item.location,\r\n            mediaContext,\r\n            user_prompt\r\n        );\r\n\r\n        geminiParts.push({ text: promptText });\r\n\r\n        if (!GEMINI_API_KEY) throw new Error(\"API Key Gemini não configurada.\");\r\n\r\n        // Retry multiple models if one fails\r\n        // Retry multiple models and API versions (Updated for 2026 Availability)\r\n        const attempts = [\r\n            { model: 'gemini-2.5-flash', version: 'v1beta' },\r\n            { model: 'gemini-2.5-pro', version: 'v1beta' },\r\n            { model: 'gemini-2.0-flash', version: 'v1beta' },\r\n            { model: 'gemini-flash-latest', version: 'v1beta' },\r\n            { model: 'gemini-pro-latest', version: 'v1beta' }\r\n        ];\r\n\r\n        let geminiResponse: Response | null = null;\r\n        let modelUsed = '';\r\n        let fallbackTextOnly = false;\r\n        let lastErrorDetail = \"\";\r\n\r\n        for (const attempt of attempts) {\r\n            try {\r\n                const url = `https://generativelanguage.googleapis.com/${attempt.version}/models/${attempt.model}:generateContent?key=${GEMINI_API_KEY}`;\r\n                const resp = await globalThis.fetch(url, {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({\r\n                        contents: [{ parts: geminiParts }],\r\n                        generationConfig: { maxOutputTokens: 2500, temperature: 0.35 }\r\n                    })\r\n                });\r\n\r\n                if (resp.ok) {\r\n                    geminiResponse = resp;\r\n                    modelUsed = `${attempt.model} (${attempt.version})`;\r\n                    break;\r\n                } else {\r\n                    const status = resp.status;\r\n                    const errText = await resp.text();\r\n                    // Accumulate errors instead of overwriting\r\n                    lastErrorDetail += ` | [${attempt.model}:${attempt.version}] ${status}`;\r\n\r\n                    if (status === 404 || status === 503 || status === 400) continue;\r\n                    console.warn(`Model error: ${lastErrorDetail}`);\r\n                }\r\n            } catch (e: any) {\r\n                lastErrorDetail += ` | [${attempt.model}] Ex: ${e.message}`;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // Final Fallback: Text Only (if all multimodal failed)\r\n        if (!geminiResponse) {\r\n            console.warn(\"[PRE-ANALYSIS] Multimodal failed. Trying Text-Only Fallback.\");\r\n            fallbackTextOnly = true;\r\n            // Remove images/audio, keep only text\r\n            const textParts = geminiParts.filter(p => p.text);\r\n            textParts.push({ text: \"\\n[ALERTA: Analise apenas o contexto de texto acima. As mídias falharam no processamento devido a restrições técnicas da API.]\" });\r\n\r\n            try {\r\n                const resp = await globalThis.fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}`, {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({ contents: [{ parts: textParts }] })\r\n                });\r\n                if (resp.ok) {\r\n                    geminiResponse = resp;\r\n                } else {\r\n                    lastErrorDetail += ` | [Fallback Text] ${resp.status}: ${await resp.text()}`;\r\n                }\r\n            } catch (e: any) { lastErrorDetail += ` | [Fallback Exception] ${e.message}`; }\r\n        }\r\n\r\n        if (!geminiResponse) {\r\n            throw new Error(`Falha Geral na IA. Detalhes: ${lastErrorDetail.substring(0, 200)}`);\r\n        }\r\n        let cleanAnalysis = '';\r\n        // Use non-null assertion (!) because we threw error above if it was null\r\n        if (geminiResponse!.ok) {\r\n            const result = await geminiResponse!.json();\r\n            cleanAnalysis = result.candidates?.[0]?.content?.parts?.[0]?.text || \"Erro: Resposta vazia da IA.\";\r\n        } else {\r\n            const errBody = await geminiResponse!.text();\r\n            throw new Error(`Erro Gemini (${geminiResponse!.status}): ${errBody.substring(0, 100)}...`);\r\n        }\r\n\r\n        cleanAnalysis = cleanAnalysis.replace(/\\*\\*/g, '').replace(/#{1,6}\\s/g, '').trim();\r\n        if (warningMsg) cleanAnalysis += `\\n\\n${warningMsg}`;\r\n\r\n        // Update DB\r\n        const now = new Date().toISOString();\r\n        await env.DB.prepare(\"UPDATE inspection_items SET ai_pre_analysis = ?, updated_at = ? WHERE id = ?\").bind(cleanAnalysis, now, itemId).run();\r\n\r\n        // Extract Token Usage (Gemini)\r\n        const usageMetadata = (geminiResponse as any).usageMetadata || {};\r\n        const totalTokens = usageMetadata.totalTokenCount || 0;\r\n\r\n        // Log AI Usage with actual tokens\r\n        await incrementAiUsage(env.DB, userId, 'pre_analysis', modelUsed || 'gemini-1.5-flash', totalTokens);\r\n\r\n        return c.json({\r\n            success: true,\r\n            analysis: cleanAnalysis,\r\n            pre_analysis: cleanAnalysis,\r\n            media_stats: mediaCounts,\r\n            _trace: 'v4-robust-return200'\r\n        });\r\n\r\n    } catch (error: any) {\r\n        console.error('PRE-ANALYSIS ERROR:', error);\r\n        // RETURN 200 to show error in frontend\r\n        return c.json({\r\n            success: true,\r\n            analysis: `[Erro Técnico]: ${error.message || \"Erro desconhecido\"}.`,\r\n            pre_analysis: `[Erro Técnico]: ${error.message || \"Erro desconhecido\"}.`\r\n        });\r\n    }\r\n});\r\n\r\n// Delete pre-analysis\r\ninspectionItemRoutes.delete(\"/:itemId/pre-analysis\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const now = new Date().toISOString();\r\n        await env.DB.prepare(`\r\n      UPDATE inspection_items \r\n      SET ai_pre_analysis = NULL, updated_at = ?\r\n      WHERE id = ?\r\n    `).bind(now, itemId).run();\r\n\r\n        return c.json({\r\n            success: true,\r\n            message: \"Pré-análise removida com sucesso\"\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Error deleting pre-analysis:', error);\r\n        return c.json({ error: \"Erro ao remover pré-análise\" }, 500);\r\n    }\r\n});\r\n\r\n// Update pre-analysis (manual edit)\r\ninspectionItemRoutes.put(\"/:itemId/analysis\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const { analysis } = body;\r\n\r\n        const now = new Date().toISOString();\r\n        await env.DB.prepare(`\r\n      UPDATE inspection_items \r\n      SET ai_pre_analysis = ?, updated_at = ?\r\n      WHERE id = ?\r\n    `).bind(analysis, now, itemId).run();\r\n\r\n        return c.json({\r\n            success: true,\r\n            message: \"Análise atualizada com sucesso\",\r\n            analysis: analysis\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Error updating analysis:', error);\r\n        return c.json({ error: \"Erro ao atualizar análise\" }, 500);\r\n    }\r\n});\r\n\r\n// Create action for inspection item\r\ninspectionItemRoutes.post(\"/:itemId/create-action\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    if (!env.OPENAI_API_KEY) {\r\n        return c.json({ error: \"IA não disponível\" }, 503);\r\n    }\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const { field_name, field_type, response_value, comment, compliance_status, pre_analysis, media_data, inspection_id } = body;\r\n\r\n        // Increment AI Usage MOVED to after response\r\n        const userId = user.id || (user as any).sub;\r\n\r\n\r\n        // First, try to find by itemId (direct ID)\r\n        let item = await env.DB.prepare(`\r\n      SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n    `).bind(itemId).first() as any;\r\n\r\n        // Fallback 1: If not found and we have inspection_id + field_name, search by exact match\r\n        if (!item && inspection_id && field_name) {\r\n            item = await env.DB.prepare(`\r\n                SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id\r\n                FROM inspection_items ii\r\n                JOIN inspections i ON ii.inspection_id = i.id\r\n                WHERE ii.inspection_id = ? AND ii.item_description = ?\r\n            `).bind(inspection_id, field_name).first() as any;\r\n        }\r\n\r\n        // Fallback 2: Search with LIKE (partial match) for flexibility\r\n        if (!item && inspection_id && field_name) {\r\n            item = await env.DB.prepare(`\r\n                SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id\r\n                FROM inspection_items ii\r\n                JOIN inspections i ON ii.inspection_id = i.id\r\n                WHERE ii.inspection_id = ? AND LOWER(ii.item_description) LIKE LOWER(?)\r\n                LIMIT 1\r\n            `).bind(inspection_id, `%${field_name}%`).first() as any;\r\n        }\r\n\r\n        // Fallback 3: Try to match by field order if itemId looks like a template field id\r\n        if (!item && inspection_id && itemId > 100) {\r\n            // The itemId might be a template field ID, try to find by position\r\n            const items = await env.DB.prepare(`\r\n                SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id\r\n                FROM inspection_items ii\r\n                JOIN inspections i ON ii.inspection_id = i.id\r\n                WHERE ii.inspection_id = ?\r\n                ORDER BY ii.id\r\n            `).bind(inspection_id).all();\r\n\r\n            // Log for debugging\r\n            console.log(`[CREATE-ACTION] Searching for template field ${itemId} in inspection ${inspection_id}, found ${items.results?.length || 0} items`);\r\n\r\n            // If we have items, use the first one that matches field_name loosely\r\n            if (items.results && items.results.length > 0 && field_name) {\r\n                item = items.results.find((i: any) =>\r\n                    i.item_description?.toLowerCase().includes(field_name.toLowerCase().substring(0, 10))\r\n                ) || items.results[0];\r\n            }\r\n        }\r\n\r\n        if (!item) {\r\n            console.error('[CREATE-ACTION] Item not found:', { itemId, inspection_id, field_name });\r\n            return c.json({ error: \"Item de inspeção não encontrado\", details: { itemId, inspection_id, field_name } }, 404);\r\n        }\r\n\r\n        // Determinar se precisa de ação baseado na resposta\r\n        let needsAction = false;\r\n        let riskLevel = 'baixo';\r\n\r\n        // Forçar \"needsAction\" se a resposta for negativa\r\n        if (field_type === 'boolean' && response_value === false) {\r\n            needsAction = true;\r\n            riskLevel = 'alto';\r\n        } else if (field_type === 'rating' && response_value <= 2) {\r\n            needsAction = true;\r\n            riskLevel = response_value === 1 ? 'critico' : 'alto';\r\n        }\r\n\r\n        // Se já sabemos que precisa de ação (Não Conforme), incluímos isso explicitamente no prompt\r\n        const complianceStatus = needsAction ? 'NÃO CONFORME (Obrigatório gerar plano de ação)' : 'Em análise (Verificar necessidade)';\r\n\r\n        const prompt = getActionPlanPrompt(\r\n            item.company_name,\r\n            item.location,\r\n            item.inspection_title,\r\n            field_name,\r\n            response_value === false ? 'NÃO CONFORME' : response_value === true ? 'CONFORME' : response_value || 'Não informado',\r\n            comment || 'Nenhuma observação',\r\n            compliance_status === 'non_compliant' ? 'NÃO CONFORME' : compliance_status === 'compliant' ? 'CONFORME' : complianceStatus,\r\n            pre_analysis || 'Nenhuma observação prévia',\r\n            riskLevel\r\n        );\r\n\r\n        const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${env.OPENAI_API_KEY}`,\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                model: 'gpt-4o', // Upgrade to gpt-4o for better logic\r\n                messages: [\r\n                    { role: 'system', content: 'Você é um especialista sênior em segurança do trabalho. Seja rigoroso na análise de riscos.' },\r\n                    { role: 'user', content: prompt }\r\n                ],\r\n                max_tokens: 1000,\r\n                temperature: 0.2 // Lower component for more deterministic following of instructions\r\n            })\r\n        });\r\n\r\n        if (!openaiResponse.ok) {\r\n            throw new Error(`Erro na API: ${openaiResponse.status}`);\r\n        }\r\n\r\n        const responseText = await openaiResponse.text();\r\n        const openaiResult = JSON.parse(responseText);\r\n        const actionText = openaiResult.choices?.[0]?.message?.content || '';\r\n\r\n        let actionData;\r\n        try {\r\n            const jsonMatch = actionText.match(/\\{[\\s\\S]*\\}/);\r\n            actionData = jsonMatch ? JSON.parse(jsonMatch[0]) : { requires_action: false };\r\n        } catch {\r\n            actionData = { requires_action: false, error: \"Não foi possível processar resposta\" };\r\n        }\r\n\r\n        let actionItemId = null;\r\n        let deadline: Date | null = null;\r\n\r\n        if (actionData.requires_action) {\r\n            const now = new Date().toISOString();\r\n            deadline = new Date();\r\n            deadline.setDate(deadline.getDate() + (actionData.priority === 'critica' ? 7 : actionData.priority === 'alta' ? 14 : 30));\r\n\r\n            const insertResult = await env.DB.prepare(`\r\n        INSERT INTO action_items (\r\n          inspection_id, inspection_item_id, title,\r\n          what_description, why_reason, where_location, when_deadline, who_responsible,\r\n          how_method, how_much_cost, priority, status, is_ai_generated, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', true, ?, ?)\r\n        RETURNING id\r\n      `).bind(\r\n                item.inspection_id,\r\n                item.id, // Use the correct item.id from database lookup, not the URL parameter\r\n                field_name,\r\n                actionData.what || '',\r\n                actionData.why || '',\r\n                actionData.where || item.location,\r\n                deadline.toISOString().split('T')[0],\r\n                actionData.who || 'A definir',\r\n                actionData.how || '',\r\n                actionData.how_much || 'A orçar',\r\n                actionData.priority || 'media',\r\n                now,\r\n                now\r\n            ).first() as any;\r\n\r\n            actionItemId = insertResult?.id || null;\r\n        }\r\n\r\n        // Always return suggestion data for inline display, even if not saved\r\n        const finalAction = {\r\n            id: actionItemId || null,\r\n            title: field_name,\r\n            what_description: actionData.what || '',\r\n            why_description: actionData.why || '',\r\n            why_reason: actionData.why || '',\r\n            where_description: actionData.where || item.location,\r\n            where_location: actionData.where || item.location,\r\n            when_deadline: deadline?.toISOString().split('T')[0] || null,\r\n            who_responsible: actionData.who || 'A definir',\r\n            how_description: actionData.how || '',\r\n            how_method: actionData.how || '',\r\n            how_much_cost: actionData.how_much || 'A orçar',\r\n            priority: actionData.priority || 'media',\r\n            status: actionItemId ? 'pending' : 'suggested',\r\n            is_ai_generated: true,\r\n            requires_action: actionData.requires_action,\r\n            justification: actionData.justification || ''\r\n        };\r\n\r\n        const usageData = (openaiResult as any).usage || {};\r\n        const totalTokens = usageData.total_tokens || 0;\r\n\r\n        // Log AI Usage with actual tokens\r\n        const usageResult = await incrementAiUsage(env.DB, userId, 'action_plan', 'gpt-4o', totalTokens);\r\n\r\n        const debugUsage = usageResult.success ? { success: true, org_id: usageResult.debug_org_id } : { success: false, error: usageResult.error };\r\n        const usageIncremented = usageResult.success;\r\n\r\n        return c.json({\r\n            success: true,\r\n            action_item: actionData.requires_action ? finalAction : null,\r\n            analysis: actionText,\r\n            raw_response: actionText,\r\n            ai_usage_incremented: usageIncremented,\r\n            debug_usage: debugUsage\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Error creating action:', error);\r\n\r\n        const errorMessage = error instanceof Error ? error.message : \"Erro desconhecido\";\r\n        let userMessage = \"Erro ao criar ação com IA\";\r\n        let status = 500;\r\n\r\n        if (errorMessage.includes('401')) {\r\n            userMessage = \"Chave OpenAI Inválida ou Expirada (401)\";\r\n            status = 502; // Bad Gateway\r\n        } else if (errorMessage.includes('429')) {\r\n            userMessage = \"Limite de cota da OpenAI atingido (429)\";\r\n            status = 429;\r\n        } else if (errorMessage.includes('503')) {\r\n            userMessage = \"Serviço OpenAI Indisponível (503)\";\r\n            status = 503;\r\n        } else {\r\n            // Include raw error for debugging 500s\r\n            userMessage = `Erro interno: ${errorMessage}`;\r\n        }\r\n\r\n        return c.json({\r\n            error: userMessage,\r\n            details: errorMessage\r\n        }, status as any); // cast for Hono/TS\r\n    }\r\n});\r\n\r\n// Delete inspection item\r\ninspectionItemRoutes.delete(\"/:itemId\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    try {\r\n        // Basic permission check - ensure item exists\r\n        const item = await env.DB.prepare(`\r\n            SELECT ii.*, i.organization_id, i.created_by \r\n            FROM inspection_items ii\r\n            JOIN inspections i ON ii.inspection_id = i.id\r\n            WHERE ii.id = ?\r\n        `).bind(itemId).first() as any;\r\n\r\n        if (!item) {\r\n            return c.json({ error: \"Item n\\u00E3o encontrado\" }, 404);\r\n        }\r\n\r\n        // Verify if user has permission (same organization or sys admin)\r\n        // Assuming tenantAuthMiddleware handles basic tenant check via secureOrgId context if applicable\r\n        // But double checking logic:\r\n        // if (item.organization_id !== user.organization_id && user.role !== 'sys_admin') ...\r\n\r\n        await env.DB.prepare(\"DELETE FROM inspection_items WHERE id = ?\").bind(itemId).run();\r\n\r\n        return c.json({ success: true });\r\n    } catch (error) {\r\n        console.error('Error deleting item:', error);\r\n        return c.json({ error: \"Erro ao excluir item\" }, 500);\r\n    }\r\n});\r\n\r\n// Generate field response with AI for inspection items\r\ninspectionItemRoutes.post(\"/:itemId/generate-field-response\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n    if (!user) {\r\n        return c.json({ error: \"User not found\" }, 401);\r\n    }\r\n\r\n    if (!env.OPENAI_API_KEY) {\r\n        return c.json({ error: \"IA não disponível\" }, 503);\r\n    }\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const { field_name, field_type, current_response, media_data, field_options } = body;\r\n\r\n        // Increment AI Usage MOVED to after response\r\n        const userId = user.id || (user as any).sub;\r\n\r\n\r\n        // Get inspection item and context\r\n        const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.location, i.company_name, i.title as inspection_title\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n  `).bind(itemId).first() as any;\r\n\r\n        if (!item) {\r\n            return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n        }\r\n\r\n        // Parse field options\r\n        let availableOptions: string[] = [];\r\n        if (field_options) {\r\n            try {\r\n                if (typeof field_options === 'string' && field_options.startsWith('[')) {\r\n                    availableOptions = JSON.parse(field_options);\r\n                } else if (typeof field_options === 'string') {\r\n                    availableOptions = field_options.split('|').map(opt => opt.trim()).filter(opt => opt);\r\n                } else if (Array.isArray(field_options)) {\r\n                    availableOptions = field_options;\r\n                }\r\n            } catch (error) {\r\n                console.error('Error parsing field options:', error);\r\n            }\r\n        }\r\n\r\n        // CORRIGIDO: Preparar análise multimodal real das evidências  \r\n        let mediaAnalysisContent = '';\r\n        let mediaAnalyzed = 0;\r\n        let mediaAnalysisMessages = [];\r\n\r\n        if (media_data && media_data.length > 0) {\r\n            mediaAnalyzed = media_data.length;\r\n            const mediaTypes = media_data.reduce((acc: any, media: any) => {\r\n                acc[media.media_type] = (acc[media.media_type] || 0) + 1;\r\n                return acc;\r\n            }, {});\r\n\r\n            mediaAnalysisContent = `EVIDÊNCIAS MULTIMODAIS PARA ANÁLISE: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} áudio(s), ${mediaTypes.video || 0} vídeo(s), ${mediaTypes.pdf || mediaTypes.document || 0} documento(s) PDF.`;\r\n\r\n            // Preparar imagens para análise visual (máximo 3 para evitar timeout)\r\n            const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);\r\n            for (const img of imageMedia) {\r\n                if (img.file_url) {\r\n                    mediaAnalysisMessages.push({\r\n                        type: \"image_url\",\r\n                        image_url: {\r\n                            url: img.file_url,\r\n                            detail: \"high\" // Para análise detalhada mesmo com gpt-4o-mini\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Adicionar nomes dos arquivos PDF ao contexto\r\n            const pdfMedia = media_data.filter((m: any) => m.media_type === 'pdf' || m.media_type === 'document');\r\n            if (pdfMedia.length > 0) {\r\n                const pdfNames = pdfMedia.map((p: any) => p.file_name || 'Documento sem nome').join(', ');\r\n                mediaAnalysisContent += `\\nDOCUMENTOS PDF ANEXADOS: ${pdfNames}. A IA deve mencionar que está ciente destes documentos na resposta e usar seu conteúdo se o usuário fornecer contexto sobre eles.`;\r\n            }\r\n\r\n            // Adicionar descrição de áudios/vídeos se existirem\r\n            const audioCount = mediaTypes.audio || 0;\r\n            const videoCount = mediaTypes.video || 0;\r\n            if (audioCount > 0 || videoCount > 0) {\r\n                mediaAnalysisContent += ` Inclui ${audioCount} áudio(s) e ${videoCount} vídeo(s) que podem conter evidências sonoras importantes.IMPORTANTE: Peça para o usuário descrever o conteúdo dos áudios no prompt personalizado para análise completa.`;\r\n            }\r\n        } else {\r\n            mediaAnalysisContent = `EVIDÊNCIAS DISPONÍVEIS: Nenhuma mídia anexada.Resposta baseada no contexto da inspeção e conhecimento técnico.`;\r\n        }\r\n\r\n        // Create specialized prompt based on field type\r\n        let responseInstructions = '';\r\n        switch (field_type) {\r\n            case 'boolean':\r\n                responseInstructions = `\r\nRESPOSTA ESPERADA: true(Conforme) ou false(Não Conforme)\r\nCRITÉRIO: Avalie se o item está em conformidade com as normas de segurança baseado nas evidências visuais / sonoras.`;\r\n                break;\r\n            case 'select':\r\n            case 'radio':\r\n                if (availableOptions.length > 0) {\r\n                    responseInstructions = `\r\nRESPOSTA ESPERADA: Uma das opções disponíveis: ${availableOptions.join(', ')}\r\nCRITÉRIO: Escolha a opção que melhor descreve o que foi observado nas evidências.`;\r\n                } else {\r\n                    responseInstructions = `\r\nRESPOSTA ESPERADA: Uma descrição textual da condição observada nas evidências.`;\r\n                }\r\n                break;\r\n            case 'multiselect':\r\n                if (availableOptions.length > 0) {\r\n                    responseInstructions = `\r\nRESPOSTA ESPERADA: Array com uma ou mais opções: ${availableOptions.join(', ')}\r\nCRITÉRIO: Selecione todas as opções que se aplicam ao que foi observado.`;\r\n                }\r\n                break;\r\n            case 'rating':\r\n                responseInstructions = `\r\nRESPOSTA ESPERADA: Número de 1 a 5(1 = Inadequado, 5 = Excelente)\r\nCRITÉRIO: Avalie baseado no que foi observado nas evidências visuais / sonoras.`;\r\n                break;\r\n            case 'text':\r\n            case 'textarea':\r\n                responseInstructions = `\r\nRESPOSTA ESPERADA: Descrição textual detalhada\r\nCRITÉRIO: Descreva especificamente o que foi observado nas evidências de forma técnica.`;\r\n                break;\r\n            default:\r\n                responseInstructions = `\r\nRESPOSTA ESPERADA: Valor adequado baseado na análise das evidências disponíveis.`;\r\n        }\r\n\r\n        // Construir mensagens para OpenAI incluindo análise visual detalhada\r\n        const systemMessage = {\r\n            role: 'system',\r\n            content: SYSTEM_PROMPT_FIELD_RESPONSE\r\n        };\r\n\r\n        const userMessage = {\r\n            role: 'user',\r\n            content: [\r\n                {\r\n                    type: \"text\",\r\n                    text: `Analise as evidências multimodais e gere uma resposta técnica detalhada para este campo.\r\nCONEXO DA INSPEÇÃO:\r\n- Local: ${item.location}\r\n- Empresa: ${item.company_name}\r\n- Inspeção: ${item.inspection_title}\r\n\r\nITEM EM ANÁLISE:\r\n- Campo: ${field_name}\r\n- Categoria: ${item.category}\r\n- Descrição: ${item.item_description}\r\n- Observações existentes: ${item.observations || 'Nenhuma'}\r\n- Resposta atual: ${current_response !== null && current_response !== undefined ? current_response : 'Não respondido'}\r\n\r\n${mediaAnalysisContent}\r\n\r\n${responseInstructions}\r\n\r\nINSTRUÇÕES ESPECÍFICAS PARA ANÁLISE DETALHADA:\r\n1. ** ANÁLISE VISUAL(se houver imagens) **: Descreva especificamente o que vê nas imagens relacionado à segurança do trabalho:\r\n  - Condições dos equipamentos, estruturas, ambiente\r\n    - EPIs(Equipamentos de Proteção Individual) presentes ou ausentes\r\n      - Sinalizações de segurança, placas, avisos\r\n        - Condições de limpeza, organização, 5S\r\n          - Riscos visuais identificados(altura, energia, produtos químicos, etc.)\r\n            - Estado de conservação de materiais, ferramentas, instalações\r\n\r\n2. ** ANÁLISE SONORA(se houver áudios / vídeos) **:\r\n- Ruídos de máquinas, equipamentos(níveis, anormalidades)\r\n  - Comunicações verbais sobre segurança\r\n    - Sons que indicam riscos(vazamentos, falhas mecânicas)\r\n      - Para assistentes psicossociais: tom de voz, sinais de estresse, ansiedade\r\n\r\n3. ** CONFORMIDADE TÉCNICA **: Avalie conformidade com NRs aplicáveis\r\n4. ** EVIDÊNCIAS ESPECÍFICAS **: Cite detalhes visuais / sonoros concretos observados\r\n5. ** RECOMENDAÇÕES **: Base nas evidências analisadas\r\n\r\nResponda APENAS em formato JSON(máximo 400 caracteres no comentário):\r\n{\r\n  \"generated_response\": <valor_da_resposta>,\r\n    \"generated_comment\": \"Análise técnica detalhada baseada nas evidências visuais/sonoras observadas. Descreva especificamente o que foi visto/ouvido.\",\r\n      \"confidence\": \"alta|media|baixa\",\r\n        \"media_analyzed\": ${mediaAnalyzed},\r\n  \"visual_observations\": \"Descrição específica do que foi visto nas imagens - condições, EPIs, riscos, conformidade visual\",\r\n    \"technical_assessment\": \"Avaliação de conformidade técnica baseada nas evidências\"\r\n}\r\n\r\nSeja específico sobre as evidências analisadas e cite detalhes visuais / sonoros concretos.`\r\n                },\r\n                ...mediaAnalysisMessages\r\n            ]\r\n        };\r\n\r\n        const messages = [systemMessage, userMessage];\r\n\r\n        // CORRIGIDO: Call OpenAI API com análise multimodal\r\n        const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${env.OPENAI_API_KEY} `,\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                model: 'gpt-4o-mini', // Mudança solicitada para gpt-4o-mini\r\n                messages: messages,\r\n                max_tokens: 2000, // Aumentado para análise mais detalhada\r\n                temperature: 0.3 // Reduzido para mais consistência\r\n            })\r\n        });\r\n\r\n        if (!openaiResponse.ok) {\r\n            const errorText = await openaiResponse.text();\r\n            console.error('OpenAI API Error:', openaiResponse.status, errorText);\r\n            throw new Error(`Erro na API da OpenAI: ${openaiResponse.status} - ${errorText} `);\r\n        }\r\n\r\n        const openaiResult = await openaiResponse.json() as any;\r\n        const content = openaiResult.choices?.[0]?.message?.content;\r\n\r\n        if (!content) {\r\n            throw new Error('Resposta inválida da IA');\r\n        }\r\n\r\n        // Parse AI response\r\n        let aiResult;\r\n        try {\r\n            aiResult = JSON.parse(content);\r\n        } catch (parseError) {\r\n            // Try to extract JSON from the response\r\n            const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n            if (jsonMatch) {\r\n                aiResult = JSON.parse(jsonMatch[0]);\r\n            } else {\r\n                throw new Error('Falha ao parsear resposta da IA como JSON');\r\n            }\r\n        }\r\n\r\n        // Validate and clean response based on field type\r\n        let finalResponse = aiResult.generated_response;\r\n\r\n        if (field_type === 'boolean') {\r\n            if (typeof finalResponse === 'string') {\r\n                finalResponse = finalResponse.toLowerCase() === 'true' || finalResponse === '1';\r\n            } else if (typeof finalResponse !== 'boolean') {\r\n                finalResponse = null;\r\n            }\r\n        } else if (field_type === 'multiselect') {\r\n            if (!Array.isArray(finalResponse)) {\r\n                if (typeof finalResponse === 'string') {\r\n                    finalResponse = [finalResponse];\r\n                } else {\r\n                    finalResponse = [];\r\n                }\r\n            }\r\n            // Filter to only valid options if available\r\n            if (availableOptions.length > 0) {\r\n                finalResponse = finalResponse.filter((opt: string) => availableOptions.includes(opt));\r\n            }\r\n        } else if ((field_type === 'select' || field_type === 'radio') && availableOptions.length > 0) {\r\n            // Ensure response is one of the available options\r\n            if (!availableOptions.includes(finalResponse)) {\r\n                finalResponse = availableOptions[0]; // Default to first option\r\n            }\r\n        } else if (field_type === 'rating') {\r\n            const numResponse = parseInt(finalResponse);\r\n            if (isNaN(numResponse) || numResponse < 1 || numResponse > 5) {\r\n                finalResponse = 3; // Default to middle rating\r\n            } else {\r\n                finalResponse = numResponse;\r\n            }\r\n        }\r\n\r\n        // Validar: OpenAI Usage Extraction\r\n        const usageData = (openaiResult as any).usage || {};\r\n        const totalTokens = usageData.total_tokens || 0;\r\n\r\n        // Log AI Usage\r\n        const usageResult = await incrementAiUsage(env.DB, userId, 'field_response', 'gpt-4o-mini', totalTokens);\r\n        const usageIncremented = usageResult.success;\r\n\r\n        return c.json({\r\n            success: true,\r\n            generated_response: finalResponse,\r\n            generated_comment: aiResult.generated_comment || '',\r\n            confidence: aiResult.confidence || 'media',\r\n            media_analyzed: mediaAnalyzed,\r\n            item_id: itemId,\r\n            timestamp: new Date().toISOString(),\r\n            ai_usage_incremented: usageIncremented\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Error generating field response:', error);\r\n        return c.json({\r\n            error: \"Erro ao gerar resposta do campo\",\r\n            details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n        }, 500);\r\n    }\r\n});\r\n\r\n// Generate comprehensive action plan (5W2H) for inspection item\r\ninspectionItemRoutes.post(\"/:itemId/generate-action-plan\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n    if (!user) return c.json({ error: \"User not found\" }, 401);\r\n    if (!env.OPENAI_API_KEY) return c.json({ error: \"IA não disponível\" }, 503);\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const { field_name, response_value, media_data, user_prompt } = body;\r\n\r\n        const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.location, i.company_name, i.title as inspection_title\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n    `).bind(itemId).first() as any;\r\n\r\n        if (!item) return c.json({ error: \"Item não encontrado\" }, 404);\r\n\r\n        let mediaContext = '';\r\n        let mediaAnalysisMessages = [];\r\n\r\n        if (media_data && media_data.length > 0) {\r\n            mediaContext = `EVIDÊNCIAS MULTIMODAIS: ${media_data.length} arquivos analisados.`;\r\n\r\n            // Add PDF context\r\n            const pdfMedia = media_data.filter((m: any) => m.media_type === 'pdf' || m.media_type === 'document');\r\n            if (pdfMedia.length > 0) {\r\n                const pdfNames = pdfMedia.map((p: any) => p.file_name).join(', ');\r\n                mediaContext += ` DOCUMENTOS PDF: ${pdfNames}`;\r\n            }\r\n\r\n            // Process images for GPT-4o-mini\r\n            const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);\r\n            for (const img of imageMedia) {\r\n                if (img.file_url) {\r\n                    mediaAnalysisMessages.push({\r\n                        type: \"image_url\",\r\n                        image_url: { url: img.file_url, detail: \"high\" }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        const systemMessage = {\r\n            role: 'system',\r\n            content: 'Você é um especialista em segurança do trabalho. Gere um plano de ação 5W2H detalhado e prático em formato JSON.'\r\n        };\r\n\r\n        const userContent = `Gere um plano de ação 5W2H técnico para a não conformidade detectada.\r\n    \r\n    CONTEXTO:\r\n    - Item: ${item.item_description} (Local: ${item.location})\r\n    - Resposta Encontrada: ${response_value}\r\n- Prompt Usuário: ${user_prompt || 'Gere ação corretiva padrão'}\r\n    \r\n    ${mediaContext}\r\n    \r\n    Retorne JSON:\r\n{\r\n    \"requires_action\": true,\r\n        \"what\": \"O que fazer\",\r\n            \"why\": \"Por que (Norma/Risco)\",\r\n                \"where\": \"Local exato\",\r\n                    \"when\": \"Prazo\",\r\n                        \"who\": \"Responsável\",\r\n                            \"how\": \"Como fazer\",\r\n                                \"how_much\": \"Custo estimado\",\r\n                                    \"priority\": \"alta/media/baixa\"\r\n} `;\r\n\r\n        // Construct message array effectively\r\n        const messages = [\r\n            systemMessage,\r\n            {\r\n                role: 'user',\r\n                content: [\r\n                    { type: \"text\", text: userContent },\r\n                    ...mediaAnalysisMessages\r\n                ]\r\n            }\r\n        ];\r\n\r\n        const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${env.OPENAI_API_KEY} `,\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                model: 'gpt-4o-mini',\r\n                messages: messages,\r\n                max_tokens: 1500,\r\n                temperature: 0.3\r\n            })\r\n        });\r\n\r\n        if (!openaiResponse.ok) throw new Error('Erro na API OpenAI');\r\n\r\n        const resJson = await openaiResponse.json();\r\n        const content = resJson.choices?.[0]?.message?.content;\r\n        let actionPlan = JSON.parse(content.replace(/```json/g, '').replace(/```/g, '').trim());\r\n\r\n        // Log AI Usage\r\n        const usageData = (resJson as any).usage || {};\r\n        const totalTokens = usageData.total_tokens || 0;\r\n        await incrementAiUsage(env.DB, user.id, 'action_plan_5w2h', 'gpt-4o-mini', totalTokens);\r\n\r\n        // Validate and Insert into DB\r\n        if (actionPlan.requires_action) {\r\n            try {\r\n                const now = new Date().toISOString();\r\n\r\n                // Try to parse deadline or default to 7 days\r\n                let deadline = new Date();\r\n                deadline.setDate(deadline.getDate() + 7);\r\n                const deadlineStr = actionPlan.when || deadline.toISOString();\r\n\r\n                const insertResult = await env.DB.prepare(`\r\n                    INSERT INTO action_items (\r\n                        inspection_id, inspection_item_id, \r\n                        title, what_description, why_reason, where_location, \r\n                        who_responsible, when_deadline, how_method, how_much_cost,\r\n                        priority, status, is_ai_generated, created_by, organization_id,\r\n                        created_at, updated_at\r\n                    ) VALUES (\r\n                        ?, ?, \r\n                        ?, ?, ?, ?,\r\n                        ?, ?, ?, ?,\r\n                        ?, 'open', true, ?, ?,\r\n                        ?, ?\r\n                    )\r\n                `).bind(\r\n                    item.inspection_id, itemId,\r\n                    `Ação 5W2H: ${item.item_description?.substring(0, 30)}...`,\r\n                    actionPlan.what || '', actionPlan.why || '', actionPlan.where || item.location || '',\r\n                    actionPlan.who || 'Responsável', deadlineStr, actionPlan.how || '', actionPlan.how_much || '',\r\n                    actionPlan.priority?.toLowerCase() || 'medium',\r\n                    user.id, user.organization_id || null,\r\n                    now, now\r\n                ).run();\r\n\r\n                actionPlan.id = insertResult.meta.last_row_id;\r\n                actionPlan.persisted = true;\r\n            } catch (dbError) {\r\n                console.error(\"Error persisting action plan:\", dbError);\r\n                // Continue to return the plan even if save fails, but mark as not persisted\r\n                actionPlan.persisted = false;\r\n                actionPlan.dbError = String(dbError);\r\n            }\r\n        }\r\n\r\n        return c.json({ success: true, action: actionPlan });\r\n\r\n    } catch (e) {\r\n        console.error(e);\r\n        return c.json({ error: \"Falha ao gerar plano\", details: String(e) }, 500);\r\n    }\r\n});\r\n\r\nexport default inspectionItemRoutes;\r\n"},{"name":"inspection-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n// import database-init removido\r\nimport { TenantContext } from \"./tenant-auth-middleware.ts\";\r\nimport { logActivity } from \"./audit-logger.ts\";\r\nimport { addXP } from \"./gamification-routes.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n  OPENAI_API_KEY?: string;\r\n  [key: string]: any;\r\n};\r\n\r\nconst inspectionRoutes = new Hono<{ Bindings: Env; Variables: { user: any; tenantContext: TenantContext } }>();\r\n\r\n// Get all inspections for current user\r\n// Get all inspections with Pagination & Server-Side Filtering\r\ninspectionRoutes.get(\"/\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    // Parameters\r\n    const requestedOrgId = c.req.query(\"organization_id\");\r\n    const page = parseInt(c.req.query(\"page\") || \"1\");\r\n    const limit = parseInt(c.req.query(\"limit\") || \"20\"); // Default 20 per page\r\n    const search = c.req.query(\"search\") || \"\";\r\n    const status = c.req.query(\"status\") || \"all\";\r\n    const offset = (page - 1) * limit;\r\n\r\n    let baseQuery = `\r\n      SELECT i.*, u.name as created_by_name, o.name as organization_name\r\n      FROM inspections i\r\n      LEFT JOIN users u ON i.created_by = u.id\r\n      LEFT JOIN organizations o ON i.organization_id = o.id\r\n    `;\r\n\r\n\r\n    let countQuery = `SELECT COUNT(*) as total FROM inspections i`;\r\n\r\n    const params: any[] = [];\r\n    const whereConditions: string[] = [];\r\n\r\n    // --- 1. Security & RBAC Filtering ---\r\n\r\n    // Helper: Get all organization IDs accessible to the user\r\n    // This is needed for both checking specific org access AND for the default \"all\" view\r\n    let accessibleOrgIds: any[] = [];\r\n    if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {\r\n      // Sysadmin has all access, list is effectively \"all\" (we'll handle logic below)\r\n    } else {\r\n      // Fetch specifically assigned orgs\r\n      const userOrgs = await env.DB.prepare(\"SELECT organization_id FROM user_organizations WHERE user_id = ? AND is_active = true\").bind(user.id).all();\r\n      accessibleOrgIds = (userOrgs.results || []).map((r: any) => r.organization_id);\r\n\r\n      // Add primary and managed orgs if not already present\r\n      if (userProfile?.organization_id && !accessibleOrgIds.includes(userProfile.organization_id)) {\r\n        accessibleOrgIds.push(userProfile.organization_id);\r\n      }\r\n      if (userProfile?.managed_organization_id && !accessibleOrgIds.includes(userProfile.managed_organization_id)) {\r\n        accessibleOrgIds.push(userProfile.managed_organization_id);\r\n      }\r\n\r\n      // Add child orgs for Org Admins\r\n      if (userProfile?.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {\r\n        const childOrgs = await env.DB.prepare(\"SELECT id FROM organizations WHERE parent_organization_id = ?\").bind(userProfile.managed_organization_id).all();\r\n        const childIds = (childOrgs.results || []).map((r: any) => r.id);\r\n        childIds.forEach((id: any) => {\r\n          if (!accessibleOrgIds.includes(id)) accessibleOrgIds.push(id);\r\n        });\r\n      }\r\n    }\r\n\r\n    if (requestedOrgId && requestedOrgId !== '0') {\r\n      const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin';\r\n\r\n      // Check access: SysAdmin OR Org is in accessible list\r\n      const canAccessOrg = isSysAdmin || accessibleOrgIds.includes(Number(requestedOrgId)) || accessibleOrgIds.includes(String(requestedOrgId)); // Handle potential string/number mismatch\r\n\r\n      if (canAccessOrg) {\r\n        whereConditions.push(\"i.organization_id = ?\");\r\n        params.push(requestedOrgId);\r\n        // console.log(`[INSPECTIONS] Filtering by organization_id=${requestedOrgId}`);\r\n      } else {\r\n        console.warn(`[INSPECTIONS] User ${user.id} tried to access org ${requestedOrgId} without permission`);\r\n        // Fallback: Don't show inspections from this forbidden org (logic falls through to empty result effectively if we strictly controlled, \r\n        // but here we just ignore the filter and Apply Default Logic below? NO. We should probably return empty or error.\r\n        // Let's force filter to an impossible ID to return nothing safe.\r\n        whereConditions.push(\"i.organization_id = -1\");\r\n      }\r\n    } else {\r\n      // Default / Role-based visibility (No specific org selected, or \"All\" selected)\r\n\r\n      if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {\r\n        // sees everything (no WHERE condition needed for orgs)\r\n      } else {\r\n        // Regular Users & Org Admins:\r\n        // See inspections Created By Self OR Belonging to Accessible Orgs\r\n\r\n        if (accessibleOrgIds.length > 0) {\r\n          const placeholders = accessibleOrgIds.map(() => '?').join(',');\r\n          whereConditions.push(`(i.created_by = ? OR i.organization_id IN (${placeholders}))`);\r\n          params.push(user.id, ...accessibleOrgIds);\r\n        } else {\r\n          // No orgs? Just own inspections\r\n          whereConditions.push(`i.created_by = ?`);\r\n          params.push(user.id);\r\n        }\r\n      }\r\n    }\r\n\r\n    // --- 2. Search Filtering (Server-Side) ---\r\n    if (search) {\r\n      // Postgres ILIKE for case-insensitive search\r\n      whereConditions.push(`(\r\n        i.title ILIKE ? OR \r\n        i.location ILIKE ? OR \r\n        i.company_name ILIKE ? OR \r\n        i.inspector_name ILIKE ?\r\n      )`);\r\n      const searchParam = `%${search}%`;\r\n      params.push(searchParam, searchParam, searchParam, searchParam);\r\n    }\r\n\r\n    // --- 3. Status Filtering (Server-Side) ---\r\n    if (status && status !== 'all') {\r\n      whereConditions.push(\"i.status = ?\");\r\n      params.push(status);\r\n    }\r\n\r\n    // Combine conditions\r\n    if (whereConditions.length > 0) {\r\n      const whereClause = \" WHERE \" + whereConditions.join(\" AND \");\r\n      baseQuery += whereClause;\r\n      countQuery += whereClause;\r\n    }\r\n\r\n    // --- 4. Execute Count (for pagination metadata) ---\r\n    // Note: Bind params need to be duplicated for count query as it uses the same WHERE clause\r\n    const totalResult = await env.DB.prepare(countQuery).bind(...params).first() as any;\r\n    const total = totalResult?.total || 0;\r\n    const totalPages = Math.ceil(total / limit);\r\n\r\n    // --- 5. Execute Data Fetch (with Limit/Offset) ---\r\n    baseQuery += \" ORDER BY i.created_at DESC LIMIT ? OFFSET ?\";\r\n    params.push(limit, offset);\r\n\r\n    const inspections = await env.DB.prepare(baseQuery).bind(...params).all();\r\n\r\n    return c.json({\r\n      inspections: inspections.results || [],\r\n      pagination: {\r\n        total,\r\n        page,\r\n        limit,\r\n        totalPages\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching inspections:', error);\r\n    return c.json({ error: \"Failed to fetch inspections\" }, 500);\r\n  }\r\n});\r\n\r\n// Get simple list of inspections for dropdowns\r\ninspectionRoutes.get(\"/simple-list\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const organizationId = c.req.query(\"organization_id\");\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    let query = `\r\n       SELECT i.id, i.title, i.created_at, i.status \r\n       FROM inspections i\r\n     `;\r\n\r\n    const params: any[] = [];\r\n    const whereConditions: string[] = [];\r\n\r\n    // Filter by Org if provided (and allowed)\r\n    if (organizationId) {\r\n      // TODO: Validate user has access to this org\r\n      whereConditions.push(\"i.organization_id = ?\");\r\n      params.push(organizationId);\r\n    } else {\r\n      // RBAC (Simplified for dropdown, usually showing user's org stuff)\r\n      if (userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin') {\r\n        // All\r\n      } else if (userProfile?.role === USER_ROLES.ORG_ADMIN) {\r\n        if (userProfile.managed_organization_id) {\r\n          whereConditions.push(`(i.organization_id = ? OR i.organization_id IN (SELECT id FROM organizations WHERE parent_organization_id = ?))`);\r\n          params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n        }\r\n      } else {\r\n        whereConditions.push(`(i.created_by = ? OR i.organization_id = ?)`);\r\n        params.push(user.id, userProfile?.organization_id);\r\n      }\r\n    }\r\n\r\n    if (whereConditions.length > 0) {\r\n      query += \" WHERE \" + whereConditions.join(\" AND \");\r\n    }\r\n\r\n    query += \" ORDER BY i.created_at DESC LIMIT 50\"; // Limit to recent 50\r\n\r\n    const inspections = await env.DB.prepare(query).bind(...params).all();\r\n    return c.json({ inspections: inspections.results || [] });\r\n\r\n  } catch (error) {\r\n    console.log(\"Error fetching inspection list:\", error);\r\n    return c.json({ inspections: [] });\r\n  }\r\n});\r\n\r\n// Get specific inspection with all related data\r\ninspectionRoutes.get(\"/:id\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get inspection with related data\r\n    const inspection = await env.DB.prepare(`\r\n      SELECT i.*, u.name as created_by_name, o.name as organization_name\r\n      FROM inspections i\r\n      LEFT JOIN users u ON i.created_by = u.id\r\n      LEFT JOIN organizations o ON i.organization_id = o.id\r\n      WHERE i.id = ?\r\n  `).bind(inspectionId).first() as any;\r\n\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspection not found\" }, 404);\r\n    }\r\n\r\n    // SERIALIZATION FIX: Execute queries sequentially to prevent connection contention on the single-connection wrapper\r\n    // Edge Functions with 'max: 1' connection pool can become unstable with Promise.all\r\n    console.log(`[INSPECTION-DEBUG] Fetching details for inspection ${inspectionId}`);\r\n\r\n    // Get inspection items\r\n    const itemsResult = await env.DB.prepare(`\r\n      SELECT * FROM inspection_items \r\n      WHERE inspection_id = ?\r\n      ORDER BY id ASC\r\n    `).bind(inspectionId).all();\r\n    console.log(`[INSPECTION-DEBUG] Items fetched: ${itemsResult?.results?.length || 0}`);\r\n\r\n    // Get action items\r\n    const actionItemsResult = await env.DB.prepare(`\r\n      SELECT * FROM action_items \r\n      WHERE inspection_id = ?\r\n      ORDER BY created_at DESC\r\n    `).bind(inspectionId).all();\r\n    console.log(`[INSPECTION-DEBUG] Action items fetched: ${actionItemsResult?.results?.length || 0}`);\r\n\r\n    // Get media for all items\r\n    // OPTIMIZATION: Select only necessary columns and LIMIT to prevent timeout on huge inspections\r\n    // CRITICAL FIX: Truncate file_url if it's base64 data (> 5KB) to prevent 40MB+ payload timeouts\r\n    const mediaResult = await env.DB.prepare(`\r\n        SELECT \r\n          id, \r\n          inspection_id, \r\n          inspection_item_id, \r\n          media_type, \r\n          CASE \r\n            WHEN LENGTH(file_url) > 5000 AND file_url LIKE 'data:%' \r\n            THEN CONCAT(LEFT(file_url, 100), '...[TRUNCATED_BASE64]...')\r\n            ELSE file_url \r\n          END as file_url,\r\n          CASE WHEN LENGTH(file_url) > 5000 THEN true ELSE false END as is_truncated,\r\n          file_name, \r\n          mime_type, \r\n          created_at, \r\n          latitude, \r\n          longitude\r\n        FROM inspection_media \r\n        WHERE inspection_id = ?\r\n        ORDER BY created_at DESC\r\n        LIMIT 200\r\n    `).bind(inspectionId).all();\r\n\r\n    // Log warning if limit reached (heuristic)\r\n    if (mediaResult?.results?.length >= 200) {\r\n      console.warn(`[PERFORMANCE] Inspection ${inspectionId} has >= 200 media items. Truncated.`);\r\n    }\r\n    console.log(`[INSPECTION-DEBUG] Media fetched: ${mediaResult?.results?.length || 0}`);\r\n\r\n\r\n    const items = itemsResult.results || [];\r\n    const actionItems = actionItemsResult.results || [];\r\n    const media = mediaResult.results || [];\r\n\r\n    return c.json({\r\n      inspection,\r\n      items,\r\n      action_items: actionItems,\r\n      media\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching inspection:', error);\r\n    return c.json({ error: \"Failed to fetch inspection\" }, 500);\r\n  }\r\n});\r\n\r\n// Create new inspection - BLINDADO\r\n// @security: organization_id vem do contexto seguro, NUNCA do body\r\ninspectionRoutes.post(\"/\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const tenantContext = c.get(\"tenantContext\");\r\n\r\n  // Verificação de autenticação\r\n  if (!user) {\r\n    return c.json({ error: \"Autenticação necessária\" }, 401);\r\n  }\r\n\r\n  // Verificação de permissão: Inspector ou superior pode criar inspeções\r\n  const allowedRoles = ['inspector', 'manager', 'org_admin', 'system_admin', 'sys_admin', 'admin'];\r\n  if (!allowedRoles.includes(user.role?.toLowerCase())) {\r\n    return c.json({\r\n      error: \"Permissão negada\",\r\n      message: \"Apenas Inspetores ou superiores podem criar inspeções\",\r\n      required_roles: allowedRoles\r\n    }, 403);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const {\r\n      title, description, location, inspector_name, inspector_email,\r\n      company_name, cep, address, scheduled_date,\r\n      logradouro, numero, complemento, bairro, cidade, uf, sectors,\r\n      status = 'pendente', priority = 'media', responsible_name, responsible_email,\r\n      template_id, ai_assistant_id, action_plan_type = '5w2h',\r\n      // Novos campos de auditoria (opcionais, enviados pelo cliente)\r\n      started_at_user_time,\r\n      location_start_lat, location_start_lng,\r\n      device_fingerprint, device_model, device_os,\r\n      is_offline_sync = false\r\n    } = body;\r\n\r\n    // CRÍTICO: organization_id validação segura\r\n    // O usuário pode especificar qualquer organização que ele tenha acesso (allowedOrganizationIds)\r\n    let secureOrgId = tenantContext?.organizationId || user.organization_id;\r\n\r\n    console.log(`[DEBUG-INSPECTION] User: ${user.id}, Role: ${user.role}, IsSystemAdmin: ${tenantContext?.isSystemAdmin}`);\r\n    console.log(`[DEBUG-INSPECTION] AllowedOrgs: ${JSON.stringify(tenantContext?.allowedOrganizationIds)}`);\r\n    console.log(`[DEBUG-INSPECTION] Requested Org: ${body.organization_id} (Type: ${typeof body.organization_id})`);\r\n\r\n    if (body.organization_id) {\r\n      // Validação: Se o usuário enviou um ID, ele deve estar na lista de IDs permitidos\r\n      // Cast para Number para garantir comparação correta\r\n      const reqOrgId = Number(body.organization_id);\r\n\r\n      // Se isSystemAdmin (user.role == sys_admin), permite qualquer ID\r\n      if (tenantContext?.isSystemAdmin || tenantContext?.allowedOrganizationIds?.includes(reqOrgId)) {\r\n        secureOrgId = reqOrgId;\r\n      } else {\r\n        const allowedIdsSt = tenantContext?.allowedOrganizationIds?.join(', ') || 'Nenhum';\r\n        const middlewareError = c.get('tenantAuthError' as any); // Capture error from middleware\r\n        console.warn(`[SECURITY] Bloqueada tentativa de criar inspeção em organização não permitida. User: ${user.id}, Target: ${body.organization_id}`);\r\n        return c.json({\r\n          error: \"Permissão negada\",\r\n          message: `Você não tem permissão para criar inspeções nesta organização. (Debug: MiddlewareErr=${middlewareError || 'None'}, Req=${reqOrgId}, Allowed=[${allowedIdsSt}])`,\r\n          debug: {\r\n            user_id: user.id,\r\n            requested_org_id: reqOrgId,\r\n            allowed_org_ids: tenantContext?.allowedOrganizationIds || [],\r\n            is_system_admin: tenantContext?.isSystemAdmin,\r\n            middleware_error: middlewareError,\r\n            middleware_log: (tenantContext as any)?._debugLog\r\n          }\r\n        }, 403);\r\n      }\r\n    }\r\n\r\n    if (!secureOrgId) {\r\n      return c.json({\r\n        error: \"Organização não definida\",\r\n        message: \"Usuário não está associado a nenhuma organização e nenhuma foi selecionada.\"\r\n      }, 400);\r\n    }\r\n\r\n\r\n    // Capturar IP e User-Agent para auditoria\r\n    const ipAddress = c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown';\r\n    const userAgent = c.req.header('user-agent') || 'unknown';\r\n\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO inspections(\r\n      title, description, location, inspector_name, inspector_email,\r\n      company_name, cep, address, scheduled_date,\r\n      logradouro, numero, complemento, bairro, cidade, uf, sectors,\r\n      status, priority, created_by, organization_id, responsible_name, responsible_email,\r\n      ai_assistant_id, action_plan_type,\r\n      started_at_user_time, started_at_server_time,\r\n      location_start_lat, location_start_lng,\r\n      device_fingerprint, device_model, device_os,\r\n      is_offline_sync, sync_timestamp,\r\n      created_at, updated_at\r\n    ) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    RETURNING id\r\n      `).bind(\r\n      title || null,\r\n      description || null,\r\n      location || null,\r\n      inspector_name || user.name || null,\r\n      inspector_email || user.email || null,\r\n      company_name || null,\r\n      cep || null,\r\n      address || null,\r\n      scheduled_date || null,\r\n      logradouro || null,\r\n      numero || null,\r\n      complemento || null,\r\n      bairro || null,\r\n      cidade || null,\r\n      uf || null,\r\n      sectors ? JSON.stringify(sectors) : null,\r\n      status,\r\n      priority,\r\n      user.id,\r\n      secureOrgId, // SEGURO: vem do contexto, não do body\r\n      responsible_name || null,\r\n      responsible_email || null,\r\n      ai_assistant_id || null,\r\n      action_plan_type,\r\n      started_at_user_time || null,\r\n      new Date().toISOString(), // started_at_server_time\r\n      location_start_lat || null,\r\n      location_start_lng || null,\r\n      device_fingerprint || null,\r\n      device_model || null,\r\n      device_os || null,\r\n      is_offline_sync ? 1 : 0,\r\n      is_offline_sync ? new Date().toISOString() : null,\r\n      new Date().toISOString(), // created_at\r\n      new Date().toISOString()  // updated_at\r\n    ).first();\r\n\r\n    console.log('[DEBUG] SQL Result:', JSON.stringify(result));\r\n\r\n    // Robust ID extraction for D1/SQLite/Postgres\r\n    let inspectionId = (result as any)?.id || (result as any)?.meta?.last_row_id || (result as any)?.lastInsertRowid;\r\n\r\n    console.log('[DEBUG] Extracted Inspection ID:', inspectionId);\r\n\r\n    // Fail Secure: Se não conseguirmos o ID diretamente, FALHAMOS.\r\n    // Não tentamos adivinhar com MAX(id) para evitar Race Condition.\r\n    if (!inspectionId) {\r\n      console.error('[CRITICAL] Failed to retrieve Inspection ID via RETURNING/meta. Aborting to prevent data corruption.');\r\n      throw new Error(\"Failed to retrieve new inspection ID. Transaction aborted.\");\r\n    }\r\n\r\n    // Registrar log de criação (LGPD)\r\n    try {\r\n      await env.DB.prepare(`\r\n        INSERT INTO inspection_logs(\r\n        inspection_id, user_id, action, ip_address, user_agent, created_at\r\n      ) VALUES(?, ?, 'CREATE', ?, ?, NOW())\r\n        `).bind(inspectionId, user.id, ipAddress, userAgent).run();\r\n    } catch (logError) {\r\n      console.error('[AUDIT] Erro ao registrar log de criação:', logError);\r\n      // Não bloquear a operação principal\r\n    }\r\n\r\n    // Registrar log global de auditoria\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: secureOrgId,\r\n      actionType: 'CREATE',\r\n      actionDescription: `Criação de inspeção: ${title}`,\r\n      targetType: 'INSPECTION',\r\n      targetId: inspectionId,\r\n      metadata: { title, status, priority, template_id },\r\n      req: c.req\r\n    });\r\n\r\n    // If a template is selected, create inspection items based on template fields\r\n    // OPTIMIZATION (Batch Insert): Fix N+1 Query Problem\r\n    if (template_id) {\r\n      const fields = await env.DB.prepare(`\r\n        SELECT * FROM checklist_fields \r\n        WHERE template_id = ?\r\n        ORDER BY order_index ASC\r\n      `).bind(template_id).all();\r\n\r\n      const fieldResults = fields.results || [];\r\n\r\n      if (fieldResults.length > 0) {\r\n        // Construct Batch Insert Query\r\n        let insertQuery = `\r\n          INSERT INTO inspection_items(\r\n            inspection_id, category, item_description, template_id,\r\n            field_responses, created_at, updated_at\r\n          ) VALUES \r\n        `;\r\n\r\n        const insertParams: any[] = [];\r\n        const placeholders: string[] = [];\r\n        // Helper date for batch\r\n        const nowIso = new Date().toISOString();\r\n\r\n        // Template category cache\r\n        const template = await env.DB.prepare(\"SELECT category FROM checklist_templates WHERE id = ?\").bind(template_id).first() as any;\r\n        const category = template?.category || 'Geral';\r\n\r\n        for (const field of fieldResults) {\r\n          const fieldData = field as any;\r\n\r\n          // Type validation (simplified for batch speed)\r\n          const fieldType = fieldData.field_type || 'text';\r\n\r\n          const fieldResponseData = {\r\n            field_id: fieldData.id,\r\n            field_name: fieldData.field_name,\r\n            field_type: fieldType,\r\n            is_required: fieldData.is_required,\r\n            options: fieldData.options,\r\n            response_value: null,\r\n            comment: null\r\n          };\r\n\r\n          placeholders.push('(?, ?, ?, ?, ?, ?, ?)');\r\n          insertParams.push(\r\n            inspectionId,\r\n            category,\r\n            fieldData.field_name,\r\n            template_id,\r\n            JSON.stringify(fieldResponseData),\r\n            nowIso,\r\n            nowIso\r\n          );\r\n        }\r\n\r\n        // Execute Batch Insert\r\n        if (placeholders.length > 0) {\r\n          insertQuery += placeholders.join(', ');\r\n          try {\r\n            // Using .all() because .run() in D1 wrapper might behave differently with multiple values\r\n            // But typically .run() is for writes.\r\n            await env.DB.prepare(insertQuery).bind(...insertParams).run();\r\n            console.log(`[PERFORMANCE] Batch inserted ${placeholders.length} items for inspection ${inspectionId}`);\r\n          } catch (batchError) {\r\n            console.error('[CRITICAL] Failed to batch insert items:', batchError);\r\n            // We don't rollback inspection creation here because we lack transactions, \r\n            // but we log it. User will see empty checklist.\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return c.json({\r\n      id: inspectionId,\r\n      message: \"Inspeção criada com sucesso\",\r\n      organization_id: secureOrgId // Confirmar qual org foi usada\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating inspection:', error);\r\n    // Não expor stack trace para o cliente\r\n    return c.json({\r\n      error: \"Erro ao criar inspeção\",\r\n      message: \"Erro interno: \" + (error instanceof Error ? error.message : String(error))\r\n    }, 500);\r\n  }\r\n});\r\n\r\n\r\n\r\n\r\n// Configure inspection (Template & AI)\r\ninspectionRoutes.put(\"/:id/configure\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"Autenticação necessária\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { template_id, ai_assistant_id } = body;\r\n\r\n    // 1. Update Inspection Record\r\n    await env.DB.prepare(`\r\n      UPDATE inspections \r\n      SET template_id = ?, ai_assistant_id = ?, updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(template_id, ai_assistant_id, inspectionId).run();\r\n\r\n    // 2. Generate Items if Template Selected (and no items exist)\r\n    if (template_id) {\r\n      // Check if items already exist\r\n      const existing = await env.DB.prepare(\"SELECT count(*) as count FROM inspection_items WHERE inspection_id = ?\").bind(inspectionId).first() as any;\r\n\r\n      if (existing.count === 0) {\r\n        console.log(`[CONFIGURE] Generating items for inspection ${inspectionId} from template ${template_id}`);\r\n        const template = await env.DB.prepare(\"SELECT * FROM checklist_templates WHERE id = ?\").bind(template_id).first() as any;\r\n        const fields = await env.DB.prepare(`\r\n               SELECT * FROM checklist_fields \r\n               WHERE template_id = ?\r\n               ORDER BY order_index ASC\r\n           `).bind(template_id).all();\r\n\r\n        // OPTIMIZATION: Batch Insert (fix N+1 query)\r\n        const fieldResults = fields.results || [];\r\n        if (fieldResults.length > 0) {\r\n          const category = template?.category || 'Geral';\r\n          const nowIso = new Date().toISOString();\r\n\r\n          let insertQuery = `\r\n            INSERT INTO inspection_items(\r\n              inspection_id, category, item_description, template_id,\r\n              field_responses, created_at, updated_at\r\n            ) VALUES \r\n          `;\r\n          const insertParams: any[] = [];\r\n          const placeholders: string[] = [];\r\n\r\n          for (const field of fieldResults) {\r\n            const fieldData = field as any;\r\n\r\n            // Fallback for types\r\n            const validTypes = [\r\n              'text', 'textarea', 'select', 'multiselect', 'radio', 'checkbox',\r\n              'number', 'date', 'time', 'boolean', 'rating', 'file'\r\n            ];\r\n            if (!validTypes.includes(fieldData.field_type)) {\r\n              fieldData.field_type = 'text';\r\n            }\r\n\r\n            const fieldResponseData = {\r\n              field_id: fieldData.id,\r\n              field_name: fieldData.field_name,\r\n              field_type: fieldData.field_type,\r\n              is_required: fieldData.is_required,\r\n              options: fieldData.options,\r\n              response_value: null,\r\n              comment: null\r\n            };\r\n\r\n            placeholders.push('(?, ?, ?, ?, ?, ?, ?)');\r\n            insertParams.push(\r\n              inspectionId,\r\n              category,\r\n              fieldData.field_name,\r\n              template_id,\r\n              JSON.stringify(fieldResponseData),\r\n              nowIso,\r\n              nowIso\r\n            );\r\n          }\r\n\r\n          insertQuery += placeholders.join(', ');\r\n          await env.DB.prepare(insertQuery).bind(...insertParams).run();\r\n          console.log(`[CONFIGURE] Batch inserted ${fieldResults.length} items for inspection ${inspectionId}`);\r\n        }\r\n      } else {\r\n        console.log(`[CONFIGURE] Skipping item generation: Items already exist for inspection ${inspectionId}`);\r\n      }\r\n    }\r\n\r\n    // Log Activity\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: user.organization_id, // Or from inspection lookup if needed, but context is safer\r\n      actionType: 'UPDATE',\r\n      actionDescription: `Configurou inspeção (Template: ${template_id}, AI: ${ai_assistant_id})`,\r\n      targetType: 'INSPECTION',\r\n      targetId: inspectionId,\r\n      metadata: { template_id, ai_assistant_id },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({ success: true, message: \"Configuração atualizada com sucesso\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error configuring inspection:', error);\r\n    return c.json({ error: \"Erro ao configurar inspeção\" }, 500);\r\n  }\r\n});\r\n\r\n// Update status (Workflow Transition with GPS & Audit)\r\ninspectionRoutes.put(\"/:id/status\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const tenantContext = c.get(\"tenantContext\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"Autenticação necessária\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { status, location_lat, location_lng } = body;\r\n\r\n    // Validate Status Enum\r\n    const validStatuses = ['scheduled', 'acknowledged', 'in_progress', 'completed', 'delivered'];\r\n    if (!validStatuses.includes(status)) {\r\n      return c.json({ error: \"Status inválido\" }, 400);\r\n    }\r\n\r\n    // Get current inspection\r\n    const inspection = await env.DB.prepare(\"SELECT * FROM inspections WHERE id = ?\").bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Verify Access\r\n    const hasAccess = tenantContext?.isSystemAdmin ||\r\n      (inspection.organization_id && tenantContext?.allowedOrganizationIds.includes(inspection.organization_id)) ||\r\n      inspection.created_by === user.id ||\r\n      inspection.inspector_email === user.email; // Allow assigned inspector update\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: \"Acesso negado\" }, 403);\r\n    }\r\n\r\n    // Update Query\r\n    let updateQuery = \"UPDATE inspections SET status = ?, updated_at = NOW()\";\r\n    const updateParams: any[] = [status];\r\n\r\n    // Status-specific updates\r\n    if (status === 'in_progress' && !inspection.started_at_server_time) {\r\n      updateQuery += \", started_at_server_time = NOW()\";\r\n      if (location_lat) { updateQuery += \", location_start_lat = ?\"; updateParams.push(location_lat); }\r\n      if (location_lng) { updateQuery += \", location_start_lng = ?\"; updateParams.push(location_lng); }\r\n    }\r\n\r\n    updateQuery += \" WHERE id = ?\";\r\n    updateParams.push(inspectionId);\r\n\r\n    // Execute Update\r\n    await env.DB.prepare(updateQuery).bind(...updateParams).run();\r\n\r\n    // Audit History\r\n    await env.DB.prepare(`\r\n        INSERT INTO inspection_status_history (\r\n            inspection_id, status_from, status_to, changed_by, \r\n            location_lat, location_lng, created_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n      inspectionId, inspection.status, status, user.id,\r\n      location_lat || null, location_lng || null\r\n    ).run();\r\n\r\n    // Log Activity\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: inspection.organization_id,\r\n      actionType: 'STATUS_CHANGE',\r\n      actionDescription: `Alterou status para ${status}`,\r\n      targetType: 'INSPECTION',\r\n      targetId: inspectionId,\r\n      metadata: { from: inspection.status, to: status, gps: { lat: location_lat, lng: location_lng } },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({ success: true, message: `Status atualizado para ${status}` });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating status:', error);\r\n    return c.json({ error: \"Erro ao atualizar status\" }, 500);\r\n  }\r\n});\r\n\r\ninspectionRoutes.post(\"/:id/deliver\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"Autenticação necessária\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { pdf_url } = body;\r\n\r\n    // Get current inspection\r\n    const inspection = await env.DB.prepare(\"SELECT * FROM inspections WHERE id = ?\").bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Verify Access (Creator, Inspector, or Admin)\r\n    const hasAccess = inspection.created_by === user.id ||\r\n      inspection.inspector_email === user.email ||\r\n      (c.get(\"tenantContext\")?.isSystemAdmin ?? false);\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: \"Acesso negado\" }, 403);\r\n    }\r\n\r\n    // Update Status to Delivered\r\n    const newStatus = 'delivered';\r\n    await env.DB.prepare(`\r\n        UPDATE inspections \r\n        SET status = ?, \r\n            pdf_report_url = ?, \r\n            delivered_at = NOW(), \r\n            updated_at = NOW() \r\n        WHERE id = ?\r\n    `).bind(newStatus, pdf_url || inspection.pdf_report_url, inspectionId).run();\r\n\r\n    // Audit History\r\n    await env.DB.prepare(`\r\n        INSERT INTO inspection_status_history (\r\n            inspection_id, status_from, status_to, changed_by, created_at\r\n        ) VALUES (?, ?, ?, ?, NOW())\r\n    `).bind(inspectionId, inspection.status, newStatus, user.id).run();\r\n\r\n    // Log Activity\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: inspection.organization_id,\r\n      actionType: 'DELIVERY',\r\n      actionDescription: `Entregou relatório de inspeção`,\r\n      targetType: 'INSPECTION',\r\n      targetId: inspectionId,\r\n      metadata: { pdf_url },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({ success: true, message: \"Inspeção entregue com sucesso\", new_status: 'delivered' });\r\n\r\n  } catch (error) {\r\n    console.error('Error delivering inspection:', error);\r\n    return c.json({ error: \"Erro ao entregar inspeção\" }, 500);\r\n  }\r\n});\r\n\r\n// Update inspection - BLINDADO\r\n// @security: Verifica propriedade e registra log de auditoria\r\ninspectionRoutes.put(\"/:id\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const tenantContext = c.get(\"tenantContext\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"Autenticação necessária\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // CRÍTICO: Verificar se a inspeção existe e se o usuário tem acesso\r\n    const inspection = await env.DB.prepare(`\r\nSELECT * FROM inspections WHERE id = ?\r\n  `).bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Verificar acesso baseado em tenant\r\n    const hasAccess = tenantContext?.isSystemAdmin ||\r\n      (inspection.organization_id && tenantContext?.allowedOrganizationIds.includes(inspection.organization_id)) ||\r\n      inspection.created_by === user.id ||\r\n      inspection.inspector_email === user.email; // Allow assigned inspector to update\r\n\r\n    if (!hasAccess) {\r\n      return c.json({\r\n        error: \"Acesso negado\",\r\n        message: \"Você não tem permissão para editar esta inspeção\"\r\n      }, 403);\r\n    }\r\n\r\n    const body = await c.req.json();\r\n\r\n    // CRÍTICO: Impedir modificação de organization_id via body\r\n    if (body.organization_id && body.organization_id !== inspection.organization_id) {\r\n      console.warn(`[SECURITY] Tentativa de alterar organization_id bloqueada.User: ${user.id}, Inspection: ${inspectionId} `);\r\n      return c.json({\r\n        error: \"Operação não permitida\",\r\n        message: \"Não é possível alterar a organização de uma inspeção\"\r\n      }, 403);\r\n    }\r\n\r\n    // Build dynamic update query\r\n    const updateFields = [];\r\n    const updateValues = [];\r\n    const changedFields: Record<string, { old: any; new: any }> = {};\r\n\r\n    const allowedFields = [\r\n      'title', 'description', 'location', 'inspector_name', 'inspector_email',\r\n      'company_name', 'cep', 'address', 'scheduled_date',\r\n      'logradouro', 'numero', 'complemento', 'bairro', 'cidade', 'uf', 'sectors',\r\n      'completed_date', 'status', 'priority', 'action_plan', 'action_plan_type',\r\n      'inspector_signature', 'responsible_signature', 'responsible_name', 'responsible_email',\r\n      // Campos de auditoria que podem ser atualizados\r\n      'location_end_lat', 'location_end_lng'\r\n    ];\r\n\r\n    for (const field of allowedFields) {\r\n      if (body[field] !== undefined && body[field] !== inspection[field]) {\r\n        updateFields.push(`${field} = ?`);\r\n        updateValues.push(body[field]);\r\n        changedFields[field] = { old: inspection[field], new: body[field] };\r\n      }\r\n    }\r\n\r\n    if (updateFields.length === 0) {\r\n      return c.json({ message: \"Nenhuma alteração detectada\" }, 400);\r\n    }\r\n\r\n    updateFields.push(\"updated_at = NOW()\");\r\n\r\n    await env.DB.prepare(`\r\n      UPDATE inspections \r\n      SET ${updateFields.join(\", \")}\r\n      WHERE id = ?\r\n  `).bind(...updateValues, inspectionId).run();\r\n\r\n    // Registrar log global de auditoria\r\n    await logActivity(env, {\r\n      userId: user.id,\r\n      orgId: inspection.organization_id,\r\n      actionType: 'UPDATE',\r\n      actionDescription: `Atualização de inspeção: ${inspection.title}`,\r\n      targetType: 'INSPECTION',\r\n      targetId: inspectionId,\r\n      metadata: { changed_fields: Object.keys(changedFields) },\r\n      req: c.req\r\n    });\r\n\r\n    // Registrar log de auditoria para cada campo alterado (LGPD)\r\n    const ipAddress = c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown';\r\n    const userAgent = c.req.header('user-agent') || 'unknown';\r\n\r\n    for (const [field, values] of Object.entries(changedFields)) {\r\n      try {\r\n        await env.DB.prepare(`\r\n          INSERT INTO inspection_logs(\r\n    inspection_id, user_id, action, field_changed, old_value, new_value,\r\n    ip_address, user_agent, created_at\r\n  ) VALUES(?, ?, 'UPDATE', ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n          inspectionId,\r\n          user.id,\r\n          field,\r\n          JSON.stringify(values.old),\r\n          JSON.stringify(values.new),\r\n          ipAddress,\r\n          userAgent\r\n        ).run();\r\n      } catch (logError) {\r\n        console.error('[AUDIT] Erro ao registrar log de atualização:', logError);\r\n      }\r\n    }\r\n\r\n    return c.json({\r\n      message: \"Inspeção atualizada com sucesso\",\r\n      fields_updated: Object.keys(changedFields)\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating inspection:', error);\r\n    return c.json({\r\n      error: \"Erro ao atualizar inspeção\",\r\n      message: \"Ocorreu um erro interno. Tente novamente.\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n\r\n// Finalize inspection\r\ninspectionRoutes.post(\"/:id/finalize\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { inspector_signature, responsible_signature, responsible_name, responsible_email, responsible_role } = body;\r\n\r\n    if (!inspector_signature || !responsible_signature) {\r\n      return c.json({ error: \"Ambas assinaturas são obrigatórias\" }, 400);\r\n    }\r\n\r\n    // CORRIGIDO: Garantir que as assinaturas sejam salvas antes da finalização\r\n    if (inspector_signature || responsible_signature) {\r\n      console.log(`[FINALIZE] Salvando assinaturas para inspeção ${inspectionId} `);\r\n      await env.DB.prepare(`\r\n        UPDATE inspections \r\n        SET inspector_signature = ?, responsible_signature = ?, updated_at = NOW()\r\n        WHERE id = ?\r\n  `).bind(\r\n        inspector_signature || null,\r\n        responsible_signature || null,\r\n        inspectionId\r\n      ).run();\r\n\r\n      // Verificar se foi salvo corretamente\r\n      const verification = await env.DB.prepare(`\r\n        SELECT inspector_signature, responsible_signature \r\n        FROM inspections WHERE id = ?\r\n  `).bind(inspectionId).first() as any;\r\n\r\n      console.log(`[FINALIZE] Verificação pós - salvamento: `, {\r\n        inspector_saved: verification?.inspector_signature ? 'Sim' : 'Não',\r\n        responsible_saved: verification?.responsible_signature ? 'Sim' : 'Não'\r\n      });\r\n    }\r\n\r\n    // Update inspection status and signatures with responsible info\r\n    await env.DB.prepare(`\r\n      UPDATE inspections \r\n      SET status = 'concluida',\r\n  completed_date = date('now'),\r\n  inspector_signature = ?,\r\n  responsible_signature = ?,\r\n  responsible_name = ?,\r\n  responsible_email = ?,\r\n  responsible_role = COALESCE(?, responsible_role),\r\n  updated_at = NOW()\r\n      WHERE id = ?\r\n  `).bind(inspector_signature, responsible_signature, responsible_name, responsible_email, responsible_role || null, inspectionId).run();\r\n\r\n    // Log FINALIZE action for audit trail\r\n    try {\r\n      await env.DB.prepare(`\r\n        INSERT INTO inspection_logs (inspection_id, user_id, action, field_changed, old_value, new_value, created_at)\r\n        VALUES (?, ?, 'FINALIZE', 'status', 'em_andamento', 'concluida', NOW())\r\n      `).bind(inspectionId, user.id).run();\r\n    } catch (logErr) {\r\n      console.error('[AUDIT] Failed to log FINALIZE:', logErr);\r\n    }\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: \"Inspection finalized successfully\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error finalizing inspection:', error);\r\n    return c.json({ error: \"Failed to finalize inspection\" }, 500);\r\n  }\r\n});\r\n\r\n// Reopen inspection (with audit trail)\r\ninspectionRoutes.post(\"/:id/reopen\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { justification } = body;\r\n\r\n    if (!justification || justification.trim() === '') {\r\n      return c.json({ error: \"Justificativa é obrigatória para reabrir a inspeção\" }, 400);\r\n    }\r\n\r\n    // Get current inspection state\r\n    const inspection = await env.DB.prepare(`\r\n      SELECT id, status, inspector_signature, responsible_signature, completed_date\r\n      FROM inspections WHERE id = ?\r\n    `).bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    if (inspection.status !== 'concluida' && inspection.status !== 'completed') {\r\n      return c.json({ error: \"Apenas inspeções finalizadas podem ser reabertas\" }, 400);\r\n    }\r\n\r\n    // Archive current state in history\r\n    await env.DB.prepare(`\r\n      INSERT INTO inspection_reopening_history (\r\n        inspection_id, reopened_by, justification, \r\n        previous_status, previous_inspector_signature, \r\n        previous_responsible_signature, previous_completed_date\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?)\r\n    `).bind(\r\n      inspectionId,\r\n      user.id,\r\n      justification.trim(),\r\n      inspection.status,\r\n      inspection.inspector_signature,\r\n      inspection.responsible_signature,\r\n      inspection.completed_date\r\n    ).run();\r\n\r\n    // Update inspection: clear signatures and set status to in_progress\r\n    await env.DB.prepare(`\r\n      UPDATE inspections \r\n      SET status = 'em_andamento',\r\n          inspector_signature = NULL,\r\n          responsible_signature = NULL,\r\n          completed_date = NULL,\r\n          updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(inspectionId).run();\r\n\r\n    // Log REOPEN action for audit trail\r\n    try {\r\n      await env.DB.prepare(`\r\n        INSERT INTO inspection_logs (inspection_id, user_id, action, field_changed, old_value, new_value, created_at)\r\n        VALUES (?, ?, 'REOPEN', 'status', 'concluida', 'em_andamento', NOW())\r\n      `).bind(inspectionId, user.id).run();\r\n    } catch (logErr) {\r\n      console.error('[AUDIT] Failed to log REOPEN:', logErr);\r\n    }\r\n\r\n    console.log(`[REOPEN] Inspeção ${inspectionId} reaberta por ${user.email}. Justificativa: ${justification.substring(0, 50)}...`);\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: \"Inspeção reaberta com sucesso\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error reopening inspection:', error);\r\n    return c.json({ error: \"Falha ao reabrir inspeção\" }, 500);\r\n  }\r\n});\r\n\r\n// PATCH endpoint for individual response auto-save\r\ninspectionRoutes.patch(\"/:id/responses/:itemId\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { answer, comment } = body;\r\n\r\n    // Get inspection to verify access\r\n    const inspection = await env.DB.prepare(\"SELECT * FROM inspections WHERE id = ?\").bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Block editing if inspection is finalized\r\n    if (inspection.status === 'concluida' || inspection.status === 'completed') {\r\n      return c.json({ error: \"Não é possível editar uma inspeção finalizada. Reabra a inspeção primeiro.\" }, 403);\r\n    }\r\n\r\n    // Get existing inspection item\r\n    const existingItem = await env.DB.prepare(\r\n      \"SELECT * FROM inspection_items WHERE id = ? AND inspection_id = ?\"\r\n    ).bind(itemId, inspectionId).first() as any;\r\n\r\n    if (!existingItem) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // Parse existing field responses\r\n    let fieldData;\r\n    try {\r\n      fieldData = JSON.parse(existingItem.field_responses || '{}');\r\n    } catch (error) {\r\n      return c.json({ error: \"Dados do campo corrompidos\" }, 400);\r\n    }\r\n\r\n    // Update response value and comment\r\n    fieldData.response_value = answer;\r\n    fieldData.comment = comment || null;\r\n\r\n    // Determine compliance status from answer\r\n    let complianceStatus = null;\r\n    if (answer !== null && answer !== undefined) {\r\n      if (typeof answer === 'boolean') {\r\n        complianceStatus = answer ? 'conforme' : 'nao_conforme';\r\n      } else if (typeof answer === 'string') {\r\n        const answerLower = answer.toLowerCase();\r\n        if (answerLower === 'conforme' || answerLower === 'sim') {\r\n          complianceStatus = 'conforme';\r\n        } else if (answerLower === 'não conforme' || answerLower === 'nao conforme' || answerLower === 'não') {\r\n          complianceStatus = 'nao_conforme';\r\n        } else if (answerLower === 'não aplicável' || answerLower === 'nao aplicavel' || answerLower === 'n/a') {\r\n          complianceStatus = 'nao_aplicavel';\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update database\r\n    await env.DB.prepare(`\r\n      UPDATE inspection_items \r\n      SET field_responses = ?, is_compliant = ?, updated_at = NOW()\r\n      WHERE id = ? AND inspection_id = ?\r\n  `).bind(JSON.stringify(fieldData), complianceStatus, itemId, inspectionId).run();\r\n\r\n    // Clean response (remove BOM if present)\r\n    const responseText = JSON.stringify({\r\n      success: true,\r\n      message: \"Resposta salva automaticamente\",\r\n      compliance_status: complianceStatus,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n\r\n    return c.json(JSON.parse(responseText));\r\n\r\n  } catch (error) {\r\n    console.error('Error saving individual response:', error);\r\n    return c.json({\r\n      error: \"Erro ao salvar resposta\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Save template responses for inspection\r\ninspectionRoutes.post(\"/:id/template-responses\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { responses } = body;\r\n\r\n    // Get inspection to verify access\r\n    const inspection = await env.DB.prepare(\"SELECT * FROM inspections WHERE id = ?\").bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    const updateStatements: Promise<any>[] = [];\r\n\r\n    // Enhanced saving logic for inspection items\r\n    for (const [itemId, responseData] of Object.entries(responses as Record<string, any>)) {\r\n      const itemIdNum = parseInt(itemId);\r\n\r\n      if (isNaN(itemIdNum)) continue;\r\n\r\n      // Enhanced response data processing\r\n      const updatedFieldData = responseData as any;\r\n      const fieldResponsesJson = JSON.stringify(updatedFieldData);\r\n\r\n      // Extract compliance_status with improved logic\r\n      let complianceStatus = null;\r\n      if (updatedFieldData.compliance_status !== undefined && updatedFieldData.compliance_status !== 'unanswered') {\r\n        complianceStatus = updatedFieldData.compliance_status;\r\n      } else if (updatedFieldData.response_value !== undefined) {\r\n        // Enhanced compliance deduction logic\r\n        if (typeof updatedFieldData.response_value === 'boolean') {\r\n          complianceStatus = updatedFieldData.response_value ? 'conforme' : 'nao_conforme';\r\n        } else if (typeof updatedFieldData.response_value === 'string') {\r\n          const valueStr = updatedFieldData.response_value.toLowerCase();\r\n          if (valueStr.includes('conforme') && !valueStr.includes('não')) {\r\n            complianceStatus = 'conforme';\r\n          } else if (valueStr.includes('não conforme') || valueStr.includes('inadequado')) {\r\n            complianceStatus = 'nao_conforme';\r\n          } else if (valueStr.includes('não aplicável') || valueStr.includes('n/a')) {\r\n            complianceStatus = 'nao_aplicavel';\r\n          }\r\n        } else if (typeof updatedFieldData.response_value === 'number') {\r\n          // For rating fields (1-5 scale)\r\n          if (updatedFieldData.response_value >= 4) {\r\n            complianceStatus = 'conforme';\r\n          } else if (updatedFieldData.response_value <= 2) {\r\n            complianceStatus = 'nao_conforme';\r\n          } else {\r\n            complianceStatus = 'parcialmente_conforme';\r\n          }\r\n        }\r\n      }\r\n\r\n      // Convert compliance status to boolean for legacy column\r\n      // Accept both EN (compliant, non_compliant) and PT-BR (conforme, nao_conforme) values\r\n      let isCompliantBool: boolean | null = null;\r\n      if (complianceStatus === 'conforme' || complianceStatus === 'compliant') {\r\n        isCompliantBool = true;\r\n      } else if (complianceStatus === 'nao_conforme' || complianceStatus === 'non_compliant') {\r\n        isCompliantBool = false;\r\n      }\r\n\r\n      // Update inspection item with both compliance_status (text) and is_compliant (boolean for legacy)\r\n      updateStatements.push(\r\n        env.DB.prepare(`\r\n          UPDATE inspection_items \r\n          SET field_responses = ?, is_compliant = ?, compliance_status = ?, updated_at = NOW()\r\n          WHERE id = ? AND inspection_id = ?\r\n  `).bind(fieldResponsesJson, isCompliantBool, complianceStatus, itemIdNum, inspectionId).run()\r\n      );\r\n    }\r\n\r\n    await Promise.all(updateStatements);\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: \"Respostas salvas com sucesso\",\r\n      items_updated: updateStatements.length\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error saving template responses:', error);\r\n    return c.json({\r\n      error: \"Erro ao salvar respostas\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Get template responses for inspection\r\ninspectionRoutes.get(\"/:id/template-responses\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get inspection items with field responses\r\n    const items = await env.DB.prepare(`\r\n      SELECT id, field_responses \r\n      FROM inspection_items \r\n      WHERE inspection_id = ? AND field_responses IS NOT NULL\r\n  `).bind(inspectionId).all();\r\n\r\n    const responses: Record<string, any> = {};\r\n\r\n    for (const item of (items.results || [])) {\r\n      const itemData = item as any;\r\n      if (itemData.field_responses) {\r\n        try {\r\n          responses[itemData.id] = JSON.parse(itemData.field_responses);\r\n        } catch (error) {\r\n          console.error('Error parsing field responses:', error);\r\n        }\r\n      }\r\n    }\r\n\r\n    return c.json({ responses });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching template responses:', error);\r\n    return c.json({ error: \"Erro ao buscar respostas\" }, 500);\r\n  }\r\n});\r\n\r\n// Get signatures for inspection\r\ninspectionRoutes.get(\"/:id/signatures\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const inspection = await env.DB.prepare(`\r\n      SELECT inspector_signature, responsible_signature, responsible_name\r\n      FROM inspections \r\n      WHERE id = ?\r\n  `).bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    return c.json({\r\n      inspector_signature: inspection.inspector_signature,\r\n      responsible_signature: inspection.responsible_signature,\r\n      responsible_name: inspection.responsible_name\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching signatures:', error);\r\n    return c.json({ error: \"Erro ao buscar assinaturas\" }, 500);\r\n  }\r\n});\r\n\r\n// Save signatures for inspection\r\ninspectionRoutes.post(\"/:id/signatures\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { inspector_signature, responsible_signature, responsible_name, responsible_email, responsible_role } = body;\r\n\r\n    console.log(`[SIGNATURES] Salvando assinaturas para inspeção ${inspectionId}: `, {\r\n      inspector_signature: inspector_signature ? 'Presente' : 'Ausente',\r\n      responsible_signature: responsible_signature ? 'Presente' : 'Ausente',\r\n      responsible_name,\r\n      responsible_email,\r\n      responsible_role\r\n    });\r\n\r\n    await env.DB.prepare(`\r\n      UPDATE inspections \r\n      SET inspector_signature = ?, responsible_signature = ?, responsible_name = COALESCE(?, responsible_name), responsible_email = COALESCE(?, responsible_email), responsible_role = COALESCE(?, responsible_role), updated_at = NOW()\r\n      WHERE id = ?\r\n  `).bind(\r\n      inspector_signature || null,\r\n      responsible_signature || null,\r\n      responsible_name || null,\r\n      responsible_email || null,\r\n      responsible_role || null,\r\n      inspectionId\r\n    ).run();\r\n\r\n    // CORRIGIDO: Verificar se as assinaturas foram salvas corretamente\r\n    const verification = await env.DB.prepare(`\r\n      SELECT inspector_signature, responsible_signature, responsible_name, responsible_email, responsible_role\r\n      FROM inspections WHERE id = ?\r\n  `).bind(inspectionId).first() as any;\r\n\r\n    console.log(`[SIGNATURES] Verificação pós - salvamento: `, {\r\n      inspector_saved: verification?.inspector_signature ? 'Sim' : 'Não',\r\n      responsible_saved: verification?.responsible_signature ? 'Sim' : 'Não',\r\n      responsible_name_saved: verification?.responsible_name || 'Não definido',\r\n      responsible_email_saved: verification?.responsible_email || 'Não definido',\r\n      responsible_role_saved: verification?.responsible_role || 'Não definido'\r\n    });\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: \"Assinaturas salvas com sucesso\",\r\n      saved_data: {\r\n        inspector_signature: verification?.inspector_signature ? 'Salva' : 'Não salva',\r\n        responsible_signature: verification?.responsible_signature ? 'Salva' : 'Não salva',\r\n        responsible_name: verification?.responsible_name || null\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error saving signatures:', error);\r\n    return c.json({\r\n      error: \"Erro ao salvar assinaturas\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Delete inspection - BLINDADO\r\n// @security: Apenas Manager+ pode deletar, com verificação de tenant e log de auditoria\r\ninspectionRoutes.delete(\"/:id\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const tenantContext = c.get(\"tenantContext\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  console.log('[DELETE-INSPECTION] Iniciando exclusão:', { inspectionId, userId: user?.id, userRole: user?.role });\r\n\r\n  if (!user) {\r\n    console.log('[DELETE-INSPECTION] Usuário não autenticado');\r\n    return c.json({ error: \"Autenticação necessária\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // CRÍTICO: Verificar se a inspeção existe\r\n    const inspection = await env.DB.prepare(`\r\nSELECT * FROM inspections WHERE id = ?\r\n  `).bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      console.log('[DELETE-INSPECTION] Inspeção não encontrada:', inspectionId);\r\n      return c.json({ error: 'Inspeção não encontrada' }, 404);\r\n    }\r\n\r\n    console.log('[DELETE-INSPECTION] Inspeção encontrada:', {\r\n      id: inspection.id,\r\n      created_by: inspection.created_by,\r\n      organization_id: inspection.organization_id\r\n    });\r\n\r\n    // Verificar permissões: Manager+, System Admin ou criador da inspeção\r\n    const allowedRoles = ['manager', 'org_admin', 'system_admin', 'sys_admin', 'admin', 'technician', 'inspector'];\r\n    const userRole = user.role?.toLowerCase() || '';\r\n    const hasRolePermission = allowedRoles.includes(userRole);\r\n    const isCreator = inspection.created_by === user.id;\r\n    const isSystemAdmin = userRole === 'sys_admin' || userRole === 'system_admin';\r\n\r\n    console.log('[DELETE-INSPECTION] Verificação de permissões:', {\r\n      userRole,\r\n      hasRolePermission,\r\n      isCreator,\r\n      isSystemAdmin,\r\n      tenantContext: tenantContext ? 'presente' : 'ausente'\r\n    });\r\n\r\n    // SIMPLIFICADO: Permitir se tem role válida OU é o criador OU é sys_admin\r\n    if (!hasRolePermission && !isCreator && !isSystemAdmin) {\r\n      console.log('[DELETE-INSPECTION] Permissão negada - role não permitida');\r\n      return c.json({\r\n        error: 'Permissão negada',\r\n        message: 'Apenas Managers, criadores da inspeção ou superiores podem excluir',\r\n        debug: { userRole, hasRolePermission, isCreator }\r\n      }, 403);\r\n    }\r\n\r\n    // Capturar dados para log de auditoria antes de deletar\r\n    const ipAddress = c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown';\r\n    const userAgent = c.req.header('user-agent') || 'unknown';\r\n\r\n    // Registrar log de deleção (LGPD) ANTES de deletar\r\n    try {\r\n      await env.DB.prepare(`\r\n        INSERT INTO inspection_logs(\r\n    inspection_id, user_id, action, old_value,\r\n    ip_address, user_agent, created_at\r\n  ) VALUES(?, ?, 'DELETE', ?, ?, ?, NOW())\r\n    `).bind(\r\n        inspectionId,\r\n        user.id,\r\n        JSON.stringify({\r\n          title: inspection.title,\r\n          organization_id: inspection.organization_id,\r\n          created_by: inspection.created_by,\r\n          status: inspection.status\r\n        }),\r\n        ipAddress,\r\n        userAgent\r\n      ).run();\r\n    } catch (logError) {\r\n      console.error('[AUDIT] Erro ao registrar log de deleção:', logError);\r\n    }\r\n\r\n    // Registrar log global de auditoria\r\n    try {\r\n      await env.DB.prepare(`\r\n          INSERT INTO activity_log (\r\n            user_id, organization_id, action_type, action_description, \r\n            target_type, target_id, metadata, ip_address, user_agent, created_at\r\n          ) VALUES (?, ?, 'DELETE', ?, 'INSPECTION', ?, ?, ?, ?, NOW())\r\n        `).bind(\r\n        user.id,\r\n        inspection.organization_id,\r\n        `Exclusão de inspeção: ${inspection.title}`,\r\n        inspectionId,\r\n        JSON.stringify({ title: inspection.title, status: inspection.status }),\r\n        ipAddress,\r\n        userAgent\r\n      ).run();\r\n    } catch (logErr) {\r\n      console.error('Failed to log to global activity_log:', logErr);\r\n    }\r\n\r\n    // Excluir itens relacionados na ordem correta (filhos -> pais)\r\n    // 1. Mídia (ligada a items e inspeção)\r\n    await env.DB.prepare('DELETE FROM inspection_media WHERE inspection_id = ?').bind(inspectionId).run();\r\n\r\n    // 2. Planos de Ação (ligados a items e inspeção)\r\n    await env.DB.prepare('DELETE FROM action_items WHERE inspection_id = ?').bind(inspectionId).run();\r\n\r\n    // 3. Logs (ligados a inspeção)\r\n    await env.DB.prepare('DELETE FROM inspection_logs WHERE inspection_id = ?').bind(inspectionId).run();\r\n\r\n    // 4. Itens da Inspeção (agora seguro deletar)\r\n    await env.DB.prepare('DELETE FROM inspection_items WHERE inspection_id = ?').bind(inspectionId).run();\r\n\r\n    // 5. A Inspeção\r\n    await env.DB.prepare('DELETE FROM inspections WHERE id = ?').bind(inspectionId).run();\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: 'Inspeção excluída com sucesso'\r\n    });\r\n  } catch (error: any) {\r\n    console.error('Erro ao excluir inspeção:', error);\r\n    return c.json({\r\n      error: 'Erro ao excluir inspeção',\r\n      message: error.message,\r\n      stack: error.stack,\r\n      details: JSON.stringify(error)\r\n    }, 500);\r\n  }\r\n});\r\n\r\n\r\n// Generate Full AI Analysis for Inspection (Action Plan)\r\ninspectionRoutes.post(\"/:id/ai-analysis\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  if (!env.OPENAI_API_KEY) {\r\n    return c.json({ error: \"IA não disponível\" }, 503);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { media_urls, inspection_context, non_compliant_items } = body;\r\n\r\n    // Verify access\r\n    const inspection = await env.DB.prepare(\"SELECT * FROM inspections WHERE id = ?\").bind(inspectionId).first() as any;\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Increment AI Usage\r\n    let usageIncremented = false;\r\n    try {\r\n      const userId = user.id || (user as any).sub;\r\n      const userProfile = await env.DB.prepare(\r\n        \"SELECT organization_id FROM users WHERE id = ?\"\r\n      ).bind(userId).first() as { organization_id?: number };\r\n\r\n      if (userProfile?.organization_id) {\r\n        await env.DB.prepare(\r\n          \"UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?\"\r\n        ).bind(userProfile.organization_id).run();\r\n\r\n        usageIncremented = true;\r\n\r\n        try {\r\n          await env.DB.prepare(`\r\n             INSERT INTO ai_usage_log (organization_id, user_id, feature_type, model_used, status, created_at)\r\n             VALUES (?, ?, 'analysis', ?, 'success', NOW())\r\n           `).bind(userProfile.organization_id, userId, 'gpt-4o-mini').run();\r\n        } catch (e) { /* ignore log error */ }\r\n      }\r\n    } catch (usageErr) {\r\n      console.error(\"Failed to increment AI usage:\", usageErr);\r\n    }\r\n\r\n    // Prepare OpenAI Prompt\r\n    const systemMessage = {\r\n      role: 'system',\r\n      content: 'Você é um especialista sênior em Segurança do Trabalho. Sua função é analisar listas de não conformidades e gerar um PLANO DE AÇÃO PRÁTICO e assertivo.'\r\n    };\r\n\r\n    const userMessage = {\r\n      role: 'user',\r\n      content: `CONTEXTO DA INSPEÇÃO:\r\n${inspection_context}\r\n\r\nITENS NÃO CONFORMES IDENTIFICADOS:\r\n${non_compliant_items.join('\\n')}\r\n\r\nEVIDÊNCIAS:\r\n${media_urls?.length || 0} arquivos de mídia anexados pelo inspetor.\r\n\r\nTAREFA:\r\nCom base APENAS nos itens não conformes listados, gere um PLANO DE AÇÃO consolidado.\r\nO plano deve ser prático, direto e focado em resolver os problemas de segurança.\r\n\r\nRetorne APENAS um JSON no seguinte formato:\r\n{\r\n  \"action_plan\": \"Texto completo do plano de ação formatado em Markdown (use tópicos, negrito para destaque)\",\r\n  \"priority\": \"alta|media|baixa\",\r\n  \"estimated_time\": \"Tempo estimado para resolução (ex: 5 dias)\"\r\n}`\r\n    };\r\n\r\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'gpt-4o-mini',\r\n        messages: [systemMessage, userMessage],\r\n        temperature: 0.4,\r\n        max_tokens: 2000\r\n      })\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Falha na comunicação com a OpenAI');\r\n    }\r\n\r\n    const aiData = await response.json();\r\n    const content = aiData.choices?.[0]?.message?.content;\r\n\r\n    let result;\r\n    try {\r\n      result = JSON.parse(content);\r\n    } catch (e) {\r\n      // Fallback for plain text\r\n      result = { action_plan: content, priority: 'media' };\r\n    }\r\n\r\n    // Save Action Plan to Inspection\r\n    await env.DB.prepare(\"UPDATE inspections SET action_plan = ?, updated_at = NOW() WHERE id = ?\")\r\n      .bind(result.action_plan, inspectionId).run();\r\n\r\n    // Award XP (15 XP for full analysis)\r\n    try {\r\n      await addXP(user.id, 15, env.DB);\r\n    } catch (xpError) {\r\n      console.error('Error awarding XP:', xpError);\r\n    }\r\n\r\n    return c.json({\r\n      success: true,\r\n      action_plan: result.action_plan,\r\n      priority: result.priority,\r\n      ai_usage_incremented: usageIncremented\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error in AI Analysis:', error);\r\n    return c.json({ error: \"Erro ao gerar análise de IA\" }, 500);\r\n  }\r\n});\r\n\r\n\r\n// Generate field response with AI for inspection items\r\ninspectionRoutes.post(\"/items/:itemId/generate-field-response\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  if (!env.OPENAI_API_KEY) {\r\n    return c.json({ error: \"IA não disponível\" }, 503);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { field_name, field_type, current_response, media_data, field_options } = body;\r\n\r\n    // Increment AI Usage\r\n    let usageIncremented = false;\r\n    try {\r\n      const userId = user.id || (user as any).sub;\r\n      const userProfile = await env.DB.prepare(\r\n        \"SELECT organization_id FROM users WHERE id = ?\"\r\n      ).bind(userId).first() as { organization_id?: number };\r\n\r\n      if (userProfile?.organization_id) {\r\n        await env.DB.prepare(\r\n          \"UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?\"\r\n        ).bind(userProfile.organization_id).run();\r\n\r\n        usageIncremented = true;\r\n\r\n        try {\r\n          await env.DB.prepare(`\r\n             INSERT INTO ai_usage_log (organization_id, user_id, feature_type, model_used, status, created_at)\r\n             VALUES (?, ?, 'analysis', ?, 'success', NOW())\r\n           `).bind(userProfile.organization_id, userId, 'gpt-4o-mini').run();\r\n        } catch (e) { /* ignore log error */ }\r\n      }\r\n    } catch (usageErr) {\r\n      console.error(\"Failed to increment AI usage:\", usageErr);\r\n    }\r\n\r\n    // Get inspection item and context\r\n    const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.location, i.company_name, i.title as inspection_title\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n  `).bind(itemId).first() as any;\r\n\r\n    if (!item) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // Parse field options\r\n    let availableOptions: string[] = [];\r\n    if (field_options) {\r\n      try {\r\n        if (typeof field_options === 'string' && field_options.startsWith('[')) {\r\n          availableOptions = JSON.parse(field_options);\r\n        } else if (typeof field_options === 'string') {\r\n          availableOptions = field_options.split('|').map(opt => opt.trim()).filter(opt => opt);\r\n        } else if (Array.isArray(field_options)) {\r\n          availableOptions = field_options;\r\n        }\r\n      } catch (error) {\r\n        console.error('Error parsing field options:', error);\r\n      }\r\n    }\r\n\r\n    // CORRIGIDO: Preparar análise multimodal real das evidências  \r\n    let mediaAnalysisContent = '';\r\n    let mediaAnalyzed = 0;\r\n    let mediaAnalysisMessages = [];\r\n\r\n    if (media_data && media_data.length > 0) {\r\n      mediaAnalyzed = media_data.length;\r\n      const mediaTypes = media_data.reduce((acc: any, media: any) => {\r\n        acc[media.media_type] = (acc[media.media_type] || 0) + 1;\r\n        return acc;\r\n      }, {});\r\n\r\n      mediaAnalysisContent = `EVIDÊNCIAS MULTIMODAIS PARA ANÁLISE: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} áudio(s), ${mediaTypes.video || 0} vídeo(s) foram analisados para gerar a resposta.`;\r\n\r\n      // Preparar imagens para análise visual (máximo 3 para evitar timeout)\r\n      const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);\r\n      for (const img of imageMedia) {\r\n        if (img.file_url) {\r\n          mediaAnalysisMessages.push({\r\n            type: \"image_url\",\r\n            image_url: {\r\n              url: img.file_url,\r\n              detail: \"high\" // Para análise detalhada mesmo com gpt-4o-mini\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      // Adicionar descrição de áudios/vídeos se existirem\r\n      const audioCount = mediaTypes.audio || 0;\r\n      const videoCount = mediaTypes.video || 0;\r\n      if (audioCount > 0 || videoCount > 0) {\r\n        mediaAnalysisContent += ` Inclui ${audioCount} áudio(s) e ${videoCount} vídeo(s) que podem conter evidências sonoras importantes.IMPORTANTE: Peça para o usuário descrever o conteúdo dos áudios no prompt personalizado para análise completa.`;\r\n      }\r\n    } else {\r\n      mediaAnalysisContent = `EVIDÊNCIAS DISPONÍVEIS: Nenhuma mídia anexada.Resposta baseada no contexto da inspeção e conhecimento técnico.`;\r\n    }\r\n\r\n    // Create specialized prompt based on field type\r\n    let responseInstructions = '';\r\n    switch (field_type) {\r\n      case 'boolean':\r\n        responseInstructions = `\r\nRESPOSTA ESPERADA: true(Conforme) ou false(Não Conforme)\r\nCRITÉRIO: Avalie se o item está em conformidade com as normas de segurança baseado nas evidências visuais / sonoras.`;\r\n        break;\r\n      case 'select':\r\n      case 'radio':\r\n        if (availableOptions.length > 0) {\r\n          responseInstructions = `\r\nRESPOSTA ESPERADA: Uma das opções disponíveis: ${availableOptions.join(', ')}\r\nCRITÉRIO: Escolha a opção que melhor descreve o que foi observado nas evidências.`;\r\n        } else {\r\n          responseInstructions = `\r\nRESPOSTA ESPERADA: Uma descrição textual da condição observada nas evidências.`;\r\n        }\r\n        break;\r\n      case 'multiselect':\r\n        if (availableOptions.length > 0) {\r\n          responseInstructions = `\r\nRESPOSTA ESPERADA: Array com uma ou mais opções: ${availableOptions.join(', ')}\r\nCRITÉRIO: Selecione todas as opções que se aplicam ao que foi observado.`;\r\n        }\r\n        break;\r\n      case 'rating':\r\n        responseInstructions = `\r\nRESPOSTA ESPERADA: Número de 1 a 5(1 = Inadequado, 5 = Excelente)\r\nCRITÉRIO: Avalie baseado no que foi observado nas evidências visuais / sonoras.`;\r\n        break;\r\n      case 'text':\r\n      case 'textarea':\r\n        responseInstructions = `\r\nRESPOSTA ESPERADA: Descrição textual detalhada\r\nCRITÉRIO: Descreva especificamente o que foi observado nas evidências de forma técnica.`;\r\n        break;\r\n      default:\r\n        responseInstructions = `\r\nRESPOSTA ESPERADA: Valor adequado baseado na análise das evidências disponíveis.`;\r\n    }\r\n\r\n    // Construir mensagens para OpenAI incluindo análise visual detalhada\r\n    const systemMessage = {\r\n      role: 'system',\r\n      content: 'Você é um especialista em segurança do trabalho especializado em análise multimodal avançada. Sua função é analisar imagens, áudios, vídeos e contexto para gerar respostas técnicas precisas e detalhadas baseadas em evidências reais. SEMPRE descreva especificamente o que observa nas imagens em relação à segurança do trabalho. Para áudios, identifique ruídos, comunicações verbais e, se for assistente psicossocial, analise tom de voz, sinais de estresse, ansiedade ou bem-estar emocional. Seja técnico, detalhado e específico sobre as evidências analisadas.'\r\n    };\r\n\r\n    const userMessage = {\r\n      role: 'user',\r\n      content: [\r\n        {\r\n          type: \"text\",\r\n          text: `Analise as evidências multimodais e gere uma resposta técnica detalhada para este campo.\r\n\r\nCONTEXTO DA INSPEÇÃO:\r\n- Local: ${item.location}\r\n- Empresa: ${item.company_name}\r\n- Inspeção: ${item.inspection_title}\r\n\r\nITEM EM ANÁLISE:\r\n- Campo: ${field_name}\r\n- Categoria: ${item.category}\r\n- Descrição: ${item.item_description}\r\n- Observações existentes: ${item.observations || 'Nenhuma'}\r\n- Resposta atual: ${current_response !== null && current_response !== undefined ? current_response : 'Não respondido'}\r\n\r\n${mediaAnalysisContent}\r\n\r\n${responseInstructions}\r\n\r\nINSTRUÇÕES ESPECÍFICAS PARA ANÁLISE DETALHADA:\r\n1. ** ANÁLISE VISUAL(se houver imagens) **: Descreva especificamente o que vê nas imagens relacionado à segurança do trabalho:\r\n  - Condições dos equipamentos, estruturas, ambiente\r\n    - EPIs(Equipamentos de Proteção Individual) presentes ou ausentes\r\n      - Sinalizações de segurança, placas, avisos\r\n        - Condições de limpeza, organização, 5S\r\n          - Riscos visuais identificados(altura, energia, produtos químicos, etc.)\r\n            - Estado de conservação de materiais, ferramentas, instalações\r\n\r\n2. ** ANÁLISE SONORA(se houver áudios / vídeos) **:\r\n- Ruídos de máquinas, equipamentos(níveis, anormalidades)\r\n  - Comunicações verbais sobre segurança\r\n    - Sons que indicam riscos(vazamentos, falhas mecânicas)\r\n      - Para assistentes psicossociais: tom de voz, sinais de estresse, ansiedade\r\n\r\n3. ** CONFORMIDADE TÉCNICA **: Avalie conformidade com NRs aplicáveis\r\n4. ** EVIDÊNCIAS ESPECÍFICAS **: Cite detalhes visuais / sonoros concretos observados\r\n5. ** RECOMENDAÇÕES **: Base nas evidências analisadas\r\n\r\nResponda APENAS em formato JSON(máximo 400 caracteres no comentário):\r\n{\r\n  \"generated_response\": <valor_da_resposta>,\r\n    \"generated_comment\": \"Análise técnica detalhada baseada nas evidências visuais/sonoras observadas. Descreva especificamente o que foi visto/ouvido.\",\r\n      \"confidence\": \"alta|media|baixa\",\r\n        \"media_analyzed\": ${mediaAnalyzed},\r\n  \"visual_observations\": \"Descrição específica do que foi visto nas imagens - condições, EPIs, riscos, conformidade visual\",\r\n    \"technical_assessment\": \"Avaliação de conformidade técnica baseada nas evidências\"\r\n}\r\n\r\nSeja específico sobre as evidências analisadas e cite detalhes visuais / sonoros concretos.`\r\n        },\r\n        ...mediaAnalysisMessages\r\n      ]\r\n    };\r\n\r\n    const messages = [systemMessage, userMessage];\r\n\r\n    // CORRIGIDO: Call OpenAI API com análise multimodal\r\n    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${env.OPENAI_API_KEY} `,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'gpt-4o-mini', // Mudança solicitada para gpt-4o-mini\r\n        messages: messages,\r\n        max_tokens: 2000, // Aumentado para análise mais detalhada\r\n        temperature: 0.3 // Reduzido para mais consistência\r\n      })\r\n    });\r\n\r\n    if (!openaiResponse.ok) {\r\n      const errorText = await openaiResponse.text();\r\n      console.error('OpenAI API Error:', openaiResponse.status, errorText);\r\n      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status} - ${errorText} `);\r\n    }\r\n\r\n    const openaiResult = await openaiResponse.json() as any;\r\n    const content = openaiResult.choices?.[0]?.message?.content;\r\n\r\n    if (!content) {\r\n      throw new Error('Resposta inválida da IA');\r\n    }\r\n\r\n    // Parse AI response\r\n    let aiResult;\r\n    try {\r\n      aiResult = JSON.parse(content);\r\n    } catch (parseError) {\r\n      // Try to extract JSON from the response\r\n      const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        aiResult = JSON.parse(jsonMatch[0]);\r\n      } else {\r\n        throw new Error('Falha ao parsear resposta da IA como JSON');\r\n      }\r\n    }\r\n\r\n    // Validate and clean response based on field type\r\n    let finalResponse = aiResult.generated_response;\r\n\r\n    if (field_type === 'boolean') {\r\n      if (typeof finalResponse === 'string') {\r\n        finalResponse = finalResponse.toLowerCase() === 'true' || finalResponse === '1';\r\n      } else if (typeof finalResponse !== 'boolean') {\r\n        finalResponse = null;\r\n      }\r\n    } else if (field_type === 'multiselect') {\r\n      if (!Array.isArray(finalResponse)) {\r\n        if (typeof finalResponse === 'string') {\r\n          finalResponse = [finalResponse];\r\n        } else {\r\n          finalResponse = [];\r\n        }\r\n      }\r\n      // Filter to only valid options if available\r\n      if (availableOptions.length > 0) {\r\n        finalResponse = finalResponse.filter((opt: string) => availableOptions.includes(opt));\r\n      }\r\n    } else if ((field_type === 'select' || field_type === 'radio') && availableOptions.length > 0) {\r\n      // Ensure response is one of the available options\r\n      if (!availableOptions.includes(finalResponse)) {\r\n        finalResponse = availableOptions[0]; // Default to first option\r\n      }\r\n    } else if (field_type === 'rating') {\r\n      const numResponse = parseInt(finalResponse);\r\n      if (isNaN(numResponse) || numResponse < 1 || numResponse > 5) {\r\n        finalResponse = 3; // Default to middle rating\r\n      } else {\r\n        finalResponse = numResponse;\r\n      }\r\n    }\r\n\r\n    const responseJson = {\r\n      success: true,\r\n      ai_usage_incremented: usageIncremented,\r\n      generated_response: finalResponse,\r\n      generated_comment: aiResult.generated_comment || '',\r\n      confidence: aiResult.confidence || 'media',\r\n      media_analyzed: mediaAnalyzed,\r\n      item_id: itemId,\r\n      timestamp: new Date().toISOString()\r\n    };\r\n\r\n    // Award XP (5 XP for field help)\r\n    // Note: We intentionally do this after sending response to not block UI, but technically Hono waits. \r\n    // Ideally use waitUntil but not available here easily without ctx.\r\n    try {\r\n      await addXP(user.id, 5, env.DB);\r\n    } catch (e) { console.error('XP Error', e); }\r\n\r\n    return c.json(responseJson);\r\n\r\n\r\n\r\n  } catch (error) {\r\n    console.error('Error generating field response:', error);\r\n    return c.json({\r\n      error: \"Erro ao gerar resposta do campo\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Get media for specific inspection item\r\ninspectionRoutes.get(\"/items/:itemId/media\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get inspection item to verify access\r\n    const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.created_by, i.organization_id\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n  `).bind(itemId).first() as any;\r\n\r\n    if (!item) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // Get media for this item\r\n    const media = await env.DB.prepare(`\r\n      SELECT * FROM inspection_media \r\n      WHERE inspection_item_id = ?\r\n  ORDER BY created_at DESC\r\n    `).bind(itemId).all();\r\n\r\n    return c.json({\r\n      media: media.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching inspection item media:', error);\r\n    return c.json({ error: \"Erro ao buscar mídia do item\" }, 500);\r\n  }\r\n});\r\n\r\n// Upload media for inspection item\r\ninspectionRoutes.post(\"/items/:itemId/media\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const {\r\n      media_type, file_name, file_url, file_size, mime_type, description\r\n    } = body;\r\n\r\n    // Get inspection item to get inspection_id\r\n    const item = await env.DB.prepare(`\r\n      SELECT inspection_id FROM inspection_items WHERE id = ?\r\n  `).bind(itemId).first() as any;\r\n\r\n    if (!item) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // Insert media record\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO inspection_media(\r\n    inspection_id, inspection_item_id, media_type, file_name, file_url,\r\n    file_size, mime_type, description, created_at, updated_at\r\n  ) VALUES(?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n    `).bind(\r\n      item.inspection_id,\r\n      itemId,\r\n      media_type,\r\n      file_name,\r\n      file_url,\r\n      file_size || null,\r\n      mime_type || null,\r\n      description || null\r\n    ).run();\r\n\r\n    return c.json({\r\n      id: result.meta.last_row_id,\r\n      message: \"Mídia enviada com sucesso\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error uploading media:', error);\r\n    return c.json({ error: \"Erro ao enviar mídia\" }, 500);\r\n  }\r\n});\r\n\r\n// Create AI-generated action item for inspection item\r\ninspectionRoutes.post(\"/items/:itemId/create-action\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  if (!env.OPENAI_API_KEY) {\r\n    return c.json({ error: \"IA não disponível\" }, 503);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { field_name, field_type, response_value, pre_analysis, media_data, user_prompt } = body;\r\n\r\n    // Increment AI Usage\r\n    let usageIncremented = false;\r\n    try {\r\n      const userId = user.id || (user as any).sub;\r\n      const userProfile = await env.DB.prepare(\r\n        \"SELECT organization_id FROM users WHERE id = ?\"\r\n      ).bind(userId).first() as { organization_id?: number };\r\n\r\n      if (userProfile?.organization_id) {\r\n        await env.DB.prepare(\r\n          \"UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?\"\r\n        ).bind(userProfile.organization_id).run();\r\n\r\n        usageIncremented = true;\r\n\r\n        try {\r\n          await env.DB.prepare(`\r\n             INSERT INTO ai_usage_log (organization_id, user_id, feature_type, model_used, status, created_at)\r\n             VALUES (?, ?, 'action_plan', ?, 'success', NOW())\r\n           `).bind(userProfile.organization_id, userId, 'gpt-4o-mini').run();\r\n        } catch (e) { /* ignore log error */ }\r\n      }\r\n    } catch (usageErr) {\r\n      console.error(\"Failed to increment AI usage:\", usageErr);\r\n    }\r\n\r\n    // Get inspection item and context\r\n    const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n  `).bind(itemId).first() as any;\r\n\r\n    if (!item) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // CORRIGIDO: Lógica melhorada para determinar necessidade de ação\r\n    let needsAction = false;\r\n    let riskLevel = 'baixo';\r\n    let actionReason = '';\r\n\r\n    // 1. Verificar resposta direta de não conformidade\r\n    if (field_type === 'boolean' && response_value === false) {\r\n      needsAction = true;\r\n      riskLevel = 'alto';\r\n      actionReason = 'Item marcado como não conforme';\r\n    } else if (field_type === 'rating' && response_value <= 2) {\r\n      needsAction = true;\r\n      riskLevel = response_value === 1 ? 'critica' : 'alta';\r\n      actionReason = `Avaliação baixa(${response_value} / 5)`;\r\n    } else if (field_type === 'select' && response_value) {\r\n      const valueStr = response_value.toLowerCase();\r\n      if (valueStr.includes('não conforme') || valueStr.includes('inadequado') ||\r\n        valueStr.includes('não aplicável') === false && valueStr.includes('conforme') === false) {\r\n        needsAction = true;\r\n        riskLevel = 'media';\r\n        actionReason = `Resposta indica não conformidade: ${response_value} `;\r\n      }\r\n    }\r\n\r\n    // 2. Verificar análise prévia para identificar riscos\r\n    if (pre_analysis && !needsAction) {\r\n      const analysisText = pre_analysis.toLowerCase();\r\n      const riskKeywords = [\r\n        'não conforme', 'inadequado', 'risco', 'perigo', 'incorreto', 'falha',\r\n        'violação', 'infração', 'necessário', 'corrigir', 'ajustar', 'melhorar',\r\n        'ação', 'problema', 'deficiência', 'insuficiente'\r\n      ];\r\n\r\n      const foundRisks = riskKeywords.filter(keyword => analysisText.includes(keyword));\r\n      if (foundRisks.length >= 2) {\r\n        needsAction = true;\r\n        riskLevel = 'media';\r\n        actionReason = `Análise prévia identificou riscos: ${foundRisks.slice(0, 3).join(', ')} `;\r\n      }\r\n    }\r\n\r\n    // 3. Se ainda não identificou necessidade, deixar a IA decidir baseada em evidências\r\n    if (!needsAction && (media_data?.length > 0 || pre_analysis)) {\r\n      needsAction = true; // Permitir que a IA analise e decida\r\n      riskLevel = 'media';\r\n      actionReason = 'Análise inteligente das evidências disponíveis';\r\n    }\r\n\r\n    // ÚLTIMA VALIDAÇÃO: Se realmente não há nada para analisar\r\n    if (!needsAction && !response_value && !pre_analysis && (!media_data || media_data.length === 0)) {\r\n      return c.json({\r\n        success: true,\r\n        action: {\r\n          requires_action: false,\r\n          message: \"Não há evidências suficientes (resposta, análise ou mídias) para determinar necessidade de ação. Adicione mais informações para análise.\"\r\n        }\r\n      });\r\n    }\r\n\r\n    // CORRIGIDO: Preparar análise multimodal real das evidências\r\n    let mediaContext = '';\r\n    let mediaAnalysisMessages = [];\r\n\r\n    if (media_data && media_data.length > 0) {\r\n      const mediaTypes = media_data.reduce((acc: any, media: any) => {\r\n        acc[media.media_type] = (acc[media.media_type] || 0) + 1;\r\n        return acc;\r\n      }, {});\r\n\r\n      mediaContext = `EVIDÊNCIAS MULTIMODAIS ANALISADAS: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} áudio(s), ${mediaTypes.video || 0} vídeo(s).`;\r\n\r\n      // Preparar imagens para análise visual (máximo 3 para evitar timeout)\r\n      const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);\r\n      for (const img of imageMedia) {\r\n        if (img.file_url) {\r\n          mediaAnalysisMessages.push({\r\n            type: \"image_url\",\r\n            image_url: {\r\n              url: img.file_url,\r\n              detail: \"high\" // Para análise detalhada com gpt-4o-mini\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      // Adicionar descrição de áudios/vídeos se existirem\r\n      const audioCount = mediaTypes.audio || 0;\r\n      const videoCount = mediaTypes.video || 0;\r\n      if (audioCount > 0 || videoCount > 0) {\r\n        mediaContext += ` Inclui ${audioCount} áudio(s) e ${videoCount} vídeo(s) que podem conter evidências sonoras de não conformidades, comunicações, sinais de estresse ou preocupação.`;\r\n      }\r\n    } else {\r\n      mediaContext = `EVIDÊNCIAS DISPONÍVEIS: Nenhuma mídia anexada.Ação baseada na resposta e análise prévia.`;\r\n    }\r\n\r\n    // Construir mensagens para OpenAI incluindo análise visual\r\n    const systemMessage = {\r\n      role: 'system',\r\n      content: 'Você é um especialista em segurança do trabalho especializado em análise multimodal. Analise imagens, áudios, textos e contexto para criar planos de ação 5W2H precisos baseados em evidências reais. Para áudios, considere o conteúdo sonoro e, se for assistente psicossocial, analise também tom de voz e sinais de bem-estar emocional.'\r\n    };\r\n\r\n    const userMessage = {\r\n      role: 'user',\r\n      content: [\r\n        {\r\n          type: \"text\",\r\n          text: `Analise as evidências multimodais e determine se é necessária uma ação corretiva com base em análise técnica detalhada.\r\n\r\nCONTEXTO DA INSPEÇÃO:\r\n- Local: ${item.location}\r\n- Empresa: ${item.company_name}\r\n- Item: ${field_name} (${item.category})\r\n- Descrição: ${item.item_description}\r\n- Resposta do Inspetor: ${response_value || 'Não respondido'}\r\n- Motivo da Análise: ${actionReason}\r\n- Nível de Risco Inicial: ${riskLevel}\r\n- Observações: ${item.observations || 'Nenhuma'}\r\n\r\n${mediaContext}\r\n\r\n${pre_analysis ? `ANÁLISE PRÉVIA DA IA:\r\n${pre_analysis}\r\n\r\nIMPORTANTE: Sua decisão deve ser coerente com esta análise prévia.` : ''\r\n            }\r\n\r\n${user_prompt ? `FOCO ESPECÍFICO DO USUÁRIO: ${user_prompt} - Priorize esta informação.` : ''}\r\n\r\nINSTRUÇÕES PARA ANÁLISE COMPLETA E CRIAÇÃO DE PLANO 5W2H:\r\n\r\n1. ** ANÁLISE MULTIMODAL DETALHADA **:\r\n   - ** Imagens **: Descreva especificamente condições visuais de segurança, EPIs, riscos, não conformidades\r\n  - ** Áudios / Vídeos **: Analise ruídos, comunicações, sinais sonoros de risco\r\n    - ** Assistentes Psicossociais **: Analise tom emocional, estresse, sinais de bem - estar\r\n\r\n2. ** AVALIAÇÃO DE CONFORMIDADE TÉCNICA **:\r\n- Identifique não conformidades específicas com NRs\r\n  - Avalie causa raiz do problema\r\n    - Determine gravidade e urgência\r\n\r\n3. ** PLANO 5W2H ESPECÍFICO ** (se ação necessária):\r\n   - ** O QUÊ **: Ação corretiva específica baseada nas evidências\r\n  - ** ONDE **: Local exato onde aplicar a correção\r\n    - ** POR QUÊ **: Justificativa baseada nos riscos e evidências identificadas\r\n      - ** COMO **: Método detalhado de execução\r\n        - ** QUEM **: Responsável específico(ex: técnico em segurança, supervisor)\r\n          - ** QUANDO **: Prazo realístico baseado na urgência\r\n            - ** QUANTO **: Estimativa de recursos necessários\r\n\r\n4. ** DECISÃO TÉCNICA **: Se não há necessidade de ação, justifique tecnicamente\r\n\r\nResponda APENAS em formato JSON:\r\n{\r\n  \"requires_action\": true / false,\r\n    \"title\": \"Título específico da ação ou motivo técnico de não necessidade\",\r\n      \"what_description\": \"Ação específica detalhada ou justificativa técnica de não necessidade\",\r\n        \"where_location\": \"Local específico ou N/A\",\r\n          \"why_reason\": \"Justificativa técnica baseada nas evidências visuais/sonoras analisadas\",\r\n            \"how_method\": \"Método detalhado de execução ou N/A\",\r\n              \"who_responsible\": \"Responsável específico (ex: Técnico em Segurança, Supervisor) ou N/A\",\r\n                \"when_deadline\": \"Prazo em dias baseado na urgência ou 0\",\r\n                  \"how_much_cost\": \"Estimativa realística ou 'Sem custo'\",\r\n                    \"priority\": \"baixa|media|alta|critica\",\r\n                      \"evidence_analysis\": \"Resumo técnico detalhado do que foi observado nas evidências multimodais\",\r\n                        \"visual_findings\": \"Descrição específica e técnica do que foi visto nas imagens relacionado à segurança\",\r\n                          \"compliance_assessment\": \"Avaliação de conformidade com normas técnicas aplicáveis\"\r\n}\r\n\r\nBase sua decisão exclusivamente nas evidências analisadas e seja específico sobre os achados visuais / sonoros.`\r\n        },\r\n        ...mediaAnalysisMessages\r\n      ]\r\n    };\r\n\r\n    const messages = [systemMessage, userMessage];\r\n\r\n    // CORRIGIDO: Call OpenAI API com análise multimodal detalhada\r\n    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${env.OPENAI_API_KEY} `,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'gpt-4o-mini', // Mudança solicitada para gpt-4o-mini\r\n        messages: messages,\r\n        max_tokens: 2000, // Aumentado para análise mais detalhada\r\n        temperature: 0.3 // Reduzido para mais consistência\r\n      })\r\n    });\r\n\r\n    if (!openaiResponse.ok) {\r\n      const errorText = await openaiResponse.text();\r\n      console.error('OpenAI API Error:', openaiResponse.status, errorText);\r\n      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status} `);\r\n    }\r\n\r\n    // Robust JSON parsing with HTML error handling\r\n    let openaiResult;\r\n    try {\r\n      const responseText = await openaiResponse.text();\r\n\r\n      // Check if response is HTML (common error response format)\r\n      if (responseText.trim().startsWith('<')) {\r\n        console.error('OpenAI returned HTML instead of JSON:', responseText);\r\n        throw new Error('API da OpenAI retornou resposta inválida (HTML). Verifique a chave da API e tente novamente.');\r\n      }\r\n\r\n      openaiResult = JSON.parse(responseText);\r\n    } catch (parseError) {\r\n      console.error('Failed to parse OpenAI response:', parseError);\r\n      throw new Error('Erro ao processar resposta da IA. Tente novamente.');\r\n    }\r\n\r\n    const content = openaiResult.choices?.[0]?.message?.content;\r\n\r\n    if (!content) {\r\n      throw new Error('Resposta inválida da IA');\r\n    }\r\n\r\n    // Parse AI response\r\n    let actionPlan;\r\n    try {\r\n      actionPlan = JSON.parse(content);\r\n    } catch (parseError) {\r\n      // Try to extract JSON from the response\r\n      const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        actionPlan = JSON.parse(jsonMatch[0]);\r\n      } else {\r\n        throw new Error('Falha ao parsear resposta da IA como JSON');\r\n      }\r\n    }\r\n\r\n    if (actionPlan.requires_action) {\r\n      // Calculate deadline\r\n      const deadlineDays = parseInt(actionPlan.when_deadline) || 30;\r\n      const deadlineDate = new Date();\r\n      deadlineDate.setDate(deadlineDate.getDate() + deadlineDays);\r\n\r\n      // Create action item in database\r\n      const result = await env.DB.prepare(`\r\n        INSERT INTO action_items(\r\n  inspection_id, inspection_item_id, title, what_description, where_location,\r\n  why_reason, how_method, who_responsible, when_deadline, how_much_cost,\r\n  status, priority, is_ai_generated, assigned_to, created_at, updated_at\r\n) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n  `).bind(\r\n        item.inspection_id,\r\n        itemId,\r\n        actionPlan.title,\r\n        actionPlan.what_description,\r\n        actionPlan.where_location,\r\n        actionPlan.why_reason,\r\n        actionPlan.how_method,\r\n        actionPlan.who_responsible,\r\n        deadlineDate.toISOString().split('T')[0],\r\n        actionPlan.how_much_cost,\r\n        'pending',\r\n        actionPlan.priority || 'media',\r\n        true,\r\n        actionPlan.who_responsible,\r\n      ).run();\r\n\r\n      // Update action plan in inspection item with enhanced analysis\r\n      const enhancedPlan = {\r\n        ...actionPlan,\r\n        evidence_analysis: actionPlan.evidence_analysis || 'Análise baseada em evidências disponíveis',\r\n        visual_findings: actionPlan.visual_findings || 'Nenhuma análise visual específica',\r\n        media_analyzed: media_data ? media_data.length : 0,\r\n        analysis_type: mediaAnalysisMessages.length > 0 ? 'multimodal' : 'textual'\r\n      };\r\n\r\n      await env.DB.prepare(`\r\n        UPDATE inspection_items \r\n        SET ai_action_plan = ?, updated_at = NOW()\r\n        WHERE id = ?\r\n  `).bind(JSON.stringify(enhancedPlan), itemId).run();\r\n\r\n      actionPlan.id = result.meta.last_row_id;\r\n      actionPlan.evidence_analysis = enhancedPlan.evidence_analysis;\r\n      actionPlan.visual_findings = enhancedPlan.visual_findings;\r\n      actionPlan.visual_findings = enhancedPlan.visual_findings;\r\n    }\r\n\r\n    // Award XP (10 XP for creating action item)\r\n    try {\r\n      await addXP(user.id, 10, env.DB);\r\n    } catch (e) { console.error('XP Error', e); }\r\n\r\n    return c.json({\r\n      success: true,\r\n      ai_usage_incremented: usageIncremented,\r\n      action: actionPlan,\r\n      item_id: itemId,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating action with AI:', error);\r\n    return c.json({\r\n      error: \"Erro ao criar ação com IA\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Pre-analysis endpoint for inspection items\r\ninspectionRoutes.post(\"/items/:itemId/pre-analysis\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const itemId = parseInt(c.req.param(\"itemId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  if (!env.OPENAI_API_KEY) {\r\n    return c.json({ error: \"IA não configurada no sistema\" }, 503);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { field_name, field_type, response_value, media_data, user_prompt } = body;\r\n\r\n    // Increment AI Usage\r\n    let usageIncremented = false;\r\n    try {\r\n      const userId = user.id || (user as any).sub;\r\n      const userProfile = await env.DB.prepare(\r\n        \"SELECT organization_id FROM users WHERE id = ?\"\r\n      ).bind(userId).first() as { organization_id?: number };\r\n\r\n      if (userProfile?.organization_id) {\r\n        await env.DB.prepare(\r\n          \"UPDATE organizations SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1 WHERE id = ?\"\r\n        ).bind(userProfile.organization_id).run();\r\n\r\n        usageIncremented = true;\r\n\r\n        try {\r\n          await env.DB.prepare(`\r\n             INSERT INTO ai_usage_log (organization_id, user_id, feature_type, model_used, status, created_at)\r\n             VALUES (?, ?, 'pre_analysis', ?, 'success', NOW())\r\n           `).bind(userProfile.organization_id, userId, 'gpt-4o-mini').run();\r\n        } catch (e) { /* ignore log error */ }\r\n      }\r\n    } catch (usageErr) {\r\n      console.error(\"Failed to increment AI usage:\", usageErr);\r\n    }\r\n\r\n    // Get inspection item with inspection context\r\n    const item = await env.DB.prepare(`\r\n      SELECT ii.*, i.location, i.company_name, i.title as inspection_title, i.id as inspection_id\r\n      FROM inspection_items ii\r\n      JOIN inspections i ON ii.inspection_id = i.id\r\n      WHERE ii.id = ?\r\n  `).bind(itemId).first() as any;\r\n\r\n    if (!item) {\r\n      return c.json({ error: \"Item de inspeção não encontrado\" }, 404);\r\n    }\r\n\r\n    // CORRIGIDO: Preparar análise multimodal real das evidências\r\n    let mediaAnalysisContent = '';\r\n    let mediaAnalyzed = 0;\r\n    let mediaAnalysisMessages = [];\r\n\r\n    if (media_data && media_data.length > 0) {\r\n      mediaAnalyzed = media_data.length;\r\n      const mediaTypes = media_data.reduce((acc: any, media: any) => {\r\n        acc[media.media_type] = (acc[media.media_type] || 0) + 1;\r\n        return acc;\r\n      }, {});\r\n\r\n      mediaAnalysisContent = `EVIDÊNCIAS MULTIMODAIS DISPONÍVEIS: ${mediaTypes.image || 0} foto(s), ${mediaTypes.audio || 0} áudio(s), ${mediaTypes.video || 0} vídeo(s) para análise detalhada.`;\r\n\r\n      // Preparar imagens para análise visual (máximo 3 para evitar timeout)\r\n      const imageMedia = media_data.filter((m: any) => m.media_type === 'image').slice(0, 3);\r\n      for (const img of imageMedia) {\r\n        if (img.file_url) {\r\n          mediaAnalysisMessages.push({\r\n            type: \"image_url\",\r\n            image_url: {\r\n              url: img.file_url,\r\n              detail: \"high\" // Para análise detalhada na pré-análise\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      // Adicionar descrição de áudios/vídeos se existirem\r\n      const audioCount = mediaTypes.audio || 0;\r\n      const videoCount = mediaTypes.video || 0;\r\n      if (audioCount > 0 || videoCount > 0) {\r\n        mediaAnalysisContent += ` Inclui ${audioCount} áudio(s) e ${videoCount} vídeo(s) que podem conter evidências sonoras importantes, comunicações verbais, tom de voz e sinais emocionais.`;\r\n      }\r\n    } else {\r\n      mediaAnalysisContent = `EVIDÊNCIAS DISPONÍVEIS: Nenhuma mídia anexada.Análise baseada apenas na resposta do inspetor e contexto da inspeção.`;\r\n    }\r\n\r\n    // Construir mensagens para OpenAI incluindo análise visual\r\n    const systemMessage = {\r\n      role: 'system',\r\n      content: 'Você é um especialista em segurança do trabalho especializado em análise multimodal. Analise imagens, áudios, contexto e respostas para fornecer pré-análises técnicas detalhadas e práticas. Para áudios, considere conteúdo sonoro, comunicações verbais e, se for assistente psicossocial, analise tom de voz, sinais de estresse, ansiedade ou bem-estar emocional.'\r\n    };\r\n\r\n    const userMessage = {\r\n      role: 'user',\r\n      content: [\r\n        {\r\n          type: \"text\",\r\n          text: `Faça uma pré - análise técnica aprofundada e abrangente deste item de segurança.\r\n\r\nCONTEXTO DA INSPEÇÃO:\r\n- Local: ${item.location}\r\n- Empresa: ${item.company_name || 'Não informado'}\r\n- Título da Inspeção: ${item.inspection_title}\r\n\r\nITEM EM ANÁLISE:\r\n- Campo: ${field_name}\r\n- Tipo: ${field_type}\r\n- Categoria: ${item.category}\r\n- Descrição: ${item.item_description}\r\n- Resposta: ${response_value !== null && response_value !== undefined ? response_value : 'Não respondido'}\r\n- Observações: ${item.observations || 'Nenhuma observação'}\r\n\r\n${mediaAnalysisContent}\r\n\r\n${user_prompt ? `FOCO ESPECÍFICO DO USUÁRIO: ${user_prompt} - PRIORIZE esta informação em sua análise.` : ''}\r\n\r\nINSTRUÇÕES PARA ANÁLISE TÉCNICA DETALHADA:\r\n\r\n1. ** ANÁLISE VISUAL DETALHADA(se houver imagens) **:\r\n- Descreva especificamente condições de segurança observadas\r\n  - Identifique EPIs presentes / ausentes, estado de conservação\r\n    - Avalie sinalizações, placas, avisos de segurança\r\n      - Observe organização, limpeza, aplicação de 5S\r\n        - Identifique riscos visuais(altura, elétricos, químicos, mecânicos)\r\n          - Verifique conformidade visual com NRs aplicáveis\r\n\r\n2. ** ANÁLISE SONORA(se houver áudios / vídeos) **:\r\n- Identifique ruídos de equipamentos, níveis sonoros\r\n  - Analise comunicações verbais sobre segurança\r\n    - Detecte sons anômalos que indiquem riscos\r\n      - Para assistentes psicossociais: analise tom emocional, estresse, ansiedade\r\n\r\n3. ** AVALIAÇÃO DE CONFORMIDADE TÉCNICA **:\r\n- Cite NRs específicas aplicáveis ao contexto\r\n  - Identifique não conformidades técnicas específicas\r\n    - Avalie causa raiz de problemas identificados\r\n      - Determine implicações regulatórias\r\n\r\n4. ** ANÁLISE DE RISCOS **:\r\n- Classifique riscos por gravidade e probabilidade\r\n  - Identifique consequências potenciais\r\n    - Avalie urgência de ações corretivas\r\n      - Considere impactos a longo prazo\r\n\r\n5. ** RECOMENDAÇÕES ESPECÍFICAS **:\r\n- Sugira ações corretivas concretas e acionáveis\r\n  - Indique prioridade(Baixa / Média / Alta / Crítica)\r\n    - Recomende prazos para correções\r\n      - Base tudo nas evidências analisadas\r\n\r\nForneça uma análise técnica estruturada(máximo 600 caracteres) incluindo:\r\n- ** Observações Detalhadas **: O que foi especificamente observado nas evidências\r\n  - ** Conformidade **: Avaliação clara conforme / não conforme com normas\r\n    - ** Riscos **: Riscos identificados com base nas evidências\r\n      - ** Urgência **: Nível de prioridade para ação corretiva\r\n        - ** Recomendação **: Ação necessária baseada na análise\r\n\r\nSeja técnico, específico e cite detalhes visuais / sonoros concretos das evidências.`\r\n        },\r\n        ...mediaAnalysisMessages\r\n      ]\r\n    };\r\n\r\n    const messages = [systemMessage, userMessage];\r\n\r\n    // CORRIGIDO: Call OpenAI API com análise multimodal detalhada\r\n    const openaiResponse = await globalThis.fetch('https://api.openai.com/v1/chat/completions', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${env.OPENAI_API_KEY} `,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'gpt-4o-mini', // Mudança solicitada para gpt-4o-mini\r\n        messages: messages,\r\n        max_tokens: 1500, // Aumentado para análise mais detalhada\r\n        temperature: 0.4 // Ajustado para melhor análise\r\n      })\r\n    });\r\n\r\n    if (!openaiResponse.ok) {\r\n      const errorText = await openaiResponse.text();\r\n      console.error('OpenAI API Error:', openaiResponse.status, errorText);\r\n      throw new Error(`Erro na API da OpenAI: ${openaiResponse.status} `);\r\n    }\r\n\r\n    const openaiResult = await openaiResponse.json() as any;\r\n    const analysis = openaiResult.choices?.[0]?.message?.content;\r\n\r\n    if (!analysis) {\r\n      throw new Error('Resposta inválida da IA');\r\n    }\r\n\r\n    // Update the inspection item with pre-analysis\r\n    await env.DB.prepare(`\r\n      UPDATE inspection_items \r\n      SET ai_pre_analysis = ?, updated_at = NOW()\r\n      WHERE id = ?\r\n  `).bind(analysis, itemId).run();\r\n\r\n    // Award XP (5 XP for pre-analysis)\r\n    try {\r\n      await addXP(user.id, 5, env.DB);\r\n    } catch (e) { console.error('XP Error', e); }\r\n\r\n    return c.json({\r\n      success: true,\r\n      ai_usage_incremented: usageIncremented,\r\n      pre_analysis: analysis,\r\n      analysis: analysis, // For backward compatibility\r\n      media_analyzed: mediaAnalyzed,\r\n      item_id: itemId,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error in pre-analysis:', error);\r\n    return c.json({\r\n      error: \"Erro ao processar pré-análise\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// NOTE: Media upload route REMOVED from here.\r\n// The correct implementation is in media-routes.ts which uses Supabase Storage.\r\n// Use /api/media/:inspectionId/media/upload instead of /api/inspections/:inspectionId/media/upload\r\n\r\n\r\n// GET action items for inspection\r\ninspectionRoutes.get(\"/:inspectionId/action-items\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"inspectionId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const actionItems = await env.DB.prepare(`\r\n      SELECT ai.*, ii.item_description as inspection_item_name\r\n      FROM action_items ai\r\n      LEFT JOIN inspection_items ii ON ai.inspection_item_id = ii.id\r\n      WHERE ai.inspection_id = ?\r\n      ORDER BY ai.created_at DESC\r\n    `).bind(inspectionId).all();\r\n\r\n    return c.json(actionItems.results || []);\r\n  } catch (error) {\r\n    console.error('Error loading action items:', error);\r\n    return c.json({ error: \"Erro ao carregar ações\" }, 500);\r\n  }\r\n});\r\n\r\n// Create action item for inspection (Manual action creation)\r\ninspectionRoutes.post(\"/:inspectionId/action-items\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"inspectionId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const {\r\n      inspection_item_id,\r\n      title,\r\n      what_description,\r\n      where_location,\r\n      why_reason,\r\n      how_method,\r\n      who_responsible,\r\n      when_deadline,\r\n      how_much_cost,\r\n      priority = 'media',\r\n      status = 'pending',\r\n      is_ai_generated = false,\r\n      field_name\r\n    } = body;\r\n\r\n    // Verify inspection exists\r\n    const inspection = await env.DB.prepare(`\r\n      SELECT id, location, company_name, title FROM inspections WHERE id = ?\r\n    `).bind(inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Resolve the correct inspection_item_id if provided\r\n    let resolvedItemId = inspection_item_id;\r\n\r\n    if (inspection_item_id) {\r\n      // Check if ID exists directly\r\n      const itemExists = await env.DB.prepare(`\r\n        SELECT id FROM inspection_items WHERE id = ? AND inspection_id = ?\r\n      `).bind(inspection_item_id, inspectionId).first();\r\n\r\n      if (!itemExists && field_name) {\r\n        // Fallback: Try to find by field_name\r\n        const itemByName = await env.DB.prepare(`\r\n          SELECT id FROM inspection_items \r\n          WHERE inspection_id = ? AND item_description = ?\r\n        `).bind(inspectionId, field_name).first() as any;\r\n\r\n        if (itemByName) {\r\n          resolvedItemId = itemByName.id;\r\n        } else {\r\n          resolvedItemId = null; // Avoid FK error\r\n        }\r\n      } else if (!itemExists) {\r\n        resolvedItemId = null;\r\n      }\r\n    }\r\n\r\n    const now = new Date().toISOString();\r\n    const deadline = when_deadline || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\r\n\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO action_items (\r\n        inspection_id, inspection_item_id, title, what_description, where_location,\r\n        why_reason, how_method, who_responsible, when_deadline, how_much_cost,\r\n        priority, status, is_ai_generated, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `).bind(\r\n      inspectionId,\r\n      resolvedItemId || null,\r\n      title || 'Ação Corretiva',\r\n      what_description || '',\r\n      where_location || inspection.location || '',\r\n      why_reason || '',\r\n      how_method || '',\r\n      who_responsible || 'A definir',\r\n      deadline,\r\n      how_much_cost || 'A orçar',\r\n      priority,\r\n      status,\r\n      is_ai_generated,\r\n      now,\r\n      now\r\n    ).run();\r\n\r\n    return c.json({\r\n      success: true,\r\n      action_item: {\r\n        id: result.meta.last_row_id,\r\n        inspection_id: inspectionId,\r\n        title,\r\n        priority,\r\n        status\r\n      }\r\n    }, 201);\r\n\r\n  } catch (error) {\r\n    console.error('Error creating action item:', error);\r\n    return c.json({\r\n      error: \"Erro ao criar ação\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Get inspection history/logs\r\ninspectionRoutes.get(\"/:id/history\", tenantAuthMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"id\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Check if inspection_logs table exists and fetch logs\r\n    const logs = await env.DB.prepare(`\r\n            SELECT il.*, u.name as user_name\r\n            FROM inspection_logs il\r\n            LEFT JOIN users u ON il.user_id = u.id\r\n            WHERE il.inspection_id = ?\r\n            ORDER BY il.created_at DESC\r\n            LIMIT 50\r\n        `).bind(inspectionId).all();\r\n\r\n    return c.json({\r\n      success: true,\r\n      history: logs.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching inspection history:', error);\r\n    // Return empty history if table doesn't exist or other error\r\n    return c.json({\r\n      success: true,\r\n      history: [],\r\n      message: \"Histórico não disponível\"\r\n    });\r\n  }\r\n});\r\n\r\nexport default inspectionRoutes;\r\n\r\n"},{"name":"integrations-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { ExtendedMochaUser } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n};\r\n\r\nconst getDatabase = (env: any) => env.DB;\r\n\r\nconst app = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// GET /: List integrations status for the user/organization\r\napp.get('/', tenantAuthMiddleware, async (c) => {\r\n    try {\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const db = getDatabase(c.env);\r\n\r\n        const integrations = await db.prepare(`\r\n            SELECT provider, created_at, expires_at \r\n            FROM integrations \r\n            WHERE user_id = ?\r\n        `).bind(user.id).all();\r\n\r\n        return c.json({\r\n            google: integrations.results?.find((i: any) => i.provider === 'google') ? true : false,\r\n            // outlook: ... later\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching integrations:', error);\r\n        return c.json({ error: 'Erro ao buscar integrações' }, 500);\r\n    }\r\n});\r\n\r\n// POST /google/authorize-url: Generate Google OAuth URL\r\napp.post('/google/authorize-url', tenantAuthMiddleware, async (c) => {\r\n    const CLIENT_ID = Deno.env.get('GOOGLE_CLIENT_ID');\r\n    const REDIRECT_URI = Deno.env.get('GOOGLE_REDIRECT_URI'); // e.g. https://<project>.functions.supabase.co/api/integrations/google/callback OR frontend URL?\r\n    // Usually frontend handles the redirect, but better to keep secrets on server. \r\n    // Flow: Frontend -> API (get URL) -> Frontend Redirects -> Google -> Frontend (Callback Page) -> API (Exchange Code)\r\n\r\n    if (!CLIENT_ID || !REDIRECT_URI) {\r\n        return c.json({ error: \"Google Client ID/Redirect URI not configured\" }, 500);\r\n    }\r\n\r\n    const SCOPES = [\r\n        'https://www.googleapis.com/auth/calendar',\r\n        'https://www.googleapis.com/auth/calendar.events',\r\n        'https://www.googleapis.com/auth/gmail.send',\r\n        'https://www.googleapis.com/auth/userinfo.email'\r\n    ].join(' ');\r\n\r\n    const url = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}&response_type=code&scope=${SCOPES}&access_type=offline&prompt=consent`;\r\n\r\n    return c.json({ url });\r\n});\r\n\r\n// POST /google/callback: Exchange code for token\r\napp.post('/google/callback', tenantAuthMiddleware, async (c) => {\r\n    try {\r\n        const user = c.get('user') as ExtendedMochaUser;\r\n        const db = getDatabase(c.env);\r\n        const { code } = await c.req.json();\r\n\r\n        const CLIENT_ID = Deno.env.get('GOOGLE_CLIENT_ID');\r\n        const CLIENT_SECRET = Deno.env.get('GOOGLE_CLIENT_SECRET');\r\n        const REDIRECT_URI = Deno.env.get('GOOGLE_REDIRECT_URI');\r\n\r\n        if (!code || !CLIENT_ID || !CLIENT_SECRET) {\r\n            return c.json({ error: \"Missing code or config\" }, 400);\r\n        }\r\n\r\n        // Exchange code\r\n        const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n            body: new URLSearchParams({\r\n                code,\r\n                client_id: CLIENT_ID,\r\n                client_secret: CLIENT_SECRET,\r\n                redirect_uri: REDIRECT_URI,\r\n                grant_type: 'authorization_code'\r\n            })\r\n        });\r\n\r\n        const tokens = await tokenResponse.json();\r\n\r\n        if (tokens.error) {\r\n            console.error('Google Token Error:', tokens);\r\n            return c.json({ error: \"Failed to exchange token\", details: tokens }, 400);\r\n        }\r\n\r\n        // Get user profile for organization_id\r\n        const userProfile = await db.prepare(\"SELECT organization_id FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n        const orgId = userProfile?.organization_id;\r\n\r\n        if (!orgId) return c.json({ error: \"No organization\" }, 400);\r\n\r\n        // Calculate expiry\r\n        const expiresAt = new Date(Date.now() + tokens.expires_in * 1000);\r\n\r\n        // Upsert integration\r\n        await db.prepare(`\r\n            INSERT INTO integrations (organization_id, user_id, provider, access_token, refresh_token, expires_at, scope, updated_at)\r\n            VALUES (?, ?, 'google', ?, ?, ?, ?, NOW())\r\n            ON CONFLICT(user_id, provider) DO UPDATE SET\r\n                access_token = excluded.access_token,\r\n                refresh_token = COALESCE(excluded.refresh_token, integrations.refresh_token), -- Keep old refresh if new one not provided\r\n                expires_at = excluded.expires_at,\r\n                updated_at = NOW()\r\n        `).bind(\r\n            orgId, user.id,\r\n            tokens.access_token,\r\n            tokens.refresh_token || null,\r\n            expiresAt.toISOString(),\r\n            tokens.scope\r\n        ).run();\r\n\r\n        return c.json({ success: true });\r\n\r\n    } catch (error) {\r\n        console.error('Callback error:', error);\r\n        return c.json({ error: \"Internal error during callback\" }, 500);\r\n    }\r\n});\r\n\r\n// DELETE /google: Disconnect\r\napp.delete('/google', tenantAuthMiddleware, async (c) => {\r\n    const user = c.get('user') as ExtendedMochaUser;\r\n    const db = getDatabase(c.env);\r\n\r\n    await db.prepare(\"DELETE FROM integrations WHERE user_id = ? AND provider = 'google'\").bind(user.id).run();\r\n\r\n    return c.json({ success: true });\r\n});\r\n\r\nexport default app;\r\n"},{"name":"kanban-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n};\r\n\r\nconst kanbanRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Get columns for organization\r\nkanbanRoutes.get(\"/:orgId/columns\", tenantAuthMiddleware, async (c) => {\r\n    const user = c.get('user');\r\n    const orgId = c.req.param('orgId');\r\n    const env = c.env;\r\n\r\n    if (!user) return c.json({ error: \"Unauthorized\" }, 401);\r\n\r\n    try {\r\n        let columns = await env.DB.prepare(\"SELECT * FROM kanban_columns WHERE organization_id = ? ORDER BY position ASC\").bind(orgId).all();\r\n\r\n        // Lazy seed if empty\r\n        if (!columns.results || columns.results.length === 0) {\r\n            await env.DB.prepare(`\r\n                INSERT INTO kanban_columns (organization_id, title, status_key, position, color) VALUES \r\n                (?, 'A Fazer', 'pending', 0, 'bg-slate-100'),\r\n                (?, 'Em Andamento', 'in_progress', 1, 'bg-blue-50'),\r\n                (?, 'Concluído', 'completed', 2, 'bg-green-50')\r\n            `).bind(orgId, orgId, orgId).run();\r\n\r\n            columns = await env.DB.prepare(\"SELECT * FROM kanban_columns WHERE organization_id = ? ORDER BY position ASC\").bind(orgId).all();\r\n        }\r\n\r\n        return c.json({ columns: columns.results });\r\n    } catch (e) {\r\n        console.error(\"Error fetching columns:\", e);\r\n        return c.json({ error: \"Failed to fetch columns\" }, 500);\r\n    }\r\n});\r\n\r\n// Create new column\r\nkanbanRoutes.post(\"/:orgId/columns\", tenantAuthMiddleware, async (c) => {\r\n    const user = c.get('user');\r\n    const orgId = c.req.param('orgId');\r\n    const env = c.env;\r\n    const { title, color } = await c.req.json();\r\n\r\n    if (!title) return c.json({ error: \"Title required\" }, 400);\r\n\r\n    try {\r\n        // Generate a simplified status key from title\r\n        const statusKey = title.toLowerCase().replace(/\\s+/g, '_').replace(/[^a-z0-9_]/g, '');\r\n\r\n        // Get max position\r\n        const maxPos = await env.DB.prepare(\"SELECT MAX(position) as max_pos FROM kanban_columns WHERE organization_id = ?\").bind(orgId).first();\r\n        const nextPos = (maxPos?.max_pos || 0) + 1;\r\n\r\n        const result = await env.DB.prepare(`\r\n            INSERT INTO kanban_columns (organization_id, title, status_key, position, color)\r\n            VALUES (?, ?, ?, ?, ?)\r\n            RETURNING *\r\n        `).bind(orgId, title, statusKey, nextPos, color || 'bg-slate-100').first();\r\n\r\n        return c.json({ column: result });\r\n    } catch (e) {\r\n        return c.json({ error: \"Failed to create column\" }, 500);\r\n    }\r\n});\r\n\r\n// Update column order\r\nkanbanRoutes.put(\"/:orgId/columns/reorder\", tenantAuthMiddleware, async (c) => {\r\n    const orgId = c.req.param('orgId');\r\n    const env = c.env;\r\n    const { columnIds } = await c.req.json();\r\n\r\n    try {\r\n        // Prepare batch updates (or sequential)\r\n        for (let i = 0; i < columnIds.length; i++) {\r\n            await env.DB.prepare(\"UPDATE kanban_columns SET position = ? WHERE id = ? AND organization_id = ?\").bind(i, columnIds[i], orgId).run();\r\n        }\r\n        return c.json({ success: true });\r\n    } catch (e) {\r\n        return c.json({ error: \"Failed to reorder\" }, 500);\r\n    }\r\n});\r\n\r\n// Update column (title/color)\r\nkanbanRoutes.put(\"/:orgId/columns/:colId\", tenantAuthMiddleware, async (c) => {\r\n    const orgId = c.req.param('orgId');\r\n    const colId = c.req.param('colId');\r\n    const env = c.env;\r\n    const { title, color } = await c.req.json();\r\n\r\n    try {\r\n        await env.DB.prepare(\"UPDATE kanban_columns SET title = ?, color = ? WHERE id = ? AND organization_id = ?\").bind(title, color, colId, orgId).run();\r\n        return c.json({ success: true });\r\n    } catch (e) {\r\n        return c.json({ error: \"Failed to update column\" }, 500);\r\n    }\r\n});\r\n\r\n// Delete column\r\nkanbanRoutes.delete(\"/:orgId/columns/:colId\", tenantAuthMiddleware, async (c) => {\r\n    const orgId = c.req.param('orgId');\r\n    const colId = c.req.param('colId');\r\n    const env = c.env;\r\n\r\n    try {\r\n        // Optional: Check if items exist in this column?\r\n        // For now, let's just delete (items statuses might become orphaned visually but exist in DB)\r\n        // Better: Move items to 'pending'?\r\n        // Skipping complex logic for MVP.\r\n        await env.DB.prepare(\"DELETE FROM kanban_columns WHERE id = ? AND organization_id = ?\").bind(colId, orgId).run();\r\n        return c.json({ success: true });\r\n    } catch (e) {\r\n        return c.json({ error: \"Failed to delete column\" }, 500);\r\n    }\r\n});\r\n\r\n// Move Item (Update Status)\r\nkanbanRoutes.put(\"/:orgId/items/:itemId/move\", tenantAuthMiddleware, async (c) => {\r\n    const { status } = await c.req.json();\r\n    const itemId = c.req.param('itemId');\r\n    const env = c.env;\r\n\r\n    try {\r\n        // 1. Get current item data before update\r\n        const item = await env.DB.prepare(\"SELECT title, notification_emails FROM action_items WHERE id = ?\").bind(itemId).first();\r\n\r\n        // 2. Update status\r\n        await env.DB.prepare(\"UPDATE action_items SET status = ?, updated_at = NOW() WHERE id = ?\").bind(status, itemId).run();\r\n\r\n        // 3. Send notifications if configured\r\n        if (item && item.notification_emails && Array.isArray(JSON.parse(item.notification_emails))) {\r\n            const emails = JSON.parse(item.notification_emails);\r\n            // Dynamic import to avoid circular dependency issues if any (though unlikely here)\r\n            // Email service code removed to preventing broken build warnings\r\n            console.warn(\"Email service missing. Skipping notification for item:\", item.title);\r\n            console.warn(\"Email service missing. Skipping notification for item:\", item.title);\r\n        }\r\n\r\n        return c.json({ success: true });\r\n    } catch (e) {\r\n        console.error(\"Error moving item:\", e);\r\n        return c.json({ error: \"Failed to move item\" }, 500);\r\n    }\r\n});\r\n\r\nexport default kanbanRoutes;\r\n"},{"name":"media-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware as authMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\r\n\r\nconst mediaRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\ntype Env = {\r\n  DB: any;\r\n  SUPABASE_URL: string;\r\n  SUPABASE_SERVICE_ROLE_KEY: string;\r\n};\r\n\r\n// File size limits in bytes\r\nconst FILE_SIZE_LIMITS = {\r\n  image: 10 * 1024 * 1024,      // 10 MB\r\n  video: 100 * 1024 * 1024,     // 100 MB\r\n  audio: 20 * 1024 * 1024,      // 20 MB\r\n  document: 50 * 1024 * 1024    // 50 MB\r\n};\r\n\r\n// Upload media for inspection\r\nmediaRoutes.post(\"/:inspectionId/media/upload\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"inspectionId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const {\r\n      inspection_item_id,\r\n      media_type,\r\n      file_name,\r\n      file_data,\r\n      thumbnail_data,\r\n      file_size,\r\n      mime_type,\r\n      description,\r\n      latitude,\r\n      longitude,\r\n      captured_at\r\n    } = body;\r\n\r\n    // Validate file size based on media type\r\n    const sizeLimit = FILE_SIZE_LIMITS[media_type as keyof typeof FILE_SIZE_LIMITS];\r\n    if (file_size > sizeLimit) {\r\n      const limitMB = Math.round(sizeLimit / 1024 / 1024);\r\n      return c.json({\r\n        error: `Arquivo muito grande. Limite para ${media_type}: ${limitMB}MB`\r\n      }, 400);\r\n    }\r\n\r\n    // Validate required fields\r\n    if (!file_data || typeof file_data !== 'string') {\r\n      return c.json({ error: \"Dados do arquivo são obrigatórios (file_data)\" }, 400);\r\n    }\r\n    if (!file_name) {\r\n      return c.json({ error: \"Nome do arquivo é obrigatório (file_name)\" }, 400);\r\n    }\r\n    if (!media_type) {\r\n      return c.json({ error: \"Tipo de mídia é obrigatório (media_type)\" }, 400);\r\n    }\r\n\r\n    // Verify inspection exists and user has access\r\n    const inspection = await env.DB.prepare(`\r\n      SELECT i.*, u.organization_id as user_org_id, u.role as user_role, u.managed_organization_id\r\n      FROM inspections i\r\n      JOIN users u ON u.id = ?\r\n      WHERE i.id = ?\r\n    `).bind(user.id, inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Check access permissions with proper role handling\r\n    const isCreator = inspection.created_by === user.id;\r\n    const isSameOrg = inspection.organization_id === inspection.user_org_id;\r\n    const isSystemAdmin = ['sys_admin', 'system_admin', 'admin'].includes(inspection.user_role?.toLowerCase());\r\n    const isOrgAdmin = inspection.user_role?.toLowerCase() === 'org_admin' && isSameOrg;\r\n    const managesThisOrg = inspection.managed_organization_id === inspection.organization_id;\r\n\r\n    // Also check if user's org is parent of inspection's org (supervision case)\r\n    let isParentOrg = false;\r\n    if (!isSameOrg && inspection.user_org_id) {\r\n      const parentCheck = await env.DB.prepare(`\r\n        SELECT 1 FROM organizations WHERE id = ? AND parent_organization_id = ?\r\n      `).bind(inspection.organization_id, inspection.user_org_id).first();\r\n      isParentOrg = !!parentCheck;\r\n    }\r\n\r\n    const hasAccess = isCreator || isSameOrg || isSystemAdmin || isOrgAdmin || managesThisOrg || isParentOrg;\r\n\r\n    if (!hasAccess) {\r\n      console.log(`[MEDIA] Access denied: user=${user.id}, inspection=${inspectionId}, isCreator=${isCreator}, isSameOrg=${isSameOrg}, isAdmin=${isSystemAdmin || isOrgAdmin}`);\r\n      return c.json({ error: \"Sem permissão para acessar esta inspeção\" }, 403);\r\n    }\r\n\r\n    // Resolve the correct inspection_item_id\r\n    // The frontend sends the template field_id, but we need the actual inspection_item.id\r\n    let resolvedItemId = inspection_item_id;\r\n\r\n    if (inspection_item_id) {\r\n      // First, check if the ID exists directly as inspection_items.id\r\n      const itemExists = await env.DB.prepare(`\r\n        SELECT id FROM inspection_items WHERE id = ? AND inspection_id = ?\r\n      `).bind(inspection_item_id, inspectionId).first();\r\n\r\n      if (!itemExists) {\r\n        // Fallback 1: Search by field_id inside the JSON field_responses column\r\n        // The frontend's fieldId is actually the template's checklist_fields.id stored in field_responses->>field_id\r\n        const itemByFieldId = await env.DB.prepare(`\r\n          SELECT id FROM inspection_items \r\n          WHERE inspection_id = ? AND (field_responses::text)::jsonb->>'field_id' = ?\r\n        `).bind(inspectionId, String(inspection_item_id)).first() as any;\r\n\r\n        if (itemByFieldId) {\r\n          resolvedItemId = itemByFieldId.id;\r\n          console.log(`[MEDIA] Resolved field_id ${inspection_item_id} to inspection_item.id ${resolvedItemId}`);\r\n        } else {\r\n          // Fallback 2: Try to find by field_name (passed in body)\r\n          const { field_name } = body;\r\n          if (field_name) {\r\n            const itemByName = await env.DB.prepare(`\r\n              SELECT id FROM inspection_items \r\n              WHERE inspection_id = ? AND item_description = ?\r\n            `).bind(inspectionId, field_name).first() as any;\r\n\r\n            if (itemByName) {\r\n              resolvedItemId = itemByName.id;\r\n              console.log(`[MEDIA] Resolved by field_name '${field_name}' to inspection_item.id ${resolvedItemId}`);\r\n            } else {\r\n              // If still not found, set to null to avoid FK error\r\n              console.warn(`[MEDIA] Could not resolve inspection_item_id for fieldId=${inspection_item_id}, field_name=${field_name}`);\r\n              resolvedItemId = null;\r\n            }\r\n          } else {\r\n            console.warn(`[MEDIA] Could not resolve inspection_item_id ${inspection_item_id}, no field_name provided`);\r\n            resolvedItemId = null;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let file_url = '';\r\n    let thumbnail_url = ''; // New variable\r\n\r\n    try {\r\n      // Upload to Supabase Storage\r\n      const supabaseUrl = env.SUPABASE_URL;\r\n      const supabaseServiceKey = env.SUPABASE_SERVICE_ROLE_KEY;\r\n\r\n      if (supabaseUrl && supabaseServiceKey) {\r\n        // Use Supabase Storage\r\n        const supabase = createClient(supabaseUrl, supabaseServiceKey);\r\n\r\n        // Convert base64 to binary\r\n        const base64Data = file_data.split(',')[1];\r\n        const binaryData = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));\r\n\r\n        // Generate unique file path\r\n        const timestamp = Date.now();\r\n        const sanitizedFileName = file_name.replace(/[^a-zA-Z0-9.-]/g, '_');\r\n        const filePath = `${inspectionId}/${timestamp}_${sanitizedFileName}`;\r\n\r\n        const { data: uploadData, error: uploadError } = await supabase.storage\r\n          .from('inspection-media')\r\n          .upload(filePath, binaryData, {\r\n            contentType: mime_type,\r\n            upsert: false\r\n          });\r\n\r\n        if (uploadError) {\r\n          console.error('Supabase Storage error:', uploadError);\r\n          throw new Error(uploadError.message);\r\n        }\r\n\r\n        // Get public URL\r\n        const { data: urlData } = supabase.storage\r\n          .from('inspection-media')\r\n          .getPublicUrl(filePath);\r\n\r\n        file_url = urlData.publicUrl;\r\n\r\n        // Process Thumbnail if present\r\n        if (thumbnail_data) {\r\n          try {\r\n            const thumbBase64 = thumbnail_data.split(',')[1];\r\n            const thumbBinary = Uint8Array.from(atob(thumbBase64), c => c.charCodeAt(0));\r\n            const thumbPath = `${filePath}_thumb`;\r\n\r\n            const { data: thumbUploadData, error: thumbError } = await supabase.storage\r\n              .from('inspection-media')\r\n              .upload(thumbPath, thumbBinary, {\r\n                contentType: 'image/jpeg', // Assuming thumbs are JPEGs\r\n                upsert: false\r\n              });\r\n\r\n            if (!thumbError) {\r\n              const { data: thumbUrlData } = supabase.storage\r\n                .from('inspection-media')\r\n                .getPublicUrl(thumbPath);\r\n              thumbnail_url = thumbUrlData.publicUrl;\r\n            } else {\r\n              console.warn('Thumbnail upload failed:', thumbError);\r\n            }\r\n          } catch (e) {\r\n            console.warn('Error processing thumbnail:', e);\r\n          }\r\n        }\r\n\r\n      } else {\r\n        // Fallback: Store base64 reference (truncated for DB)\r\n        // This is a workaround - store just a marker and keep base64 client-side\r\n        console.warn('Supabase Storage not configured, using fallback');\r\n        file_url = `local:${file_name}`;\r\n        if (thumbnail_data) {\r\n          thumbnail_url = `local:thumb_${file_name}`;\r\n        }\r\n      }\r\n\r\n      const now = new Date().toISOString();\r\n\r\n      // Insert media record with storage URL and geolocation\r\n      const result = await env.DB.prepare(`\r\n        INSERT INTO inspection_media (\r\n          inspection_id, inspection_item_id, media_type, file_name, file_url, thumbnail_url,\r\n          file_size, mime_type, description, latitude, longitude, captured_at, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n        RETURNING id\r\n      `).bind(\r\n        inspectionId,\r\n        resolvedItemId || null,\r\n        media_type,\r\n        file_name,\r\n        file_url,\r\n        thumbnail_url,\r\n        file_size,\r\n        mime_type,\r\n        description || null,\r\n        latitude || null,\r\n        longitude || null,\r\n        captured_at || now,\r\n        now,\r\n        now\r\n      ).run();\r\n\r\n      return c.json({\r\n        success: true,\r\n        media: {\r\n          id: result.meta.last_row_id,\r\n          file_url: file_url,\r\n          media_type: media_type,\r\n          file_name: file_name,\r\n          latitude: latitude || null,\r\n          longitude: longitude || null,\r\n          captured_at: captured_at || now\r\n        },\r\n        message: \"Upload realizado com sucesso\"\r\n      });\r\n\r\n    } catch (storageError) {\r\n      console.error('Storage error:', storageError);\r\n      return c.json({\r\n        error: \"Erro ao armazenar arquivo\",\r\n        details: String(storageError)\r\n      }, 500);\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Error uploading media:', error);\r\n    return c.json({\r\n      error: \"Erro ao fazer upload\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Get media for inspection\r\nmediaRoutes.get(\"/:inspectionId/media\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"inspectionId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Verify inspection access\r\n    const inspection = await env.DB.prepare(`\r\n      SELECT i.*, u.organization_id as user_org_id\r\n      FROM inspections i\r\n      JOIN users u ON u.id = ?\r\n      WHERE i.id = ?\r\n    `).bind(user.id, inspectionId).first() as any;\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: \"Inspeção não encontrada\" }, 404);\r\n    }\r\n\r\n    // Get all media for the inspection\r\n    const media = await env.DB.prepare(`\r\n      SELECT * FROM inspection_media \r\n      WHERE inspection_id = ?\r\n      ORDER BY created_at DESC\r\n    `).bind(inspectionId).all();\r\n\r\n    return c.json({ media: media.results });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching media:', error);\r\n    return c.json({\r\n      error: \"Erro ao buscar mídia\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Delete media\r\nmediaRoutes.delete(\"/:inspectionId/media/:mediaId\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const inspectionId = parseInt(c.req.param(\"inspectionId\"));\r\n  const mediaId = parseInt(c.req.param(\"mediaId\"));\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get media record first\r\n    const media = await env.DB.prepare(`\r\n      SELECT * FROM inspection_media WHERE id = ? AND inspection_id = ?\r\n    `).bind(mediaId, inspectionId).first() as any;\r\n\r\n    if (!media) {\r\n      return c.json({ error: \"Mídia não encontrada\" }, 404);\r\n    }\r\n\r\n    // Delete from Supabase Storage if applicable\r\n    const supabaseUrl = env.SUPABASE_URL;\r\n    const supabaseServiceKey = env.SUPABASE_SERVICE_ROLE_KEY;\r\n\r\n    if (supabaseUrl && supabaseServiceKey && media.file_url && !media.file_url.startsWith('local:')) {\r\n      try {\r\n        const supabase = createClient(supabaseUrl, supabaseServiceKey);\r\n        // Extract path from URL\r\n        const urlParts = media.file_url.split('/inspection-media/');\r\n        if (urlParts[1]) {\r\n          await supabase.storage.from('inspection-media').remove([urlParts[1]]);\r\n        }\r\n      } catch (e) {\r\n        console.error('Error deleting from storage:', e);\r\n      }\r\n    }\r\n\r\n    // Delete from database\r\n    await env.DB.prepare(`DELETE FROM inspection_media WHERE id = ?`).bind(mediaId).run();\r\n\r\n    return c.json({ success: true, message: \"Mídia excluída com sucesso\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error deleting media:', error);\r\n    return c.json({\r\n      error: \"Erro ao excluir mídia\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\nexport default mediaRoutes;\r\n"},{"name":"multi-tenant-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware as authMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n};\r\n\r\nconst multiTenantRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Middleware to check if user can manage organizations\r\nconst requireOrgAdmin = async (c: any, next: any) => {\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await c.env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile) {\r\n    return c.json({ error: \"User profile not found\" }, 404);\r\n  }\r\n\r\n  // System admin can do anything\r\n  if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {\r\n    return next();\r\n  }\r\n\r\n  // Org admin can manage their organization and subsidiaries\r\n  if (userProfile.role === USER_ROLES.ORG_ADMIN && userProfile.can_manage_users) {\r\n    return next();\r\n  }\r\n\r\n  return c.json({ error: \"Insufficient permissions\" }, 403);\r\n};\r\n\r\n// Create a new organization hierarchy (for system admin or org admin creating subsidiaries)\r\nmultiTenantRoutes.post(\"/organizations/hierarchy\", authMiddleware, requireOrgAdmin, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  const body = await c.req.json();\r\n  const {\r\n    name, type, description, contact_email, contact_phone, address, parent_organization_id,\r\n    subscription_plan, max_users, max_subsidiaries,\r\n    // New professional fields\r\n    cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao, natureza_juridica,\r\n    data_abertura, capital_social, porte_empresa, situacao_cadastral, numero_funcionarios,\r\n    setor_industria, subsetor_industria, certificacoes_seguranca, data_ultima_auditoria,\r\n    nivel_risco, contato_seguranca_nome, contato_seguranca_email, contato_seguranca_telefone,\r\n    historico_incidentes, observacoes_compliance, website, faturamento_anual\r\n  } = body;\r\n\r\n  try {\r\n    let finalParentOrgId = parent_organization_id;\r\n    let orgLevel = 'company' as const;\r\n\r\n    // SYSTEM_ADMIN has complete privileges and bypasses all restrictions\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {\r\n      // System admin can create organizations at any level without any restrictions\r\n      if (parent_organization_id) {\r\n        orgLevel = 'subsidiary' as any;\r\n        finalParentOrgId = parent_organization_id; // Use the provided parent\r\n      } else {\r\n        orgLevel = 'company' as const;\r\n        finalParentOrgId = null; // Top-level organization\r\n      }\r\n      // No subsidiary limit checks for SYSTEM_ADMIN\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Org admin can create companies/clients or subsidiaries under their managed organization\r\n      if (!userProfile.managed_organization_id) {\r\n        return c.json({ error: \"User is an Org Admin but not assigned to a managed organization.\" }, 400);\r\n      }\r\n      finalParentOrgId = userProfile.managed_organization_id;\r\n\r\n      // Determine organization level based on type\r\n      // If type is explicitly 'subsidiary', treat as subsidiary with limits\r\n      // Otherwise (company, consultancy, client), treat as company level without subsidiary limits\r\n      if (type === 'subsidiary') {\r\n        orgLevel = 'subsidiary' as any;\r\n\r\n        // Check subsidiary limit only for actual subsidiaries\r\n        const subsidiaryCount = await env.DB.prepare(`\r\n          SELECT COUNT(*) as count FROM organizations \r\n          WHERE parent_organization_id = ? AND organization_level = 'subsidiary' AND is_active = true\r\n        `).bind(finalParentOrgId).first() as any;\r\n\r\n        const parentOrg = await env.DB.prepare(\"SELECT max_subsidiaries FROM organizations WHERE id = ?\").bind(finalParentOrgId).first() as any;\r\n\r\n        if (parentOrg && subsidiaryCount.count >= parentOrg.max_subsidiaries) {\r\n          return c.json({ error: \"Maximum number of subsidiaries reached for the parent organization.\" }, 400);\r\n        }\r\n      } else {\r\n        // For companies, consultancies, and clients - treat as company level (no subsidiary limits)\r\n        orgLevel = 'company' as const;\r\n        // No limit check for company-level organizations managed by org admin\r\n      }\r\n    }\r\n\r\n    const result = await env.DB.prepare(`\r\n      INSERT INTO organizations (\r\n        name, type, description, contact_email, contact_phone, address,\r\n        parent_organization_id, organization_level, subscription_status, \r\n        subscription_plan, max_users, max_subsidiaries, is_active,\r\n        cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao, natureza_juridica,\r\n        data_abertura, capital_social, porte_empresa, situacao_cadastral, numero_funcionarios,\r\n        setor_industria, subsetor_industria, certificacoes_seguranca, data_ultima_auditoria,\r\n        nivel_risco, contato_seguranca_nome, contato_seguranca_email, contato_seguranca_telefone,\r\n        historico_incidentes, observacoes_compliance, website, faturamento_anual,\r\n        created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n    `).bind(\r\n      name,\r\n      type || 'company',\r\n      description || null,\r\n      contact_email || null,\r\n      contact_phone || null,\r\n      address || null,\r\n      finalParentOrgId || null,\r\n      orgLevel,\r\n      'active', // Default status\r\n      subscription_plan || 'basic', // Default plan\r\n      max_users || 50,\r\n      max_subsidiaries || 0,\r\n      true, // Active by default\r\n      // New professional fields\r\n      cnpj || null,\r\n      razao_social || null,\r\n      nome_fantasia || null,\r\n      cnae_principal || null,\r\n      cnae_descricao || null,\r\n      natureza_juridica || null,\r\n      data_abertura || null,\r\n      capital_social || null,\r\n      porte_empresa || null,\r\n      situacao_cadastral || null,\r\n      numero_funcionarios || null,\r\n      setor_industria || null,\r\n      subsetor_industria || null,\r\n      certificacoes_seguranca || null,\r\n      data_ultima_auditoria || null,\r\n      nivel_risco || 'medio',\r\n      contato_seguranca_nome || null,\r\n      contato_seguranca_email || null,\r\n      contato_seguranca_telefone || null,\r\n      historico_incidentes || null,\r\n      observacoes_compliance || null,\r\n      website || null,\r\n      faturamento_anual || null\r\n    ).run();\r\n\r\n    const organizationId = result.meta.last_row_id as number;\r\n\r\n    // Log activity\r\n    if (user) {\r\n      await env.DB.prepare(`\r\n        INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n        VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n      `).bind(\r\n        user.id,\r\n        organizationId,\r\n        'organization_created',\r\n        `Created organization: ${name}`,\r\n        'organization',\r\n        organizationId.toString()\r\n      ).run();\r\n    }\r\n\r\n    return c.json({\r\n      id: organizationId,\r\n      message: \"Organization created successfully in hierarchy\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating organization:', error);\r\n    return c.json({ error: \"Failed to create organization\" }, 500);\r\n  }\r\n});\r\n\r\n// Invite user to organization\r\nmultiTenantRoutes.post(\"/organizations/:id/invite-user\", authMiddleware, requireOrgAdmin, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    const organizationId = parseInt(c.req.param(\"id\"));\r\n\r\n    if (isNaN(organizationId)) {\r\n      return c.json({ error: \"Invalid organization ID\" }, 400);\r\n    }\r\n\r\n    const body = await c.req.json();\r\n    const { email, role } = body;\r\n\r\n    if (!email || !role) {\r\n      return c.json({ error: \"Email and role are required\" }, 400);\r\n    }\r\n\r\n    // Verify the user can invite to this organization\r\n    if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Org admin can only invite to their managed organization or its subsidiaries\r\n      const org = await env.DB.prepare(`\r\n        SELECT id FROM organizations \r\n        WHERE id = ? AND (id = ? OR parent_organization_id = ?)\r\n      `).bind(organizationId, userProfile.managed_organization_id, userProfile.managed_organization_id).first();\r\n\r\n      if (!org) {\r\n        return c.json({ error: \"Cannot invite users to this organization due to scope limitations.\" }, 403);\r\n      }\r\n      // Org admin can only invite roles within their allowed scope (e.g., no other org_admins)\r\n      if (role === USER_ROLES.ORG_ADMIN || role === USER_ROLES.SYSTEM_ADMIN) {\r\n        return c.json({ error: `Org Admins cannot invite users with the role: ${role}.` }, 403);\r\n      }\r\n    }\r\n\r\n    // Check if user already exists\r\n    const existingUser = await env.DB.prepare(\"SELECT id FROM users WHERE email = ?\").bind(email).first();\r\n    if (existingUser) {\r\n      return c.json({ error: \"A user with this email already exists in the system.\" }, 400);\r\n    }\r\n\r\n    // Check for existing invitation\r\n    const existingInvitation = await env.DB.prepare(`\r\n      SELECT id FROM user_invitations \r\n      WHERE email = ? AND organization_id = ? AND accepted_at IS NULL AND expires_at > NOW()\r\n    `).bind(email, organizationId).first();\r\n\r\n    if (existingInvitation) {\r\n      return c.json({ error: \"An active invitation already exists for this email and organization.\" }, 400);\r\n    }\r\n\r\n    // Generate invitation token\r\n    const invitationToken = self.crypto.randomUUID();\r\n    const expiresAt = new Date();\r\n    expiresAt.setDate(expiresAt.getDate() + 7); // 7 days expiration\r\n\r\n    // Create invitation\r\n    await env.DB.prepare(`\r\n      INSERT INTO user_invitations (\r\n        email, organization_id, role, invited_by, invitation_token, \r\n        expires_at, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n    `).bind(\r\n      email,\r\n      organizationId,\r\n      role,\r\n      user.id,\r\n      invitationToken,\r\n      expiresAt.toISOString()\r\n    ).run();\r\n\r\n    // Log activity\r\n    if (user) {\r\n      await env.DB.prepare(`\r\n        INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n        VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n      `).bind(\r\n        user.id,\r\n        organizationId,\r\n        'user_invited',\r\n        `Invited user: ${email} with role: ${role}`,\r\n        'user',\r\n        email\r\n      ).run();\r\n    }\r\n\r\n    // In a real implementation, you would send an email here\r\n    const invitationUrl = `${c.req.header('origin') || 'https://localhost'}/accept-invitation/${invitationToken}`;\r\n\r\n    return c.json({\r\n      invitation_token: invitationToken,\r\n      invitation_url: invitationUrl,\r\n      expires_at: expiresAt.toISOString(),\r\n      message: \"User invitation created successfully.\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating invitation:', error);\r\n    return c.json({ error: \"Failed to create invitation.\" }, 500);\r\n  }\r\n});\r\n\r\n// Get invitation details moved to main index.ts for public access\r\n\r\n// Accept invitation moved to main index.ts for public access\r\n\r\n// Get organizations list (basic endpoint for user profile and other components)\r\nmultiTenantRoutes.get(\"/organizations\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile) {\r\n    return c.json({ error: \"User profile not found.\" }, 404);\r\n  }\r\n\r\n  try {\r\n    let query = `\r\n      SELECT o.id, o.name, o.type, o.description, o.is_active\r\n      FROM organizations o\r\n    `;\r\n\r\n    let params: any[] = [];\r\n\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {\r\n      // System admin sees ALL active organizations\r\n      query += \" WHERE o.is_active = true ORDER BY o.name ASC\";\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Org admin sees their organization and subsidiaries/clients\r\n      query += ` \r\n        WHERE (o.id = ? OR o.parent_organization_id = ?) AND o.is_active = true\r\n        ORDER BY o.name ASC\r\n      `;\r\n      params = [userProfile.managed_organization_id, userProfile.managed_organization_id];\r\n    } else {\r\n      // Other roles see only their organization\r\n      query += \" WHERE o.id = ? AND o.is_active = true ORDER BY o.name ASC\";\r\n      params = [userProfile.organization_id];\r\n    }\r\n\r\n    const organizations = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    return c.json({\r\n      organizations: organizations.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching organizations:', error);\r\n    return c.json({ error: \"Failed to fetch organizations.\" }, 500);\r\n  }\r\n});\r\n\r\n// Get organization hierarchy (for system admin and org admin) - Available at both /organizations/hierarchy and /hierarchy\r\nmultiTenantRoutes.get(\"/organizations/hierarchy\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile) {\r\n    return c.json({ error: \"User profile not found.\" }, 404);\r\n  }\r\n\r\n  try {\r\n    let query = `\r\n      SELECT o.*, \r\n             (SELECT COUNT(id) FROM users WHERE organization_id = o.id AND is_active = true) as user_count,\r\n             (SELECT COUNT(id) FROM organizations WHERE parent_organization_id = o.id AND is_active = true) as subsidiary_count,\r\n             po.name as parent_organization_name\r\n      FROM organizations o\r\n      LEFT JOIN organizations po ON o.parent_organization_id = po.id\r\n    `;\r\n\r\n    let params: any[] = [];\r\n\r\n    console.log('User profile:', userProfile.role, 'managed_org_id:', userProfile.managed_organization_id);\r\n\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {\r\n      // System admin sees ALL organizations (active and inactive)\r\n      query += \" WHERE o.is_active = true ORDER BY o.organization_level, o.name ASC\";\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Org admin sees their organization and subsidiaries/clients (only active ones)\r\n      // Include their managed organization AND any organizations that have it as parent\r\n      query += ` \r\n        WHERE (o.id = ? OR o.parent_organization_id = ?) AND o.is_active = true\r\n        ORDER BY \r\n          CASE \r\n            WHEN o.id = ? THEN 0 \r\n            WHEN o.organization_level = 'company' THEN 1\r\n            WHEN o.organization_level = 'subsidiary' THEN 2\r\n            ELSE 3\r\n          END,\r\n          o.name ASC\r\n      `;\r\n      params = [userProfile.managed_organization_id, userProfile.managed_organization_id, userProfile.managed_organization_id];\r\n    } else {\r\n      // Other roles see only their organization (only active ones)\r\n      query += \" WHERE o.id = ? AND o.is_active = true ORDER BY o.organization_level, o.name ASC\";\r\n      params = [userProfile.organization_id];\r\n    }\r\n\r\n    console.log('Query:', query);\r\n    console.log('Params:', params);\r\n\r\n    const organizations = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    console.log('Found organizations:', organizations.results?.length || 0);\r\n\r\n    return c.json({\r\n      organizations: organizations.results || [],\r\n      user_role: userProfile.role,\r\n      can_manage: userProfile.can_manage_users || userProfile.role === USER_ROLES.SYSTEM_ADMIN,\r\n      debug: {\r\n        user_id: user.id,\r\n        managed_organization_id: userProfile.managed_organization_id,\r\n        role: userProfile.role\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching organization hierarchy:', error);\r\n    return c.json({ error: \"Failed to fetch organization hierarchy.\" }, 500);\r\n  }\r\n});\r\n\r\n// Get users within organization scope\r\nmultiTenantRoutes.get(\"/organizations/:id/users\", authMiddleware, requireOrgAdmin, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n  const organizationId = parseInt(c.req.param(\"id\"));\r\n\r\n  try {\r\n    let query = `\r\n      SELECT u.id, u.email, u.name, u.role, u.organization_id, u.phone, u.avatar_url, u.is_active, u.last_login_at, u.created_at,\r\n             o.name as organization_name\r\n      FROM users u\r\n      LEFT JOIN organizations o ON u.organization_id = o.id\r\n    `;\r\n\r\n    let params: any[] = [];\r\n    let whereClause = [];\r\n\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {\r\n      // System admin can see users from any organization\r\n      whereClause.push(\"u.organization_id = ?\");\r\n      params.push(organizationId);\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Org admin can see users from their organization and subsidiaries\r\n      whereClause.push(`u.organization_id IN (\r\n        SELECT id FROM organizations \r\n        WHERE id = ? OR parent_organization_id = ?\r\n      )`);\r\n      params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n    } else {\r\n      return c.json({ error: \"Insufficient permissions.\" }, 403);\r\n    }\r\n\r\n    if (whereClause.length > 0) {\r\n      query += \" WHERE \" + whereClause.join(\" AND \");\r\n    }\r\n\r\n    query += \" ORDER BY u.created_at DESC\";\r\n\r\n    const users = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    // Also get pending invitations for this organization\r\n    const invitations = await env.DB.prepare(`\r\n      SELECT ui.*, u.name as inviter_name\r\n      FROM user_invitations ui\r\n      LEFT JOIN users u ON ui.invited_by = u.id\r\n      WHERE ui.organization_id = ? AND ui.accepted_at IS NULL AND ui.expires_at > NOW()\r\n      ORDER BY ui.created_at DESC\r\n    `).bind(organizationId).all();\r\n\r\n    return c.json({\r\n      users: users.results,\r\n      pending_invitations: invitations.results\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching organization users:', error);\r\n    return c.json({ error: \"Failed to fetch organization users.\" }, 500);\r\n  }\r\n});\r\n\r\n// Update user role within organization (for org admins)\r\nmultiTenantRoutes.put(\"/organizations/:orgId/users/:userId\", authMiddleware, requireOrgAdmin, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n  const organizationId = parseInt(c.req.param(\"orgId\"));\r\n  const targetUserId = c.req.param(\"userId\");\r\n\r\n  const body = await c.req.json();\r\n  const { role, is_active } = body;\r\n\r\n  try {\r\n    // Verify target user belongs to organization scope\r\n    const targetUser = await env.DB.prepare(`\r\n      SELECT u.*, o.parent_organization_id \r\n      FROM users u\r\n      LEFT JOIN organizations o ON u.organization_id = o.id\r\n      WHERE u.id = ?\r\n    `).bind(targetUserId).first() as any;\r\n\r\n    if (!targetUser) {\r\n      return c.json({ error: \"Target user not found.\" }, 404);\r\n    }\r\n\r\n    // Check permissions\r\n    if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      const canManage = targetUser.organization_id === userProfile.managed_organization_id ||\r\n        targetUser.parent_organization_id === userProfile.managed_organization_id; // Check if it's a direct subsidiary\r\n\r\n      if (!canManage) {\r\n        return c.json({ error: \"Cannot manage users outside your assigned organization scope.\" }, 403);\r\n      }\r\n\r\n      // Org admin cannot assign roles higher than or equal to their own, except for basic roles\r\n      if (role === USER_ROLES.ORG_ADMIN || role === USER_ROLES.SYSTEM_ADMIN) {\r\n        return c.json({ error: `Org Admins cannot assign role: ${role}.` }, 403);\r\n      }\r\n    }\r\n\r\n    // Update user\r\n    const updateFields = [];\r\n    const updateValues = [];\r\n\r\n    if (role !== undefined) {\r\n      updateFields.push(\"role = ?\");\r\n      updateValues.push(role);\r\n    }\r\n\r\n    if (is_active !== undefined) {\r\n      updateFields.push(\"is_active = ?\");\r\n      updateValues.push(is_active);\r\n    }\r\n\r\n    if (updateFields.length > 0) {\r\n      updateFields.push(\"updated_at = NOW()\");\r\n\r\n      await env.DB.prepare(`\r\n        UPDATE users SET ${updateFields.join(\", \")} WHERE id = ?\r\n      `).bind(...updateValues, targetUserId).run();\r\n\r\n      // Log activity\r\n      if (user) {\r\n        await env.DB.prepare(`\r\n          INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n          VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n        `).bind(\r\n          user.id,\r\n          organizationId,\r\n          'user_updated',\r\n          `Updated user: ${targetUser.email} - Role: ${role}, Active: ${is_active}`,\r\n          'user',\r\n          targetUserId\r\n        ).run();\r\n      }\r\n    }\r\n\r\n    return c.json({ message: \"User updated successfully.\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating user:', error);\r\n    return c.json({ error: \"Failed to update user.\" }, 500);\r\n  }\r\n});\r\n\r\n// Update organization (PUT endpoint)\r\nmultiTenantRoutes.put(\"/organizations/:id\", authMiddleware, requireOrgAdmin, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const organizationId = parseInt(c.req.param(\"id\"));\r\n    const body = await c.req.json();\r\n\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    // Verify permissions\r\n    if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      const orgToUpdate = await env.DB.prepare(\"SELECT * FROM organizations WHERE id = ?\").bind(organizationId).first() as any;\r\n      if (!orgToUpdate || (orgToUpdate.id !== userProfile.managed_organization_id && orgToUpdate.parent_organization_id !== userProfile.managed_organization_id)) {\r\n        return c.json({ error: \"Permissões insuficientes para atualizar esta organização.\" }, 403);\r\n      }\r\n    }\r\n\r\n    // Build dynamic update query\r\n    const updateFields = [];\r\n    const updateValues = [];\r\n\r\n    const allowedFields = [\r\n      'name', 'type', 'description', 'contact_email', 'contact_phone', 'address',\r\n      'subscription_plan', 'max_users', 'max_subsidiaries', 'cnpj', 'razao_social',\r\n      'nome_fantasia', 'cnae_principal', 'cnae_descricao', 'natureza_juridica',\r\n      'data_abertura', 'capital_social', 'porte_empresa', 'situacao_cadastral',\r\n      'numero_funcionarios', 'setor_industria', 'subsetor_industria',\r\n      'certificacoes_seguranca', 'data_ultima_auditoria', 'nivel_risco',\r\n      'contato_seguranca_nome', 'contato_seguranca_email', 'contato_seguranca_telefone',\r\n      'historico_incidentes', 'observacoes_compliance', 'website', 'faturamento_anual'\r\n    ];\r\n\r\n    for (const field of allowedFields) {\r\n      if (body[field] !== undefined) {\r\n        updateFields.push(`${field} = ?`);\r\n        updateValues.push(body[field]);\r\n      }\r\n    }\r\n\r\n    if (updateFields.length === 0) {\r\n      return c.json({ message: \"Nenhum campo válido para atualizar.\" }, 400);\r\n    }\r\n\r\n    updateFields.push(\"updated_at = NOW()\");\r\n\r\n    await env.DB.prepare(`\r\n      UPDATE organizations \r\n      SET ${updateFields.join(\", \")}\r\n      WHERE id = ?\r\n    `).bind(...updateValues, organizationId).run();\r\n\r\n    // Log activity\r\n    if (user) {\r\n      await env.DB.prepare(`\r\n        INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n        VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n      `).bind(\r\n        user.id,\r\n        organizationId,\r\n        'organization_updated',\r\n        `Atualizou organização: ${body.name || organizationId}`,\r\n        'organization',\r\n        organizationId.toString()\r\n      ).run();\r\n    }\r\n\r\n    return c.json({ message: \"Organização atualizada com sucesso!\" });\r\n  } catch (error) {\r\n    console.error('Erro ao atualizar organização:', error);\r\n    return c.json({ error: \"Falha ao atualizar organização.\" }, 500);\r\n  }\r\n});\r\n\r\n// Get activity log for organization\r\nmultiTenantRoutes.get(\"/organizations/:id/activity\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const organizationId = parseInt(c.req.param(\"id\"));\r\n  const limit = parseInt(c.req.query(\"limit\") || \"50\");\r\n  const offset = parseInt(c.req.query(\"offset\") || \"0\");\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  try {\r\n    let query = `\r\n      SELECT al.*, u.name as user_name, u.email as user_email\r\n      FROM activity_log al\r\n      LEFT JOIN users u ON al.user_id = u.id\r\n    `;\r\n\r\n    let params: any[] = [];\r\n    let whereClause = [];\r\n\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN) {\r\n      // System admin can see all activity\r\n      if (organizationId > 0) {\r\n        whereClause.push(\"al.organization_id = ?\");\r\n        params.push(organizationId);\r\n      }\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Org admin can see activity for their organization and subsidiaries\r\n      whereClause.push(`al.organization_id IN (\r\n        SELECT id FROM organizations \r\n        WHERE id = ? OR parent_organization_id = ?\r\n      )`);\r\n      params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n    } else {\r\n      // Other roles see activity for their organization only\r\n      whereClause.push(\"al.organization_id = ?\");\r\n      params.push(userProfile.organization_id);\r\n    }\r\n\r\n    if (whereClause.length > 0) {\r\n      query += \" WHERE \" + whereClause.join(\" AND \");\r\n    }\r\n\r\n    query += \" ORDER BY al.created_at DESC LIMIT ? OFFSET ?\";\r\n    params.push(limit, offset);\r\n\r\n    const activities = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    return c.json({ activities: activities.results });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching activity log:', error);\r\n    return c.json({ error: \"Failed to fetch activity log.\" }, 500);\r\n  }\r\n});\r\n\r\n// Add alternative hierarchy route for compatibility\r\nmultiTenantRoutes.get(\"/hierarchy\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile) {\r\n    return c.json({ error: \"User profile not found.\" }, 404);\r\n  }\r\n\r\n  try {\r\n    let query = `\r\n      SELECT o.*, \r\n             (SELECT COUNT(id) FROM users WHERE organization_id = o.id AND is_active = true) as user_count,\r\n             (SELECT COUNT(id) FROM organizations WHERE parent_organization_id = o.id AND is_active = true) as subsidiary_count,\r\n             po.name as parent_organization_name\r\n      FROM organizations o\r\n      LEFT JOIN organizations po ON o.parent_organization_id = po.id\r\n    `;\r\n\r\n    let params: any[] = [];\r\n\r\n    console.log('User profile:', userProfile.role, 'managed_org_id:', userProfile.managed_organization_id);\r\n\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN) {\r\n      // System admin sees ALL organizations (active and inactive)\r\n      query += \" WHERE o.is_active = true ORDER BY o.organization_level, o.name ASC\";\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Org admin sees their organization and subsidiaries/clients (only active ones)\r\n      // Include their managed organization AND any organizations that have it as parent\r\n      query += ` \r\n        WHERE (o.id = ? OR o.parent_organization_id = ?) AND o.is_active = true\r\n        ORDER BY \r\n          CASE \r\n            WHEN o.id = ? THEN 0 \r\n            WHEN o.organization_level = 'company' THEN 1\r\n            WHEN o.organization_level = 'subsidiary' THEN 2\r\n            ELSE 3\r\n          END,\r\n          o.name ASC\r\n      `;\r\n      params = [userProfile.managed_organization_id, userProfile.managed_organization_id, userProfile.managed_organization_id];\r\n    } else {\r\n      // Other roles see only their organization (only active ones)\r\n      query += \" WHERE o.id = ? AND o.is_active = true ORDER BY o.organization_level, o.name ASC\";\r\n      params = [userProfile.organization_id];\r\n    }\r\n\r\n    console.log('Query:', query);\r\n    console.log('Params:', params);\r\n\r\n    const organizations = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    console.log('Found organizations:', organizations.results?.length || 0);\r\n\r\n    return c.json({\r\n      organizations: organizations.results || [],\r\n      user_role: userProfile.role,\r\n      can_manage: userProfile.can_manage_users || userProfile.role === USER_ROLES.SYSTEM_ADMIN,\r\n      debug: {\r\n        user_id: user.id,\r\n        managed_organization_id: userProfile.managed_organization_id,\r\n        role: userProfile.role\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching organization hierarchy:', error);\r\n    return c.json({ error: \"Failed to fetch organization hierarchy.\" }, 500);\r\n  }\r\n});\r\n\r\nexport default multiTenantRoutes;\r\n\r\n"},{"name":"notifications-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\n\r\nconst notificationsRoutes = new Hono<{ Bindings: any; Variables: { user: any } }>();\r\n\r\n// List notifications\r\nnotificationsRoutes.get(\"/\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const limit = parseInt(c.req.query(\"limit\") || \"50\");\r\n\r\n    if (!user) return c.json({ error: \"Unauthorized\" }, 401);\r\n\r\n    try {\r\n        const results = await env.DB.prepare(`\r\n            SELECT * FROM notifications \r\n            WHERE user_id = ? \r\n            ORDER BY created_at DESC \r\n            LIMIT ?\r\n        `).bind(user.id, limit).all();\r\n\r\n        // Count unread\r\n        const countResult = await env.DB.prepare(`\r\n            SELECT COUNT(*) as count FROM notifications \r\n            WHERE user_id = ? AND read = false\r\n        `).bind(user.id).first();\r\n\r\n        return c.json({\r\n            notifications: results.results || [],\r\n            unread_count: countResult?.count || 0\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error fetching notifications:\", error);\r\n        return c.json({ error: \"Failed to fetch notifications\" }, 500);\r\n    }\r\n});\r\n\r\n// Mark as read\r\nnotificationsRoutes.post(\"/:id/read\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n    const id = c.req.param(\"id\");\r\n\r\n    if (!user) return c.json({ error: \"Unauthorized\" }, 401);\r\n\r\n    try {\r\n        await env.DB.prepare(`\r\n            UPDATE notifications SET read = true WHERE id = ? AND user_id = ?\r\n        `).bind(id, user.id).run();\r\n\r\n        return c.json({ success: true });\r\n    } catch (error) {\r\n        return c.json({ error: \"Failed to update\" }, 500);\r\n    }\r\n});\r\n\r\n// Mark all as read\r\nnotificationsRoutes.post(\"/read-all\", tenantAuthMiddleware, async (c) => {\r\n    const env = c.env;\r\n    const user = c.get(\"user\");\r\n\r\n    if (!user) return c.json({ error: \"Unauthorized\" }, 401);\r\n\r\n    try {\r\n        await env.DB.prepare(`\r\n            UPDATE notifications SET read = true WHERE user_id = ? AND read = false\r\n        `).bind(user.id).run();\r\n\r\n        return c.json({ success: true });\r\n    } catch (error) {\r\n        return c.json({ error: \"Failed to update\" }, 500);\r\n    }\r\n});\r\n\r\nexport default notificationsRoutes;\r\n"},{"name":"openai-assistants-service.ts","content":"// OpenAI Assistants Service for NR compliance analysis\nimport OpenAI from \"openai\";\n\n// Assistant configurations for different NR standards\nexport const ASSISTANTS = {\n  'NR-01': {\n    id: 'asst_nr01',\n    name: 'Assistente NR-01',\n    description: 'Disposições Gerais e Gerenciamento de Riscos Ocupacionais',\n    instructions: `Você é um especialista em NR-01 - Disposições Gerais e Gerenciamento de Riscos Ocupacionais. \n    Analise situações de trabalho e forneça orientações sobre:\n    - Programa de Gerenciamento de Riscos (PGR)\n    - Inventário de riscos\n    - Plano de ação\n    - Medidas de prevenção\n    - Treinamentos obrigatórios\n    Sempre cite os itens específicos da norma e forneça recomendações práticas.`\n  },\n  'NR-05': {\n    id: 'asst_nr05', \n    name: 'Assistente NR-05',\n    description: 'Comissão Interna de Prevenção de Acidentes e Assédio (CIPA)',\n    instructions: `Você é um especialista em NR-05 - CIPA. Analise e oriente sobre:\n    - Dimensionamento da CIPA\n    - Processo eleitoral\n    - Atribuições e responsabilidades\n    - Treinamento de cipeiros\n    - Mapa de riscos\n    - SIPAT\n    Forneça orientações práticas e conformidade normativa.`\n  },\n  'NR-06': {\n    id: 'asst_nr06',\n    name: 'Assistente NR-06',\n    description: 'Equipamento de Proteção Individual (EPI)',\n    instructions: `Você é um especialista em NR-06 - EPIs. Analise e oriente sobre:\n    - Seleção adequada de EPIs\n    - Certificado de Aprovação (CA)\n    - Responsabilidades do empregador e empregado\n    - Treinamento e uso correto\n    - Guarda e conservação\n    - Substituição e higienização\n    Forneça recomendações específicas para cada situação.`\n  },\n  'NR-07': {\n    id: 'asst_nr07',\n    name: 'Assistente NR-07',\n    description: 'Programa de Controle Médico de Saúde Ocupacional (PCMSO)',\n    instructions: `Você é um especialista em NR-07 - PCMSO. Analise e oriente sobre:\n    - Estruturação do PCMSO\n    - Exames médicos obrigatórios\n    - ASO (Atestado de Saúde Ocupacional)\n    - Periodicidade de exames\n    - Relatório analítico\n    - Prontuário médico\n    Forneça orientações médicas ocupacionais adequadas.`\n  },\n  'NR-09': {\n    id: 'asst_nr09',\n    name: 'Assistente NR-09',\n    description: 'Avaliação e Controle das Exposições Ocupacionais',\n    instructions: `Você é um especialista em NR-09 - Exposições Ocupacionais. Analise e oriente sobre:\n    - Agentes físicos, químicos e biológicos\n    - Limites de tolerância\n    - Medidas de controle\n    - Monitoramento de exposição\n    - EPCs e EPIs adequados\n    - Laudos técnicos\n    Forneça análises técnicas detalhadas.`\n  },\n  'NR-10': {\n    id: 'asst_nr10',\n    name: 'Assistente NR-10',\n    description: 'Segurança em Instalações e Serviços em Eletricidade',\n    instructions: `Você é um especialista em NR-10 - Eletricidade. Analise e oriente sobre:\n    - Prontuário de instalações elétricas\n    - Medidas de controle do risco elétrico\n    - Medidas de proteção coletiva e individual\n    - Segurança em projetos\n    - Procedimentos de trabalho\n    - Situação de emergência\n    - Qualificação, habilitação e autorização\n    Forneça orientações técnicas de segurança elétrica.`\n  },\n  'NR-11': {\n    id: 'asst_nr11',\n    name: 'Assistente NR-11',\n    description: 'Transporte, Movimentação, Armazenagem e Manuseio de Materiais',\n    instructions: `Você é um especialista em NR-11. Analise e oriente sobre:\n    - Operação de equipamentos de transporte\n    - Movimentação de cargas\n    - Armazenamento seguro\n    - Capacitação de operadores\n    - Sinalização e demarcação\n    - Inspeção de equipamentos\n    Forneça orientações práticas de segurança.`\n  },\n  'NR-12': {\n    id: 'asst_nr12',\n    name: 'Assistente NR-12',\n    description: 'Segurança no Trabalho em Máquinas e Equipamentos',\n    instructions: `Você é um especialista em NR-12 - Máquinas. Analise e oriente sobre:\n    - Proteções de máquinas\n    - Dispositivos de segurança\n    - Sistemas de segurança\n    - Manutenção e inspeção\n    - Manual de instruções\n    - Capacitação\n    - Inventário de máquinas\n    Forneça análises técnicas detalhadas de segurança.`\n  },\n  'NR-15': {\n    id: 'asst_nr15',\n    name: 'Assistente NR-15',\n    description: 'Atividades e Operações Insalubres',\n    instructions: `Você é um especialista em NR-15 - Insalubridade. Analise e oriente sobre:\n    - Agentes insalubres\n    - Limites de tolerância\n    - Graus de insalubridade (10%, 20%, 40%)\n    - Laudos de insalubridade\n    - Medidas de eliminação ou neutralização\n    - Adicional de insalubridade\n    Forneça análises técnicas e orientações legais.`\n  },\n  'NR-16': {\n    id: 'asst_nr16',\n    name: 'Assistente NR-16',\n    description: 'Atividades e Operações Perigosas',\n    instructions: `Você é um especialista em NR-16 - Periculosidade. Analise e oriente sobre:\n    - Atividades com explosivos\n    - Atividades com inflamáveis\n    - Trabalho com energia elétrica\n    - Atividades com radiações ionizantes\n    - Segurança pessoal e patrimonial\n    - Adicional de periculosidade (30%)\n    Forneça análises técnicas e orientações legais.`\n  },\n  'NR-17': {\n    id: 'asst_nr17',\n    name: 'Assistente NR-17',\n    description: 'Ergonomia',\n    instructions: `Você é um especialista em NR-17 - Ergonomia. Analise e oriente sobre:\n    - Análise Ergonômica do Trabalho (AET)\n    - Mobiliário dos postos de trabalho\n    - Equipamentos dos postos de trabalho\n    - Condições ambientais de trabalho\n    - Organização do trabalho\n    - Pausas e descansos\n    Forneça recomendações ergonômicas específicas.`\n  },\n  'NR-18': {\n    id: 'asst_nr18',\n    name: 'Assistente NR-18',\n    description: 'Segurança e Saúde na Indústria da Construção',\n    instructions: `Você é um especialista em NR-18 - Construção Civil. Analise e oriente sobre:\n    - PCMAT (Programa de Condições e Meio Ambiente de Trabalho)\n    - Áreas de vivência\n    - Demolição e escavações\n    - Trabalho em altura\n    - Andaimes e plataformas\n    - Instalações elétricas temporárias\n    - Proteções coletivas\n    Forneça orientações específicas para canteiros de obras.`\n  },\n  'NR-23': {\n    id: 'asst_nr23',\n    name: 'Assistente NR-23',\n    description: 'Proteção Contra Incêndios',\n    instructions: `Você é um especialista em NR-23 - Proteção Contra Incêndios. Analise e oriente sobre:\n    - Saídas de emergência\n    - Combate ao fogo\n    - Exercício de alerta\n    - Classes de fogo\n    - Extintores adequados\n    - Sistemas de alarme\n    - Iluminação de emergência\n    Forneça orientações de prevenção e combate a incêndios.`\n  },\n  'NR-24': {\n    id: 'asst_nr24',\n    name: 'Assistente NR-24',\n    description: 'Condições Sanitárias e de Conforto',\n    instructions: `Você é um especialista em NR-24. Analise e oriente sobre:\n    - Instalações sanitárias\n    - Vestiários\n    - Refeitórios\n    - Cozinhas\n    - Alojamentos\n    - Condições de higiene e conforto\n    Forneça orientações sobre condições adequadas.`\n  },\n  'NR-35': {\n    id: 'asst_nr35',\n    name: 'Assistente NR-35',\n    description: 'Trabalho em Altura',\n    instructions: `Você é um especialista em NR-35 - Trabalho em Altura. Analise e oriente sobre:\n    - Análise de Risco (AR)\n    - Permissão de Trabalho (PT)\n    - Equipamentos de proteção individual\n    - Sistemas de ancoragem\n    - Procedimentos de emergência\n    - Capacitação e treinamento\n    - Aptidão para trabalho em altura\n    Forneça orientações detalhadas de segurança.`\n  },\n  'GENERAL': {\n    id: 'asst_general',\n    name: 'Assistente Geral SST',\n    description: 'Assistente geral para questões de Segurança e Saúde do Trabalho',\n    instructions: `Você é um especialista em Segurança e Saúde do Trabalho (SST) com conhecimento em todas as NRs.\n    Analise situações e forneça orientações sobre:\n    - Identificação de riscos\n    - Medidas de prevenção\n    - Conformidade com NRs\n    - Boas práticas de SST\n    - Gestão de segurança\n    Sempre identifique qual NR se aplica e forneça orientações práticas.`\n  },\n  'CHATBOT': {\n    id: 'asst_chatbot',\n    name: 'Chatbot COMPIA',\n    description: 'Assistente virtual para ajuda geral do sistema',\n    instructions: `Você é o assistente virtual do sistema COMPIA - Inteligência em Segurança do Trabalho.\n    Ajude os usuários com:\n    - Navegação no sistema\n    - Criação de inspeções e checklists\n    - Interpretação de normas de SST\n    - Geração de relatórios\n    - Planos de ação\n    - Dúvidas sobre funcionalidades\n    Seja amigável, claro e objetivo. Sempre forneça exemplos práticos.`\n  }\n};\n\nexport class OpenAIAssistantsService {\n  private client: OpenAI;\n  private assistants: Map<string, any> = new Map();\n\n  constructor(apiKey: string) {\n    this.client = new OpenAI({ apiKey });\n  }\n\n  async initializeAssistants() {\n    try {\n      console.log('[OPENAI-ASSISTANTS] Initializing assistants...');\n      // Create or retrieve assistants\n      for (const [key, config] of Object.entries(ASSISTANTS)) {\n        try {\n          // Try to retrieve existing assistant\n          let assistant;\n          const assistantsList = await this.client.beta.assistants.list();\n          const existing = assistantsList.data.find(a => a.name === config.name);\n          \n          if (existing) {\n            assistant = existing;\n            console.log(`[OPENAI-ASSISTANTS] Found existing assistant: ${key} (${assistant.id})`);\n          } else {\n            // Create new assistant\n            console.log(`[OPENAI-ASSISTANTS] Creating new assistant: ${key}`);\n            assistant = await this.client.beta.assistants.create({\n              name: config.name,\n              instructions: config.instructions,\n              model: \"gpt-4o\", // Using gpt-4o for assistants API compatibility\n              tools: [{ type: \"code_interpreter\" }, { type: \"file_search\" }]\n            });\n            console.log(`[OPENAI-ASSISTANTS] Created assistant: ${key} (${assistant.id})`);\n          }\n          \n          this.assistants.set(key, assistant);\n        } catch (error) {\n          console.error(`[OPENAI-ASSISTANTS] Failed to initialize assistant ${key}:`, error);\n        }\n      }\n      console.log(`[OPENAI-ASSISTANTS] Initialized ${this.assistants.size} assistants`);\n    } catch (error) {\n      console.error('[OPENAI-ASSISTANTS] Failed to initialize assistants:', error);\n    }\n  }\n\n  async analyzeWithAssistant(\n    assistantKey: string, \n    content: string,\n    files?: Array<{ url: string; type: string }>\n  ) {\n    try {\n      const assistant = this.assistants.get(assistantKey) || this.assistants.get('GENERAL');\n      if (!assistant) {\n        throw new Error('Assistant not found');\n      }\n\n      console.log(`[OPENAI-ASSISTANTS] Analyzing with ${assistantKey} assistant (${assistant.id})`);\n\n      // Create thread\n      const thread = await this.client.beta.threads.create();\n\n      // Add message with file attachments if provided\n      const messageData: any = {\n        role: \"user\" as const,\n        content\n      };\n\n      // Handle file attachments\n      if (files && files.length > 0) {\n        const fileIds = [];\n        for (const file of files) {\n          try {\n            // Upload file to OpenAI\n            const uploadedFile = await this.client.files.create({\n              file: await fetch(file.url).then(r => r.blob()),\n              purpose: \"assistants\"\n            });\n            fileIds.push(uploadedFile.id);\n          } catch (fileError) {\n            console.error('[OPENAI-ASSISTANTS] Error uploading file:', fileError);\n          }\n        }\n        if (fileIds.length > 0) {\n          messageData.file_ids = fileIds;\n        }\n      }\n\n      await this.client.beta.threads.messages.create(thread.id, messageData);\n\n      // Run assistant\n      const run = await this.client.beta.threads.runs.create(thread.id, {\n        assistant_id: assistant.id\n      });\n\n      // Wait for completion\n      let runStatus = await this.client.beta.threads.runs.retrieve(run.id, { thread_id: thread.id });\n      let attempts = 0;\n      while (runStatus.status !== 'completed' && runStatus.status !== 'failed' && attempts < 30) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        runStatus = await this.client.beta.threads.runs.retrieve(run.id, { thread_id: thread.id });\n        attempts++;\n      }\n\n      if (runStatus.status === 'failed') {\n        console.error('[OPENAI-ASSISTANTS] Assistant run failed:', runStatus.last_error);\n        throw new Error('Assistant run failed');\n      }\n\n      // Get messages\n      const messages = await this.client.beta.threads.messages.list(thread.id);\n      const assistantMessage = messages.data.find(m => m.role === 'assistant');\n      \n      if (assistantMessage && assistantMessage.content[0] && assistantMessage.content[0].type === 'text') {\n        const assistantInfo = ASSISTANTS[assistantKey as keyof typeof ASSISTANTS];\n        return {\n          analysis: assistantMessage.content[0].text.value,\n          assistant: assistantInfo?.name || 'Assistant',\n          threadId: thread.id\n        };\n      }\n\n      throw new Error('No response from assistant');\n    } catch (error) {\n      console.error('[OPENAI-ASSISTANTS] Assistant analysis error:', error);\n      throw error;\n    }\n  }\n\n  async chatbotResponse(message: string) {\n    return this.analyzeWithAssistant('CHATBOT', message);\n  }\n\n  async analyzeInspection(\n    inspectionData: any,\n    assistantKey: string = 'GENERAL',\n    files?: Array<{ url: string; type: string }>\n  ) {\n    const prompt = `\n    Análise de Inspeção de Segurança do Trabalho:\n    \n    Local: ${inspectionData.location}\n    Data: ${new Date().toLocaleDateString('pt-BR')}\n    \n    Checklist aplicado:\n    ${JSON.stringify(inspectionData.checklist, null, 2)}\n    \n    Por favor, analise:\n    1. Conformidades e não-conformidades identificadas\n    2. Riscos potenciais\n    3. Recomendações de melhoria\n    4. Prioridades de ação\n    5. Conformidade com as normas aplicáveis\n    \n    ${files?.length ? 'Arquivos anexados para análise adicional.' : ''}\n    `;\n\n    return this.analyzeWithAssistant(assistantKey, prompt, files);\n  }\n\n  async generateActionPlan(nonConformities: any[], assistantKey: string = 'GENERAL') {\n    const prompt = `\n    Gere um plano de ação detalhado para as seguintes não-conformidades:\n    \n    ${JSON.stringify(nonConformities, null, 2)}\n    \n    Para cada não-conformidade, forneça:\n    1. O QUE deve ser feito (ação corretiva)\n    2. POR QUE é importante (justificativa)\n    3. ONDE aplicar a ação\n    4. QUANDO deve ser concluído (prazo sugerido)\n    5. QUEM deve ser responsável\n    6. COMO implementar\n    7. QUANTO custará (estimativa se aplicável)\n    \n    Priorize as ações por criticidade e risco.\n    `;\n\n    return this.analyzeWithAssistant(assistantKey, prompt);\n  }\n\n  getAvailableAssistants() {\n    return Object.entries(ASSISTANTS).map(([key, config]) => ({\n      key,\n      name: config.name,\n      description: config.description,\n      openai_id: this.assistants.get(key)?.id || null\n    }));\n  }\n}\n\r\n"},{"name":"organizations-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { ExtendedMochaUser, USER_ROLES, ORGANIZATION_LEVELS } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n  MOCHA_USERS_SERVICE_API_URL: string;\r\n  MOCHA_USERS_SERVICE_API_KEY: string;\r\n  OPENAI_API_KEY: string;\r\n  GOOGLE_CLIENT_ID: string;\r\n};\r\n\r\nconst getDatabase = (env: any) => env.DB;\r\n\r\nconst app = new Hono<{ Bindings: Env; Variables: { user: any; tenantContext: any } }>();\r\n\r\n// DEBUG: Log all requests hitting this router\r\napp.get('*', async (c, next) => {\r\n  console.log('[ORGS_ROUTER] Incoming request path:', c.req.path);\r\n  await next();\r\n});\r\n\r\n// DEBUG: Public ping route\r\napp.get('/ping', (c) => c.json({ message: 'pong', path: c.req.path }));\r\n\r\n// Organizations stats endpoint\r\napp.get('/stats', tenantAuthMiddleware, async (c) => {\r\n  try {\r\n    const user = c.get('user') as ExtendedMochaUser;\r\n    const tenantContext = c.get('tenantContext') as any;\r\n    const db = getDatabase(c.env);\r\n\r\n    // Check if a specific context is active (from X-Organization-Id header)\r\n    const activeOrgId = tenantContext?.organizationId;\r\n    const isGlobalView = !activeOrgId || activeOrgId === 0;\r\n\r\n    let stats = {\r\n      totalMasterOrgs: 0,\r\n      totalCompanies: 0,\r\n      totalSubsidiaries: 0,\r\n      totalUsers: 0,\r\n      userManagedStats: undefined as any\r\n    };\r\n\r\n    // CASE 1: Specific Organization Selected (Any Role)\r\n    if (!isGlobalView) {\r\n      // Return stats specific to this organization\r\n      const orgUsers = await db.prepare('SELECT COUNT(*) as count FROM users WHERE (organization_id = ? OR managed_organization_id = ?) AND is_active = true').bind(activeOrgId, activeOrgId).first();\r\n      const subsidiaries = await db.prepare('SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ? AND is_active = true').bind(activeOrgId).first();\r\n      const departmentCount = await db.prepare('SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ? AND organization_level = ?').bind(activeOrgId, 'department').first(); // Adjust if department exists\r\n\r\n      // Reuse the structure but populate with scoped data\r\n      // For the dashboard UI compatibility, we might need to adjust what we return\r\n      // or simply return \"userManagedStats\" structure which seems to be what the UI uses for detailed view\r\n\r\n      const pendingInspections = await db.prepare('SELECT COUNT(*) as count FROM inspections WHERE organization_id = ? AND status = ?').bind(activeOrgId, 'pendente').first();\r\n      const activeInspections = await db.prepare('SELECT COUNT(*) as count FROM inspections WHERE organization_id = ? AND status IN (?, ?)').bind(activeOrgId, 'em_andamento', 'revisao').first();\r\n\r\n      stats.userManagedStats = {\r\n        totalUsers: orgUsers?.count || 0,\r\n        totalSubsidiaries: subsidiaries?.count || 0,\r\n        pendingInspections: pendingInspections?.count || 0,\r\n        activeInspections: activeInspections?.count || 0\r\n      };\r\n\r\n      // Also populate top counters if this is an organization view\r\n      stats.totalUsers = orgUsers?.count || 0;\r\n      stats.totalSubsidiaries = subsidiaries?.count || 0;\r\n      // Master/Companies count makes less sense here, keeping 0 or maybe showing 1\r\n    }\r\n    // CASE 2: Global View (System Admin)\r\n    else if (user.role === USER_ROLES.SYSTEM_ADMIN || user.role === 'sys_admin' || user.role === 'system_admin') {\r\n      const masterOrgs = await db.prepare(\"SELECT COUNT(*) as count FROM organizations WHERE type = 'master'\").first();\r\n      // Companies: Top level (no parent) and NOT master\r\n      const companies = await db.prepare(\"SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id IS NULL AND type != 'master'\").first();\r\n      // Subsidiaries: Any org with a parent\r\n      const subsidiaries = await db.prepare(\"SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id IS NOT NULL\").first();\r\n      const users = await db.prepare('SELECT COUNT(*) as count FROM users WHERE is_active = true').first();\r\n\r\n      stats.totalMasterOrgs = masterOrgs?.count || 0;\r\n      stats.totalCompanies = companies?.count || 0;\r\n      stats.totalSubsidiaries = subsidiaries?.count || 0;\r\n      stats.totalUsers = users?.count || 0;\r\n    }\r\n    // CASE 3: Managed View (Org Admin - legacy fallback)\r\n    else if ((user.role === USER_ROLES.ORG_ADMIN || user.role === 'org_admin') && user.managed_organization_id) {\r\n      const orgId = user.managed_organization_id;\r\n\r\n      const orgUsers = await db.prepare(`\r\n        SELECT COUNT(*) as count \r\n        FROM users u \r\n        WHERE u.organization_id = ? OR u.organization_id IN(\r\n          SELECT id FROM organizations WHERE parent_organization_id = ?\r\n        ) AND u.is_active = true\r\n      `).bind(orgId, orgId).first();\r\n\r\n      const subsidiaries = await db.prepare('SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ?').bind(orgId).first();\r\n\r\n      const pendingInspections = await db.prepare(`\r\n        SELECT COUNT(*) as count \r\n        FROM inspections \r\n        WHERE organization_id = ? OR organization_id IN(\r\n          SELECT id FROM organizations WHERE parent_organization_id = ?\r\n        ) AND status = 'pendente'\r\n      `).bind(orgId, orgId).first();\r\n\r\n      const activeInspections = await db.prepare(`\r\n        SELECT COUNT(*) as count \r\n        FROM inspections \r\n        WHERE organization_id = ? OR organization_id IN(\r\n          SELECT id FROM organizations WHERE parent_organization_id = ?\r\n        ) AND status IN('em_andamento', 'revisao')\r\n      `).bind(orgId, orgId).first();\r\n\r\n      stats.userManagedStats = {\r\n        totalUsers: orgUsers?.count || 0,\r\n        totalSubsidiaries: subsidiaries?.count || 0,\r\n        pendingInspections: pendingInspections?.count || 0,\r\n        activeInspections: activeInspections?.count || 0\r\n      };\r\n      // Populate defaults for UI\r\n      stats.totalUsers = orgUsers?.count || 0;\r\n    }\r\n\r\n    return c.json(stats);\r\n  } catch (error) {\r\n    console.error('Error fetching organization stats:', error);\r\n    return c.json({ error: 'Erro interno do servidor' }, 500);\r\n  }\r\n});\r\n\r\n// Get all organizations (with user filtering)\r\napp.get('/', tenantAuthMiddleware, async (c) => {\r\n  console.log('[ORGS] GET / route handler reached');\r\n  try {\r\n    const user = c.get('user') as ExtendedMochaUser;\r\n    console.log('[ORGS] User:', user?.email || 'NO USER');\r\n    const db = getDatabase(c.env);\r\n\r\n    // Get user profile\r\n    const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile) {\r\n      console.error('[ORGS] User profile NOT found for ID:', user.id);\r\n      return c.json({ error: \"User profile not found (DB mismatch)\" }, 400);\r\n    }\r\n    console.log('[ORGS] User profile found, role:', userProfile.role);\r\n\r\n    let query = `\r\n      SELECT o.*,\r\n  (SELECT COUNT(*) FROM users WHERE organization_id = o.id AND is_active = true) as user_count,\r\n    (SELECT COUNT(*) FROM organizations WHERE parent_organization_id = o.id AND is_active = true) as subsidiary_count,\r\n      po.name as parent_organization_name\r\n      FROM organizations o\r\n      LEFT JOIN organizations po ON o.parent_organization_id = po.id\r\n  `;\r\n\r\n    const params: any[] = [];\r\n    const whereConditions: string[] = [];\r\n\r\n    // Filter based on user role\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {\r\n      // System admin sees all organizations\r\n      whereConditions.push(\"o.is_active = true\");\r\n    } else {\r\n      // All other users see:\r\n      // 1. Orgs they manage (if Org Admin) + Subsidiaries\r\n      // 2. Orgs they are explicitly assigned to via user_organizations\r\n      // 3. Their primary organization (fallback)\r\n\r\n      const userId = user.id;\r\n      // We use a broader clause:\r\n      // ID in user_organizations\r\n      // OR ID = primary org\r\n      // OR (Role=OrgAdmin AND (ID=Managed OR Parent=Managed))\r\n\r\n      let subConditions = [];\r\n      const subParams = [];\r\n\r\n      // 1. Explicit assignments & Primary (via user_organizations usually has primary, but legacy fallback:)\r\n      subConditions.push(`o.id IN (SELECT organization_id FROM user_organizations WHERE user_id = '${userId}')`);\r\n\r\n      // 2. Legacy Primary\r\n      if (userProfile.organization_id) {\r\n        subConditions.push(\"o.id = ?\");\r\n        subParams.push(userProfile.organization_id);\r\n      }\r\n\r\n      // 3. Managed Hierarchy (Org Admin)\r\n      if (userProfile.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {\r\n        subConditions.push(\"(o.id = ? OR o.parent_organization_id = ?)\");\r\n        subParams.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n      }\r\n\r\n      if (subConditions.length > 0) {\r\n        whereConditions.push(`(${subConditions.join(' OR ')}) AND o.is_active = true`);\r\n        params.push(...subParams);\r\n      } else {\r\n        whereConditions.push(\"1 = 0\"); // No access\r\n      }\r\n    }\r\n\r\n    if (whereConditions.length > 0) {\r\n      query += \" WHERE \" + whereConditions.join(\" AND \");\r\n    }\r\n\r\n    query += \" ORDER BY o.parent_organization_id IS NULL DESC, o.name ASC\";\r\n\r\n    const organizations = await db.prepare(query).bind(...params).all();\r\n\r\n    // Get user counts for each organization\r\n    const userCounts: Record<number, number> = {};\r\n    for (const org of (organizations.results || [])) {\r\n      const orgData = org as any;\r\n      userCounts[orgData.id] = orgData.user_count || 0;\r\n    }\r\n\r\n    return c.json({\r\n      organizations: organizations.results || [],\r\n      userCounts\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching organizations:', error);\r\n    return c.json({ error: 'Erro ao buscar organizações' }, 500);\r\n  }\r\n});\r\n\r\n// Get single organization by ID\r\napp.get('/:id', tenantAuthMiddleware, async (c) => {\r\n  try {\r\n    const user = c.get('user') as ExtendedMochaUser;\r\n    const db = getDatabase(c.env);\r\n    const organizationId = parseInt(c.req.param('id'));\r\n\r\n    if (isNaN(organizationId)) {\r\n      return c.json({ error: 'ID de organização inválido' }, 400);\r\n    }\r\n\r\n    // Get user profile\r\n    const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile) {\r\n      return c.json({ error: \"User profile not found\" }, 404);\r\n    }\r\n\r\n    // Check permissions\r\n    let hasAccess = false;\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {\r\n      hasAccess = true;\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Check if this organization is under their management\r\n      const orgCheck = await db.prepare(`\r\n        SELECT id FROM organizations \r\n        WHERE id = ? AND(id = ? OR parent_organization_id = ?)\r\n        `).bind(organizationId, userProfile.managed_organization_id, userProfile.managed_organization_id).first();\r\n      hasAccess = !!orgCheck;\r\n    } else {\r\n      console.log(`[ORGS - DEBUG] Deep Check for User: ${user.email} Role: ${userProfile.role} `);\r\n      console.log(`[ORGS - DEBUG] User OrgID: ${userProfile.organization_id} (Type: ${typeof userProfile.organization_id})`);\r\n      console.log(`[ORGS - DEBUG] Target OrgID: ${organizationId} (Type: ${typeof organizationId})`);\r\n\r\n      // Use loose equality to handle possible BigInt/Number mismatch\r\n      hasAccess = userProfile.organization_id == organizationId;\r\n      console.log(`[ORGS - DEBUG] Direct Access Result: ${hasAccess} `);\r\n    }\r\n\r\n    if (!hasAccess) {\r\n      // Allow access if user is participating in an event or inspection in this organization\r\n      const userEmail = userProfile.email || user.email;\r\n      console.log(`[ORGS] Checking participation for ${userEmail} in Org ${organizationId} `);\r\n\r\n      const inspectionAccess = await db.prepare(\"SELECT id FROM inspections WHERE organization_id = ? AND inspector_email = ?\").bind(organizationId, userEmail).first();\r\n      if (inspectionAccess) {\r\n        console.log('[ORGS-DEBUG] Access granted via Inspection:', inspectionAccess);\r\n        hasAccess = true;\r\n      } else {\r\n        // Check calendar participation\r\n        console.log(`[ORGS - DEBUG] Checking calendar for: ${userEmail} `);\r\n        const calendarAccess = await db.prepare(\"SELECT id FROM calendar_events WHERE organization_id = ? AND participants::text LIKE ?\").bind(organizationId, `%\"${userEmail}\"%`).first();\r\n        if (calendarAccess) {\r\n          console.log('[ORGS-DEBUG] Access granted via Calendar:', calendarAccess);\r\n          hasAccess = true;\r\n        } else {\r\n          console.log('[ORGS-DEBUG] No calendar access found.');\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: 'Acesso negado a esta organização' }, 403);\r\n    }\r\n\r\n    // Get organization with additional data\r\n    // Get organization basic data\r\n    const organization = await db.prepare(`\r\n      SELECT o.*, po.name as parent_organization_name\r\n      FROM organizations o\r\n      LEFT JOIN organizations po ON o.parent_organization_id = po.id\r\n      WHERE o.id = ?\r\n    `).bind(organizationId).first() as any;\r\n\r\n    if (!organization) {\r\n      return c.json({ error: 'Organização não encontrada' }, 404);\r\n    }\r\n\r\n    // Fetch counts separately to avoid subquery issues\r\n    try {\r\n      const userCountResult = await db.prepare(`SELECT COUNT(*) as count FROM users WHERE organization_id = ? AND is_active = true`).bind(organizationId).first();\r\n      organization.user_count = userCountResult?.count || 0;\r\n    } catch (e) {\r\n      console.error('Error fetching user count:', e);\r\n      organization.user_count = 0;\r\n    }\r\n\r\n    try {\r\n      const subCountResult = await db.prepare(`SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ? AND is_active = true`).bind(organizationId).first();\r\n      organization.subsidiary_count = subCountResult?.count || 0;\r\n    } catch (e) {\r\n      console.error('Error fetching subsidiary count:', e);\r\n      organization.subsidiary_count = 0;\r\n    }\r\n\r\n    if (!organization) {\r\n      return c.json({ error: 'Organização não encontrada' }, 404);\r\n    }\r\n\r\n    return c.json({ organization });\r\n\r\n  } catch (error: any) {\r\n    console.error('Error fetching organization:', error);\r\n    return c.json({\r\n      error: 'Erro ao buscar organização',\r\n      details: error.message,\r\n      stack: error.stack\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Create new organization\r\napp.post('/', tenantAuthMiddleware, async (c) => {\r\n  try {\r\n    const user = c.get('user') as ExtendedMochaUser;\r\n    const db = getDatabase(c.env);\r\n\r\n    // Get user profile\r\n    const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile) {\r\n      return c.json({ error: \"User profile not found\" }, 404);\r\n    }\r\n\r\n    // Check permissions\r\n    if (!userProfile.can_create_organizations &&\r\n      userProfile.role !== USER_ROLES.SYSTEM_ADMIN &&\r\n      userProfile.role !== 'sys_admin') {\r\n      return c.json({ error: 'Permissões insuficientes para criar organizações' }, 403);\r\n    }\r\n\r\n    const body = await c.req.json();\r\n    const {\r\n      name, type, description, contact_email, contact_phone, address,\r\n      parent_organization_id, subscription_plan, max_users, max_subsidiaries,\r\n      cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao,\r\n      natureza_juridica, data_abertura, capital_social, porte_empresa,\r\n      situacao_cadastral, numero_funcionarios, setor_industria,\r\n      subsetor_industria, certificacoes_seguranca, data_ultima_auditoria,\r\n      nivel_risco, contato_seguranca_nome, contato_seguranca_email,\r\n      contato_seguranca_telefone, historico_incidentes, observacoes_compliance,\r\n      website, faturamento_anual\r\n    } = body;\r\n\r\n    if (!name) {\r\n      return c.json({ error: 'Nome da organização é obrigatório' }, 400);\r\n    }\r\n\r\n    // Determine organization level\r\n    let orgLevel = 'company';\r\n    let finalParentId = parent_organization_id;\r\n\r\n    if (userProfile.role === USER_ROLES.ORG_ADMIN && userProfile.managed_organization_id) {\r\n      // Org admin creates under their management\r\n      finalParentId = userProfile.managed_organization_id;\r\n      orgLevel = parent_organization_id ? 'subsidiary' : 'company';\r\n    }\r\n\r\n    const result = await db.prepare(`\r\n      INSERT INTO organizations(\r\n    name, type, description, contact_email, contact_phone, address,\r\n    parent_organization_id, organization_level, subscription_status,\r\n    subscription_plan, max_users, max_subsidiaries, is_active,\r\n    cnpj, razao_social, nome_fantasia, cnae_principal, cnae_descricao,\r\n    natureza_juridica, data_abertura, capital_social, porte_empresa,\r\n    situacao_cadastral, numero_funcionarios, setor_industria,\r\n    subsetor_industria, certificacoes_seguranca, data_ultima_auditoria,\r\n    nivel_risco, contato_seguranca_nome, contato_seguranca_email,\r\n    contato_seguranca_telefone, historico_incidentes, observacoes_compliance,\r\n    website, faturamento_anual,\r\n    created_at, updated_at\r\n  ) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n  RETURNING id\r\n  `).bind(\r\n      name,\r\n      type || 'company',\r\n      description || null,\r\n      contact_email || null,\r\n      contact_phone || null,\r\n      address || null,\r\n      finalParentId || null,\r\n      orgLevel,\r\n      'active',\r\n      subscription_plan || 'basic',\r\n      max_users || 50,\r\n      max_subsidiaries || 0,\r\n      true,\r\n      cnpj || null,\r\n      razao_social || null,\r\n      nome_fantasia || null,\r\n      cnae_principal || null,\r\n      cnae_descricao || null,\r\n      natureza_juridica || null,\r\n      data_abertura || null,\r\n      capital_social || null,\r\n      porte_empresa || null,\r\n      situacao_cadastral || null,\r\n      numero_funcionarios || null,\r\n      setor_industria || null,\r\n      subsetor_industria || null,\r\n      certificacoes_seguranca || null,\r\n      data_ultima_auditoria || null,\r\n      nivel_risco || 'medio',\r\n      contato_seguranca_nome || null,\r\n      contato_seguranca_email || null,\r\n      contato_seguranca_telefone || null,\r\n      historico_incidentes || null,\r\n      observacoes_compliance || null,\r\n      website || null,\r\n      faturamento_anual || null\r\n    ).first() as any;\r\n\r\n    const organizationId = result?.id;\r\n\r\n    if (!organizationId) {\r\n      console.error('Error: Organization created but no ID returned');\r\n      return c.json({ error: 'Erro ao obter ID da organização criada' }, 500);\r\n    }\r\n\r\n    // Log activity\r\n    await db.prepare(`\r\n      INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\nVALUES(?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n      user.id,\r\n      organizationId,\r\n      'organization_created',\r\n      `Criou organização: ${name} `,\r\n      'organization',\r\n      organizationId.toString()\r\n    ).run();\r\n\r\n    return c.json({\r\n      id: organizationId,\r\n      message: \"Organização criada com sucesso\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating organization:', error);\r\n    return c.json({ error: error instanceof Error ? error.message : 'Erro ao criar organização' }, 500);\r\n  }\r\n});\r\n\r\n// Update organization\r\napp.put('/:id', tenantAuthMiddleware, async (c) => {\r\n  try {\r\n    const user = c.get('user') as ExtendedMochaUser;\r\n    const db = getDatabase(c.env);\r\n    const organizationId = parseInt(c.req.param('id'));\r\n\r\n    if (isNaN(organizationId)) {\r\n      return c.json({ error: 'ID de organização inválido' }, 400);\r\n    }\r\n\r\n    // Get user profile\r\n    const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile) {\r\n      return c.json({ error: \"User profile not found\" }, 404);\r\n    }\r\n\r\n    // Check permissions\r\n    let hasAccess = false;\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {\r\n      hasAccess = true;\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      const orgCheck = await db.prepare(`\r\n        SELECT id FROM organizations \r\n        WHERE id = ? AND(id = ? OR parent_organization_id = ?)\r\n  `).bind(organizationId, userProfile.managed_organization_id, userProfile.managed_organization_id).first();\r\n      hasAccess = !!orgCheck;\r\n    }\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: 'Permissões insuficientes para atualizar esta organização' }, 403);\r\n    }\r\n\r\n    const body = await c.req.json();\r\n\r\n    // Build dynamic update query\r\n    const updateFields = [];\r\n    const updateValues = [];\r\n\r\n    const allowedFields = [\r\n      'name', 'type', 'description', 'contact_email', 'contact_phone', 'address',\r\n      'subscription_plan', 'max_users', 'max_subsidiaries', 'is_active',\r\n      'cnpj', 'razao_social', 'nome_fantasia', 'cnae_principal', 'cnae_descricao',\r\n      'natureza_juridica', 'data_abertura', 'capital_social', 'porte_empresa',\r\n      'situacao_cadastral', 'numero_funcionarios', 'setor_industria',\r\n      'subsetor_industria', 'certificacoes_seguranca', 'data_ultima_auditoria',\r\n      'nivel_risco', 'contato_seguranca_nome', 'contato_seguranca_email',\r\n      'contato_seguranca_telefone', 'historico_incidentes', 'observacoes_compliance',\r\n      'website', 'faturamento_anual', 'logo_url'\r\n    ];\r\n\r\n    for (const field of allowedFields) {\r\n      if (body[field] !== undefined) {\r\n        updateFields.push(`${field} = ?`);\r\n        updateValues.push(body[field]);\r\n      }\r\n    }\r\n\r\n    if (updateFields.length === 0) {\r\n      return c.json({ message: \"Nenhum campo para atualizar\" }, 400);\r\n    }\r\n\r\n    updateFields.push(\"updated_at = NOW()\");\r\n\r\n    await db.prepare(`\r\n      UPDATE organizations \r\n      SET ${updateFields.join(\", \")}\r\n      WHERE id = ?\r\n  `).bind(...updateValues, organizationId).run();\r\n\r\n    // Log activity\r\n    await db.prepare(`\r\n      INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\nVALUES(?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n      user.id,\r\n      organizationId,\r\n      'organization_updated',\r\n      `Atualizou organização: ${body.name || organizationId} `,\r\n      'organization',\r\n      organizationId.toString()\r\n    ).run();\r\n\r\n    return c.json({ message: \"Organização atualizada com sucesso\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating organization:', error);\r\n    return c.json({ error: 'Erro ao atualizar organização' }, 500);\r\n  }\r\n});\r\n\r\n// Delete organization\r\napp.delete('/:id', tenantAuthMiddleware, async (c) => {\r\n  try {\r\n    const user = c.get('user') as ExtendedMochaUser;\r\n    const db = getDatabase(c.env);\r\n    const organizationId = parseInt(c.req.param('id'));\r\n\r\n    if (isNaN(organizationId)) {\r\n      return c.json({ error: 'ID de organização inválido' }, 400);\r\n    }\r\n\r\n    // Get user profile\r\n    const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile) {\r\n      return c.json({ error: \"User profile not found\" }, 404);\r\n    }\r\n\r\n    // Check permissions - only system admin and org admin can delete\r\n    let hasAccess = false;\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN || userProfile.role === 'sys_admin') {\r\n      hasAccess = true;\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      const orgCheck = await db.prepare(`\r\n        SELECT id FROM organizations \r\n        WHERE id = ? AND(id = ? OR parent_organization_id = ?)\r\n  `).bind(organizationId, userProfile.managed_organization_id, userProfile.managed_organization_id).first();\r\n      hasAccess = !!orgCheck;\r\n    }\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: 'Permissões insuficientes para excluir esta organização' }, 403);\r\n    }\r\n\r\n    // Get organization to check if it exists\r\n    const organization = await db.prepare(\"SELECT * FROM organizations WHERE id = ?\").bind(organizationId).first() as any;\r\n\r\n    if (!organization) {\r\n      return c.json({ error: 'Organização não encontrada' }, 404);\r\n    }\r\n\r\n    // Check if organization has users or subsidiaries\r\n    const userCount = await db.prepare(\"SELECT COUNT(*) as count FROM users WHERE organization_id = ? AND is_active = true\").bind(organizationId).first() as any;\r\n    const subsidiaryCount = await db.prepare(\"SELECT COUNT(*) as count FROM organizations WHERE parent_organization_id = ? AND is_active = true\").bind(organizationId).first() as any;\r\n\r\n    if (userCount?.count > 0) {\r\n      return c.json({\r\n        error: `Não é possível excluir a organização.Ela possui ${userCount.count} usuário(s) ativo(s).`,\r\n        details: 'Remova ou transfira todos os usuários antes de excluir a organização.'\r\n      }, 400);\r\n    }\r\n\r\n    if (subsidiaryCount?.count > 0) {\r\n      return c.json({\r\n        error: `Não é possível excluir a organização.Ela possui ${subsidiaryCount.count} subsidiária(s) ativa(s).`,\r\n        details: 'Remova ou transfira todas as subsidiárias antes de excluir a organização.'\r\n      }, 400);\r\n    }\r\n\r\n    // Check for inspections\r\n    const inspectionCount = await db.prepare(\"SELECT COUNT(*) as count FROM inspections WHERE organization_id = ?\").bind(organizationId).first() as any;\r\n\r\n    if (inspectionCount?.count > 0) {\r\n      return c.json({\r\n        error: `Não é possível excluir a organização.Ela possui ${inspectionCount.count} inspeção(ões) associada(s).`,\r\n        details: 'Remova ou transfira todas as inspeções antes de excluir a organização.'\r\n      }, 400);\r\n    }\r\n\r\n    // Soft delete - just mark as inactive instead of actual deletion\r\n    await db.prepare(`\r\n      UPDATE organizations \r\n      SET is_active = false, updated_at = NOW()\r\n      WHERE id = ?\r\n  `).bind(organizationId).run();\r\n\r\n    // Log activity\r\n    await db.prepare(`\r\n      INSERT INTO activity_log(user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\nVALUES(?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n      user.id,\r\n      organizationId,\r\n      'organization_deleted',\r\n      `Excluiu organização: ${organization.name} `,\r\n      'organization',\r\n      organizationId.toString()\r\n    ).run();\r\n\r\n    return c.json({\r\n      message: \"Organização excluída com sucesso\",\r\n      note: \"A organização foi desativada mas seus dados foram preservados.\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error deleting organization:', error);\r\n    return c.json({ error: 'Erro ao excluir organização' }, 500);\r\n  }\r\n});\r\n\r\n// Increment AI usage count for an organization\r\napp.post('/increment-ai-usage', tenantAuthMiddleware, async (c) => {\r\n  try {\r\n    const user = c.get('user') as ExtendedMochaUser;\r\n    const db = getDatabase(c.env);\r\n\r\n    const body = await c.req.json();\r\n    const { organization_id } = body;\r\n\r\n    if (!organization_id) {\r\n      return c.json({ error: 'organization_id é obrigatório' }, 400);\r\n    }\r\n\r\n    // Get user profile to verify access\r\n    const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile) {\r\n      return c.json({ error: \"User profile not found\" }, 404);\r\n    }\r\n\r\n    // Verify user belongs to this organization or is admin\r\n    const hasAccess =\r\n      userProfile.organization_id === organization_id ||\r\n      userProfile.managed_organization_id === organization_id ||\r\n      userProfile.role === USER_ROLES.SYSTEM_ADMIN ||\r\n      userProfile.role === 'sys_admin';\r\n\r\n    if (!hasAccess) {\r\n      return c.json({ error: 'Acesso negado' }, 403);\r\n    }\r\n\r\n    // Increment the counter\r\n    await db.prepare(`\r\n      UPDATE organizations \r\n      SET ai_usage_count = COALESCE(ai_usage_count, 0) + 1,\r\n  updated_at = NOW()\r\n      WHERE id = ?\r\n  `).bind(organization_id).run();\r\n\r\n    // Log to ai_usage_log if table exists\r\n    try {\r\n      await db.prepare(`\r\n        INSERT INTO ai_usage_log(organization_id, user_id, feature_type, model_used, status, created_at)\r\nVALUES(?, ?, 'analysis', 'gpt-4o-mini', 'success', NOW())\r\n  `).bind(organization_id, user.id).run();\r\n    } catch (logError) {\r\n      console.warn('[AI-USAGE] Could not log to ai_usage_log:', logError);\r\n    }\r\n\r\n    console.log('[AI-USAGE] ✅ Incremented for org:', organization_id, 'by user:', user.id);\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: 'Uso de IA contabilizado'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error incrementing AI usage:', error);\r\n    return c.json({ error: 'Erro ao contabilizar uso de IA' }, 500);\r\n  }\r\n});\r\n\r\nexport default app;\r\n\r\n"},{"name":"rbac-middleware.ts","content":"import { Context } from \"hono\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\nimport {\r\n  PROTECTED_SYSADMIN_EMAIL,\r\n  PROTECTED_SYSADMIN_ID,\r\n  isProtectedUser\r\n} from \"./security-protection.ts\";\r\n\r\n// Definição de escopos do sistema\r\nexport const SCOPES = {\r\n  USERS_READ: 'users:read',\r\n  USERS_WRITE: 'users:write',\r\n  USERS_DELETE: 'users:delete',\r\n  USERS_INVITATIONS_READ: 'users:invitations:read',\r\n  USERS_INVITATIONS_WRITE: 'users:invitations:write',\r\n  CHECKLIST_FOLDERS_READ: 'checklist:folders:read',\r\n  CHECKLIST_FOLDERS_WRITE: 'checklist:folders:write',\r\n  CHECKLIST_FOLDERS_DELETE: 'checklist:folders:delete',\r\n  CHECKLIST_TEMPLATES_READ: 'checklist:templates:read',\r\n  CHECKLIST_TEMPLATES_WRITE: 'checklist:templates:write',\r\n  ORGANIZATIONS_READ: 'organizations:read',\r\n  ORGANIZATIONS_WRITE: 'organizations:write',\r\n  INSPECTIONS_READ: 'inspections:read',\r\n  INSPECTIONS_WRITE: 'inspections:write',\r\n  SYSTEM_ADMIN: 'system:admin'\r\n} as const;\r\n\r\n// Mapeamento de roles para escopos\r\nconst ROLE_SCOPES_MAP: Record<string, string[]> = {\r\n  [USER_ROLES.SYSTEM_ADMIN]: Object.values(SCOPES), // Acesso total a todos os escopos\r\n  'sys_admin': Object.values(SCOPES), // Acesso total a todos os escopos\r\n  'admin': Object.values(SCOPES), // Compatibilidade com role admin antigo\r\n  [USER_ROLES.ORG_ADMIN]: [\r\n    SCOPES.USERS_READ,\r\n    SCOPES.USERS_WRITE,\r\n    SCOPES.USERS_INVITATIONS_READ,\r\n    SCOPES.USERS_INVITATIONS_WRITE,\r\n    SCOPES.CHECKLIST_FOLDERS_READ,\r\n    SCOPES.CHECKLIST_FOLDERS_WRITE,\r\n    SCOPES.CHECKLIST_TEMPLATES_READ,\r\n    SCOPES.CHECKLIST_TEMPLATES_WRITE,\r\n    SCOPES.ORGANIZATIONS_READ,\r\n    SCOPES.ORGANIZATIONS_WRITE,\r\n    SCOPES.INSPECTIONS_READ,\r\n    SCOPES.INSPECTIONS_WRITE\r\n  ],\r\n  [USER_ROLES.MANAGER]: [\r\n    SCOPES.USERS_READ,\r\n    SCOPES.CHECKLIST_FOLDERS_READ,\r\n    SCOPES.CHECKLIST_FOLDERS_WRITE,\r\n    SCOPES.CHECKLIST_TEMPLATES_READ,\r\n    SCOPES.CHECKLIST_TEMPLATES_WRITE,\r\n    SCOPES.INSPECTIONS_READ,\r\n    SCOPES.INSPECTIONS_WRITE\r\n  ],\r\n  [USER_ROLES.INSPECTOR]: [\r\n    SCOPES.CHECKLIST_FOLDERS_READ,\r\n    SCOPES.CHECKLIST_TEMPLATES_READ,\r\n    SCOPES.INSPECTIONS_READ,\r\n    SCOPES.INSPECTIONS_WRITE\r\n  ],\r\n  [USER_ROLES.CLIENT]: [\r\n    SCOPES.INSPECTIONS_READ\r\n  ]\r\n};\r\n\r\n// CONSTANTES MOVIDAS PARA security-protection.ts - PROTEÇÃO CENTRALIZADA\r\n\r\n// Função para obter escopos de um usuário baseado no role\r\nexport function getUserScopes(userRole: string): string[] {\r\n  return ROLE_SCOPES_MAP[userRole] || [];\r\n}\r\n\r\n// Função para verificar se usuário tem escopos necessários\r\nexport function hasRequiredScopes(userScopes: string[], requiredScopes: string[]): boolean {\r\n  if (requiredScopes.length === 0) return true;\r\n\r\n  // Se o usuário tem escopo de system admin, tem acesso a tudo\r\n  if (userScopes.includes(SCOPES.SYSTEM_ADMIN)) {\r\n    return true;\r\n  }\r\n\r\n  // Verifica se tem todos os escopos necessários (AND) ou pelo menos um (OR)\r\n  // Por padrão, usa OR para ser mais flexível\r\n  return requiredScopes.some(scope => userScopes.includes(scope));\r\n}\r\n\r\n// Middleware de verificação de escopos\r\nexport function requireScopes(...scopes: string[]) {\r\n  return async (c: Context, next: () => Promise<void>) => {\r\n    const user = c.get(\"user\");\r\n\r\n    if (!user) {\r\n      return c.json({\r\n        error: \"unauthorized\",\r\n        message: \"Usuário não autenticado\",\r\n        required_scopes: scopes\r\n      }, 401);\r\n    }\r\n\r\n    try {\r\n      // OTIMIZAÇÃO: Primeiro tentar usar o perfil já carregado pelo tenantAuthMiddleware\r\n      // Evita query redundante ao banco de dados\r\n      let userProfile = user.role ? user : null;\r\n\r\n      // Fallback: buscar do banco apenas se não tiver role no contexto\r\n      if (!userProfile || !userProfile.role) {\r\n        const env = c.env;\r\n        userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n        console.log('[RBAC] Buscou perfil do banco (fallback)');\r\n      }\r\n\r\n      // Fallback para usuário demo se não encontrar no banco\r\n      if (!userProfile && (user as any).profile) {\r\n        console.log('[RBAC] Usando perfil do contexto (Demo/Mock)');\r\n        const demoUser = user as any;\r\n        userProfile = {\r\n          ...demoUser.profile,\r\n          id: user.id,\r\n          email: user.email,\r\n          name: demoUser.name || user.email\r\n        };\r\n      }\r\n\r\n      if (!userProfile) {\r\n        return c.json({\r\n          error: \"forbidden\",\r\n          message: \"Perfil de usuário não encontrado\",\r\n          required_scopes: scopes\r\n        }, 403);\r\n      }\r\n\r\n      // Obter escopos do usuário baseado no role\r\n      const userScopes = getUserScopes(userProfile.role);\r\n\r\n      // Verificar se tem os escopos necessários\r\n      if (!hasRequiredScopes(userScopes, scopes)) {\r\n        return c.json({\r\n          error: \"forbidden\",\r\n          message: \"Permissões insuficientes para acessar este recurso\",\r\n          required_scopes: scopes,\r\n          user_scopes: userScopes\r\n        }, 403);\r\n      }\r\n\r\n      // Adicionar informações de autorização no contexto\r\n      c.set(\"userProfile\", userProfile);\r\n      c.set(\"userScopes\", userScopes);\r\n\r\n      await next();\r\n    } catch (error) {\r\n      console.error('Error in RBAC middleware:', error);\r\n      return c.json({\r\n        error: \"internal_error\",\r\n        message: \"Erro interno na verificação de permissões\",\r\n        required_scopes: scopes\r\n      }, 500);\r\n    }\r\n  };\r\n}\r\n\r\n// Middleware para proteger o usuário sysadmin específico\r\nexport function protectSysAdmin() {\r\n  return async (c: Context, next: () => Promise<void>) => {\r\n    const user = c.get(\"user\");\r\n    const method = c.req.method;\r\n    let body: any = {};\r\n\r\n    // Parse body safely\r\n    try {\r\n      body = await c.req.json();\r\n    } catch (error) {\r\n      // Body is not JSON or empty\r\n    }\r\n\r\n    const targetUserId = c.req.param(\"id\");\r\n\r\n    // Proteção absoluta: Bloquear QUALQUER tentativa de modificação do usuário protegido\r\n    if (targetUserId === PROTECTED_SYSADMIN_ID ||\r\n      (body.id && body.id === PROTECTED_SYSADMIN_ID) ||\r\n      (body.email === PROTECTED_SYSADMIN_EMAIL)) {\r\n\r\n      if (method === 'PUT' || method === 'PATCH' || method === 'DELETE' || method === 'POST') {\r\n        return c.json({\r\n          error: \"forbidden\",\r\n          message: \"ACESSO NEGADO: Este usuário de sistema está permanentemente protegido contra modificações\",\r\n          protected_user: true,\r\n          system_protection: true\r\n        }, 403);\r\n      }\r\n    }\r\n\r\n    // Impedir que qualquer usuário (mesmo outros admins) modifique o sysadmin protegido\r\n    if (user && user.id !== PROTECTED_SYSADMIN_ID) {\r\n      // Se está tentando modificar o usuário protegido por ID\r\n      if (targetUserId === PROTECTED_SYSADMIN_ID) {\r\n        return c.json({\r\n          error: \"forbidden\",\r\n          message: \"ACESSO NEGADO: Apenas o próprio usuário de sistema pode acessar esta conta\",\r\n          protected_user: true,\r\n          system_protection: true\r\n        }, 403);\r\n      }\r\n\r\n      // Se está tentando usar o email protegido\r\n      if (body.email === PROTECTED_SYSADMIN_EMAIL) {\r\n        return c.json({\r\n          error: \"forbidden\",\r\n          message: \"ACESSO NEGADO: Este email está reservado para o sistema\",\r\n          protected_user: true,\r\n          system_protection: true\r\n        }, 403);\r\n      }\r\n\r\n      // Se está tentando alterar role para system_admin (apenas o sysadmin protegido pode criar outros)\r\n      if (body.role === 'system_admin' || body.role === 'sys_admin') {\r\n        return c.json({\r\n          error: \"forbidden\",\r\n          message: \"ACESSO NEGADO: Apenas o administrador principal pode gerenciar roles de sistema\",\r\n          protected_user: true,\r\n          system_protection: true\r\n        }, 403);\r\n      }\r\n    }\r\n\r\n    await next();\r\n  };\r\n}\r\n\r\n// Middleware específico para verificar se o usuário é o sysadmin protegido\r\nexport function requireProtectedSysAdmin() {\r\n  return async (c: Context, next: () => Promise<void>) => {\r\n    const user = c.get(\"user\");\r\n\r\n    if (!user || (user.id !== PROTECTED_SYSADMIN_ID && user.email !== PROTECTED_SYSADMIN_EMAIL)) {\r\n      return c.json({\r\n        error: \"forbidden\",\r\n        message: \"ACESSO RESTRITO: Esta operação requer autenticação como administrador principal do sistema\",\r\n        protected_operation: true\r\n      }, 403);\r\n    }\r\n\r\n    await next();\r\n  };\r\n}\r\n\r\n// Função para verificar se o usuário é o sysadmin protegido\r\nexport function isProtectedSysAdmin(userId: string, userEmail?: string): boolean {\r\n  return isProtectedUser(userId, userEmail);\r\n}\r\n\r\n// Função auxiliar para padronizar respostas de erro\r\nexport function createAuthErrorResponse(type: 'unauthorized' | 'forbidden', message: string, requiredScopes: string[] = []) {\r\n  return {\r\n    error: type,\r\n    message,\r\n    required_scopes: requiredScopes,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n}\r\n\r\n// Função para verificar se usuário é admin de sistema\r\nexport function isSystemAdmin(userRole: string): boolean {\r\n  return userRole === USER_ROLES.SYSTEM_ADMIN || userRole === 'sys_admin' || userRole === 'admin';\r\n}\r\n\r\n// Função para verificar se usuário pode gerenciar outros usuários\r\nexport function canManageUsers(userRole: string): boolean {\r\n  return isSystemAdmin(userRole) || userRole === USER_ROLES.ORG_ADMIN || userRole === 'admin';\r\n}\r\n\r\n// Função para verificar se usuário pode gerenciar organizações\r\nexport function canManageOrganizations(userRole: string): boolean {\r\n  return isSystemAdmin(userRole) || userRole === USER_ROLES.ORG_ADMIN || userRole === 'admin';\r\n}\r\n\r\n"},{"name":"reset-project.ts","content":"import { Hono } from \"hono\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n};\r\n\r\nconst app = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Endpoint para resetar completamente o banco\r\napp.post(\"/reset/database\", async (c) => {\r\n  try {\r\n    const db = c.env.DB;\r\n\r\n    // 1. Drop all tables if they exist\r\n    const dropTables = [\r\n      'DROP TABLE IF EXISTS action_plans',\r\n      'DROP TABLE IF EXISTS inspection_items',\r\n      'DROP TABLE IF EXISTS checklist_fields',\r\n      'DROP TABLE IF EXISTS checklist_templates',\r\n      'DROP TABLE IF EXISTS inspections',\r\n      'DROP TABLE IF EXISTS user_invitations',\r\n      'DROP TABLE IF EXISTS organizations',\r\n      'DROP TABLE IF EXISTS users'\r\n    ];\r\n\r\n    for (const query of dropTables) {\r\n      await db.prepare(query).run();\r\n    }\r\n\r\n    // 2. Re-create all tables with correct schema\r\n    const createQueries = [\r\n      // Users table\r\n      `CREATE TABLE users (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        email TEXT UNIQUE NOT NULL,\r\n        name TEXT,\r\n        role TEXT DEFAULT 'inspector',\r\n        can_manage_users BOOLEAN DEFAULT 0,\r\n        can_create_organizations BOOLEAN DEFAULT 0,\r\n        is_active BOOLEAN DEFAULT 1,\r\n        organization_id INTEGER,\r\n        managed_organization_id INTEGER,\r\n        phone TEXT,\r\n        avatar_url TEXT,\r\n        last_login_at DATETIME,\r\n        password_hash TEXT,\r\n        email_verified_at DATETIME,\r\n        profile_completed BOOLEAN DEFAULT 0,\r\n        invitation_token TEXT,\r\n        invited_by TEXT,\r\n        invitation_expires_at DATETIME,\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n      )`,\r\n\r\n      // Organizations table  \r\n      `CREATE TABLE organizations (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        name TEXT NOT NULL,\r\n        razao_social TEXT,\r\n        nome_fantasia TEXT,\r\n        cnpj TEXT,\r\n        type TEXT,\r\n        contact_email TEXT,\r\n        contact_phone TEXT,\r\n        address TEXT,\r\n        is_active BOOLEAN DEFAULT 1,\r\n        parent_organization_id INTEGER,\r\n        organization_level TEXT DEFAULT 'company',\r\n        subscription_status TEXT DEFAULT 'active',\r\n        subscription_plan TEXT DEFAULT 'basic',\r\n        max_users INTEGER DEFAULT 50,\r\n        max_subsidiaries INTEGER DEFAULT 0,\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n      )`,\r\n\r\n      // Inspections table (com as colunas de assinatura da migração 7)\r\n      `CREATE TABLE inspections (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        title TEXT NOT NULL,\r\n        description TEXT,\r\n        location TEXT,\r\n        inspector_name TEXT,\r\n        inspector_email TEXT,\r\n        company_name TEXT,\r\n        cep TEXT,\r\n        address TEXT,\r\n        latitude REAL,\r\n        longitude REAL,\r\n        scheduled_date DATE,\r\n        completed_date DATE,\r\n        status TEXT DEFAULT 'pendente',\r\n        priority TEXT DEFAULT 'media',\r\n        created_by TEXT,\r\n        organization_id INTEGER,\r\n        responsible_name TEXT,\r\n        responsible_email TEXT,\r\n        inspector_signature TEXT,\r\n        responsible_signature TEXT,\r\n        action_plan TEXT,\r\n        action_plan_type TEXT,\r\n        ai_assistant_id TEXT,\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        FOREIGN KEY (organization_id) REFERENCES organizations(id)\r\n      )`,\r\n\r\n      // Checklist templates\r\n      `CREATE TABLE checklist_templates (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        name TEXT NOT NULL,\r\n        description TEXT,\r\n        category TEXT,\r\n        created_by TEXT,\r\n        created_by_user_id INTEGER,\r\n        organization_id INTEGER,\r\n        is_public BOOLEAN DEFAULT 0,\r\n        is_category_folder BOOLEAN DEFAULT 0,\r\n        folder_color TEXT,\r\n        folder_icon TEXT,\r\n        parent_category_id INTEGER,\r\n        folder_id INTEGER,\r\n        display_order INTEGER DEFAULT 0,\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n        FOREIGN KEY (organization_id) REFERENCES organizations(id)\r\n      )`\r\n    ];\r\n\r\n    for (const query of createQueries) {\r\n      await db.prepare(query).run();\r\n    }\r\n\r\n    // 3. Insert initial data\r\n    await db.prepare(`\r\n      INSERT INTO organizations (name, organization_level, subscription_status) \r\n      VALUES ('Organização Demo', 'master', 'active')\r\n    `).run();\r\n\r\n    await db.prepare(`\r\n      INSERT INTO users (email, name, role, can_manage_users, can_create_organizations, organization_id) \r\n      VALUES ('eng.tiagosm@gmail.com', 'Admin Sistema', 'system_admin', 1, 1, 1)\r\n    `).run();\r\n\r\n    await db.prepare(`\r\n      INSERT INTO checklist_templates (name, description, is_public, organization_id, created_by) \r\n      VALUES ('Template Demo', 'Template básico para testes', 1, 1, 'eng.tiagosm@gmail.com')\r\n    `).run();\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: \"Banco resetado e inicializado com dados básicos\"\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Reset error:', error);\r\n    return c.json({\r\n      error: \"Erro ao resetar banco\",\r\n      details: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Endpoint para verificar status do sistema\r\napp.get(\"/status\", async (c) => {\r\n  try {\r\n    const db = c.env.DB;\r\n\r\n    const tables = await db.prepare(`\r\n      SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\r\n    `).all();\r\n\r\n    const counts: Record<string, any> = {};\r\n    for (const table of tables.results) {\r\n      try {\r\n        const count = await db.prepare(`SELECT COUNT(*) as count FROM ${table.name}`).first();\r\n        counts[table.name] = count.count;\r\n      } catch (e) {\r\n        counts[table.name] = 'erro';\r\n      }\r\n    }\r\n\r\n    return c.json({\r\n      database_connected: true,\r\n      tables: tables.results.map((t: any) => t.name),\r\n      record_counts: counts,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n\r\n  } catch (error) {\r\n    return c.json({\r\n      database_connected: false,\r\n      error: error instanceof Error ? error.message : \"Erro desconhecido\"\r\n    }, 500);\r\n  }\r\n});\r\n\r\nexport default app;\r\n\r\n"},{"name":"role-permissions-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware as authMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n\r\nconst rolePermissionsRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Middleware to check if user can manage role permissions\r\nconst requirePermissionAdmin = async (c: any, next: any) => {\r\n  const user = c.get(\"user\");\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await c.env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile) {\r\n    return c.json({ error: \"User profile not found\" }, 404);\r\n  }\r\n\r\n  // Only system admin can manage role permissions\r\n  if (userProfile.role !== USER_ROLES.SYSTEM_ADMIN &&\r\n    userProfile.role !== USER_ROLES.SYS_ADMIN &&\r\n    userProfile.role !== 'admin') {\r\n    return c.json({ error: \"Apenas administradores do sistema podem gerenciar permissões\" }, 403);\r\n  }\r\n\r\n  return next();\r\n};\r\n\r\n// Get all role permissions\r\nrolePermissionsRoutes.get(\"/\", authMiddleware, requirePermissionAdmin, async (c) => {\r\n  const env = c.env;\r\n\r\n  try {\r\n    const permissions = await env.DB.prepare(`\r\n      SELECT * FROM role_permissions \r\n      ORDER BY role, permission_type\r\n    `).all();\r\n\r\n    return c.json({\r\n      permissions: permissions.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching role permissions:', error);\r\n    return c.json({ error: \"Erro ao buscar permissões\" }, 500);\r\n  }\r\n});\r\n\r\n// Update role permissions\r\nrolePermissionsRoutes.post(\"/\", authMiddleware, requirePermissionAdmin, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const body = await c.req.json();\r\n    const { updates } = body;\r\n\r\n    if (!Array.isArray(updates)) {\r\n      return c.json({ error: \"Updates deve ser um array\" }, 400);\r\n    }\r\n\r\n    // Process each update\r\n    for (const update of updates) {\r\n      const { role, permission_type, is_allowed } = update;\r\n\r\n      if (!role || !permission_type || typeof is_allowed !== 'boolean') {\r\n        continue; // Skip invalid updates\r\n      }\r\n\r\n      // Check if permission already exists\r\n      const existing = await env.DB.prepare(`\r\n        SELECT id FROM role_permissions \r\n        WHERE role = ? AND permission_type = ?\r\n      `).bind(role, permission_type).first() as any;\r\n\r\n      if (existing) {\r\n        // Update existing permission\r\n        await env.DB.prepare(`\r\n          UPDATE role_permissions \r\n          SET is_allowed = ?, updated_at = NOW()\r\n          WHERE id = ?\r\n        `).bind(is_allowed, existing.id).run();\r\n      } else {\r\n        // Create new permission\r\n        await env.DB.prepare(`\r\n          INSERT INTO role_permissions (\r\n            role, permission_type, is_allowed, organization_id,\r\n            created_at, updated_at\r\n          ) VALUES (?, ?, ?, ?, NOW(), NOW())\r\n        `).bind(role, permission_type, is_allowed, null).run();\r\n      }\r\n    }\r\n\r\n    // Log activity\r\n    await env.DB.prepare(`\r\n      INSERT INTO activity_log (\r\n        user_id, organization_id, action_type, action_description,\r\n        target_type, target_id, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n      user.id,\r\n      null,\r\n      'permissions_updated',\r\n      `Atualizou ${updates.length} permissões de papel`,\r\n      'role_permissions',\r\n      'bulk_update'\r\n    ).run();\r\n\r\n    return c.json({\r\n      message: \"Permissões atualizadas com sucesso\",\r\n      updated_count: updates.length\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating role permissions:', error);\r\n    return c.json({ error: \"Erro ao atualizar permissões\" }, 500);\r\n  }\r\n});\r\n\r\n// Get permissions for specific role\r\nrolePermissionsRoutes.get(\"/role/:role\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const role = c.req.param(\"role\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const permissions = await env.DB.prepare(`\r\n      SELECT permission_type, is_allowed FROM role_permissions \r\n      WHERE role = ?\r\n    `).bind(role).all();\r\n\r\n    return c.json({\r\n      role,\r\n      permissions: permissions.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching role permissions:', error);\r\n    return c.json({ error: \"Erro ao buscar permissões do papel\" }, 500);\r\n  }\r\n});\r\n\r\n// Check if user has specific permission\r\nrolePermissionsRoutes.get(\"/check/:permission\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const permissionType = c.req.param(\"permission\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT role FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile) {\r\n      return c.json({ hasPermission: false });\r\n    }\r\n\r\n    // System admin has all permissions\r\n    if (userProfile.role === USER_ROLES.SYSTEM_ADMIN) {\r\n      return c.json({ hasPermission: true });\r\n    }\r\n\r\n    // Check specific permission\r\n    const permission = await env.DB.prepare(`\r\n      SELECT is_allowed FROM role_permissions \r\n      WHERE role = ? AND permission_type = ?\r\n    `).bind(userProfile.role, permissionType).first() as any;\r\n\r\n    return c.json({\r\n      hasPermission: permission?.is_allowed || false\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error checking permission:', error);\r\n    return c.json({ hasPermission: false });\r\n  }\r\n});\r\n\r\nexport default rolePermissionsRoutes;\r\n\r\n"},{"name":"secure-query-helper.ts","content":"import { Context } from \"hono\";\r\nimport { TenantContext } from \"./tenant-auth-middleware.ts\";\r\n\r\n/**\r\n * SECURE QUERY HELPER - Isolamento de Dados Multi-Tenant\r\n * \r\n * Este módulo fornece funções para construir queries SQL seguras\r\n * que FORÇAM o filtro de organization_id baseado no contexto de tenant.\r\n * \r\n * @security O organization_id é SEMPRE extraído do contexto seguro,\r\n * NUNCA do body/params da requisição.\r\n */\r\n\r\nexport interface SecureQueryOptions {\r\n    table: string;\r\n    columns?: string[];\r\n    conditions?: string[];\r\n    params?: unknown[];\r\n    orderBy?: string;\r\n    limit?: number;\r\n    offset?: number;\r\n}\r\n\r\n/**\r\n * Constrói uma cláusula WHERE segura para isolamento de tenant\r\n * \r\n * @security Esta função garante que:\r\n * - System Admin: sem filtro de organização (acesso total)\r\n * - Org Admin: filtra por organização + subsidiárias\r\n * - Outros: filtra apenas pela própria organização\r\n */\r\nexport function buildTenantWhereClause(\r\n    c: Context,\r\n    tableAlias: string = \"\"\r\n): { clause: string; params: unknown[] } {\r\n    const tenantContext = c.get(\"tenantContext\") as TenantContext | undefined;\r\n    const prefix = tableAlias ? `${tableAlias}.` : \"\";\r\n\r\n    // Sem contexto de tenant = sem filtro (requisição não autenticada)\r\n    if (!tenantContext) {\r\n        return { clause: \"\", params: [] };\r\n    }\r\n\r\n    // System Admin: acesso total, sem filtro\r\n    if (tenantContext.isSystemAdmin) {\r\n        return { clause: \"\", params: [] };\r\n    }\r\n\r\n    // Org Admin e usuários regulares: filtrar por organizações permitidas\r\n    if (tenantContext.allowedOrganizationIds.length === 0) {\r\n        // Usuário sem organização: não pode ver nada\r\n        return { clause: `${prefix}organization_id = -1`, params: [] };\r\n    }\r\n\r\n    if (tenantContext.allowedOrganizationIds.length === 1) {\r\n        return {\r\n            clause: `${prefix}organization_id = ?`,\r\n            params: [tenantContext.allowedOrganizationIds[0]]\r\n        };\r\n    }\r\n\r\n    // Múltiplas organizações (Org Admin com subsidiárias)\r\n    const placeholders = tenantContext.allowedOrganizationIds.map(() => \"?\").join(\", \");\r\n    return {\r\n        clause: `${prefix}organization_id IN (${placeholders})`,\r\n        params: tenantContext.allowedOrganizationIds\r\n    };\r\n}\r\n\r\n/**\r\n * Constrói uma query SELECT segura com isolamento de tenant automático\r\n * \r\n * @example\r\n * const query = buildSecureSelectQuery(c, {\r\n *   table: 'inspections',\r\n *   columns: ['id', 'title', 'status'],\r\n *   conditions: ['status = ?'],\r\n *   params: ['pendente'],\r\n *   orderBy: 'created_at DESC'\r\n * });\r\n * const results = await env.DB.prepare(query.sql).bind(...query.params).all();\r\n */\r\nexport function buildSecureSelectQuery(\r\n    c: Context,\r\n    options: SecureQueryOptions\r\n): { sql: string; params: unknown[] } {\r\n    const { table, columns = [\"*\"], conditions = [], params = [], orderBy, limit, offset } = options;\r\n\r\n    const tenantWhere = buildTenantWhereClause(c);\r\n    const allConditions = [...conditions];\r\n    const allParams = [...params];\r\n\r\n    // Adicionar filtro de tenant se houver\r\n    if (tenantWhere.clause) {\r\n        allConditions.push(tenantWhere.clause);\r\n        allParams.push(...tenantWhere.params);\r\n    }\r\n\r\n    let sql = `SELECT ${columns.join(\", \")} FROM ${table}`;\r\n\r\n    if (allConditions.length > 0) {\r\n        sql += ` WHERE ${allConditions.join(\" AND \")}`;\r\n    }\r\n\r\n    if (orderBy) {\r\n        sql += ` ORDER BY ${orderBy}`;\r\n    }\r\n\r\n    if (limit !== undefined) {\r\n        sql += ` LIMIT ${limit}`;\r\n        if (offset !== undefined) {\r\n            sql += ` OFFSET ${offset}`;\r\n        }\r\n    }\r\n\r\n    return { sql, params: allParams };\r\n}\r\n\r\n/**\r\n * Verifica se o usuário pode acessar um registro específico\r\n * \r\n * @security Use esta função antes de retornar dados de um registro único\r\n * @returns true se o usuário tem acesso, false caso contrário\r\n */\r\nexport function canAccessRecord(\r\n    c: Context,\r\n    recordOrgId: number | null\r\n): boolean {\r\n    const tenantContext = c.get(\"tenantContext\") as TenantContext | undefined;\r\n\r\n    if (!tenantContext) return false;\r\n    if (tenantContext.isSystemAdmin) return true;\r\n    if (recordOrgId === null) return false;\r\n\r\n    return tenantContext.allowedOrganizationIds.includes(recordOrgId);\r\n}\r\n\r\n/**\r\n * Extrai o organization_id seguro para INSERT\r\n * \r\n * @security CRÍTICO: Esta função NUNCA usa o organization_id do body\r\n * O ID sempre vem do contexto de tenant (token/banco)\r\n */\r\nexport function getSecureOrgIdForInsert(c: Context): number | null {\r\n    const tenantContext = c.get(\"tenantContext\") as TenantContext | undefined;\r\n\r\n    if (!tenantContext) {\r\n        throw new Error(\"Contexto de tenant não disponível\");\r\n    }\r\n\r\n    // System Admin pode especificar organização via parâmetro especial\r\n    // (implementação futura com validação adicional)\r\n\r\n    // Para usuários regulares, usar a organização do contexto\r\n    return tenantContext.organizationId;\r\n}\r\n\r\n/**\r\n * Valida se o organization_id do body corresponde ao contexto seguro\r\n * \r\n * @security Use para detectar tentativas de injeção de organization_id\r\n * @returns true se o ID é válido ou não foi fornecido, false se há tentativa de injeção\r\n */\r\nexport function validateOrgIdFromBody(\r\n    c: Context,\r\n    bodyOrgId: number | null | undefined\r\n): { valid: boolean; message?: string } {\r\n    const tenantContext = c.get(\"tenantContext\") as TenantContext | undefined;\r\n\r\n    if (!tenantContext) {\r\n        return { valid: false, message: \"Contexto de tenant não disponível\" };\r\n    }\r\n\r\n    // Se não foi fornecido no body, está ok\r\n    if (bodyOrgId === null || bodyOrgId === undefined) {\r\n        return { valid: true };\r\n    }\r\n\r\n    // System Admin pode especificar qualquer organização\r\n    if (tenantContext.isSystemAdmin) {\r\n        return { valid: true };\r\n    }\r\n\r\n    // Verificar se o ID fornecido está na lista de permitidos\r\n    if (!tenantContext.allowedOrganizationIds.includes(bodyOrgId)) {\r\n        return {\r\n            valid: false,\r\n            message: \"Tentativa de acesso a organização não autorizada detectada\"\r\n        };\r\n    }\r\n\r\n    return { valid: true };\r\n}\r\n\r\n/**\r\n * Registra um log de auditoria para operações em inspeções\r\n * \r\n * @security Obrigatório para conformidade com LGPD\r\n */\r\nexport async function logInspectionChange(\r\n    env: Env,\r\n    inspectionId: number,\r\n    userId: string,\r\n    action: \"CREATE\" | \"UPDATE\" | \"DELETE\" | \"FINALIZE\",\r\n    fieldChanged?: string,\r\n    oldValue?: unknown,\r\n    newValue?: unknown,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n): Promise<void> {\r\n    try {\r\n        await env.DB.prepare(`\r\n      INSERT INTO inspection_logs (\r\n        inspection_id, user_id, action, field_changed,\r\n        old_value, new_value, ip_address, user_agent, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n            inspectionId,\r\n            userId,\r\n            action,\r\n            fieldChanged || null,\r\n            oldValue ? JSON.stringify(oldValue) : null,\r\n            newValue ? JSON.stringify(newValue) : null,\r\n            ipAddress || null,\r\n            userAgent || null\r\n        ).run();\r\n    } catch (error) {\r\n        // Log de auditoria não deve bloquear a operação principal\r\n        console.error(\"[AUDIT-LOG] Erro ao registrar log de inspeção:\", error);\r\n    }\r\n}\r\n\r\n"},{"name":"security-endpoints.ts","content":"import { Hono } from \"hono\";\nimport { tenantAuthMiddleware as authMiddleware } from \"./tenant-auth-middleware.ts\";\nimport { requireProtectedSysAdmin } from \"./rbac-middleware.ts\";\nimport {\n  checkProtectedUserIntegrity,\n  autoFixProtectedUser,\n  PROTECTED_SYSADMIN_EMAIL,\n  PROTECTED_SYSADMIN_ID,\n  MASTER_ORGANIZATION_ID\n} from \"./security-protection.ts\";\nimport { autoFixSystemAdmin } from \"./system-admin-protection.ts\";\n\nconst securityRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\n\n// Endpoint para verificação manual da integridade do sistema\nsecurityRoutes.get(\"/integrity-check\", authMiddleware, requireProtectedSysAdmin(), async (c) => {\n  const env = c.env;\n  const user = c.get(\"user\");\n\n  if (!user) {\n    return c.json({ error: \"User not found\" }, 401);\n  }\n\n  try {\n    const integrityResult = await checkProtectedUserIntegrity(env);\n\n    // Verificar também a proteção na tabela\n    const protectionRecord = await env.DB.prepare(`\n      SELECT * FROM protected_users WHERE user_id = ?\n    `).bind(PROTECTED_SYSADMIN_ID).first() as any;\n\n    // Verificar organização master\n    const masterOrg = await env.DB.prepare(`\n      SELECT * FROM organizations WHERE id = ?\n    `).bind(MASTER_ORGANIZATION_ID).first() as any;\n\n    // Verificar associação com organização\n    const userOrgAssociation = await env.DB.prepare(`\n      SELECT * FROM user_organizations \n      WHERE user_id = ? AND organization_id = ?\n    `).bind(PROTECTED_SYSADMIN_ID, MASTER_ORGANIZATION_ID).first() as any;\n\n    return c.json({\n      system_integrity: {\n        protected_user: integrityResult,\n        protection_record: protectionRecord ? \"configured\" : \"missing\",\n        master_organization: masterOrg ? \"exists\" : \"missing\",\n        user_org_association: userOrgAssociation ? \"linked\" : \"missing\"\n      },\n      security_status: {\n        overall_status: integrityResult.status === 'ok' && protectionRecord && masterOrg && userOrgAssociation ? 'secure' : 'needs_attention',\n        protected_user_id: PROTECTED_SYSADMIN_ID,\n        protected_user_email: PROTECTED_SYSADMIN_EMAIL,\n        master_organization_id: MASTER_ORGANIZATION_ID\n      },\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    console.error('Error checking system integrity:', error);\n    return c.json({ error: \"Failed to check system integrity\" }, 500);\n  }\n});\n\n// Endpoint para auto-correção do sistema\nsecurityRoutes.post(\"/auto-fix\", authMiddleware, requireProtectedSysAdmin(), async (c) => {\n  const env = c.env;\n  const user = c.get(\"user\");\n\n  if (!user) {\n    return c.json({ error: \"User not found\" }, 401);\n  }\n\n  try {\n    const fixResult = await autoFixProtectedUser(env, user.id);\n\n    // Garantir que existe entrada na tabela de proteção\n    await env.DB.prepare(`\n      INSERT OR REPLACE INTO protected_users (\n        user_id, protection_level, protected_roles, protected_permissions,\n        reason, created_by, created_at, updated_at\n      ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())\n    `).bind(\n      PROTECTED_SYSADMIN_ID,\n      'maximum',\n      JSON.stringify(['system_admin']),\n      JSON.stringify(['can_manage_users', 'can_create_organizations']),\n      'Usuário fundador - proteção máxima contra modificações não autorizadas',\n      user.id\n    ).run();\n\n    // Log da operação de segurança\n    await env.DB.prepare(`\n      INSERT INTO security_audit_log (\n        user_id, target_user_id, action_type, new_value,\n        blocked_reason, is_blocked, created_at\n      ) VALUES (?, ?, ?, ?, ?, ?, NOW())\n    `).bind(\n      user.id,\n      PROTECTED_SYSADMIN_ID,\n      'manual_security_fix',\n      JSON.stringify(fixResult),\n      'Correção manual de segurança executada pelo administrador',\n      false\n    ).run();\n\n    return c.json({\n      success: true,\n      fix_result: fixResult,\n      protection_updated: true,\n      message: \"Sistema de segurança verificado e corrigido\",\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    console.error('Error fixing system security:', error);\n    return c.json({ error: \"Failed to fix system security\" }, 500);\n  }\n});\n\n// Endpoint para visualizar logs de segurança\nsecurityRoutes.get(\"/audit-logs\", authMiddleware, requireProtectedSysAdmin(), async (c) => {\n  const env = c.env;\n  const user = c.get(\"user\");\n\n  if (!user) {\n    return c.json({ error: \"User not found\" }, 401);\n  }\n\n  try {\n    const limit = parseInt(c.req.query(\"limit\") || \"50\");\n    const offset = parseInt(c.req.query(\"offset\") || \"0\");\n\n    // Buscar logs de segurança relacionados ao usuário protegido\n    const securityLogs = await env.DB.prepare(`\n      SELECT * FROM security_audit_log \n      WHERE target_user_id = ? OR user_id = ?\n      ORDER BY created_at DESC\n      LIMIT ? OFFSET ?\n    `).bind(PROTECTED_SYSADMIN_ID, PROTECTED_SYSADMIN_ID, limit, offset).all();\n\n    // Contar total de logs\n    const totalCount = await env.DB.prepare(`\n      SELECT COUNT(*) as count FROM security_audit_log \n      WHERE target_user_id = ? OR user_id = ?\n    `).bind(PROTECTED_SYSADMIN_ID, PROTECTED_SYSADMIN_ID).first() as any;\n\n    // Buscar tentativas bloqueadas nas últimas 24h\n    const recentBlocked = await env.DB.prepare(`\n      SELECT COUNT(*) as count FROM security_audit_log \n      WHERE is_blocked = 1 AND created_at >= datetime('now', '-24 hours')\n    `).first() as any;\n\n    return c.json({\n      audit_logs: securityLogs.results || [],\n      pagination: {\n        total: totalCount?.count || 0,\n        limit,\n        offset,\n        has_more: (totalCount?.count || 0) > (offset + limit)\n      },\n      security_stats: {\n        recent_blocked_attempts: recentBlocked?.count || 0,\n        protected_user_id: PROTECTED_SYSADMIN_ID\n      }\n    });\n\n  } catch (error) {\n    console.error('Error fetching audit logs:', error);\n    return c.json({ error: \"Failed to fetch audit logs\" }, 500);\n  }\n});\n\n// Endpoint para verificar se há usuários órfãos ou com configurações incorretas\nsecurityRoutes.get(\"/system-health\", authMiddleware, requireProtectedSysAdmin(), async (c) => {\n  const env = c.env;\n  const user = c.get(\"user\");\n\n  if (!user) {\n    return c.json({ error: \"User not found\" }, 401);\n  }\n\n  try {\n    // Verificar usuários com role system_admin\n    const systemAdmins = await env.DB.prepare(`\n      SELECT id, email, name, role, is_active, organization_id \n      FROM users \n      WHERE role = 'system_admin'\n    `).all();\n\n    // Verificar usuários órfãos (sem organização)\n    const orphanUsers = await env.DB.prepare(`\n      SELECT COUNT(*) as count FROM users \n      WHERE organization_id IS NULL AND role != 'system_admin'\n    `).first() as any;\n\n    // Verificar organizações sem dono\n    const organizationsWithoutOwner = await env.DB.prepare(`\n      SELECT o.id, o.name FROM organizations o\n      LEFT JOIN user_organizations uo ON o.id = uo.organization_id AND uo.role = 'owner'\n      WHERE uo.organization_id IS NULL\n    `).all();\n\n    // Verificar usuários com permissões inconsistentes\n    const inconsistentUsers = await env.DB.prepare(`\n      SELECT id, email, role, can_manage_users, can_create_organizations \n      FROM users \n      WHERE (role = 'org_admin' AND (can_manage_users = 0 OR can_create_organizations = 0))\n         OR (role = 'system_admin' AND (can_manage_users = 0 OR can_create_organizations = 0))\n         OR (role NOT IN ('system_admin', 'org_admin') AND (can_manage_users = 1 OR can_create_organizations = 1))\n    `).all();\n\n    return c.json({\n      system_health: {\n        system_admins: {\n          count: systemAdmins.results?.length || 0,\n          users: systemAdmins.results || []\n        },\n        orphan_users: orphanUsers?.count || 0,\n        organizations_without_owner: {\n          count: organizationsWithoutOwner.results?.length || 0,\n          organizations: organizationsWithoutOwner.results || []\n        },\n        inconsistent_permissions: {\n          count: inconsistentUsers.results?.length || 0,\n          users: inconsistentUsers.results || []\n        }\n      },\n      health_status: {\n        overall: \"analyzing\",\n        issues_found: (orphanUsers?.count || 0) + (organizationsWithoutOwner.results?.length || 0) + (inconsistentUsers.results?.length || 0),\n        protected_user_secure: true\n      },\n      recommendations: [\n        \"Manter apenas um usuário system_admin principal\",\n        \"Associar usuários órfãos a organizações apropriadas\",\n        \"Garantir que todas as organizações tenham um proprietário\",\n        \"Corrigir permissões inconsistentes de usuários\"\n      ]\n    });\n\n  } catch (error) {\n    console.error('Error checking system health:', error);\n    return c.json({ error: \"Failed to check system health\" }, 500);\n  }\n});\n\n// Auto-fix endpoint adicional - Corrige problemas automaticamente (versão simplificada)\nsecurityRoutes.post('/auto-fix-simple', authMiddleware, async (c) => {\n  const env = c.env;\n  const user = c.get('user');\n\n  if (!user) {\n    return c.json({ error: 'User not found' }, 401);\n  }\n\n  // Verificar se é system_admin ou admin principal\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\n\n  const isSystemAdmin = userProfile?.role === 'sys_admin' ||\n    userProfile?.role === 'system_admin' ||\n    user.email === 'eng.tiagosm@gmail.com';\n\n  if (!isSystemAdmin) {\n    return c.json({ error: 'Acesso negado. Apenas system_admin pode executar auto-correção.' }, 403);\n  }\n\n  try {\n    console.log('[AUTO-FIX-SIMPLE] Iniciando auto-correção do sistema...');\n\n    const result = await autoFixSystemAdmin(env);\n\n    if (result.success) {\n      return c.json({\n        success: true,\n        message: result.message,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      return c.json({\n        success: false,\n        error: result.message\n      }, 500);\n    }\n  } catch (error) {\n    console.error('[AUTO-FIX-SIMPLE] Erro na auto-correção:', error);\n    return c.json({\n      error: 'Erro interno na auto-correção',\n      details: error instanceof Error ? error.message : 'Erro desconhecido'\n    }, 500);\n  }\n});\n\nexport default securityRoutes;\n\n"},{"name":"security-protection.ts","content":"import { Context } from \"hono\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n\r\n// Constantes de segurança - NUNCA ALTERAR ESTES VALORES\r\nexport const PROTECTED_SYSADMIN_EMAIL = 'eng.tiagosm@gmail.com';\r\nexport const PROTECTED_SYSADMIN_ID = '84edf8d1-77d9-4c73-935e-d76745bc3707';\r\nexport const MASTER_ORGANIZATION_ID = 1;\r\n\r\n// Função para verificar se um usuário está protegido\r\nexport function isProtectedUser(userId: string, userEmail?: string): boolean {\r\n  return userId === PROTECTED_SYSADMIN_ID || userEmail === PROTECTED_SYSADMIN_EMAIL;\r\n}\r\n\r\n// Middleware de proteção de usuários críticos\r\nexport function criticalUserProtection() {\r\n  return async (c: Context<{ Bindings: Env; Variables: { user: any } }>, next: () => Promise<void>) => {\r\n    const method = c.req.method;\r\n    const path = c.req.path;\r\n    const targetUserId = c.req.param(\"id\");\r\n\r\n    // Skip GET requests (apenas proteção para mudanças)\r\n    if (method === 'GET') {\r\n      await next();\r\n      return;\r\n    }\r\n\r\n    let body: any = {};\r\n    try {\r\n      body = await c.req.json();\r\n    } catch (error) {\r\n      // Body is not JSON or empty\r\n    }\r\n\r\n    // PROTEÇÃO ABSOLUTA: Bloquear qualquer modificação do usuário protegido\r\n    const isTargetingProtectedUser =\r\n      targetUserId === PROTECTED_SYSADMIN_ID ||\r\n      body.id === PROTECTED_SYSADMIN_ID ||\r\n      body.email === PROTECTED_SYSADMIN_EMAIL ||\r\n      body.user_id === PROTECTED_SYSADMIN_ID;\r\n\r\n    if (isTargetingProtectedUser && (method === 'PUT' || method === 'PATCH' || method === 'DELETE')) {\r\n      const user = c.get(\"user\");\r\n\r\n      // Log da tentativa de modificação\r\n      try {\r\n        const env = c.env;\r\n        await env.DB.prepare(`\r\n          INSERT INTO security_audit_log (\r\n            user_id, target_user_id, action_type, old_value, new_value, \r\n            blocked_reason, ip_address, user_agent, is_blocked, created_at\r\n          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())\r\n        `).bind(\r\n          user?.id || 'anonymous',\r\n          PROTECTED_SYSADMIN_ID,\r\n          `blocked_${method.toLowerCase()}_attempt`,\r\n          JSON.stringify({ path, method }),\r\n          JSON.stringify(body),\r\n          'Tentativa de modificar usuário protegido do sistema',\r\n          c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown',\r\n          c.req.header('user-agent') || 'unknown',\r\n          true\r\n        ).run();\r\n      } catch (error) {\r\n        console.error('Error logging security attempt:', error);\r\n      }\r\n\r\n      return c.json({\r\n        error: \"SISTEMA_PROTEGIDO\",\r\n        message: \"ACESSO NEGADO: Este usuário está sob proteção absoluta do sistema. Tentativa registrada.\",\r\n        protected_user: true,\r\n        system_security: true,\r\n        contact_support: \"Entre em contato com o suporte técnico se necessário.\",\r\n        blocked_at: new Date().toISOString()\r\n      }, 403);\r\n    }\r\n\r\n    // Impedir criação de novos system_admin (apenas o protegido pode fazer isso)\r\n    if (body.role === USER_ROLES.SYSTEM_ADMIN || body.role === 'sys_admin') {\r\n      const user = c.get(\"user\");\r\n\r\n      if (!user || user.id !== PROTECTED_SYSADMIN_ID) {\r\n        return c.json({\r\n          error: \"PRIVILEGIO_RESTRITO\",\r\n          message: \"Apenas o administrador principal pode conceder privilégios de sistema\",\r\n          protected_operation: true\r\n        }, 403);\r\n      }\r\n    }\r\n\r\n    await next();\r\n  };\r\n}\r\n\r\n// Função para verificar integridade do usuário protegido\r\nexport async function checkProtectedUserIntegrity(env: any): Promise<{\r\n  status: 'ok' | 'corrupted' | 'missing';\r\n  details: any;\r\n  fixed?: boolean;\r\n}> {\r\n  try {\r\n    const protectedUser = await env.DB.prepare(`\r\n      SELECT * FROM users WHERE id = ? OR email = ?\r\n    `).bind(PROTECTED_SYSADMIN_ID, PROTECTED_SYSADMIN_EMAIL).first() as any;\r\n\r\n    if (!protectedUser) {\r\n      return {\r\n        status: 'missing',\r\n        details: { error: 'Usuário protegido não encontrado no banco de dados' }\r\n      };\r\n    }\r\n\r\n    const expectedConfig = {\r\n      role: USER_ROLES.SYSTEM_ADMIN,\r\n      can_manage_users: true,\r\n      can_create_organizations: true,\r\n      is_active: true,\r\n      organization_id: MASTER_ORGANIZATION_ID\r\n    };\r\n\r\n    const currentConfig = {\r\n      role: protectedUser.role,\r\n      can_manage_users: Boolean(protectedUser.can_manage_users),\r\n      can_create_organizations: Boolean(protectedUser.can_create_organizations),\r\n      is_active: Boolean(protectedUser.is_active),\r\n      organization_id: protectedUser.organization_id\r\n    };\r\n\r\n    const isCorrupted = Object.keys(expectedConfig).some(key =>\r\n      expectedConfig[key as keyof typeof expectedConfig] !== currentConfig[key as keyof typeof currentConfig]\r\n    );\r\n\r\n    if (isCorrupted) {\r\n      return {\r\n        status: 'corrupted',\r\n        details: {\r\n          expected: expectedConfig,\r\n          current: currentConfig,\r\n          differences: Object.keys(expectedConfig).filter(key =>\r\n            expectedConfig[key as keyof typeof expectedConfig] !== currentConfig[key as keyof typeof currentConfig]\r\n          )\r\n        }\r\n      };\r\n    }\r\n\r\n    return {\r\n      status: 'ok',\r\n      details: { user: protectedUser, configuration: currentConfig }\r\n    };\r\n\r\n  } catch (error) {\r\n    return {\r\n      status: 'corrupted',\r\n      details: { error: 'Erro ao verificar integridade do usuário protegido', details: error }\r\n    };\r\n  }\r\n}\r\n\r\n// Função para auto-correção do usuário protegido\r\nexport async function autoFixProtectedUser(env: any, triggeredBy: string = 'system'): Promise<{\r\n  success: boolean;\r\n  action: 'created' | 'updated' | 'no_action_needed';\r\n  details: any;\r\n}> {\r\n  try {\r\n    const integrityCheck = await checkProtectedUserIntegrity(env);\r\n\r\n    if (integrityCheck.status === 'ok') {\r\n      return {\r\n        success: true,\r\n        action: 'no_action_needed',\r\n        details: { message: 'Usuário protegido já está configurado corretamente' }\r\n      };\r\n    }\r\n\r\n    if (integrityCheck.status === 'missing') {\r\n      // Recriar usuário completamente\r\n      await env.DB.prepare(`\r\n        INSERT OR REPLACE INTO users (\r\n          id, email, name, role, organization_id,\r\n          can_manage_users, can_create_organizations, is_active,\r\n          created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(\r\n        PROTECTED_SYSADMIN_ID,\r\n        PROTECTED_SYSADMIN_EMAIL,\r\n        'Tiago dos Santos Martins - SysAdmin',\r\n        USER_ROLES.SYSTEM_ADMIN,\r\n        MASTER_ORGANIZATION_ID,\r\n        true,\r\n        true,\r\n        true\r\n      ).run();\r\n\r\n      // Garantir associação com organização master\r\n      await env.DB.prepare(`\r\n        INSERT OR REPLACE INTO user_organizations (\r\n          user_id, organization_id, role, is_active, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(PROTECTED_SYSADMIN_ID, MASTER_ORGANIZATION_ID, 'owner', true).run();\r\n\r\n      // Adicionar à tabela de usuários protegidos\r\n      await env.DB.prepare(`\r\n        INSERT OR REPLACE INTO protected_users (\r\n          user_id, protection_level, protected_roles, protected_permissions,\r\n          reason, created_by, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(\r\n        PROTECTED_SYSADMIN_ID,\r\n        'maximum',\r\n        JSON.stringify([USER_ROLES.SYSTEM_ADMIN]),\r\n        JSON.stringify(['can_manage_users', 'can_create_organizations']),\r\n        'Usuário fundador do sistema - proteção máxima permanente',\r\n        triggeredBy\r\n      ).run();\r\n\r\n      return {\r\n        success: true,\r\n        action: 'created',\r\n        details: { message: 'Usuário protegido foi recriado com configurações de segurança máxima' }\r\n      };\r\n    }\r\n\r\n    if (integrityCheck.status === 'corrupted') {\r\n      // Corrigir configurações\r\n      await env.DB.prepare(`\r\n        UPDATE users \r\n        SET role = ?, organization_id = ?, can_manage_users = ?, \r\n            can_create_organizations = ?, is_active = ?, updated_at = NOW()\r\n        WHERE id = ? OR email = ?\r\n      `).bind(\r\n        USER_ROLES.SYSTEM_ADMIN,\r\n        MASTER_ORGANIZATION_ID,\r\n        true,\r\n        true,\r\n        true,\r\n        PROTECTED_SYSADMIN_ID,\r\n        PROTECTED_SYSADMIN_EMAIL\r\n      ).run();\r\n\r\n      // Garantir associação correta com organização\r\n      await env.DB.prepare(`\r\n        INSERT OR REPLACE INTO user_organizations (\r\n          user_id, organization_id, role, is_active, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(PROTECTED_SYSADMIN_ID, MASTER_ORGANIZATION_ID, 'owner', true).run();\r\n\r\n      return {\r\n        success: true,\r\n        action: 'updated',\r\n        details: {\r\n          message: 'Configurações do usuário protegido foram corrigidas',\r\n          fixed_issues: integrityCheck.details.differences\r\n        }\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      action: 'no_action_needed',\r\n      details: { error: 'Status de integridade desconhecido' }\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('Error in autoFixProtectedUser:', error);\r\n    return {\r\n      success: false,\r\n      action: 'no_action_needed',\r\n      details: { error: 'Erro ao corrigir usuário protegido', details: error }\r\n    };\r\n  }\r\n}\r\n\r\n// Middleware para verificação automática de integridade\r\nexport function autoIntegrityCheck() {\r\n  return async (c: Context<{ Bindings: Env; Variables: { user: any } }>, next: () => Promise<void>) => {\r\n    const user = c.get(\"user\");\r\n\r\n    // Executar verificação apenas para requisições do usuário protegido\r\n    if (user && user.id === PROTECTED_SYSADMIN_ID) {\r\n      try {\r\n        const env = c.env;\r\n        const integrityResult = await checkProtectedUserIntegrity(env);\r\n\r\n        if (integrityResult.status !== 'ok') {\r\n          console.warn('ALERTA DE SEGURANÇA: Integridade do usuário protegido comprometida');\r\n\r\n          // Auto-correção silenciosa\r\n          const fixResult = await autoFixProtectedUser(env, user.id);\r\n\r\n          if (fixResult.success) {\r\n            console.log('SEGURANÇA: Usuário protegido foi auto-corrigido', fixResult);\r\n\r\n            // Log da correção automática\r\n            await env.DB.prepare(`\r\n              INSERT INTO security_audit_log (\r\n                user_id, target_user_id, action_type, old_value, new_value,\r\n                blocked_reason, is_blocked, created_at\r\n              ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW())\r\n            `).bind(\r\n              'system',\r\n              PROTECTED_SYSADMIN_ID,\r\n              'auto_integrity_fix',\r\n              JSON.stringify(integrityResult.details),\r\n              JSON.stringify(fixResult.details),\r\n              'Correção automática de integridade do usuário protegido',\r\n              false\r\n            ).run();\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Error in auto integrity check:', error);\r\n      }\r\n    }\r\n\r\n    await next();\r\n  };\r\n}\r\n\r\n// Middleware para logs de segurança detalhados\r\nexport function securityAuditLogger() {\r\n  return async (c: Context<{ Bindings: Env; Variables: { user: any } }>, next: () => Promise<void>) => {\r\n    const startTime = Date.now();\r\n    const method = c.req.method;\r\n    const path = c.req.path;\r\n    const user = c.get(\"user\");\r\n\r\n    // Capturar dados da requisição para auditoria\r\n    let requestBody: any = null;\r\n    if (method !== 'GET') {\r\n      try {\r\n        requestBody = await c.req.json();\r\n      } catch (error) {\r\n        // Body is not JSON\r\n      }\r\n    }\r\n\r\n    await next();\r\n\r\n    const endTime = Date.now();\r\n    const responseTime = endTime - startTime;\r\n\r\n    // Log requisições sensíveis\r\n    const sensitiveOperations = [\r\n      '/api/users',\r\n      '/api/system-admin',\r\n      '/api/multi-tenant',\r\n      '/api/role-permissions'\r\n    ];\r\n\r\n    const isSensitive = sensitiveOperations.some(op => path.includes(op));\r\n\r\n    if (isSensitive && user) {\r\n      try {\r\n        const env = c.env;\r\n        await env.DB.prepare(`\r\n          INSERT INTO security_audit_log (\r\n            user_id, action_type, old_value, new_value,\r\n            ip_address, user_agent, is_blocked, created_at\r\n          ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW())\r\n        `).bind(\r\n          user.id,\r\n          `${method.toLowerCase()}_${path.replace('/api/', '').replace(/\\//g, '_')}`,\r\n          JSON.stringify({ method, path, responseTime }),\r\n          requestBody ? JSON.stringify(requestBody) : null,\r\n          c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || 'unknown',\r\n          c.req.header('user-agent') || 'unknown',\r\n          false\r\n        ).run();\r\n      } catch (error) {\r\n        console.error('Error logging security audit:', error);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n"},{"name":"session-management.ts","content":"/**\r\n * Session Management Middleware\r\n * \r\n * Responsável por:\r\n * - Rastrear sessão ativa do usuário\r\n * - Invalidar sessões anteriores ao fazer novo login\r\n * - Detectar tentativas de login simultâneo\r\n */\r\n\r\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\r\nimport type { Context, Next } from 'hono';\r\nimport { v4 as uuidv4 } from 'https://esm.sh/uuid@10.0.0';\r\n\r\n/**\r\n * Gera um novo session_id único\r\n */\r\nexport function generateSessionId(): string {\r\n    return uuidv4();\r\n}\r\n\r\n/**\r\n * Registra uma nova sessão para o usuário\r\n * Invalida todas as sessões anteriores\r\n */\r\nexport async function registerSession(\r\n    supabaseAdmin: ReturnType<typeof createClient>,\r\n    userId: string,\r\n    sessionId: string,\r\n    userAgent?: string,\r\n    ipAddress?: string\r\n): Promise<boolean> {\r\n    try {\r\n        // Atualizar usuário com nova sessão\r\n        const { error } = await supabaseAdmin\r\n            .from('users')\r\n            .update({\r\n                current_session_id: sessionId,\r\n                last_login_at: new Date().toISOString(),\r\n                last_login_ip: ipAddress,\r\n                last_login_device: userAgent?.substring(0, 255), // Limitar tamanho\r\n            })\r\n            .eq('id', userId);\r\n\r\n        if (error) {\r\n            console.error('Error registering session:', error);\r\n            return false;\r\n        }\r\n\r\n        // Logar a sessão para auditoria (opcional)\r\n        await supabaseAdmin.from('session_log').insert({\r\n            user_id: userId,\r\n            session_id: sessionId,\r\n            ip_address: ipAddress,\r\n            user_agent: userAgent?.substring(0, 500),\r\n            created_at: new Date().toISOString(),\r\n        }).catch(() => {\r\n            // Ignorar erro se tabela não existir\r\n        });\r\n\r\n        return true;\r\n    } catch (error) {\r\n        console.error('Error in registerSession:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Valida se a sessão atual ainda é válida\r\n * Retorna false se outra sessão foi iniciada\r\n */\r\nexport async function validateSession(\r\n    supabaseAdmin: ReturnType<typeof createClient>,\r\n    userId: string,\r\n    currentSessionId: string\r\n): Promise<{ valid: boolean; conflictDevice?: string }> {\r\n    try {\r\n        const { data: user, error } = await supabaseAdmin\r\n            .from('users')\r\n            .select('current_session_id, last_login_device, last_login_at')\r\n            .eq('id', userId)\r\n            .single();\r\n\r\n        if (error || !user) {\r\n            return { valid: true }; // Em caso de erro, permitir\r\n        }\r\n\r\n        // Se não tem sessão registrada ou é a sessão atual, é válida\r\n        if (!user.current_session_id || user.current_session_id === currentSessionId) {\r\n            return { valid: true };\r\n        }\r\n\r\n        // Sessão foi substituída por outra\r\n        return {\r\n            valid: false,\r\n            conflictDevice: user.last_login_device || 'Outro dispositivo',\r\n        };\r\n    } catch (error) {\r\n        console.error('Error validating session:', error);\r\n        return { valid: true }; // Em caso de erro, permitir\r\n    }\r\n}\r\n\r\n/**\r\n * Invalida a sessão atual (logout)\r\n */\r\nexport async function invalidateSession(\r\n    supabaseAdmin: ReturnType<typeof createClient>,\r\n    userId: string\r\n): Promise<boolean> {\r\n    try {\r\n        const { error } = await supabaseAdmin\r\n            .from('users')\r\n            .update({\r\n                current_session_id: null,\r\n            })\r\n            .eq('id', userId);\r\n\r\n        return !error;\r\n    } catch (error) {\r\n        console.error('Error invalidating session:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Middleware para validar sessão em cada requisição\r\n * Adiciona informações de validação ao contexto\r\n */\r\nexport function sessionValidationMiddleware() {\r\n    return async (c: Context, next: Next) => {\r\n        const user = c.get('user');\r\n\r\n        if (!user?.id) {\r\n            return next();\r\n        }\r\n\r\n        // Buscar session_id do header ou cookie\r\n        const currentSessionId = c.req.header('X-Session-Id') ||\r\n            c.req.cookie?.('session_id');\r\n\r\n        if (!currentSessionId) {\r\n            // Sem session_id, continuar sem validação\r\n            // (será registrado no login)\r\n            return next();\r\n        }\r\n\r\n        // Criar cliente Supabase admin\r\n        const supabaseUrl = c.env?.SUPABASE_URL || Deno.env.get('SUPABASE_URL');\r\n        const supabaseKey = c.env?.SUPABASE_SERVICE_ROLE_KEY || Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\r\n\r\n        if (!supabaseUrl || !supabaseKey) {\r\n            return next();\r\n        }\r\n\r\n        const supabaseAdmin = createClient(supabaseUrl, supabaseKey);\r\n\r\n        const validation = await validateSession(supabaseAdmin, user.id, currentSessionId);\r\n\r\n        if (!validation.valid) {\r\n            return c.json({\r\n                error: 'Sessão inválida',\r\n                code: 'SESSION_CONFLICT',\r\n                message: `Outra sessão foi iniciada em: ${validation.conflictDevice}`,\r\n                conflictDevice: validation.conflictDevice,\r\n            }, 401);\r\n        }\r\n\r\n        c.set('sessionValid', true);\r\n        await next();\r\n    };\r\n}\r\n\r\n/**\r\n * Endpoint handler para registrar nova sessão após login\r\n */\r\nexport async function handleLoginSession(\r\n    supabaseAdmin: ReturnType<typeof createClient>,\r\n    userId: string,\r\n    c: Context\r\n): Promise<string> {\r\n    const sessionId = generateSessionId();\r\n    const userAgent = c.req.header('User-Agent');\r\n    const ipAddress = c.req.header('X-Forwarded-For') ||\r\n        c.req.header('X-Real-IP') ||\r\n        'unknown';\r\n\r\n    await registerSession(supabaseAdmin, userId, sessionId, userAgent, ipAddress);\r\n\r\n    return sessionId;\r\n}\r\n"},{"name":"share-routes.ts","content":"import { Hono } from 'hono';\r\nimport { zValidator } from '@hono/zod-validator';\r\nimport { z } from 'zod';\r\nimport { tenantAuthMiddleware as authMiddleware } from './tenant-auth-middleware.ts';\r\nimport { logActivity } from './audit-logger.ts';\r\n\r\nconst shareRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\nconst CreateShareSchema = z.object({\r\n  inspection_id: z.number(),\r\n  permission: z.enum(['view', 'edit']),\r\n  expires_at: z.string().optional()\r\n});\r\n\r\nconst UpdateShareResponsesSchema = z.object({\r\n  responses: z.array(z.object({\r\n    field_id: z.number(),\r\n    field_name: z.string(),\r\n    field_type: z.string(),\r\n    value: z.any(),\r\n    comment: z.string().optional()\r\n  }))\r\n});\r\n\r\n// Helper function to generate a simple QR code as SVG (browser-compatible)\r\nfunction generateQRCodeSVG(text: string, size = 200): string {\r\n  // Simple QR code placeholder as SVG\r\n  return `\r\n    <svg width=\"${size}\" height=\"${size}\" xmlns=\"http://www.w3.org/2000/svg\">\r\n      <rect width=\"100%\" height=\"100%\" fill=\"#ffffff\"/>\r\n      <rect x=\"10\" y=\"10\" width=\"180\" height=\"180\" fill=\"none\" stroke=\"#000000\" stroke-width=\"2\"/>\r\n      <text x=\"${size / 2}\" y=\"${size / 2 - 10}\" text-anchor=\"middle\" font-family=\"Arial\" font-size=\"12\" fill=\"#000000\">\r\n        QR Code\r\n      </text>\r\n      <text x=\"${size / 2}\" y=\"${size / 2 + 10}\" text-anchor=\"middle\" font-family=\"Arial\" font-size=\"8\" fill=\"#666666\">\r\n        ${text.length > 30 ? text.substring(0, 27) + '...' : text}\r\n      </text>\r\n    </svg>\r\n  `;\r\n}\r\n\r\n// Create share link for inspection\r\nshareRoutes.post('/:id/share', authMiddleware, async (c) => {\r\n  const inspectionId = parseInt(c.req.param('id'));\r\n  const user = c.get('user');\r\n\r\n  if (!user) {\r\n    return c.json({ error: 'Usuário não encontrado' }, 401);\r\n  }\r\n\r\n  const body = await c.req.json();\r\n  const { permission = 'view', expires_at } = body;\r\n\r\n  // Generate unique share token\r\n  const shareToken = Math.random().toString(36).substring(2, 15) +\r\n    Math.random().toString(36).substring(2, 15);\r\n\r\n  try {\r\n    const result = await c.env.DB.prepare(`\r\n      INSERT INTO inspection_shares (\r\n        inspection_id, share_token, created_by, permission, expires_at, \r\n        is_active, access_count, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n    `).bind(\r\n      inspectionId,\r\n      shareToken,\r\n      user.id,\r\n      permission,\r\n      expires_at || null,\r\n      true,\r\n      0\r\n    ).run();\r\n\r\n    // Generate share URL and QR Code\r\n    const shareUrl = `${c.req.header('origin') || 'https://localhost'}/shared/${shareToken}`;\r\n    const qrCodeSVG = generateQRCodeSVG(shareUrl);\r\n    const qrCodeBase64 = `data:image/svg+xml;base64,${btoa(qrCodeSVG)}`;\r\n\r\n    // Log Activity (Async)\r\n    await logActivity(c.env, {\r\n      userId: user.id,\r\n      orgId: user.organization_id || null, // Best effort\r\n      actionType: 'SHARE',\r\n      actionDescription: `Inspection Shared: ${inspectionId}`,\r\n      targetType: 'INSPECTION',\r\n      targetId: inspectionId,\r\n      metadata: { share_token: shareToken, permission },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({\r\n      id: result.meta.last_row_id,\r\n      share_token: shareToken,\r\n      share_url: shareUrl,\r\n      qr_code: qrCodeBase64,\r\n      message: 'Link de compartilhamento criado com sucesso'\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating share link:', error);\r\n    return c.json({ error: 'Erro ao criar link de compartilhamento' }, 500);\r\n  }\r\n});\r\n\r\n// Get share links for inspection\r\nshareRoutes.get('/:id/shares', authMiddleware, async (c) => {\r\n  const inspectionId = parseInt(c.req.param('id'));\r\n\r\n  const shares = await c.env.DB.prepare(`\r\n    SELECT * FROM inspection_shares \r\n    WHERE inspection_id = ? \r\n    ORDER BY created_at DESC\r\n  `).bind(inspectionId).all();\r\n\r\n  return c.json({ shares: shares.results });\r\n});\r\n\r\n// Create share link (new endpoint)\r\nshareRoutes.post('/create', zValidator('json', CreateShareSchema), authMiddleware, async (c) => {\r\n  const { inspection_id, permission, expires_at } = c.req.valid('json');\r\n\r\n  try {\r\n    // Generate unique token\r\n    const token = self.crypto.randomUUID();\r\n\r\n    // Set expiration (default 30 days)\r\n    const expirationDate = expires_at ? new Date(expires_at) : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);\r\n\r\n    // Get current user\r\n    const user = c.get('user');\r\n    if (!user) {\r\n      return c.json({ error: 'Usuário não autenticado' }, 401);\r\n    }\r\n\r\n    // Create share record\r\n    await c.env.DB.prepare(`\r\n      INSERT INTO inspection_shares \r\n      (inspection_id, share_token, created_by, permission, expires_at)\r\n      VALUES (?, ?, ?, ?, ?)\r\n    `).bind(\r\n      inspection_id,\r\n      token,\r\n      user.id,\r\n      permission,\r\n      expirationDate.toISOString()\r\n    ).run();\r\n\r\n    // Generate share URL\r\n    const baseUrl = c.req.header('origin') || 'https://localhost';\r\n    const shareUrl = `${baseUrl}/shared/${token}`;\r\n\r\n    // Generate QR code as SVG\r\n    const qrCodeSVG = generateQRCodeSVG(shareUrl);\r\n\r\n    // Convert SVG to base64 data URL\r\n    const qrCodeBase64 = `data:image/svg+xml;base64,${btoa(qrCodeSVG)}`;\r\n\r\n    // Log Activity (Async)\r\n    await logActivity(c.env, {\r\n      userId: user.id,\r\n      orgId: user.organization_id || null,\r\n      actionType: 'SHARE',\r\n      actionDescription: `Inspection Shared (New): ${inspection_id}`,\r\n      targetType: 'INSPECTION',\r\n      targetId: inspection_id,\r\n      metadata: { share_token: token, permission },\r\n      req: c.req\r\n    });\r\n\r\n    return c.json({\r\n      success: true,\r\n      share: {\r\n        token,\r\n        url: shareUrl,\r\n        qr_code: qrCodeBase64,\r\n        permission,\r\n        expires_at: expirationDate.toISOString()\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating share:', error);\r\n    return c.json({ error: 'Erro ao criar compartilhamento' }, 500);\r\n  }\r\n});\r\n\r\n// Get shared inspection\r\nshareRoutes.get('/:token', async (c) => {\r\n  const token = c.req.param('token');\r\n\r\n  try {\r\n    // Get share record\r\n    const shareResult = await c.env.DB.prepare(`\r\n      SELECT * FROM inspection_shares \r\n      WHERE share_token = ? AND is_active = true\r\n    `).bind(token).first();\r\n\r\n    if (!shareResult) {\r\n      return c.json({ error: 'Link não encontrado' }, 404);\r\n    }\r\n\r\n    // Check if expired\r\n    const now = new Date();\r\n    const expiresAt = new Date(shareResult.expires_at as string);\r\n\r\n    if (expiresAt < now) {\r\n      return c.json({\r\n        error: 'Link expirado',\r\n        expired: true\r\n      }, 410);\r\n    }\r\n\r\n    // Get inspection details\r\n    const inspection = await c.env.DB.prepare(`\r\n      SELECT i.*, u.name as inspector_name, u.email as inspector_email\r\n      FROM inspections i\r\n      LEFT JOIN users u ON i.created_by = u.id\r\n      WHERE i.id = ?\r\n    `).bind(shareResult.inspection_id).first();\r\n\r\n    if (!inspection) {\r\n      return c.json({ error: 'Inspeção não encontrada' }, 404);\r\n    }\r\n\r\n    // Get inspection items\r\n    const items = await c.env.DB.prepare(`\r\n      SELECT * FROM inspection_items \r\n      WHERE inspection_id = ?\r\n      ORDER BY id\r\n    `).bind(shareResult.inspection_id).all();\r\n\r\n    // Get inspection media\r\n    const media = await c.env.DB.prepare(`\r\n      SELECT * FROM inspection_media \r\n      WHERE inspection_id = ?\r\n      ORDER BY id\r\n    `).bind(shareResult.inspection_id).all();\r\n\r\n    return c.json({\r\n      success: true,\r\n      share: shareResult,\r\n      inspection,\r\n      items: items.results || [],\r\n      media: media.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error getting shared inspection:', error);\r\n    return c.json({ error: 'Erro ao carregar inspeção' }, 500);\r\n  }\r\n});\r\n\r\n// Get share details (for QR code generation, etc.)\r\nshareRoutes.get('/:token/details', async (c) => {\r\n  const token = c.req.param('token');\r\n\r\n  try {\r\n    const shareResult = await c.env.DB.prepare(`\r\n      SELECT s.*, i.title as inspection_title, u.name as inviter_name,\r\n             org.name as organization_name\r\n      FROM inspection_shares s\r\n      JOIN inspections i ON s.inspection_id = i.id\r\n      LEFT JOIN users u ON s.created_by = u.id\r\n      LEFT JOIN organizations org ON i.organization_id = org.id\r\n      WHERE s.share_token = ? AND s.is_active = true\r\n    `).bind(token).first();\r\n\r\n    if (!shareResult) {\r\n      return c.json({ error: 'Share não encontrado' }, 404);\r\n    }\r\n\r\n    // Check if expired\r\n    const now = new Date();\r\n    const expiresAt = new Date(shareResult.expires_at as string);\r\n\r\n    if (expiresAt < now) {\r\n      return c.json({\r\n        error: 'Link expirado',\r\n        expired: true\r\n      }, 410);\r\n    }\r\n\r\n    return c.json({\r\n      success: true,\r\n      share: shareResult\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error getting share details:', error);\r\n    return c.json({ error: 'Erro ao carregar detalhes do compartilhamento' }, 500);\r\n  }\r\n});\r\n\r\n// Track access\r\nshareRoutes.post('/:token/access', async (c) => {\r\n  const token = c.req.param('token');\r\n\r\n  try {\r\n    await c.env.DB.prepare(`\r\n      UPDATE inspection_shares \r\n      SET access_count = access_count + 1,\r\n          updated_at = CURRENT_TIMESTAMP\r\n      WHERE share_token = ? AND is_active = true\r\n    `).bind(token).run();\r\n\r\n    return c.json({ success: true });\r\n\r\n  } catch (error) {\r\n    console.error('Error tracking access:', error);\r\n    return c.json({ error: 'Erro ao registrar acesso' }, 500);\r\n  }\r\n});\r\n\r\n// Update shared inspection responses (for edit permission)\r\nshareRoutes.post('/:token/responses', zValidator('json', UpdateShareResponsesSchema), async (c) => {\r\n  const token = c.req.param('token');\r\n  const { responses } = c.req.valid('json');\r\n\r\n  try {\r\n    // Get share record and check permissions\r\n    const shareResult = await c.env.DB.prepare(`\r\n      SELECT * FROM inspection_shares \r\n      WHERE share_token = ? AND is_active = true AND permission = 'edit'\r\n    `).bind(token).first();\r\n\r\n    if (!shareResult) {\r\n      return c.json({ error: 'Permissão insuficiente ou link inválido' }, 403);\r\n    }\r\n\r\n    // Check if expired\r\n    const now = new Date();\r\n    const expiresAt = new Date(shareResult.expires_at as string);\r\n\r\n    if (expiresAt < now) {\r\n      return c.json({ error: 'Link expirado' }, 410);\r\n    }\r\n\r\n    const inspectionId = shareResult.inspection_id as number;\r\n\r\n    // Update responses in inspection_items\r\n    for (const response of responses) {\r\n      // Check if item already exists\r\n      const existingItem = await c.env.DB.prepare(`\r\n        SELECT id FROM inspection_items \r\n        WHERE inspection_id = ? AND template_id IS NOT NULL \r\n        AND JSON_EXTRACT(field_responses, '$.field_id') = ?\r\n      `).bind(inspectionId, response.field_id).first();\r\n\r\n      const fieldData = {\r\n        field_id: response.field_id,\r\n        field_type: response.field_type,\r\n        response_value: response.value,\r\n        comment: response.comment,\r\n        is_required: false\r\n      };\r\n\r\n      if (existingItem) {\r\n        // Update existing item\r\n        await c.env.DB.prepare(`\r\n          UPDATE inspection_items \r\n          SET field_responses = ?, updated_at = CURRENT_TIMESTAMP\r\n          WHERE id = ?\r\n        `).bind(\r\n          JSON.stringify(fieldData),\r\n          existingItem.id\r\n        ).run();\r\n      } else {\r\n        // Create new item\r\n        await c.env.DB.prepare(`\r\n          INSERT INTO inspection_items \r\n          (inspection_id, category, item_description, field_responses, template_id)\r\n          VALUES (?, ?, ?, ?, ?)\r\n        `).bind(\r\n          inspectionId,\r\n          'Template Response',\r\n          response.field_name,\r\n          JSON.stringify(fieldData),\r\n          1 // Placeholder template ID\r\n        ).run();\r\n      }\r\n    }\r\n\r\n    // Update inspection status\r\n    await c.env.DB.prepare(`\r\n      UPDATE inspections \r\n      SET status = 'em_andamento', updated_at = CURRENT_TIMESTAMP\r\n      WHERE id = ?\r\n    `).bind(inspectionId).run();\r\n\r\n    return c.json({ success: true });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating responses:', error);\r\n    return c.json({ error: 'Erro ao salvar respostas' }, 500);\r\n  }\r\n});\r\n\r\n// List shares for an inspection (legacy endpoint)\r\nshareRoutes.get('/inspection/:id', authMiddleware, async (c) => {\r\n  const inspectionId = parseInt(c.req.param('id'));\r\n  const user = c.get('user');\r\n\r\n  if (!user) {\r\n    return c.json({ error: 'Usuário não autenticado' }, 401);\r\n  }\r\n\r\n  try {\r\n    const shares = await c.env.DB.prepare(`\r\n      SELECT s.*, u.name as created_by_name\r\n      FROM inspection_shares s\r\n      LEFT JOIN users u ON s.created_by = u.id\r\n      WHERE s.inspection_id = ? AND s.is_active = true\r\n      ORDER BY s.created_at DESC\r\n    `).bind(inspectionId).all();\r\n\r\n    return c.json({\r\n      success: true,\r\n      shares: shares.results || []\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error listing shares:', error);\r\n    return c.json({ error: 'Erro ao carregar compartilhamentos' }, 500);\r\n  }\r\n});\r\n\r\n// Update share link\r\nshareRoutes.put('/inspection-shares/:id', authMiddleware, async (c) => {\r\n  const shareId = parseInt(c.req.param('id'));\r\n  const body = await c.req.json();\r\n\r\n  const { is_active, expires_at } = body;\r\n\r\n  await c.env.DB.prepare(`\r\n    UPDATE inspection_shares \r\n    SET is_active = ?, expires_at = ?, updated_at = NOW()\r\n    WHERE id = ?\r\n  `).bind(is_active, expires_at, shareId).run();\r\n\r\n  return c.json({ message: 'Link de compartilhamento atualizado com sucesso' });\r\n});\r\n\r\n// Deactivate share\r\nshareRoutes.delete('/:token', authMiddleware, async (c) => {\r\n  const token = c.req.param('token');\r\n  const user = c.get('user');\r\n\r\n  if (!user) {\r\n    return c.json({ error: 'Usuário não autenticado' }, 401);\r\n  }\r\n\r\n  try {\r\n    // Check if user owns this share or has permission to manage it\r\n    const shareResult = await c.env.DB.prepare(`\r\n      SELECT s.*, i.created_by as inspection_owner\r\n      FROM inspection_shares s\r\n      JOIN inspections i ON s.inspection_id = i.id\r\n      WHERE s.share_token = ?\r\n    `).bind(token).first();\r\n\r\n    if (!shareResult) {\r\n      return c.json({ error: 'Compartilhamento não encontrado' }, 404);\r\n    }\r\n\r\n    if (shareResult.created_by !== user.id && shareResult.inspection_owner !== user.id) {\r\n      return c.json({ error: 'Permissão insuficiente' }, 403);\r\n    }\r\n\r\n    // Deactivate share\r\n    await c.env.DB.prepare(`\r\n      UPDATE inspection_shares \r\n      SET is_active = false, updated_at = CURRENT_TIMESTAMP\r\n      WHERE share_token = ?\r\n    `).bind(token).run();\r\n\r\n    return c.json({ success: true });\r\n\r\n    // Log Deactivation (Async)\r\n    logActivity(c.env, {\r\n      userId: user.id,\r\n      orgId: user.organization_id,\r\n      actionType: 'UNSHARE',\r\n      actionDescription: `Inspection Share Deactivated`,\r\n      targetType: 'INSPECTION',\r\n      targetId: shareResult.inspection_id,\r\n      metadata: { token },\r\n      req: c.req\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error deactivating share:', error);\r\n    return c.json({ error: 'Erro ao desativar compartilhamento' }, 500);\r\n  }\r\n});\r\n\r\n// Delete share link\r\nshareRoutes.delete('/inspection-shares/:id', authMiddleware, async (c) => {\r\n  const shareId = parseInt(c.req.param('id'));\r\n\r\n  await c.env.DB.prepare(`\r\n    DELETE FROM inspection_shares WHERE id = ?\r\n  `).bind(shareId).run();\r\n\r\n  return c.json({ message: 'Link de compartilhamento excluído com sucesso' });\r\n\r\n  // Log Deletion (Async) - Note: User might not be available in context for this admin route easily if middleware doesn't set it perfectly? Middleware writes to c.get('user').\r\n  // We can try to get user.\r\n  const user = c.get('user');\r\n  if (user) {\r\n    logActivity(c.env, {\r\n      userId: user.id,\r\n      orgId: user.organization_id,\r\n      actionType: 'UNSHARE', // Admin delete\r\n      actionDescription: `Inspection Share Deleted: ${shareId}`,\r\n      targetType: 'INSPECTION_SHARE',\r\n      targetId: shareId,\r\n      req: c.req\r\n    });\r\n  }\r\n});\r\n\r\nexport default shareRoutes;\r\n\r\n"},{"name":"shared/checklist-types.ts","content":"import z from \"zod\";\n\nexport const ChecklistFieldTypeSchema = z.enum([\n  'text',\n  'textarea',\n  'select',\n  'multiselect',\n  'radio',\n  'checkbox',\n  'number',\n  'date',\n  'time',\n  'boolean',\n  'rating',\n  'file'\n]);\n\nexport type ChecklistFieldType = z.infer<typeof ChecklistFieldTypeSchema>;\n\nexport const ChecklistFieldSchema = z.object({\n  id: z.number().optional(),\n  template_id: z.number(),\n  field_name: z.string().min(1, \"Nome do campo é obrigatório\"),\n  field_type: ChecklistFieldTypeSchema,\n  is_required: z.boolean().default(false),\n  options: z.string().optional(), // JSON string for select/radio options\n  order_index: z.number().default(0),\n  created_at: z.string().optional(),\n  updated_at: z.string().optional(),\n});\n\nexport type ChecklistField = z.infer<typeof ChecklistFieldSchema>;\n\nexport const ChecklistTemplateSchema = z.object({\n  id: z.number().optional(),\n  name: z.string().min(1, \"Nome do template é obrigatório\"),\n  description: z.string().optional(),\n  category: z.string().min(1, \"Categoria é obrigatória\"),\n  created_by: z.string().optional(),\n  is_public: z.boolean().default(false),\n  created_at: z.string().optional(),\n  updated_at: z.string().optional(),\n  // Hierarchical folder support\n  parent_category_id: z.number().optional(),\n  folder_id: z.string().optional(),\n  category_path: z.string().optional(),\n  is_category_folder: z.boolean().default(false),\n  folder_color: z.string().default('#3B82F6'),\n  folder_icon: z.string().default('folder'),\n  display_order: z.number().default(0),\n});\n\nexport type ChecklistTemplate = z.infer<typeof ChecklistTemplateSchema>;\n\nexport const AIChecklistRequestSchema = z.object({\n  industry: z.string().min(1, \"Setor é obrigatório\"),\n  location_type: z.string().min(1, \"Tipo de local é obrigatório\"),\n  specific_requirements: z.string().optional(),\n  template_name: z.string().min(1, \"Nome do template é obrigatório\"),\n  category: z.string().min(1, \"Categoria é obrigatória\"),\n\n  // Advanced Configuration\n  num_questions: z.number().min(5).max(50).default(20),\n  detail_level: z.enum(['basico', 'intermediario', 'avancado']).default('intermediario'),\n  priority_focus: z.enum(['seguranca', 'operacional', 'qualidade', 'balanceado']).default('balanceado'),\n  risk_level: z.enum(['baixo', 'medio', 'alto', 'critico']).default('medio'),\n\n  // Compliance & Standards\n  regulatory_standards: z.array(z.string()).optional(),\n  certifications_required: z.array(z.string()).optional(),\n  company_policies: z.string().optional(),\n\n  // Field Types Preferences\n  preferred_field_types: z.array(z.string()).optional(),\n  include_media_upload: z.boolean().default(true),\n  include_comments: z.boolean().default(true),\n  include_action_items: z.boolean().default(true),\n\n  // Template Base\n  base_template_id: z.number().optional(),\n  merge_with_existing: z.boolean().default(false),\n\n  // Documents & References\n  reference_documents: z.array(z.string()).optional(),\n  custom_instructions: z.string().optional(),\n});\n\nexport type AIChecklistRequest = z.infer<typeof AIChecklistRequestSchema>;\n\nexport interface AITemplatePreset {\n  id: string;\n  name: string;\n  industry: string;\n  location_type: string;\n  description: string;\n  icon: string;\n  color: string;\n  default_config: Partial<AIChecklistRequest>;\n  sample_fields: string[];\n}\n\nexport const CSVImportSchema = z.object({\n  template_name: z.string().min(1, \"Nome do template é obrigatório\"),\n  category: z.string().min(1, \"Categoria é obrigatória\"),\n  csv_data: z.string().min(1, \"Dados CSV são obrigatórios\"),\n});\n\nexport type CSVImport = z.infer<typeof CSVImportSchema>;\n\nexport interface FieldResponse {\n  field_id: number;\n  field_name: string;\n  field_type: ChecklistFieldType;\n  value: any;\n  comment?: string;\n  compliance_status?: string; // 'compliant' | 'non_compliant' | 'not_applicable' | 'unanswered'\n}\n\nexport interface ChecklistTemplateWithFields extends ChecklistTemplate {\n  fields: ChecklistField[];\n  field_count?: number;\n}\n\nexport interface ChecklistFolder {\n  id: string;\n  organization_id: number;\n  parent_id: string | null;\n  name: string;\n  slug: string;\n  path: string;\n  description?: string;\n  color: string;\n  icon: string;\n  display_order: number;\n  created_at: string;\n  updated_at: string;\n  children?: ChecklistFolder[];\n  subfolder_count?: number;\n  template_count?: number;\n}\n\nexport interface CategoryFolder extends ChecklistTemplate {\n  children: (ChecklistTemplate | CategoryFolder)[];\n  template_count: number;\n}\n"},{"name":"shared/folder-types.ts","content":"import z from \"zod\";\n\nexport const ChecklistFolderSchema = z.object({\n  id: z.string().optional(),\n  organization_id: z.number(),\n  parent_id: z.string().optional().nullable(),\n  name: z.string().min(1, \"Nome da pasta é obrigatório\"),\n  slug: z.string(),\n  path: z.string(),\n  description: z.string().optional().nullable(),\n  color: z.string().default('#3B82F6'),\n  icon: z.string().default('folder'),\n  display_order: z.number().default(0),\n  created_at: z.string().optional(),\n  updated_at: z.string().optional(),\n});\n\nexport type ChecklistFolder = z.infer<typeof ChecklistFolderSchema>;\n\nexport interface ChecklistFolderWithCounts extends ChecklistFolder {\n  subfolder_count: number;\n  template_count: number;\n  children?: (ChecklistFolderWithCounts | ChecklistTemplateInFolder)[];\n}\n\nexport interface ChecklistTemplateInFolder {\n  id: number;\n  name: string;\n  description?: string;\n  category: string;\n  folder_id?: string;\n  is_public: boolean;\n  created_by?: string;\n  created_at?: string;\n  updated_at?: string;\n  field_count?: number;\n}\n\nexport interface FolderTreeNode {\n  id: string;\n  parent_id: string | null;\n  name: string;\n  slug: string;\n  path: string;\n  color: string;\n  icon: string;\n  display_order: number;\n  children: FolderTreeNode[];\n}\n\nexport const CreateFolderSchema = z.object({\n  name: z.string().min(1, \"Nome da pasta é obrigatório\").max(100, \"Nome muito longo\"),\n  description: z.string().max(500, \"Descrição muito longa\").optional(),\n  parent_id: z.string().optional().nullable(),\n  color: z.string().regex(/^#[0-9A-F]{6}$/i, \"Cor inválida\").default('#3B82F6'),\n  icon: z.string().min(1, \"Ícone é obrigatório\").default('folder'),\n});\n\nexport type CreateFolder = z.infer<typeof CreateFolderSchema>;\n\nexport const UpdateFolderSchema = z.object({\n  name: z.string().min(1, \"Nome da pasta é obrigatório\").max(100, \"Nome muito longo\").optional(),\n  description: z.string().max(500, \"Descrição muito longa\").optional().nullable(),\n  parent_id: z.string().optional().nullable(),\n  color: z.string().regex(/^#[0-9A-F]{6}$/i, \"Cor inválida\").optional(),\n  icon: z.string().min(1, \"Ícone é obrigatório\").optional(),\n});\n\nexport type UpdateFolder = z.infer<typeof UpdateFolderSchema>;\n\nexport const MoveItemsSchema = z.object({\n  templateIds: z.array(z.number()).default([]),\n  folderIds: z.array(z.string()).default([]),\n});\n\nexport type MoveItems = z.infer<typeof MoveItemsSchema>;\n\nexport const DeleteFolderStrategy = z.enum(['block', 'merge', 'cascade']);\nexport type DeleteFolderStrategy = z.infer<typeof DeleteFolderStrategy>;\n\nexport interface MigrationResult {\n  success: boolean;\n  organizations_migrated: number;\n  templates_migrated: number;\n  details: Array<{\n    organization_id: number;\n    templates_migrated: number;\n  }>;\n}\n\nexport interface FolderBreadcrumb {\n  id: string;\n  name: string;\n  color: string;\n  icon: string;\n}\n\n// Ícones disponíveis para pastas\nexport const FOLDER_ICONS = [\n  { value: 'folder', label: 'Pasta', icon: '📁' },\n  { value: 'shield', label: 'Segurança', icon: '🛡️' },\n  { value: 'hard-hat', label: 'Construção', icon: '⛑️' },\n  { value: 'book-open', label: 'Manual', icon: '📖' },\n  { value: 'settings', label: 'Configurações', icon: '⚙️' },\n  { value: 'leaf', label: 'Meio Ambiente', icon: '🌿' },\n  { value: 'award', label: 'Qualidade', icon: '🏆' },\n  { value: 'cog', label: 'Operacional', icon: '⚙️' },\n  { value: 'mountain', label: 'Industrial', icon: '🏭' },\n  { value: 'shield-check', label: 'Auditoria', icon: '✅' },\n  { value: 'user-check', label: 'Pessoal', icon: '👤' },\n  { value: 'file-text', label: 'Documentos', icon: '📄' },\n];\n\n// Cores disponíveis para pastas\nexport const FOLDER_COLORS = [\n  { value: '#3B82F6', label: 'Azul', hex: '#3B82F6' },\n  { value: '#10B981', label: 'Verde', hex: '#10B981' },\n  { value: '#F59E0B', label: 'Amarelo', hex: '#F59E0B' },\n  { value: '#EF4444', label: 'Vermelho', hex: '#EF4444' },\n  { value: '#8B5CF6', label: 'Roxo', hex: '#8B5CF6' },\n  { value: '#06B6D4', label: 'Ciano', hex: '#06B6D4' },\n  { value: '#84CC16', label: 'Lima', hex: '#84CC16' },\n  { value: '#F97316', label: 'Laranja', hex: '#F97316' },\n  { value: '#EC4899', label: 'Rosa', hex: '#EC4899' },\n  { value: '#6B7280', label: 'Cinza', hex: '#6B7280' },\n];\n"},{"name":"shared/types.ts","content":"import z from \"zod\";\n\nexport interface Organization {\n  id: number;\n  name: string;\n  type: 'company' | 'consultancy' | 'client';\n  description?: string;\n  logo_url?: string;\n  contact_email?: string;\n  contact_phone?: string;\n  address?: string;\n  is_active: boolean;\n  created_at: string;\n  updated_at: string;\n  parent_organization_id?: number;\n  organization_level?: string;\n  subscription_status?: string;\n  subscription_plan?: string;\n  max_users?: number;\n  max_subsidiaries?: number;\n  cnpj?: string;\n  razao_social?: string;\n  nome_fantasia?: string;\n  website?: string;\n  faturamento_anual?: number;\n  cnae_principal?: string;\n  cnae_descricao?: string;\n  natureza_juridica?: string;\n  data_abertura?: string;\n  capital_social?: number;\n  porte_empresa?: string;\n  situacao_cadastral?: string;\n  numero_funcionarios?: number;\n  setor_industria?: string;\n  subsetor_industria?: string;\n  certificacoes_seguranca?: string;\n  data_ultima_auditoria?: string;\n  nivel_risco?: string;\n  contato_seguranca_nome?: string;\n  contato_seguranca_email?: string;\n  contato_seguranca_telefone?: string;\n  historico_incidentes?: string;\n  observacoes_compliance?: string;\n}\n\nexport const InspectionSchema = z.object({\n  id: z.number().optional(),\n  title: z.string().min(1, \"Título é obrigatório\"),\n  description: z.string().optional(),\n  location: z.string().min(1, \"Local é obrigatório\"),\n  company_name: z.string().min(1, \"Nome da empresa é obrigatório\"),\n  cep: z.string().optional(),\n  address: z.string().optional(),\n  latitude: z.number().optional(),\n  longitude: z.number().optional(),\n  inspector_name: z.string().min(1, \"Nome do inspetor é obrigatório\"),\n  inspector_email: z.string().email(\"Email inválido\").optional(),\n  responsible_name: z.string().optional(),\n  responsible_email: z.string().email(\"Email inválido\").optional(),\n  status: z.enum(['pendente', 'em_andamento', 'concluida', 'cancelada']).default('pendente'),\n  priority: z.enum(['baixa', 'media', 'alta', 'critica']).default('media'),\n  scheduled_date: z.string().optional(),\n  completed_date: z.string().optional(),\n  action_plan: z.string().optional(),\n  action_plan_type: z.enum(['5w2h', 'simple']).default('5w2h'),\n  created_at: z.string(),\n  updated_at: z.string(),\n});\n\nexport type InspectionType = z.infer<typeof InspectionSchema>;\n\nexport const InspectionItemSchema = z.object({\n  id: z.number().optional(),\n  inspection_id: z.number(),\n  category: z.string().min(1, \"Categoria é obrigatória\"),\n  item_description: z.string().min(1, \"Descrição é obrigatória\"),\n  is_compliant: z.boolean().optional(),\n  observations: z.string().optional(),\n  photo_url: z.string().optional(),\n  compliance_status: z.string().optional(), // 'compliant' | 'non_compliant' | 'not_applicable' | 'unanswered'\n});\n\nexport type InspectionItemType = z.infer<typeof InspectionItemSchema>;\n\nexport const InspectionReportSchema = z.object({\n  id: z.number().optional(),\n  inspection_id: z.number(),\n  summary: z.string().optional(),\n  recommendations: z.string().optional(),\n  risk_level: z.enum(['baixo', 'medio', 'alto', 'critico']).optional(),\n  report_url: z.string().optional(),\n});\n\nexport type InspectionReportType = z.infer<typeof InspectionReportSchema>;\n\nexport const InspectionMediaSchema = z.object({\n  id: z.number().optional(),\n  inspection_id: z.number(),\n  inspection_item_id: z.number().optional(),\n  media_type: z.enum(['image', 'video', 'audio', 'document']),\n  file_name: z.string().min(1, \"Nome do arquivo é obrigatório\"),\n  file_url: z.string().min(1, \"URL do arquivo é obrigatória\"),\n  file_size: z.number().optional(),\n  mime_type: z.string().optional(),\n  description: z.string().optional(),\n});\n\nexport type InspectionMediaType = z.infer<typeof InspectionMediaSchema>;\n\nexport const AIAnalysisRequestSchema = z.object({\n  inspection_id: z.number(),\n  media_urls: z.array(z.string()),\n  inspection_context: z.string(),\n  non_compliant_items: z.array(z.string()),\n});\n\nexport type AIAnalysisRequest = z.infer<typeof AIAnalysisRequestSchema>;\n"},{"name":"shared/user-types.ts","content":"// Interface base definida localmente para remover dependência externa @getmocha/users-service\nexport interface MochaUser {\n  id: string;\n  email: string;\n  [key: string]: any;\n}\n\nexport interface UserProfile {\n  id: string;\n  email: string;\n  name: string;\n  role: string; // 'system_admin', 'org_admin', 'manager', 'inspector', 'client'\n  organization_id?: number;\n  phone?: string;\n  avatar_url?: string;\n  is_active: boolean;\n  last_login_at?: string;\n  created_at: string;\n  updated_at: string;\n  // New fields for multi-tenant support\n  can_manage_users: boolean;\n  can_create_organizations: boolean;\n  managed_organization_id?: number;\n  invitation_token?: string;\n  invited_by?: string;\n  invitation_expires_at?: string;\n  // Email/password authentication fields\n  password_hash?: string;\n  email_verified_at?: string;\n  profile_completed: boolean;\n}\n\nexport interface Organization {\n  id: number;\n  name: string;\n  type: string; // 'master', 'company', 'consultancy', 'client'\n  description?: string;\n  logo_url?: string;\n  contact_email?: string;\n  contact_phone?: string;\n  address?: string;\n  website?: string;\n  is_active: boolean;\n  created_at: string;\n  updated_at: string;\n  // New fields for hierarchy\n  parent_organization_id?: number;\n  organization_level: string; // 'master', 'company', 'subsidiary'\n  subscription_status: string; // 'active', 'suspended', 'trial'\n  subscription_plan: string; // 'basic', 'pro', 'enterprise'\n  max_users: number;\n  max_subsidiaries: number;\n  // Runtime fields\n  user_count?: number;\n  subsidiary_count?: number;\n  parent_organization?: Organization;\n  subsidiaries?: Organization[];\n  parent_organization_name?: string;\n}\n\nexport interface UserInvitation {\n  id: number;\n  email: string;\n  organization_id: number;\n  role: string;\n  invited_by: string;\n  invitation_token: string;\n  expires_at: string;\n  accepted_at?: string;\n  created_at: string;\n  updated_at: string;\n  // Runtime fields\n  organization_name?: string;\n  inviter_name?: string;\n}\n\nexport interface OrganizationPermission {\n  id: number;\n  user_id: string;\n  organization_id: number;\n  permission_type: string; // 'view', 'edit', 'admin', 'owner'\n  granted_by: string;\n  granted_at: string;\n  is_active: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface ActivityLogEntry {\n  id: number;\n  user_id: string;\n  organization_id?: number;\n  action_type: string;\n  action_description: string;\n  target_type?: string;\n  target_id?: string;\n  metadata?: string;\n  ip_address?: string;\n  user_agent?: string;\n  created_at: string;\n}\n\nexport interface ExtendedMochaUser extends MochaUser {\n  profile?: UserProfile;\n  organizations?: Organization[];\n  managed_organization?: Organization;\n  permissions?: OrganizationPermission[];\n}\n\n// Role definitions for the multi-tenant system\nexport const USER_ROLES = {\n  SYSTEM_ADMIN: 'system_admin', // You - the creator/master admin\n  SYS_ADMIN: 'sys_admin',       // Alternative system admin role\n  ORG_ADMIN: 'org_admin',       // Company admin who bought the system\n  MANAGER: 'manager',           // Organization manager\n  INSPECTOR: 'inspector',       // Technical inspector/safety professional  \n  CLIENT: 'client'              // Client/viewer role\n} as const;\n\nexport type UserRole = typeof USER_ROLES[keyof typeof USER_ROLES];\n\nexport const ORGANIZATION_LEVELS = {\n  MASTER: 'master',       // Your master organization\n  COMPANY: 'company',     // Companies that buy the system\n  SUBSIDIARY: 'subsidiary' // Sub-organizations within companies\n} as const;\n\nexport const SUBSCRIPTION_STATUS = {\n  ACTIVE: 'active',\n  SUSPENDED: 'suspended',\n  TRIAL: 'trial',\n  EXPIRED: 'expired'\n} as const;\n\nexport const SUBSCRIPTION_PLANS = {\n  BASIC: 'basic',\n  PRO: 'pro',\n  ENTERPRISE: 'enterprise'\n} as const;\n"},{"name":"system-admin-protection.ts","content":"// Proteção automática para o usuário system_admin principal\r\n// Este módulo garante que eng.tiagosm@gmail.com e usuários demo sempre tenham acesso como system_admin\r\n\r\nexport async function ensureSystemAdminAccess(env: Env): Promise<void> {\r\n  if (!env?.DB) {\r\n    console.log('[SYSTEM-ADMIN-PROTECTION] Database não disponível');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const SYSTEM_ADMIN_EMAIL = 'eng.tiagosm@gmail.com';\r\n    const SYSTEM_ADMIN_ID = '84edf8d1-77d9-4c73-935e-d76745bc3707'; // ID real do usuário\r\n    const DEMO_USER_EMAIL = 'demo@compia.test';\r\n    const DEMO_USER_ID = 'demo-user-84edf8d1-77d9-4c73-935e-d76745bc3707'; // ID do usuário demo\r\n\r\n    // Verificar se o usuário principal existe\r\n    let systemAdmin = await env.DB.prepare(\r\n      \"SELECT * FROM users WHERE email = ? OR id = ?\"\r\n    ).bind(SYSTEM_ADMIN_EMAIL, SYSTEM_ADMIN_ID).first() as any;\r\n\r\n    // Se não existe, criar o usuário principal\r\n    if (!systemAdmin) {\r\n      console.log('[SYSTEM-ADMIN-PROTECTION] Criando usuário system_admin');\r\n\r\n      await env.DB.prepare(`\r\n        INSERT INTO users (\r\n          id, email, name, role, can_manage_users, can_create_organizations,\r\n          is_active, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(\r\n        SYSTEM_ADMIN_ID,\r\n        SYSTEM_ADMIN_EMAIL,\r\n        'Tiago Mocha System Admin',\r\n        'sys_admin',\r\n        1,\r\n        1,\r\n        1\r\n      ).run();\r\n\r\n      systemAdmin = await env.DB.prepare(\r\n        \"SELECT * FROM users WHERE id = ?\"\r\n      ).bind(SYSTEM_ADMIN_ID).first() as any;\r\n    }\r\n\r\n    // Verificar se o usuário demo existe\r\n    let demoUser = await env.DB.prepare(\r\n      \"SELECT * FROM users WHERE email = ? OR id = ?\"\r\n    ).bind(DEMO_USER_EMAIL, DEMO_USER_ID).first() as any;\r\n\r\n    // Se não existe, criar o usuário demo\r\n    if (!demoUser) {\r\n      console.log('[SYSTEM-ADMIN-PROTECTION] Criando usuário demo');\r\n\r\n      await env.DB.prepare(`\r\n        INSERT INTO users (\r\n          id, email, name, role, can_manage_users, can_create_organizations,\r\n          is_active, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(\r\n        DEMO_USER_ID,\r\n        DEMO_USER_EMAIL,\r\n        'Usuário Demo',\r\n        'sys_admin',\r\n        1,\r\n        1,\r\n        1\r\n      ).run();\r\n\r\n      demoUser = await env.DB.prepare(\r\n        \"SELECT * FROM users WHERE id = ?\"\r\n      ).bind(DEMO_USER_ID).first() as any;\r\n    }\r\n\r\n    // Garantir que o usuário principal tem role sys_admin\r\n    if (systemAdmin.role !== 'sys_admin') {\r\n      console.log('[SYSTEM-ADMIN-PROTECTION] Corrigindo role para sys_admin');\r\n\r\n      await env.DB.prepare(`\r\n        UPDATE users \r\n        SET role = 'sys_admin', can_manage_users = 1, can_create_organizations = 1,\r\n            is_active = 1, updated_at = NOW()\r\n        WHERE id = ?\r\n      `).bind(SYSTEM_ADMIN_ID).run();\r\n    }\r\n\r\n    // Garantir que o usuário demo tem role sys_admin\r\n    if (demoUser && demoUser.role !== 'sys_admin') {\r\n      console.log('[SYSTEM-ADMIN-PROTECTION] Corrigindo role do usuário demo para sys_admin');\r\n\r\n      await env.DB.prepare(`\r\n        UPDATE users \r\n        SET role = 'sys_admin', can_manage_users = 1, can_create_organizations = 1,\r\n            is_active = 1, updated_at = NOW()\r\n        WHERE id = ?\r\n      `).bind(DEMO_USER_ID).run();\r\n    }\r\n\r\n    // Verificar se existe uma organização master\r\n    let masterOrg = await env.DB.prepare(`\r\n      SELECT * FROM organizations \r\n      WHERE name = 'COMPIA Master' OR name LIKE '%Master%' OR name LIKE '%COMPIA%'\r\n      ORDER BY id ASC\r\n      LIMIT 1\r\n    `).first() as any;\r\n\r\n    // Se não existe, criar organização master\r\n    if (!masterOrg) {\r\n      console.log('[SYSTEM-ADMIN-PROTECTION] Criando organização master');\r\n\r\n      const result = await env.DB.prepare(`\r\n        INSERT INTO organizations (\r\n          name, type, is_active, created_at, updated_at,\r\n          organization_level, max_users, max_subsidiaries\r\n        ) VALUES (?, ?, ?, NOW(), NOW(), ?, ?, ?)\r\n      `).bind(\r\n        'COMPIA Master',\r\n        'company',\r\n        1, // SQLite uses 1 for true\r\n        'company',\r\n        10000,\r\n        1000\r\n      ).run();\r\n\r\n      masterOrg = {\r\n        id: result.meta.last_row_id,\r\n        name: 'COMPIA Master'\r\n      };\r\n    }\r\n\r\n    // Garantir que o system_admin está associado à organização master\r\n    if (systemAdmin.organization_id !== masterOrg.id) {\r\n      console.log('[SYSTEM-ADMIN-PROTECTION] Associando system_admin à organização master');\r\n\r\n      await env.DB.prepare(`\r\n        UPDATE users \r\n        SET organization_id = ?, managed_organization_id = ?, updated_at = NOW()\r\n        WHERE id = ?\r\n      `).bind(masterOrg.id, masterOrg.id, SYSTEM_ADMIN_ID).run();\r\n    }\r\n\r\n    // Verificar se existe entrada em user_organizations\r\n    const userOrgAssociation = await env.DB.prepare(`\r\n      SELECT * FROM user_organizations \r\n      WHERE user_id = ? AND organization_id = ?\r\n    `).bind(SYSTEM_ADMIN_ID, masterOrg.id).first();\r\n\r\n    if (!userOrgAssociation) {\r\n      console.log('[SYSTEM-ADMIN-PROTECTION] Criando associação user_organizations');\r\n\r\n      await env.DB.prepare(`\r\n        INSERT INTO user_organizations (\r\n          user_id, organization_id, role, is_active, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(SYSTEM_ADMIN_ID, masterOrg.id, 'owner', 1).run();\r\n    }\r\n\r\n    // Verificar se está protegido na tabela protected_users\r\n    // Primeiro garantir que o usuário realmente existe na tabela users\r\n    const userExists = await env.DB.prepare(`\r\n      SELECT id FROM users WHERE id = ?\r\n    `).bind(SYSTEM_ADMIN_ID).first();\r\n\r\n    if (userExists) {\r\n      const protection = await env.DB.prepare(`\r\n        SELECT * FROM protected_users WHERE user_id = ?\r\n      `).bind(SYSTEM_ADMIN_ID).first();\r\n\r\n      if (!protection) {\r\n        console.log('[SYSTEM-ADMIN-PROTECTION] Adicionando proteção de usuário');\r\n\r\n        try {\r\n          await env.DB.prepare(`\r\n            INSERT INTO protected_users (\r\n              user_id, protection_level, protected_roles, protected_permissions,\r\n              reason, created_by, created_at, updated_at\r\n            ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n          `).bind(\r\n            SYSTEM_ADMIN_ID,\r\n            'high',\r\n            JSON.stringify(['sys_admin', 'system_admin']),\r\n            JSON.stringify(['all']),\r\n            'Usuário administrador principal do sistema COMPIA',\r\n            'system'\r\n          ).run();\r\n        } catch (error) {\r\n          console.error('[SYSTEM-ADMIN-PROTECTION] Erro ao inserir proteção:', error);\r\n          // Não falhar completamente se não conseguir proteger\r\n        }\r\n      }\r\n    } else {\r\n      console.log('[SYSTEM-ADMIN-PROTECTION] Usuário não existe, pulando proteção');\r\n    }\r\n\r\n    console.log('[SYSTEM-ADMIN-PROTECTION] Proteções aplicadas com sucesso');\r\n\r\n  } catch (error) {\r\n    console.error('[SYSTEM-ADMIN-PROTECTION] Erro ao garantir acesso do system_admin:', error);\r\n  }\r\n}\r\n\r\n// Função para executar auto-correção via endpoint\r\nexport async function autoFixSystemAdmin(env: Env): Promise<{ success: boolean, message: string }> {\r\n  try {\r\n    await ensureSystemAdminAccess(env);\r\n    return {\r\n      success: true,\r\n      message: 'Sistema auto-corrigido com sucesso. Acesso de system_admin restaurado.'\r\n    };\r\n  } catch (error) {\r\n    console.error('[AUTO-FIX] Erro na auto-correção:', error);\r\n    return {\r\n      success: false,\r\n      message: `Erro na auto-correção: ${error instanceof Error ? error.message : 'Erro desconhecido'}`\r\n    };\r\n  }\r\n}\r\n\r\n"},{"name":"system-admin-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware as authMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\nimport { requireProtectedSysAdmin } from \"./rbac-middleware.ts\";\r\nimport { autoFixSystemAdmin } from \"./system-admin-protection.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n};\r\n\r\nconst systemAdminRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Endpoint para garantir que o usuário eng.tiagosm@gmail.com seja sempre system_admin\r\nsystemAdminRoutes.post(\"/ensure-protected-sysadmin\", authMiddleware, requireProtectedSysAdmin(), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Garantir que o usuário protegido sempre tenha o role correto\r\n    await env.DB.prepare(`\r\n      UPDATE users \r\n      SET role = ?, can_manage_users = ?, can_create_organizations = ?, updated_at = NOW()\r\n      WHERE email = ? OR id = ?\r\n    `).bind(\r\n      USER_ROLES.SYSTEM_ADMIN,\r\n      true,\r\n      true,\r\n      'eng.tiagosm@gmail.com',\r\n      '84edf8d1-77d9-4c73-935e-d76745bc3707'\r\n    ).run();\r\n\r\n    // Log da operação de segurança\r\n    await env.DB.prepare(`\r\n      INSERT INTO activity_log (user_id, action_type, action_description, target_type, target_id, created_at)\r\n      VALUES (?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n      user.id,\r\n      'system_security_check',\r\n      'Verificação e garantia de privilégios de administrador principal do sistema',\r\n      'user',\r\n      '84edf8d1-77d9-4c73-935e-d76745bc3707'\r\n    ).run();\r\n\r\n    return c.json({\r\n      success: true,\r\n      message: \"Privilégios de administrador principal verificados e garantidos\",\r\n      protected_user: true\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error ensuring protected sysadmin:', error);\r\n    return c.json({ error: \"Erro ao verificar privilégios do sistema\" }, 500);\r\n  }\r\n});\r\n\r\n// Endpoint para listar tentativas de modificação bloqueadas (auditoria)\r\nsystemAdminRoutes.get(\"/security-log\", authMiddleware, requireProtectedSysAdmin(), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Buscar logs relacionados a tentativas de modificação de segurança\r\n    const securityLogs = await env.DB.prepare(`\r\n      SELECT * FROM activity_log \r\n      WHERE action_type IN ('system_security_check', 'user_update_blocked', 'user_delete_blocked')\r\n         OR action_description LIKE '%eng.tiagosm@gmail.com%'\r\n         OR target_id = '84edf8d1-77d9-4c73-935e-d76745bc3707'\r\n      ORDER BY created_at DESC\r\n      LIMIT 100\r\n    `).all();\r\n\r\n    return c.json({\r\n      security_logs: securityLogs.results || [],\r\n      protected_user_id: '84edf8d1-77d9-4c73-935e-d76745bc3707',\r\n      protected_user_email: 'eng.tiagosm@gmail.com'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching security logs:', error);\r\n    return c.json({ error: \"Erro ao buscar logs de segurança\" }, 500);\r\n  }\r\n});\r\n\r\n// Endpoint para verificar status de proteção do sistema\r\nsystemAdminRoutes.get(\"/protection-status\", authMiddleware, requireProtectedSysAdmin(), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Verificar o status atual do usuário protegido\r\n    const protectedUser = await env.DB.prepare(`\r\n      SELECT id, email, name, role, can_manage_users, can_create_organizations, is_active, created_at, updated_at\r\n      FROM users \r\n      WHERE email = ? OR id = ?\r\n    `).bind('eng.tiagosm@gmail.com', '84edf8d1-77d9-4c73-935e-d76745bc3707').first() as any;\r\n\r\n    if (!protectedUser) {\r\n      return c.json({\r\n        error: \"ALERTA DE SEGURANÇA: Usuário protegido não encontrado no sistema!\",\r\n        critical: true\r\n      }, 404);\r\n    }\r\n\r\n    // Verificar se as configurações estão corretas\r\n    const isCorrectlyConfigured =\r\n      protectedUser.role === USER_ROLES.SYSTEM_ADMIN &&\r\n      protectedUser.can_manage_users === true &&\r\n      protectedUser.can_create_organizations === true &&\r\n      protectedUser.is_active === true;\r\n\r\n    // Contar outros system_admins\r\n    const otherSystemAdmins = await env.DB.prepare(`\r\n      SELECT COUNT(*) as count \r\n      FROM users \r\n      WHERE role = ? AND email != ? AND id != ?\r\n    `).bind(USER_ROLES.SYSTEM_ADMIN, 'eng.tiagosm@gmail.com', '84edf8d1-77d9-4c73-935e-d76745bc3707').first() as any;\r\n\r\n    return c.json({\r\n      protection_status: {\r\n        protected_user_found: true,\r\n        correctly_configured: isCorrectlyConfigured,\r\n        current_role: protectedUser.role,\r\n        can_manage_users: protectedUser.can_manage_users,\r\n        can_create_organizations: protectedUser.can_create_organizations,\r\n        is_active: protectedUser.is_active,\r\n        last_updated: protectedUser.updated_at\r\n      },\r\n      system_status: {\r\n        other_system_admins_count: otherSystemAdmins?.count || 0,\r\n        protection_middleware_active: true,\r\n        protected_email: 'eng.tiagosm@gmail.com',\r\n        protected_id: '84edf8d1-77d9-4c73-935e-d76745bc3707'\r\n      },\r\n      security_measures: {\r\n        role_modification_blocked: true,\r\n        user_deletion_blocked: true,\r\n        email_change_blocked: true,\r\n        permission_change_blocked: true,\r\n        api_access_restricted: true\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error checking protection status:', error);\r\n    return c.json({ error: \"Erro ao verificar status de proteção\" }, 500);\r\n  }\r\n});\r\n\r\n// Endpoint para forçar correção do usuário protegido (em caso de inconsistência)\r\nsystemAdminRoutes.post(\"/force-fix-protected-user\", authMiddleware, requireProtectedSysAdmin(), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Primeiro, verificar se o usuário existe\r\n    let protectedUser = await env.DB.prepare(`\r\n      SELECT * FROM users WHERE email = ? OR id = ?\r\n    `).bind('eng.tiagosm@gmail.com', '84edf8d1-77d9-4c73-935e-d76745bc3707').first() as any;\r\n\r\n    if (!protectedUser) {\r\n      // Criar o usuário se não existir (situação de emergência)\r\n      await env.DB.prepare(`\r\n        INSERT INTO users (\r\n          id, email, name, role, can_manage_users, can_create_organizations,\r\n          is_active, created_at, updated_at\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n      `).bind(\r\n        '84edf8d1-77d9-4c73-935e-d76745bc3707',\r\n        'eng.tiagosm@gmail.com',\r\n        'Tiago dos Santos Martins - SysAdmin',\r\n        USER_ROLES.SYSTEM_ADMIN,\r\n        true,\r\n        true,\r\n        true\r\n      ).run();\r\n\r\n      await env.DB.prepare(`\r\n        INSERT INTO activity_log (user_id, action_type, action_description, target_type, target_id, created_at)\r\n        VALUES (?, ?, ?, ?, ?, NOW())\r\n      `).bind(\r\n        user.id,\r\n        'emergency_user_creation',\r\n        'EMERGÊNCIA: Usuário protegido foi recriado no sistema',\r\n        'user',\r\n        '84edf8d1-77d9-4c73-935e-d76745bc3707'\r\n      ).run();\r\n\r\n      return c.json({\r\n        success: true,\r\n        message: \"EMERGÊNCIA: Usuário protegido foi recriado com privilégios completos\",\r\n        action: \"created\"\r\n      });\r\n    } else {\r\n      // Corrigir configurações se necessário\r\n      await env.DB.prepare(`\r\n        UPDATE users \r\n        SET role = ?, can_manage_users = ?, can_create_organizations = ?, is_active = ?, updated_at = NOW()\r\n        WHERE email = ? OR id = ?\r\n      `).bind(\r\n        USER_ROLES.SYSTEM_ADMIN,\r\n        true,\r\n        true,\r\n        true,\r\n        'eng.tiagosm@gmail.com',\r\n        '84edf8d1-77d9-4c73-935e-d76745bc3707'\r\n      ).run();\r\n\r\n      await env.DB.prepare(`\r\n        INSERT INTO activity_log (user_id, action_type, action_description, target_type, target_id, created_at)\r\n        VALUES (?, ?, ?, ?, ?, NOW())\r\n      `).bind(\r\n        user.id,\r\n        'forced_user_fix',\r\n        'Correção forçada de privilégios do usuário protegido do sistema',\r\n        'user',\r\n        '84edf8d1-77d9-4c73-935e-d76745bc3707'\r\n      ).run();\r\n\r\n      return c.json({\r\n        success: true,\r\n        message: \"Usuário protegido foi corrigido com privilégios completos\",\r\n        action: \"updated\"\r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Error fixing protected user:', error);\r\n    return c.json({ error: \"Erro ao corrigir usuário protegido\" }, 500);\r\n  }\r\n});\r\n\r\n// Endpoint específico para garantir proteção do sysadmin principal\r\nsystemAdminRoutes.post('/ensure-protected-sysadmin', authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get('user');\r\n\r\n  if (!user) {\r\n    return c.json({ error: 'User not found' }, 401);\r\n  }\r\n\r\n  // Verificar se é o usuário correto ou um admin\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  const isAuthorized = user.email === 'eng.tiagosm@gmail.com' ||\r\n    userProfile?.role === 'sys_admin' ||\r\n    userProfile?.role === 'system_admin';\r\n\r\n  if (!isAuthorized) {\r\n    return c.json({ error: 'Acesso negado. Endpoint restrito ao administrador principal.' }, 403);\r\n  }\r\n\r\n  try {\r\n    console.log('[ENSURE-PROTECTED-SYSADMIN] Garantindo proteção do system_admin...');\r\n\r\n    const result = await autoFixSystemAdmin(env);\r\n\r\n    return c.json({\r\n      success: result.success,\r\n      message: result.message,\r\n      user_id: 'eng.tiagosm',\r\n      user_email: 'eng.tiagosm@gmail.com',\r\n      timestamp: new Date().toISOString()\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('[ENSURE-PROTECTED-SYSADMIN] Erro:', error);\r\n    return c.json({\r\n      error: 'Erro ao garantir proteção do system_admin',\r\n      details: error instanceof Error ? error.message : 'Erro desconhecido'\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Endpoint para métricas SAAS (Dashboard do System Admin)\r\nsystemAdminRoutes.get(\"/saas-metrics\", authMiddleware, requireProtectedSysAdmin(), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // 1. Métricas de Organizações\r\n    // Master = Consultorias (Sem pai)\r\n    // Subsidiary = Unidades/Clientes (Com pai)\r\n    const orgsMetrics = await env.DB.prepare(`\r\n      SELECT \r\n        COUNT(*) as total,\r\n        SUM(CASE WHEN is_active = true THEN 1 ELSE 0 END) as active,\r\n        SUM(CASE WHEN parent_organization_id IS NULL THEN 1 ELSE 0 END) as master_orgs,\r\n        SUM(CASE WHEN parent_organization_id IS NOT NULL THEN 1 ELSE 0 END) as subsidiaries\r\n      FROM organizations\r\n    `).first();\r\n\r\n    // 2. Métricas de Usuários\r\n    const usersMetrics = await env.DB.prepare(`\r\n      SELECT \r\n        COUNT(*) as total,\r\n      SUM(CASE WHEN is_active = true THEN 1 ELSE 0 END) as active,\r\n      SUM(CASE WHEN created_at > (NOW() - INTERVAL '30 days') THEN 1 ELSE 0 END) as new_last_30_days\r\n      FROM users\r\n      `).first();\r\n\r\n    // 3. Métricas de Inspeções (Volume Global)\r\n    const inspectionsMetrics = await env.DB.prepare(`\r\n    SELECT\r\n    COUNT(*) as total,\r\n      SUM(CASE WHEN status = 'concluida' THEN 1 ELSE 0 END) as completed,\r\n      SUM(CASE WHEN created_at > (NOW() - INTERVAL '30 days') THEN 1 ELSE 0 END) as created_last_30_days\r\n      FROM inspections\r\n  `).first();\r\n\r\n    // 4. Consumo Global de IA (Tokens e Requisições)\r\n    let aiMetrics = { total_tokens: 0, total_cost_est: 0, total_requests: 0 };\r\n\r\n    try {\r\n      // 4a. Buscar tokens da logs (Granular)\r\n      const aiUsage = await env.DB.prepare(`\r\n          SELECT SUM(total_tokens) as total_tokens \r\n          FROM ai_usage_logs\r\n      `).first();\r\n\r\n      // 4b. Buscar requests da tabela organizations (Contador simples, fallback)\r\n      const orgsRequests = await env.DB.prepare(`\r\n          SELECT SUM(ai_usage_count) as total_requests \r\n          FROM organizations\r\n      `).first();\r\n\r\n      aiMetrics.total_requests = orgsRequests?.total_requests || 0;\r\n\r\n      if (aiUsage && aiUsage.total_tokens) {\r\n        aiMetrics.total_tokens = aiUsage.total_tokens;\r\n        // Estimativa simples: $0.03 por 1k tokens (média GPT-4)\r\n        aiMetrics.total_cost_est = (aiMetrics.total_tokens / 1000) * 0.03;\r\n      }\r\n    } catch (e) {\r\n      console.warn(\"[SAAS-METRICS] Erro ao buscar métricas de IA:\", e);\r\n    }\r\n\r\n    return c.json({\r\n      organizations: {\r\n        total: Number(orgsMetrics?.total) || 0,\r\n        active: Number(orgsMetrics?.active) || 0,\r\n        master: Number(orgsMetrics?.master_orgs) || 0, // Consultorias\r\n        subsidiary_ratio: Number(orgsMetrics?.master_orgs) > 0 ? (Number(orgsMetrics?.subsidiaries) / Number(orgsMetrics?.master_orgs)).toFixed(1) : \"0\"\r\n      },\r\n      users: {\r\n        total: usersMetrics?.total || 0,\r\n        active: usersMetrics?.active || 0,\r\n        growth_30d: usersMetrics?.new_last_30_days || 0\r\n      },\r\n      inspections: {\r\n        total: inspectionsMetrics?.total || 0,\r\n        completed: inspectionsMetrics?.completed || 0,\r\n        volume_30d: inspectionsMetrics?.created_last_30_days || 0\r\n      },\r\n      ai_usage: {\r\n        total_tokens: aiMetrics.total_tokens,\r\n        total_requests: aiMetrics.total_requests, // Enviando também requests\r\n        estimated_cost_usd: aiMetrics.total_cost_est\r\n      },\r\n      generated_at: new Date().toISOString()\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching SaaS metrics:', error);\r\n    return c.json({ error: \"Erro ao buscar métricas SaaS\" }, 500);\r\n  }\r\n});\r\n\r\nexport default systemAdminRoutes;\r\n\r\n"},{"name":"tenant-auth-middleware.ts","content":"import { Context, Next } from \"hono\";\r\nimport { getCookie } from \"hono/cookie\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n    JWT_SECRET?: string;\r\n};\r\n\r\n/**\r\n * TENANT AUTH MIDDLEWARE - Blindagem de Segurança Multi-Tenant\r\n * \r\n * Este middleware é responsável por:\r\n * 1. Autenticar o usuário (via cookie de sessão ou JWT)\r\n * 2. Injetar o contexto de tenant seguro na requisição\r\n * 3. CRÍTICO: O organizationId SEMPRE vem do banco/token, NUNCA do body/params\r\n * \r\n * @security Este middleware implementa o princípio de \"Least Privilege\"\r\n */\r\n\r\n// Tipo do contexto de tenant seguro\r\nexport interface TenantContext {\r\n    organizationId: number | null;\r\n    allowedOrganizationIds: number[]; // Inclui subsidiárias para Org Admin\r\n    isSystemAdmin: boolean;\r\n    userId: string;\r\n    userRole: string;\r\n}\r\n\r\n// Tipo do usuário autenticado\r\nexport interface AuthenticatedUser {\r\n    id: string;\r\n    email: string;\r\n    name: string;\r\n    role: string;\r\n    organization_id: number | null;\r\n    managed_organization_id: number | null;\r\n    can_manage_users: boolean;\r\n    can_create_organizations: boolean;\r\n    is_active: boolean;\r\n}\r\n\r\n/**\r\n * Middleware principal de autenticação e contexto de tenant\r\n * \r\n * @security \r\n * - Valida sessão via cookie ou JWT (quando configurado)\r\n * - Busca dados do usuário no banco para garantir integridade\r\n * - Injeta contexto de tenant seguro que NÃO pode ser manipulado pelo cliente\r\n */\r\nexport async function tenantAuthMiddleware(c: Context, next: Next) {\r\n    const env = c.env as Env;\r\n\r\n    // 0. Verificar se já existe usuário no contexto (injetado por Supabase Auth ou outro middleware)\r\n    const existingUser = c.get('user');\r\n    let userId: string | null = null;\r\n\r\n    if (existingUser && existingUser.id) {\r\n        userId = existingUser.id;\r\n    }\r\n\r\n    // 1. Extrair token de autenticação (Cookie) se não encontrado no contexto\r\n    if (!userId) {\r\n        if (!userId) {\r\n            const sessionToken = getCookie(c, \"mocha-session-token\") || getCookie(c, \"mocha_session_token\");\r\n\r\n            // 2. Validar sessão via cookie\r\n            // SEGURANÇA: dev-session só é aceito em ambiente de desenvolvimento\r\n            // Fail Secure: Assume produção (false) a menos que explicitamente 'development'\r\n            const isDevelopment = Deno.env.get('ENVIRONMENT') === 'development';\r\n\r\n            if (sessionToken && sessionToken.startsWith(\"dev-session-\") && isDevelopment) {\r\n                userId = sessionToken.replace(\"dev-session-\", \"\");\r\n                console.log('[TENANT-AUTH] DEV SESSION aceito (ambiente desenvolvimento)');\r\n            } else if (sessionToken && sessionToken.startsWith(\"dev-session-\") && !isDevelopment) {\r\n                console.warn('[TENANT-AUTH] BLOQUEADO: Tentativa de usar dev-session em produção');\r\n                // Não aceitar dev-session em produção - segurança crítica\r\n            }\r\n        }\r\n    }\r\n\r\n    // 3. Validar JWT (Authorization Header)\r\n    const authHeader = c.req.header(\"Authorization\");\r\n    if (!userId && authHeader?.startsWith(\"Bearer \")) {\r\n        try {\r\n            const token = authHeader.substring(7);\r\n            // Decode JWT payload (Part 2) without verification for now (relying on Supabase Auth context or simple extraction)\r\n            // Note: In production with --no-verify-jwt, this trusts the client. Ensure JWT_SECRET verification is added if public access.\r\n            const parts = token.split('.');\r\n            if (parts.length === 3) {\r\n                const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));\r\n                if (payload.sub) {\r\n                    userId = payload.sub;\r\n                    console.log('[TENANT-AUTH] JWT Token aceito, user:', userId);\r\n                }\r\n            }\r\n        } catch (e) {\r\n            console.error('[TENANT-AUTH] Erro ao decodificar JWT:', e);\r\n        }\r\n    }\r\n\r\n    // 4. Se não autenticado, permitir passar mas sem contexto\r\n    // Rotas protegidas devem verificar c.get('user') e c.get('tenantContext')\r\n    if (!userId) {\r\n        await next();\r\n        return;\r\n    }\r\n\r\n    // 5. CRÍTICO: Buscar dados do usuário SEMPRE do banco de dados\r\n    // Isso garante que o organizationId é confiável e não pode ser manipulado\r\n    let user: any = null;\r\n    let dbError: any = null;\r\n    let middlewareLog: string[] = [];\r\n\r\n    try {\r\n        if (!env.DB) {\r\n            console.error(\"[TENANT-AUTH] Database não disponível\");\r\n            await next();\r\n            return;\r\n        }\r\n\r\n        // Simplificado para SELECT * para evitar erros de coluna e facilitar debug\r\n        user = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(userId).first();\r\n\r\n        if (!user) {\r\n            console.warn(`[TENANT-AUTH] Usuário não encontrado no banco: ${userId}`);\r\n            dbError = \"User not found in public.users\";\r\n        } else {\r\n            // VERIFICAÇÃO CRÍTICA\r\n            // Converter tipos se necessário (ex: organization_id de string para number se o driver retornar string)\r\n            if (user.organization_id) user.organization_id = Number(user.organization_id);\r\n            if (user.managed_organization_id) user.managed_organization_id = Number(user.managed_organization_id);\r\n        }\r\n\r\n    } catch (error: any) {\r\n        console.error(\"[TENANT-AUTH] Erro ao buscar usuário:\", error);\r\n        dbError = error.message || String(error);\r\n    }\r\n\r\n    if (!user) {\r\n        console.warn(`[TENANT-AUTH] Falha crítica de autenticação - DB Error: ${dbError}`);\r\n\r\n        // Tentar auto-cadastro se falhou por não encontrar\r\n        if (existingUser && (existingUser as any).email && (!dbError || dbError.includes('not found'))) {\r\n            // Lógica de auto-cadastro simplificada para não poluir\r\n            // (Mantendo apenas o warning aqui, pois o bloco original era muito grande e complexo para substituir inline perfeitamente sem riscos)\r\n            // Se o usuário não existir, vamos retornar erro no contexto\r\n        }\r\n\r\n        c.set(\"tenantAuthError\", dbError || \"User search failed\");\r\n        // Permitir continuar, mas inspection-routes vai bloquear\r\n        await next();\r\n        return;\r\n    }\r\n\r\n    // Update last_active_at if null or > 5 min old\r\n    try {\r\n        const now = new Date();\r\n        const lastActive = user.last_active_at ? new Date(user.last_active_at) : null;\r\n\r\n        if (!lastActive || (now.getTime() - lastActive.getTime() > 5 * 60 * 1000)) {\r\n            // Async update\r\n            env.DB.prepare(\"UPDATE users SET last_active_at = NOW() WHERE id = ?\").bind(userId).run().catch((e: any) => console.error(\"Error updating last_active_at:\", e));\r\n        }\r\n    } catch (e) {\r\n        console.error(\"Error checking activity:\", e);\r\n    }\r\n\r\n    // 6. Construir contexto de tenant seguro\r\n    const isSystemAdmin = user.role === USER_ROLES.SYSTEM_ADMIN ||\r\n        user.role === 'sys_admin' ||\r\n        user.role === 'admin';\r\n\r\n    let allowedOrganizationIds: number[] = [];\r\n\r\n    if (isSystemAdmin) {\r\n        allowedOrganizationIds = []; // System Admin has access to everything effectively (handled by logic elsewhere usually)\r\n    } else {\r\n        // Start with organization_id (Legacy/Primary)\r\n        const orgsSet = new Set<number>();\r\n        if (user.organization_id) orgsSet.add(Number(user.organization_id));\r\n\r\n        // Fetch explicit assignments from user_organizations\r\n        try {\r\n            middlewareLog.push(`Fetching assignments for ${userId}`);\r\n            console.log(`[TENANT-AUTH] Fetching assignments for user ${userId}`);\r\n            const assigned = await env.DB.prepare(\"SELECT organization_id FROM user_organizations WHERE user_id = ?\").bind(userId).all();\r\n\r\n            if (assigned.results) {\r\n                middlewareLog.push(`Found ${assigned.results.length} assignments`);\r\n                assigned.results.forEach((r: any) => {\r\n                    orgsSet.add(Number(r.organization_id));\r\n                });\r\n            } else {\r\n                middlewareLog.push(`No result object from DB`);\r\n            }\r\n        } catch (e: any) {\r\n            console.error(\"[TENANT-AUTH] Error fetching user_organizations:\", e);\r\n            middlewareLog.push(`Error fetching assignments: ${e.message}`);\r\n        }\r\n\r\n        // If Org Admin, include managed org and subsidiaries\r\n        if (user.role === USER_ROLES.ORG_ADMIN && user.managed_organization_id) {\r\n            console.log(`[TENANT-AUTH] User is Org Admin for: ${user.managed_organization_id}`);\r\n            orgsSet.add(Number(user.managed_organization_id));\r\n            try {\r\n                const subsidiaries = await env.DB.prepare(\"SELECT id FROM organizations WHERE parent_organization_id = ?\").bind(user.managed_organization_id).all();\r\n                if (subsidiaries.results) {\r\n                    subsidiaries.results.forEach((s: any) => orgsSet.add(Number(s.id)));\r\n                }\r\n            } catch (e) {\r\n                console.error(\"[TENANT-AUTH] Error fetching subsidiaries:\", e);\r\n            }\r\n        }\r\n\r\n        allowedOrganizationIds = Array.from(orgsSet);\r\n    }\r\n\r\n    // Read X-Organization-Id header for context switching (Multi-Tenant)\r\n    let activeOrganizationId = user.organization_id;\r\n    const requestedOrgId = c.req.header('X-Organization-Id');\r\n\r\n    if (requestedOrgId) {\r\n        const requestedOrgIdNum = Number(requestedOrgId);\r\n        // System admin can access any org, others must have explicit access\r\n        if (isSystemAdmin || allowedOrganizationIds.includes(requestedOrgIdNum)) {\r\n            activeOrganizationId = requestedOrgIdNum;\r\n            console.log(`[TENANT-AUTH] Context switched to org: ${requestedOrgIdNum}`);\r\n        } else {\r\n            console.warn(`[TENANT-AUTH] Denied context switch to org ${requestedOrgIdNum} - not in allowed list`);\r\n        }\r\n    }\r\n\r\n    const tenantContext: TenantContext = {\r\n        organizationId: activeOrganizationId,\r\n        allowedOrganizationIds,\r\n        isSystemAdmin,\r\n        userId: user.id,\r\n        userRole: user.role,\r\n        // @ts-ignore\r\n        _debugLog: middlewareLog\r\n    };\r\n\r\n    // PRESERVE GOOGLE/SUPABASE METADATA (Picture/Name)\r\n    if (existingUser && (existingUser as any).user_metadata) {\r\n        const metadata = (existingUser as any).user_metadata;\r\n        if (metadata.picture || metadata.avatar_url) {\r\n            (user as any).google_user_data = {\r\n                picture: metadata.picture || metadata.avatar_url,\r\n                name: metadata.full_name || metadata.name\r\n            };\r\n        }\r\n    }\r\n\r\n    // 7. Injetar no contexto da requisição\r\n    c.set(\"user\", user);\r\n    c.set(\"tenantContext\", tenantContext);\r\n\r\n    // RLS: Configurar variável de sessão no Postgres para as policies funcionarem\r\n    // Isso é essencial para que 'current_setting('app.current_user_id')' funcione\r\n    try {\r\n        if (env.DB) {\r\n            // Configurar user_id\r\n            await env.DB.prepare(\"SELECT set_config('app.current_user_id', ?, false)\").bind(userId).run();\r\n        }\r\n    } catch (e) {\r\n        console.error(\"[TENANT-AUTH] Erro ao configurar RLS session:\", e);\r\n    }\r\n\r\n    try {\r\n        await next();\r\n    } finally {\r\n        // RLS: Limpar variável de sessão para evitar vazamento em conexões reutilizadas\r\n        try {\r\n            if (env.DB) {\r\n                // Reset user_id\r\n                await env.DB.prepare(\"SELECT set_config('app.current_user_id', '', false)\").bind().run();\r\n            }\r\n        } catch (e) {\r\n            console.error(\"[TENANT-AUTH] Erro ao limpar RLS session:\", e);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * Middleware de proteção de rota - Requer autenticação\r\n * \r\n * @security Use este middleware em rotas que EXIGEM usuário autenticado\r\n */\r\nexport async function requireAuth(c: Context, next: Next) {\r\n    const user = c.get(\"user\");\r\n\r\n    if (!user) {\r\n        return c.json({\r\n            error: \"unauthorized\",\r\n            message: \"Autenticação necessária para acessar este recurso\"\r\n        }, 401);\r\n    }\r\n\r\n    await next();\r\n}\r\n\r\n/**\r\n * Middleware de verificação de roles permitidos\r\n * \r\n * @param allowedRoles - Lista de roles que podem acessar a rota\r\n * @security Implementa o princípio de \"Least Privilege\"\r\n */\r\nexport function requireRoles(...allowedRoles: string[]) {\r\n    return async (c: Context, next: Next) => {\r\n        const user = c.get(\"user\") as AuthenticatedUser | undefined;\r\n        const tenantContext = c.get(\"tenantContext\") as TenantContext | undefined;\r\n\r\n        if (!user || !tenantContext) {\r\n            return c.json({\r\n                error: \"unauthorized\",\r\n                message: \"Autenticação necessária\"\r\n            }, 401);\r\n        }\r\n\r\n        // System Admin sempre tem acesso\r\n        if (tenantContext.isSystemAdmin) {\r\n            await next();\r\n            return;\r\n        }\r\n\r\n        // Verificar se o role do usuário está na lista permitida\r\n        const userRole = user.role.toLowerCase();\r\n        const normalizedAllowedRoles = allowedRoles.map(r => r.toLowerCase());\r\n\r\n        if (!normalizedAllowedRoles.includes(userRole)) {\r\n            return c.json({\r\n                error: \"forbidden\",\r\n                message: \"Permissões insuficientes para acessar este recurso\",\r\n                required_roles: allowedRoles,\r\n                user_role: user.role\r\n            }, 403);\r\n        }\r\n\r\n        await next();\r\n    };\r\n}\r\n\r\n/**\r\n * Extrai o organizationId seguro do contexto de tenant\r\n * \r\n * @security NUNCA use organization_id do body/params para usuários não-admin\r\n * @returns O organizationId do contexto seguro ou null se não disponível\r\n */\r\nexport function getSecureOrganizationId(c: Context): number | null {\r\n    const tenantContext = c.get(\"tenantContext\") as TenantContext | undefined;\r\n    return tenantContext?.organizationId ?? null;\r\n}\r\n\r\n/**\r\n * Verifica se o usuário tem acesso a uma organização específica\r\n * \r\n * @security Use esta função antes de acessar dados de uma organização\r\n */\r\nexport function canAccessOrganization(c: Context, targetOrgId: number): boolean {\r\n    const tenantContext = c.get(\"tenantContext\") as TenantContext | undefined;\r\n\r\n    if (!tenantContext) return false;\r\n    if (tenantContext.isSystemAdmin) return true;\r\n\r\n    return tenantContext.allowedOrganizationIds.includes(targetOrgId);\r\n}\r\n\r\n/**\r\n * Helper para logging de segurança\r\n * \r\n * @security Use para registrar tentativas de acesso não autorizado\r\n */\r\nexport async function logSecurityEvent(\r\n    env: Env,\r\n    userId: string,\r\n    action: string,\r\n    details: Record<string, unknown>,\r\n    isBlocked: boolean = false\r\n): Promise<void> {\r\n    try {\r\n        await env.DB.prepare(`\r\n      INSERT INTO security_audit_log (\r\n        user_id, action_type, old_value, new_value,\r\n        blocked_reason, is_blocked, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n            userId,\r\n            action,\r\n            JSON.stringify(details),\r\n            null,\r\n            isBlocked ? `Tentativa bloqueada: ${action}` : null,\r\n            isBlocked ? 1 : 0\r\n        ).run();\r\n    } catch (error) {\r\n        console.error(\"[SECURITY-LOG] Erro ao registrar evento:\", error);\r\n    }\r\n}\r\n\r\n"},{"name":"test-checklist.ts","content":"\r\nimport { createClient } from \"https://esm.sh/@supabase/supabase-js@2\";\r\n\r\nconst supabaseUrl = Deno.env.get(\"SUPABASE_URL\") || \"\";\r\nconst supabaseKey = Deno.env.get(\"SUPABASE_SERVICE_ROLE_KEY\") || \"\";\r\n\r\nconsole.log(\"Testing AI Checklist Generation...\");\r\n\r\ntry {\r\n    const response = await fetch(\"https://vjlvvmriqerfmztwtewa.supabase.co/functions/v1/api/checklist-templates/generate-ai-simple\", {\r\n        method: \"POST\",\r\n        headers: {\r\n            \"Content-Type\": \"application/json\",\r\n            \"Authorization\": `Bearer ${supabaseKey}`\r\n        },\r\n        body: JSON.stringify({\r\n            industry: \"Construção\",\r\n            location_type: \"Canteiro\",\r\n            template_name: \"Teste AI\",\r\n            category: \"Segurança\",\r\n            num_questions: 5,\r\n            detail_level: \"basico\",\r\n            regulation: \"NR-18\"\r\n        })\r\n    });\r\n\r\n    const status = response.status;\r\n    const text = await response.text();\r\n\r\n    console.log(`Status: ${status}`);\r\n    console.log(`Response: ${text.substring(0, 500)}...`);\r\n\r\n} catch (error) {\r\n    console.error(\"Error:\", error);\r\n}\r\n"},{"name":"test-orgs.ts","content":"\r\nimport { Hono } from \"hono\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n};\r\n\r\nconst app = new Hono<{ Bindings: Env }>();\r\n\r\napp.get('/', (c) => c.json({ message: 'Test connection successful' }));\r\napp.get('/:id', (c) => c.json({ message: `Test ID: ${c.req.param('id')}` }));\r\n\r\n// Debug endpoint to check organization address data\r\napp.get('/debug/addresses', async (c) => {\r\n    try {\r\n        const result = await c.env.DB.prepare(`\r\n      SELECT id, name, nome_fantasia, address, contact_email \r\n      FROM organizations \r\n      LIMIT 10\r\n    `).all();\r\n\r\n        return c.json({\r\n            success: true,\r\n            organizations: result.results || [],\r\n            message: 'Debug: Check if address column has data'\r\n        });\r\n    } catch (error) {\r\n        return c.json({\r\n            success: false,\r\n            error: error instanceof Error ? error.message : String(error)\r\n        }, 500);\r\n    }\r\n});\r\n\r\nexport default app;\r\n"},{"name":"user-assignment-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\n\r\ntype Env = {\r\n    DB: any;\r\n    [key: string]: unknown;\r\n};\r\n\r\nconst userAssignmentRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Helper para verificar se usuário pode atribuir a uma organização\r\nasync function canAssignToOrganization(\r\n    db: any,\r\n    currentUser: any,\r\n    targetOrgId: number\r\n): Promise<boolean> {\r\n    const role = currentUser.role?.toLowerCase() || '';\r\n\r\n    // SysAdmin pode atribuir a qualquer organização\r\n    const sysAdminRoles = ['system_admin', 'sys_admin', 'admin'];\r\n    if (sysAdminRoles.includes(role)) {\r\n        return true;\r\n    }\r\n\r\n    // OrgAdmin pode atribuir à sua organização e subsidiárias\r\n    const orgAdminRoles = ['org_admin', 'admin_org', 'organization_admin'];\r\n    if (orgAdminRoles.includes(role)) {\r\n        const managedOrgId = currentUser.managed_organization_id || currentUser.organization_id;\r\n        if (!managedOrgId) return false;\r\n\r\n        // Verificar se é a própria organização ou subsidiária\r\n        if (targetOrgId === managedOrgId) return true;\r\n\r\n        const subsidiary = await db.prepare(`\r\n      SELECT id FROM organizations \r\n      WHERE id = ? AND parent_organization_id = ?\r\n    `).bind(targetOrgId, managedOrgId).first();\r\n\r\n        return !!subsidiary;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// GET /api/user-assignments/:userId - Listar atribuições de um usuário\r\nuserAssignmentRoutes.get(\"/:userId\", tenantAuthMiddleware, async (c) => {\r\n    const userId = c.req.param(\"userId\");\r\n    const currentUser = c.get(\"user\");\r\n    const db = c.env.DB;\r\n\r\n    if (!currentUser) {\r\n        return c.json({ error: \"Não autorizado\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const assignments = await db.prepare(`\r\n      SELECT \r\n        uo.id,\r\n        uo.user_id,\r\n        uo.organization_id,\r\n        uo.role,\r\n        uo.permissions,\r\n        uo.is_primary,\r\n        uo.is_active,\r\n        uo.assigned_by,\r\n        uo.assigned_at,\r\n        o.name as organization_name,\r\n        o.type as organization_type,\r\n        assigner.name as assigned_by_name\r\n      FROM user_organizations uo\r\n      JOIN organizations o ON uo.organization_id = o.id\r\n      LEFT JOIN users assigner ON uo.assigned_by = assigner.id\r\n      WHERE uo.user_id = ?\r\n      ORDER BY uo.is_primary DESC, o.name ASC\r\n    `).bind(userId).all();\r\n\r\n        return c.json({\r\n            assignments: assignments.results || [],\r\n            count: assignments.results?.length || 0\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Erro ao buscar atribuições:\", error);\r\n        return c.json({ error: \"Erro ao buscar atribuições\" }, 500);\r\n    }\r\n});\r\n\r\n// GET /api/user-assignments/organization/:orgId - Listar usuários de uma organização\r\nuserAssignmentRoutes.get(\"/organization/:orgId\", tenantAuthMiddleware, async (c) => {\r\n    const orgId = parseInt(c.req.param(\"orgId\"));\r\n    const currentUser = c.get(\"user\");\r\n    const db = c.env.DB;\r\n\r\n    if (!currentUser) {\r\n        return c.json({ error: \"Não autorizado\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const assignments = await db.prepare(`\r\n      SELECT \r\n        uo.id,\r\n        uo.user_id,\r\n        uo.organization_id,\r\n        uo.role,\r\n        uo.permissions,\r\n        uo.is_primary,\r\n        uo.is_active,\r\n        uo.assigned_at,\r\n        u.name as user_name,\r\n        u.email as user_email,\r\n        u.avatar_url,\r\n        u.approval_status\r\n      FROM user_organizations uo\r\n      JOIN users u ON uo.user_id = u.id\r\n      WHERE uo.organization_id = ? AND uo.is_active = 1\r\n      ORDER BY uo.role, u.name ASC\r\n    `).bind(orgId).all();\r\n\r\n        return c.json({\r\n            assignments: assignments.results || [],\r\n            count: assignments.results?.length || 0\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Erro ao buscar usuários da organização:\", error);\r\n        return c.json({ error: \"Erro ao buscar usuários da organização\" }, 500);\r\n    }\r\n});\r\n\r\n// GET /api/user-assignments/available/:orgId - Listar usuários disponíveis para atribuição\r\nuserAssignmentRoutes.get(\"/available/:orgId\", tenantAuthMiddleware, async (c) => {\r\n    const orgId = parseInt(c.req.param(\"orgId\"));\r\n    const currentUser = c.get(\"user\");\r\n    const db = c.env.DB;\r\n\r\n    if (!currentUser) {\r\n        return c.json({ error: \"Não autorizado\" }, 401);\r\n    }\r\n\r\n    // Verificar permissão\r\n    const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(currentUser.id).first();\r\n    const canAssign = await canAssignToOrganization(db, userProfile, orgId);\r\n\r\n    if (!canAssign) {\r\n        return c.json({ error: \"Sem permissão para atribuir usuários a esta organização\" }, 403);\r\n    }\r\n\r\n    try {\r\n        // Usuários aprovados que não estão atribuídos a esta organização\r\n        const availableUsers = await db.prepare(`\r\n      SELECT \r\n        u.id,\r\n        u.name,\r\n        u.email,\r\n        u.role as current_role,\r\n        u.avatar_url,\r\n        u.approval_status,\r\n        (SELECT COUNT(*) FROM user_organizations WHERE user_id = u.id AND is_active = 1) as org_count\r\n      FROM users u\r\n      WHERE u.approval_status = 'approved'\r\n        AND u.is_active = 1\r\n        AND u.role NOT IN ('sys_admin', 'system_admin')\r\n        AND u.id NOT IN (\r\n          SELECT user_id FROM user_organizations \r\n          WHERE organization_id = ? AND is_active = 1\r\n        )\r\n      ORDER BY u.name ASC\r\n    `).bind(orgId).all();\r\n\r\n        return c.json({\r\n            users: availableUsers.results || [],\r\n            count: availableUsers.results?.length || 0\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Erro ao buscar usuários disponíveis:\", error);\r\n        return c.json({ error: \"Erro ao buscar usuários disponíveis\" }, 500);\r\n    }\r\n});\r\n\r\n// POST /api/user-assignments - Criar nova atribuição\r\nuserAssignmentRoutes.post(\"/\", tenantAuthMiddleware, async (c) => {\r\n    const currentUser = c.get(\"user\");\r\n    const db = c.env.DB;\r\n\r\n    if (!currentUser) {\r\n        return c.json({ error: \"Não autorizado\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const { user_id, organization_id, role, permissions, is_primary } = body;\r\n\r\n        if (!user_id || !organization_id || !role) {\r\n            return c.json({ error: \"user_id, organization_id e role são obrigatórios\" }, 400);\r\n        }\r\n\r\n        // Verificar permissão\r\n        const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(currentUser.id).first();\r\n        const canAssign = await canAssignToOrganization(db, userProfile, organization_id);\r\n\r\n        if (!canAssign) {\r\n            return c.json({ error: \"Sem permissão para atribuir usuários a esta organização\" }, 403);\r\n        }\r\n\r\n        // Verificar se usuário existe e está aprovado\r\n        const targetUser = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user_id).first() as any;\r\n        if (!targetUser) {\r\n            return c.json({ error: \"Usuário não encontrado\" }, 404);\r\n        }\r\n        if (targetUser.approval_status !== 'approved') {\r\n            return c.json({ error: \"Usuário precisa estar aprovado para ser atribuído\" }, 400);\r\n        }\r\n\r\n        // Verificar se já existe atribuição\r\n        const existing = await db.prepare(`\r\n      SELECT id FROM user_organizations \r\n      WHERE user_id = ? AND organization_id = ?\r\n    `).bind(user_id, organization_id).first();\r\n\r\n        if (existing) {\r\n            return c.json({ error: \"Usuário já está atribuído a esta organização\" }, 409);\r\n        }\r\n\r\n        // Se is_primary, remover flag de outras atribuições\r\n        if (is_primary) {\r\n            await db.prepare(`\r\n        UPDATE user_organizations SET is_primary = false WHERE user_id = ?\r\n      `).bind(user_id).run();\r\n\r\n            // Atualizar organization_id na tabela users (retrocompatibilidade)\r\n            await db.prepare(`\r\n        UPDATE users SET organization_id = ?, role = ? WHERE id = ?\r\n      `).bind(organization_id, role, user_id).run();\r\n        }\r\n\r\n        // Criar atribuição\r\n        const assignmentId = crypto.randomUUID();\r\n        await db.prepare(`\r\n      INSERT INTO user_organizations (\r\n        id, user_id, organization_id, role, permissions, is_primary, is_active, assigned_by, assigned_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, true, ?, NOW())\r\n    `).bind(\r\n            assignmentId,\r\n            user_id,\r\n            organization_id,\r\n            role,\r\n            JSON.stringify(permissions || {}),\r\n            is_primary ? true : false,\r\n            currentUser.id\r\n        ).run();\r\n\r\n        return c.json({\r\n            success: true,\r\n            message: \"Usuário atribuído com sucesso\",\r\n            assignment_id: assignmentId\r\n        }, 201);\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao criar atribuição:\", error);\r\n        return c.json({ error: \"Erro ao criar atribuição\" }, 500);\r\n    }\r\n});\r\n\r\n// POST /api/user-assignments/bulk - Atribuição em massa\r\nuserAssignmentRoutes.post(\"/bulk\", tenantAuthMiddleware, async (c) => {\r\n    const currentUser = c.get(\"user\");\r\n    const db = c.env.DB;\r\n\r\n    if (!currentUser) {\r\n        return c.json({ error: \"Não autorizado\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const { user_id, organization_ids, role, permissions } = body;\r\n\r\n        if (!user_id || !organization_ids || !Array.isArray(organization_ids) || organization_ids.length === 0 || !role) {\r\n            return c.json({ error: \"user_id, organization_ids (array) e role são obrigatórios\" }, 400);\r\n        }\r\n\r\n        // Verificar se usuário target existe\r\n        const targetUser = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user_id).first() as any;\r\n        if (!targetUser) {\r\n            return c.json({ error: \"Usuário alvo não encontrado\" }, 404);\r\n        }\r\n\r\n        // Verificar permissões do usuário atual\r\n        const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(currentUser.id).first();\r\n\r\n        const results = {\r\n            success: [] as number[],\r\n            failed: [] as { id: number, reason: string }[]\r\n        };\r\n\r\n        for (const orgId of organization_ids) {\r\n            try {\r\n                // Check permissions per org\r\n                const canAssign = await canAssignToOrganization(db, userProfile, orgId);\r\n                if (!canAssign) {\r\n                    results.failed.push({ id: orgId, reason: \"Sem permissão\" });\r\n                    continue;\r\n                }\r\n\r\n                // Check existing assignment\r\n                const existing = await db.prepare(`\r\n                    SELECT id FROM user_organizations \r\n                    WHERE user_id = ? AND organization_id = ?\r\n                `).bind(user_id, orgId).first();\r\n\r\n                if (existing) {\r\n                    results.failed.push({ id: orgId, reason: \"Já atribuído\" });\r\n                    continue;\r\n                }\r\n\r\n                // Insert assignment\r\n                const assignmentId = crypto.randomUUID();\r\n                await db.prepare(`\r\n                    INSERT INTO user_organizations (\r\n                        id, user_id, organization_id, role, permissions, is_primary, is_active, assigned_by, assigned_at\r\n                    ) VALUES (?, ?, ?, ?, ?, false, true, ?, NOW())\r\n                `).bind(\r\n                    assignmentId,\r\n                    user_id,\r\n                    orgId,\r\n                    role,\r\n                    JSON.stringify(permissions || {}),\r\n                    currentUser.id\r\n                ).run();\r\n\r\n                results.success.push(orgId);\r\n\r\n            } catch (err: any) {\r\n                console.error(`Erro ao atribuir org ${orgId}:`, err);\r\n                results.failed.push({ id: orgId, reason: err.message || \"Erro interno\" });\r\n            }\r\n        }\r\n\r\n        return c.json({\r\n            message: \"Processamento concluído\",\r\n            results\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro na atribuição em massa:\", error);\r\n        return c.json({ error: \"Erro interno ao processar atribuições em massa\" }, 500);\r\n    }\r\n});\r\n\r\n// PUT /api/user-assignments/:assignmentId - Atualizar atribuição\r\nuserAssignmentRoutes.put(\"/:assignmentId\", tenantAuthMiddleware, async (c) => {\r\n    const assignmentId = c.req.param(\"assignmentId\");\r\n    const currentUser = c.get(\"user\");\r\n    const db = c.env.DB;\r\n\r\n    if (!currentUser) {\r\n        return c.json({ error: \"Não autorizado\" }, 401);\r\n    }\r\n\r\n    try {\r\n        const body = await c.req.json();\r\n        const { role, permissions, is_primary, is_active } = body;\r\n\r\n        // Buscar atribuição existente\r\n        const assignment = await db.prepare(`\r\n      SELECT * FROM user_organizations WHERE id = ?\r\n    `).bind(assignmentId).first() as any;\r\n\r\n        if (!assignment) {\r\n            return c.json({ error: \"Atribuição não encontrada\" }, 404);\r\n        }\r\n\r\n        // Verificar permissão\r\n        const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(currentUser.id).first();\r\n        const canAssign = await canAssignToOrganization(db, userProfile, assignment.organization_id);\r\n\r\n        if (!canAssign) {\r\n            return c.json({ error: \"Sem permissão para modificar esta atribuição\" }, 403);\r\n        }\r\n\r\n        // Se is_primary mudou para true, remover flag de outras atribuições\r\n        if (is_primary && !assignment.is_primary) {\r\n            await db.prepare(`\r\n        UPDATE user_organizations SET is_primary = 0 WHERE user_id = ?\r\n      `).bind(assignment.user_id).run();\r\n\r\n            // Atualizar organization_id na tabela users\r\n            await db.prepare(`\r\n        UPDATE users SET organization_id = ?, role = ? WHERE id = ?\r\n      `).bind(assignment.organization_id, role || assignment.role, assignment.user_id).run();\r\n        }\r\n\r\n        // Atualizar atribuição\r\n        await db.prepare(`\r\n      UPDATE user_organizations SET\r\n        role = COALESCE(?, role),\r\n        permissions = COALESCE(?, permissions),\r\n        is_primary = COALESCE(?, is_primary),\r\n        is_active = COALESCE(?, is_active),\r\n        updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(\r\n            role || null,\r\n            permissions ? JSON.stringify(permissions) : null,\r\n            is_primary !== undefined ? (is_primary ? 1 : 0) : null,\r\n            is_active !== undefined ? (is_active ? 1 : 0) : null,\r\n            assignmentId\r\n        ).run();\r\n\r\n        return c.json({ success: true, message: \"Atribuição atualizada com sucesso\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao atualizar atribuição:\", error);\r\n        return c.json({ error: \"Erro ao atualizar atribuição\" }, 500);\r\n    }\r\n});\r\n\r\n// DELETE /api/user-assignments/:assignmentId - Remover atribuição\r\nuserAssignmentRoutes.delete(\"/:assignmentId\", tenantAuthMiddleware, async (c) => {\r\n    const assignmentId = c.req.param(\"assignmentId\");\r\n    const currentUser = c.get(\"user\");\r\n    const db = c.env.DB;\r\n\r\n    if (!currentUser) {\r\n        return c.json({ error: \"Não autorizado\" }, 401);\r\n    }\r\n\r\n    try {\r\n        // Buscar atribuição existente\r\n        const assignment = await db.prepare(`\r\n      SELECT * FROM user_organizations WHERE id = ?\r\n    `).bind(assignmentId).first() as any;\r\n\r\n        if (!assignment) {\r\n            return c.json({ error: \"Atribuição não encontrada\" }, 404);\r\n        }\r\n\r\n        // Verificar permissão\r\n        const userProfile = await db.prepare(\"SELECT * FROM users WHERE id = ?\").bind(currentUser.id).first();\r\n        const canAssign = await canAssignToOrganization(db, userProfile, assignment.organization_id);\r\n\r\n        if (!canAssign) {\r\n            return c.json({ error: \"Sem permissão para remover esta atribuição\" }, 403);\r\n        }\r\n\r\n        // Soft delete - apenas desativar\r\n        await db.prepare(`\r\n      UPDATE user_organizations SET is_active = 0, updated_at = NOW() WHERE id = ?\r\n    `).bind(assignmentId).run();\r\n\r\n        // Se era a atribuição primária, limpar organization_id do user\r\n        if (assignment.is_primary) {\r\n            // Tentar encontrar outra atribuição ativa para ser primária\r\n            const nextPrimary = await db.prepare(`\r\n        SELECT * FROM user_organizations \r\n        WHERE user_id = ? AND is_active = 1 AND id != ?\r\n        ORDER BY created_at DESC\r\n        LIMIT 1\r\n      `).bind(assignment.user_id, assignmentId).first() as any;\r\n\r\n            if (nextPrimary) {\r\n                await db.prepare(`UPDATE user_organizations SET is_primary = 1 WHERE id = ?`).bind(nextPrimary.id).run();\r\n                await db.prepare(`UPDATE users SET organization_id = ?, role = ? WHERE id = ?`)\r\n                    .bind(nextPrimary.organization_id, nextPrimary.role, assignment.user_id).run();\r\n            } else {\r\n                await db.prepare(`UPDATE users SET organization_id = NULL WHERE id = ?`).bind(assignment.user_id).run();\r\n            }\r\n        }\r\n\r\n        return c.json({ success: true, message: \"Atribuição removida com sucesso\" });\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao remover atribuição:\", error);\r\n        return c.json({ error: \"Erro ao remover atribuição\" }, 500);\r\n    }\r\n});\r\n\r\nexport default userAssignmentRoutes;\r\n\r\n"},{"name":"user-types.ts","content":"// Interface base definida localmente para remover dependência externa @getmocha/users-service\r\nexport interface MochaUser {\r\n    id: string;\r\n    email: string;\r\n    [key: string]: any;\r\n}\r\n\r\nexport interface UserProfile {\r\n    id: string;\r\n    email: string;\r\n    name: string;\r\n    role: string; // 'system_admin', 'org_admin', 'manager', 'inspector', 'client'\r\n    organization_id?: number;\r\n    phone?: string;\r\n    avatar_url?: string;\r\n    is_active: boolean;\r\n    last_login_at?: string;\r\n    created_at: string;\r\n    updated_at: string;\r\n    // New fields for multi-tenant support\r\n    can_manage_users: boolean;\r\n    can_create_organizations: boolean;\r\n    managed_organization_id?: number;\r\n    invitation_token?: string;\r\n    invited_by?: string;\r\n    invitation_expires_at?: string;\r\n    // Email/password authentication fields\r\n    password_hash?: string;\r\n    email_verified_at?: string;\r\n    profile_completed: boolean;\r\n}\r\n\r\nexport interface Organization {\r\n    id: number;\r\n    name: string;\r\n    type: string; // 'master', 'company', 'consultancy', 'client'\r\n    description?: string;\r\n    logo_url?: string;\r\n    contact_email?: string;\r\n    contact_phone?: string;\r\n    address?: string;\r\n    website?: string;\r\n    is_active: boolean;\r\n    created_at: string;\r\n    updated_at: string;\r\n    // New fields for hierarchy\r\n    parent_organization_id?: number;\r\n    organization_level: string; // 'master', 'company', 'subsidiary'\r\n    subscription_status: string; // 'active', 'suspended', 'trial'\r\n    subscription_plan: string; // 'basic', 'pro', 'enterprise'\r\n    max_users: number;\r\n    max_subsidiaries: number;\r\n    // Runtime fields\r\n    user_count?: number;\r\n    subsidiary_count?: number;\r\n    parent_organization?: Organization;\r\n    subsidiaries?: Organization[];\r\n    parent_organization_name?: string;\r\n}\r\n\r\nexport interface UserInvitation {\r\n    id: number;\r\n    email: string;\r\n    organization_id: number;\r\n    role: string;\r\n    invited_by: string;\r\n    invitation_token: string;\r\n    expires_at: string;\r\n    accepted_at?: string;\r\n    created_at: string;\r\n    updated_at: string;\r\n    // Runtime fields\r\n    organization_name?: string;\r\n    inviter_name?: string;\r\n}\r\n\r\nexport interface OrganizationPermission {\r\n    id: number;\r\n    user_id: string;\r\n    organization_id: number;\r\n    permission_type: string; // 'view', 'edit', 'admin', 'owner'\r\n    granted_by: string;\r\n    granted_at: string;\r\n    is_active: boolean;\r\n    created_at: string;\r\n    updated_at: string;\r\n}\r\n\r\nexport interface ActivityLogEntry {\r\n    id: number;\r\n    user_id: string;\r\n    organization_id?: number;\r\n    action_type: string;\r\n    action_description: string;\r\n    target_type?: string;\r\n    target_id?: string;\r\n    metadata?: string;\r\n    ip_address?: string;\r\n    user_agent?: string;\r\n    created_at: string;\r\n}\r\n\r\nexport interface ExtendedMochaUser extends MochaUser {\r\n    profile?: UserProfile;\r\n    organizations?: Organization[];\r\n    managed_organization?: Organization;\r\n    permissions?: OrganizationPermission[];\r\n}\r\n\r\n// Role definitions for the multi-tenant system\r\nexport const USER_ROLES = {\r\n    SYSTEM_ADMIN: 'system_admin', // Primary system admin role\r\n    /**\r\n     * @deprecated Use SYSTEM_ADMIN instead. Kept for backward compatibility with legacy data.\r\n     */\r\n    SYS_ADMIN: 'sys_admin',\r\n    ORG_ADMIN: 'org_admin',       // Company admin who bought the system\r\n    MANAGER: 'manager',           // Organization manager\r\n    INSPECTOR: 'inspector',       // Technical inspector/safety professional  \r\n    CLIENT: 'client'              // Client/viewer role\r\n} as const;\r\n\r\nexport type UserRole = typeof USER_ROLES[keyof typeof USER_ROLES];\r\n\r\nexport const ORGANIZATION_LEVELS = {\r\n    MASTER: 'master',       // Your master organization\r\n    COMPANY: 'company',     // Companies that buy the system\r\n    SUBSIDIARY: 'subsidiary' // Sub-organizations within companies\r\n} as const;\r\n\r\nexport const SUBSCRIPTION_STATUS = {\r\n    ACTIVE: 'active',\r\n    SUSPENDED: 'suspended',\r\n    TRIAL: 'trial',\r\n    EXPIRED: 'expired'\r\n} as const;\r\n\r\nexport const SUBSCRIPTION_PLANS = {\r\n    BASIC: 'basic',\r\n    PRO: 'pro',\r\n    ENTERPRISE: 'enterprise'\r\n} as const;\r\n"},{"name":"users-routes.ts","content":"import { Hono } from \"hono\";\r\nimport { tenantAuthMiddleware as authMiddleware } from \"./tenant-auth-middleware.ts\";\r\nimport { USER_ROLES } from \"./user-types.ts\";\r\nimport { requireScopes, protectSysAdmin, SCOPES, createAuthErrorResponse, isSystemAdmin, canManageUsers } from \"./rbac-middleware.ts\";\r\n\r\ntype Env = {\r\n  DB: any;\r\n};\r\n\r\nconst usersRoutes = new Hono<{ Bindings: Env; Variables: { user: any } }>();\r\n\r\n// Get current user profile (alias for /profile)\r\nusersRoutes.get(\"/me\", authMiddleware, async (c) => {\r\n  return c.redirect(\"/api/users/profile\");\r\n});\r\n\r\n// Get user's accessible organizations for multi-tenant switcher\r\nusersRoutes.get(\"/me/organizations\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\") as any;\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Check user role first\r\n    const userProfile = await env.DB.prepare(\"SELECT role, organization_id FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    const isSysAdmin = userProfile?.role === USER_ROLES.SYSTEM_ADMIN || userProfile?.role === 'sys_admin';\r\n\r\n    let organizations = [];\r\n\r\n    if (isSysAdmin) {\r\n      // System Admin sees ALL active organizations\r\n      const allOrgs = await env.DB.prepare(`\r\n        SELECT \r\n          id,\r\n          name,\r\n          type,\r\n          organization_level,\r\n          logo_url\r\n        FROM organizations\r\n        WHERE is_active = true\r\n        ORDER BY name ASC\r\n      `).all();\r\n\r\n      organizations = (allOrgs.results || []).map((org: any) => ({\r\n        ...org,\r\n        role: 'sys_admin',\r\n        is_primary: org.id === userProfile.organization_id\r\n      }));\r\n\r\n    } else {\r\n      // Regular users: Fetch from user_organizations join\r\n      const orgsResult = await env.DB.prepare(`\r\n        SELECT \r\n          o.id,\r\n          o.name,\r\n          o.type,\r\n          o.organization_level,\r\n          uo.role,\r\n          uo.is_primary,\r\n          o.logo_url\r\n        FROM user_organizations uo\r\n        INNER JOIN organizations o ON uo.organization_id = o.id\r\n        WHERE uo.user_id = ? AND o.is_active = true\r\n        ORDER BY uo.is_primary DESC, o.name ASC\r\n      `).bind(user.id).all();\r\n\r\n      organizations = orgsResult.results || [];\r\n\r\n      // Fallback for legacy data (if no user_organizations entry)\r\n      if (organizations.length === 0 && userProfile?.organization_id) {\r\n        const legacyOrg = await env.DB.prepare(`\r\n            SELECT id, name, type, organization_level, logo_url \r\n            FROM organizations \r\n            WHERE id = ? AND is_active = true\r\n          `).bind(userProfile.organization_id).first() as any;\r\n\r\n        if (legacyOrg) {\r\n          organizations.push({\r\n            ...legacyOrg,\r\n            role: userProfile.role,\r\n            is_primary: true\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return c.json({ organizations });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching user organizations:', error);\r\n    return c.json({ error: \"Failed to fetch organizations\" }, 500);\r\n  }\r\n});\r\n\r\n// Get user profile\r\nusersRoutes.get(\"/profile\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\") as any;\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Get user profile from database\r\n    let userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    if (!userProfile) {\r\n      // Verifica se é o usuário sys_admin protegido\r\n      if (user.id === '01990d69-5246-733d-8605-1ed319a3f98d' || user.email === 'eng.tiagosm@gmail.com') {\r\n        // Recria como sys_admin com configurações completas\r\n        await env.DB.prepare(`\r\n          INSERT INTO users (\r\n            id, email, name, role, can_manage_users, can_create_organizations,\r\n            is_active, organization_id, managed_organization_id, created_at, updated_at\r\n          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n        `).bind(\r\n          user.id,\r\n          user.email,\r\n          user.google_user_data?.name || 'Tiago Mocha System Admin',\r\n          'sys_admin',\r\n          true,\r\n          true,\r\n          true,\r\n          1, // Organização principal\r\n          1\r\n        ).run();\r\n        console.log(`[USERS_PROFILE] Usuário sys_admin protegido ${user.email} recriado com papel sys_admin.`);\r\n\r\n        // Criar entradas de organização e permissões\r\n        await env.DB.prepare(`\r\n          INSERT OR IGNORE INTO user_organizations (user_id, organization_id, role, is_active, created_at, updated_at)\r\n          VALUES (?, ?, ?, ?, NOW(), NOW())\r\n        `).bind(user.id, 1, 'owner', true).run();\r\n\r\n        await env.DB.prepare(`\r\n          INSERT OR IGNORE INTO organization_permissions (user_id, organization_id, permission_type, granted_by, is_active, created_at, updated_at)\r\n          VALUES (?, ?, ?, ?, ?, NOW(), NOW())\r\n        `).bind(user.id, 1, 'owner', 'system', true).run();\r\n\r\n      } else {\r\n        // Para outros usuários, cria como inspector (padrão)\r\n        await env.DB.prepare(`\r\n          INSERT INTO users (\r\n            id, email, name, role, can_manage_users, can_create_organizations, \r\n            is_active, created_at, updated_at\r\n          ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())\r\n        `).bind(\r\n          user.id,\r\n          user.email,\r\n          user.google_user_data?.name || user.email,\r\n          USER_ROLES.INSPECTOR, // Default role\r\n          false,\r\n          false,\r\n          true\r\n        ).run();\r\n        console.log(`[USERS_PROFILE] Usuário ${user.email} criado com papel inspector.`);\r\n      }\r\n\r\n      userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n    }\r\n\r\n    // Get organization if exists\r\n    let organization = null;\r\n    if (userProfile.organization_id) {\r\n      organization = await env.DB.prepare(\"SELECT * FROM organizations WHERE id = ?\").bind(userProfile.organization_id).first();\r\n    }\r\n\r\n    // Get managed organization for org admins\r\n    let managedOrganization = null;\r\n    if (userProfile.managed_organization_id) {\r\n      managedOrganization = await env.DB.prepare(\"SELECT * FROM organizations WHERE id = ?\").bind(userProfile.managed_organization_id).first();\r\n    }\r\n\r\n    return c.json({\r\n      profile: userProfile,\r\n      organization: organization,\r\n      managed_organization: managedOrganization\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching user profile:', error);\r\n    return c.json({ error: \"Failed to fetch user profile\" }, 500);\r\n  }\r\n});\r\n\r\n// Update user profile\r\nusersRoutes.put(\"/:id\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const userId = c.req.param(\"id\");\r\n\r\n  if (!user || user.id !== userId) {\r\n    return c.json({ error: \"Unauthorized\" }, 401);\r\n  }\r\n\r\n  const body = await c.req.json();\r\n  const { name, phone, organization_id } = body;\r\n\r\n  try {\r\n    await env.DB.prepare(`\r\n      UPDATE users \r\n      SET name = ?, phone = ?, organization_id = ?, updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(name, phone || null, organization_id || null, userId).run();\r\n\r\n    return c.json({ message: \"Profile updated successfully\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating user profile:', error);\r\n    return c.json({ error: \"Failed to update profile\" }, 500);\r\n  }\r\n});\r\n\r\n// Promote user to admin (for first-time setup)\r\nusersRoutes.post(\"/promote-to-admin\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    // Check if there are any system admins already\r\n    const existingAdmins = await env.DB.prepare(\"SELECT COUNT(*) as count FROM users WHERE role = ?\").bind(USER_ROLES.SYSTEM_ADMIN).first() as any;\r\n\r\n    if (existingAdmins.count > 0) {\r\n      return c.json({ error: \"System admin already exists. Cannot promote another user.\" }, 400);\r\n    }\r\n\r\n    // Promote user to system admin\r\n    await env.DB.prepare(`\r\n      UPDATE users \r\n      SET role = ?, can_manage_users = ?, can_create_organizations = ?, updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(USER_ROLES.SYSTEM_ADMIN, true, true, user.id).run();\r\n\r\n    // Log activity\r\n    await env.DB.prepare(`\r\n      INSERT INTO activity_log (user_id, action_type, action_description, target_type, target_id, created_at)\r\n      VALUES (?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n      user.id,\r\n      'user_promoted',\r\n      'Promoted to system administrator',\r\n      'user',\r\n      user.id\r\n    ).run();\r\n\r\n    return c.json({ message: \"Successfully promoted to system administrator.\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error promoting user:', error);\r\n    return c.json({ error: \"Failed to promote user.\" }, 500);\r\n  }\r\n});\r\n\r\n// Get simple user list for dropdowns (id, name, photo)\r\n// Accessible by authenticated users to see colleagues in their organization\r\nusersRoutes.get(\"/simple-list\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  try {\r\n    const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n    // Determine filter based on role\r\n    let query = \"SELECT id, name, email, role, avatar_url FROM users\";\r\n    const params: any[] = [];\r\n    const whereConditions: string[] = [];\r\n\r\n    if (isSystemAdmin(userProfile?.role)) {\r\n      const orgId = c.req.query('organization_id');\r\n      if (orgId) {\r\n        whereConditions.push(\"organization_id = ?\");\r\n        params.push(orgId);\r\n      }\r\n    } else if (userProfile?.role === USER_ROLES.ORG_ADMIN) {\r\n      if (userProfile.managed_organization_id) {\r\n        whereConditions.push(`(\r\n               organization_id IN (\r\n                 SELECT id FROM organizations \r\n                 WHERE id = ? OR parent_organization_id = ?\r\n               ) OR organization_id IS NULL\r\n             )`);\r\n        params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n      }\r\n    } else {\r\n      // Regular user: can only see users in their own organization\r\n      if (userProfile?.organization_id) {\r\n        whereConditions.push(\"organization_id = ?\");\r\n        params.push(userProfile.organization_id);\r\n      } else {\r\n        // If no org, return just themselves\r\n        whereConditions.push(\"id = ?\");\r\n        params.push(user.id);\r\n      }\r\n    }\r\n\r\n    if (whereConditions.length > 0) {\r\n      query += \" WHERE \" + whereConditions.join(\" AND \");\r\n    }\r\n\r\n    query += \" ORDER BY name ASC\";\r\n\r\n    const users = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    // Map to simple structure\r\n    const simpleUsers = (users.results || []).map((u: any) => {\r\n      return {\r\n        id: u.id,\r\n        name: u.name,\r\n        email: u.email,\r\n        avatar_url: u.avatar_url,\r\n        role: u.role\r\n      };\r\n    });\r\n\r\n\r\n\r\n    return c.json({ users: simpleUsers });\r\n\r\n  } catch (error: any) {\r\n    console.error('Error fetching user list:', error);\r\n    return c.json({\r\n      error: \"Failed to fetch users\",\r\n      details: error.message,\r\n      stack: error.stack\r\n    }, 500);\r\n  }\r\n});\r\n\r\n// Get all users (requires users:read scope)\r\nusersRoutes.get(\"/\", authMiddleware, requireScopes(SCOPES.USERS_READ), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  console.log('[LIST_USERS] Usuario requisitando lista:', user.email, 'ID:', user.id);\r\n\r\n  // Buscar perfil do usuário\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  console.log('[LIST_USERS] Perfil do usuario:', userProfile?.role || 'NAO_ENCONTRADO');\r\n\r\n  if (!userProfile || !canManageUsers(userProfile.role)) {\r\n    console.log('[LIST_USERS] Permissoes insuficientes. Role:', userProfile?.role);\r\n    return c.json(createAuthErrorResponse('forbidden', 'Permissões insuficientes para listar usuários', [SCOPES.USERS_READ]), 403);\r\n  }\r\n\r\n  try {\r\n    let query = `\r\n      SELECT u.*, o.name as organization_name,\r\n             mo.name as managed_organization_name\r\n      FROM users u\r\n      LEFT JOIN organizations o ON u.organization_id = o.id\r\n      LEFT JOIN organizations mo ON u.managed_organization_id = mo.id\r\n    `;\r\n\r\n    const params: any[] = [];\r\n    const whereConditions: string[] = [];\r\n\r\n    if (isSystemAdmin(userProfile.role)) {\r\n      console.log('[LIST_USERS] SYSTEM_ADMIN - vendo todos os usuarios');\r\n      // System admin vê todos os usuários sem filtros\r\n      // No filters applied\r\n    } else if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      console.log('[LIST_USERS] ORG_ADMIN - organizacao gerenciada:', userProfile.managed_organization_id);\r\n      // Org admin vê usuários da sua organização, subsidiárias e usuários não atribuídos\r\n      if (userProfile.managed_organization_id) {\r\n        whereConditions.push(`(\r\n          u.organization_id IN (\r\n            SELECT id FROM organizations \r\n            WHERE id = ? OR parent_organization_id = ?\r\n          ) OR u.organization_id IS NULL\r\n        )`);\r\n        params.push(userProfile.managed_organization_id, userProfile.managed_organization_id);\r\n      }\r\n    } else {\r\n      // Other roles see only users from their organization\r\n      if (userProfile.organization_id) {\r\n        whereConditions.push(\"u.organization_id = ?\");\r\n        params.push(userProfile.organization_id);\r\n      }\r\n    }\r\n\r\n    if (whereConditions.length > 0) {\r\n      query += \" WHERE \" + whereConditions.join(\" AND \");\r\n    }\r\n\r\n    query += \" ORDER BY u.created_at DESC\";\r\n\r\n    console.log('[LIST_USERS] Query final:', query);\r\n    console.log('[LIST_USERS] Parametros:', params);\r\n\r\n    const users = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    console.log('[LIST_USERS] Usuarios encontrados:', users.results?.length || 0);\r\n\r\n    // Debug: log first few users\r\n    if (users.results && users.results.length > 0) {\r\n      console.log('[LIST_USERS] Primeiros usuarios:', users.results.slice(0, 3).map((u: any) => ({\r\n        email: u.email,\r\n        name: u.name,\r\n        role: u.role,\r\n        organization_id: u.organization_id,\r\n        organization_name: u.organization_name\r\n      })));\r\n    }\r\n\r\n    return c.json({ users: users.results });\r\n\r\n  } catch (error) {\r\n    console.error('[LIST_USERS] Error fetching users:', error);\r\n    return c.json({ error: \"Failed to fetch users.\" }, 500);\r\n  }\r\n});\r\n\r\n// Get user statistics (for admins)\r\nusersRoutes.get(\"/stats\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  // Buscar perfil do usuário\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile || !canManageUsers(userProfile.role)) {\r\n    return c.json(createAuthErrorResponse('forbidden', 'Permissões insuficientes para ver convites', [SCOPES.USERS_INVITATIONS_READ]), 403);\r\n  }\r\n\r\n  try {\r\n    let whereClause = \"\";\r\n    let params: any[] = [];\r\n\r\n    if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Org admin can only see stats for their organization and subsidiaries\r\n      whereClause = `\r\n        WHERE organization_id IN (\r\n          SELECT id FROM organizations \r\n          WHERE id = ? OR parent_organization_id = ?\r\n        )\r\n      `;\r\n      params = [userProfile.managed_organization_id, userProfile.managed_organization_id];\r\n    }\r\n\r\n    // Get total users count\r\n    const totalUsers = await env.DB.prepare(`\r\n      SELECT COUNT(*) as count FROM users ${whereClause}\r\n    `).bind(...params).first() as any;\r\n\r\n    // Get active users count\r\n    const activeUsers = await env.DB.prepare(`\r\n      SELECT COUNT(*) as count FROM users \r\n      ${whereClause}${whereClause ? ' AND' : 'WHERE'} is_active = true\r\n    `).bind(...params).first() as any;\r\n\r\n    // Get users by role\r\n    const usersByRole = await env.DB.prepare(`\r\n      SELECT \r\n        role,\r\n        COUNT(*) as count\r\n      FROM users \r\n      ${whereClause}\r\n      GROUP BY role\r\n      ORDER BY count DESC\r\n    `).bind(...params).all();\r\n\r\n    // Get recent user registrations (last 30 days)\r\n    const recentRegistrations = await env.DB.prepare(`\r\n      SELECT COUNT(*) as count FROM users \r\n      ${whereClause}${whereClause ? ' AND' : 'WHERE'} created_at >= datetime('now', '-30 days')\r\n    `).bind(...params).first() as any;\r\n\r\n    // Get users with organizations\r\n    const usersWithOrganizations = await env.DB.prepare(`\r\n      SELECT COUNT(*) as count FROM users \r\n      ${whereClause}${whereClause ? ' AND' : 'WHERE'} organization_id IS NOT NULL\r\n    `).bind(...params).first() as any;\r\n\r\n    return c.json({\r\n      total_users: totalUsers?.count || 0,\r\n      active_users: activeUsers?.count || 0,\r\n      users_by_role: usersByRole.results || [],\r\n      recent_registrations: recentRegistrations?.count || 0,\r\n      users_with_organizations: usersWithOrganizations?.count || 0\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching user statistics:', error);\r\n    return c.json({ error: \"Failed to fetch user statistics.\" }, 500);\r\n  }\r\n});\r\n\r\n// Update user by admin (requires users:write scope and protection for sysadmin)\r\nusersRoutes.put(\"/admin/:id\", authMiddleware, requireScopes(SCOPES.USERS_WRITE), protectSysAdmin(), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const targetUserId = c.req.param(\"id\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  // Buscar perfil do usuário\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile || !canManageUsers(userProfile.role)) {\r\n    return c.json(createAuthErrorResponse('forbidden', 'Permissões insuficientes para editar usuários', [SCOPES.USERS_WRITE]), 403);\r\n  }\r\n\r\n  const body = await c.req.json();\r\n  const { name, role, is_active, organization_id } = body;\r\n\r\n  try {\r\n    // Get target user\r\n    const targetUser = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(targetUserId).first() as any;\r\n\r\n    if (!targetUser) {\r\n      return c.json({ error: \"Target user not found.\" }, 404);\r\n    }\r\n\r\n    // PROTEÇÃO ABSOLUTA: usuário sysadmin eng.tiagosm@gmail.com é INTOCÁVEL\r\n    if (targetUser.email === 'eng.tiagosm@gmail.com' || targetUser.id === '84edf8d1-77d9-4c73-935e-d76745bc3707') {\r\n      return c.json(createAuthErrorResponse('forbidden', 'SISTEMA PROTEGIDO: Este usuário principal não pode ser modificado por questões de segurança', []), 403);\r\n    }\r\n\r\n    // Check if org admin has permission to manage this user\r\n    if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      const canManage = targetUser.organization_id === userProfile.managed_organization_id ||\r\n        (await env.DB.prepare(`\r\n                         SELECT id FROM organizations \r\n                         WHERE id = ? AND parent_organization_id = ?\r\n                       `).bind(targetUser.organization_id, userProfile.managed_organization_id).first());\r\n\r\n      if (!canManage) {\r\n        return c.json({ error: \"Cannot manage users outside your organization scope.\" }, 403);\r\n      }\r\n\r\n      // Org admin cannot assign admin roles\r\n      if (role === USER_ROLES.ORG_ADMIN || role === USER_ROLES.SYSTEM_ADMIN) {\r\n        return c.json({ error: `Cannot assign role: ${role}.` }, 403);\r\n      }\r\n    }\r\n\r\n    // Update user\r\n    const updateFields = [];\r\n    const updateValues = [];\r\n\r\n    if (name !== undefined) {\r\n      updateFields.push(\"name = ?\");\r\n      updateValues.push(name);\r\n    }\r\n\r\n    if (role !== undefined) {\r\n      updateFields.push(\"role = ?\");\r\n      updateValues.push(role);\r\n\r\n      // Update permissions based on role\r\n      if (role === USER_ROLES.ORG_ADMIN) {\r\n        updateFields.push(\"can_manage_users = ?\", \"can_create_organizations = ?\", \"managed_organization_id = ?\");\r\n        updateValues.push(true, true, organization_id || targetUser.organization_id);\r\n      } else {\r\n        updateFields.push(\"can_manage_users = ?\", \"can_create_organizations = ?\", \"managed_organization_id = ?\");\r\n        updateValues.push(false, false, null);\r\n      }\r\n    }\r\n\r\n    if (is_active !== undefined) {\r\n      updateFields.push(\"is_active = ?\");\r\n      updateValues.push(is_active);\r\n    }\r\n\r\n    if (organization_id !== undefined) {\r\n      updateFields.push(\"organization_id = ?\");\r\n      updateValues.push(organization_id);\r\n    }\r\n\r\n    if (updateFields.length > 0) {\r\n      updateFields.push(\"updated_at = NOW()\");\r\n\r\n      await env.DB.prepare(`\r\n        UPDATE users SET ${updateFields.join(\", \")} WHERE id = ?\r\n      `).bind(...updateValues, targetUserId).run();\r\n\r\n      // Log activity\r\n      await env.DB.prepare(`\r\n        INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n        VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n      `).bind(\r\n        user.id,\r\n        organization_id || targetUser.organization_id,\r\n        'user_updated',\r\n        `Updated user: ${targetUser.email}`,\r\n        'user',\r\n        targetUserId\r\n      ).run();\r\n    }\r\n\r\n    return c.json({ message: \"User updated successfully.\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating user:', error);\r\n    return c.json({ error: \"Failed to update user.\" }, 500);\r\n  }\r\n});\r\n\r\n// Get pending invitations (requires users:invitations:read scope)\r\nusersRoutes.get(\"/pending-invitations\", authMiddleware, requireScopes(SCOPES.USERS_INVITATIONS_READ), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile || (!isSystemAdmin(userProfile.role) && userProfile.role !== USER_ROLES.ORG_ADMIN)) {\r\n    return c.json({ error: \"Insufficient permissions.\" }, 403);\r\n  }\r\n\r\n  try {\r\n    let query = `\r\n      SELECT ui.*, o.name as organization_name, u.name as inviter_name\r\n      FROM user_invitations ui\r\n      LEFT JOIN organizations o ON ui.organization_id = o.id\r\n      LEFT JOIN users u ON ui.invited_by = u.id\r\n      WHERE ui.accepted_at IS NULL\r\n    `;\r\n\r\n    let params: any[] = [];\r\n\r\n    if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      // Org admin can only see invitations for their organization and subsidiaries\r\n      query += `\r\n        AND ui.organization_id IN (\r\n          SELECT id FROM organizations \r\n          WHERE id = ? OR parent_organization_id = ?\r\n        )\r\n      `;\r\n      params = [userProfile.managed_organization_id, userProfile.managed_organization_id];\r\n    }\r\n\r\n    query += \" ORDER BY ui.created_at DESC\";\r\n\r\n    const invitations = await env.DB.prepare(query).bind(...params).all();\r\n\r\n    return c.json({ invitations: invitations.results });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching pending invitations:', error);\r\n    return c.json({ error: \"Failed to fetch pending invitations.\" }, 500);\r\n  }\r\n});\r\n\r\n// Get invitation token (admin only)\r\nusersRoutes.get(\"/invitations/:id/token\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const invitationId = c.req.param(\"id\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile || (!isSystemAdmin(userProfile.role) && userProfile.role !== USER_ROLES.ORG_ADMIN)) {\r\n    return c.json({ error: \"Insufficient permissions.\" }, 403);\r\n  }\r\n\r\n  try {\r\n    const invitation = await env.DB.prepare(\"SELECT invitation_token FROM user_invitations WHERE id = ?\").bind(invitationId).first() as any;\r\n\r\n    if (!invitation) {\r\n      return c.json({ error: \"Invitation not found.\" }, 404);\r\n    }\r\n\r\n    return c.json({ token: invitation.invitation_token });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching invitation token:', error);\r\n    return c.json({ error: \"Failed to fetch invitation token.\" }, 500);\r\n  }\r\n});\r\n\r\n// Revoke invitation (admin only)\r\nusersRoutes.put(\"/invitations/:id/revoke\", authMiddleware, async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const invitationId = c.req.param(\"id\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile || (!isSystemAdmin(userProfile.role) && userProfile.role !== USER_ROLES.ORG_ADMIN)) {\r\n    return c.json({ error: \"Insufficient permissions.\" }, 403);\r\n  }\r\n\r\n  try {\r\n    // Get the invitation details\r\n    const invitation = await env.DB.prepare(\"SELECT * FROM user_invitations WHERE id = ?\").bind(invitationId).first() as any;\r\n\r\n    if (!invitation) {\r\n      return c.json({ error: \"Invitation not found.\" }, 404);\r\n    }\r\n\r\n    // Check if org admin has permission to revoke this invitation\r\n    if (userProfile.role === USER_ROLES.ORG_ADMIN) {\r\n      const canRevoke = invitation.organization_id === userProfile.managed_organization_id ||\r\n        (await env.DB.prepare(`\r\n                         SELECT id FROM organizations \r\n                         WHERE id = ? AND parent_organization_id = ?\r\n                       `).bind(invitation.organization_id, userProfile.managed_organization_id).first());\r\n\r\n      if (!canRevoke) {\r\n        return c.json({ error: \"Cannot revoke invitations outside your organization scope.\" }, 403);\r\n      }\r\n    }\r\n\r\n    // Mark invitation as accepted with a special revoked timestamp to prevent reuse\r\n    await env.DB.prepare(`\r\n      UPDATE user_invitations \r\n      SET accepted_at = NOW(), updated_at = NOW()\r\n      WHERE id = ?\r\n    `).bind(invitationId).run();\r\n\r\n    // Log activity\r\n    await env.DB.prepare(`\r\n      INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n      VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n      user.id,\r\n      invitation.organization_id,\r\n      'invitation_revoked',\r\n      `Revoked invitation for: ${invitation.email}`,\r\n      'invitation',\r\n      invitationId\r\n    ).run();\r\n\r\n    return c.json({ message: \"Invitation revoked successfully.\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error revoking invitation:', error);\r\n    return c.json({ error: \"Failed to revoke invitation.\" }, 500);\r\n  }\r\n});\r\n\r\n// Delete user (system admin only)\r\nusersRoutes.delete(\"/:id\", authMiddleware, requireScopes(SCOPES.USERS_DELETE), protectSysAdmin(), async (c) => {\r\n  const env = c.env;\r\n  const user = c.get(\"user\");\r\n  const targetUserId = c.req.param(\"id\");\r\n\r\n  if (!user) {\r\n    return c.json({ error: \"User not found\" }, 401);\r\n  }\r\n\r\n  // Buscar perfil do usuário\r\n  const userProfile = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(user.id).first() as any;\r\n\r\n  if (!userProfile || !isSystemAdmin(userProfile.role)) {\r\n    return c.json(createAuthErrorResponse('forbidden', 'Apenas administradores de sistema podem excluir usuários', [SCOPES.USERS_DELETE]), 403);\r\n  }\r\n\r\n  // Don't allow self-deletion\r\n  if (user.id === targetUserId) {\r\n    return c.json({ error: \"Cannot delete your own account.\" }, 400);\r\n  }\r\n\r\n  try {\r\n    const targetUser = await env.DB.prepare(\"SELECT * FROM users WHERE id = ?\").bind(targetUserId).first() as any;\r\n\r\n    if (!targetUser) {\r\n      return c.json({ error: \"User not found.\" }, 404);\r\n    }\r\n\r\n    // PROTEÇÃO ABSOLUTA: usuário sysadmin eng.tiagosm@gmail.com é INTOCÁVEL\r\n    if (targetUser.email === 'eng.tiagosm@gmail.com' || targetUser.id === '84edf8d1-77d9-4c73-935e-d76745bc3707') {\r\n      return c.json(createAuthErrorResponse('forbidden', 'SISTEMA PROTEGIDO: Este usuário principal não pode ser excluído por questões de segurança', []), 403);\r\n    }\r\n\r\n    // Delete user permanently\r\n    await env.DB.prepare(\"DELETE FROM users WHERE id = ?\").bind(targetUserId).run();\r\n\r\n    // Clean up related credentials (if cascade is not set)\r\n    await env.DB.prepare(\"DELETE FROM user_credentials WHERE user_id = ?\").bind(targetUserId).run();\r\n\r\n    // Log activity\r\n    await env.DB.prepare(`\r\n      INSERT INTO activity_log (user_id, organization_id, action_type, action_description, target_type, target_id, created_at)\r\n      VALUES (?, ?, ?, ?, ?, ?, NOW())\r\n    `).bind(\r\n      user.id,\r\n      targetUser.organization_id,\r\n      'user_deleted',\r\n      `Deleted user: ${targetUser.email}`,\r\n      'user',\r\n      targetUserId\r\n    ).run();\r\n\r\n    return c.json({ message: \"User deleted successfully.\" });\r\n\r\n  } catch (error) {\r\n    console.error('Error deactivating user:', error);\r\n    return c.json({ error: \"Failed to deactivate user.\" }, 500);\r\n  }\r\n});\r\n\r\nexport default usersRoutes;\r\n\r\n"},{"name":"verify-logs.ts","content":"\r\nconst supabaseUrl = Deno.env.get(\"SUPABASE_URL\") || \"\";\r\nconst supabaseKey = Deno.env.get(\"SUPABASE_SERVICE_ROLE_KEY\") || \"\";\r\n\r\nconsole.log(\"🔍 Verificando últimos logs de uso de IA...\");\r\n\r\nif (!supabaseUrl || !supabaseKey) {\r\n  console.error(\"❌ Variáveis de ambiente SUPABASE_URL ou SUPABASE_SERVICE_ROLE_KEY não definidas.\");\r\n  Deno.exit(1);\r\n}\r\n\r\ntry {\r\n  const response = await fetch(`${supabaseUrl}/rest/v1/ai_usage_log?select=*&order=created_at.desc&limit=5`, {\r\n    headers: {\r\n      \"apikey\": supabaseKey,\r\n      \"Authorization\": `Bearer ${supabaseKey}`,\r\n      \"Content-Type\": \"application/json\"\r\n    }\r\n  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`HTTP error! status: ${response.status} - ${await response.text()}`);\r\n  }\r\n\r\n  const data = await response.json();\r\n\r\n  if (data.length === 0) {\r\n    console.log(\"⚠️ Nenhum log encontrado.\");\r\n  } else {\r\n    console.log(`✅ ${data.length} logs encontrados. Últimos:`);\r\n    // @ts-ignore\r\n    data.forEach((log: any, index: number) => {\r\n      console.log(`\\n--- Log #${index + 1} ---`);\r\n      console.log(`📅 Data: ${new Date(log.created_at).toLocaleString('pt-BR')}`);\r\n      console.log(`🤖 Modelo: ${log.model_used || 'N/A'}`);\r\n      console.log(`💰 Tokens: ${log.tokens_count}`);\r\n      console.log(`🏢 Org ID: ${log.organization_id}`);\r\n    });\r\n  }\r\n\r\n} catch (error) {\r\n  console.error(\"❌ Erro ao buscar logs:\", error);\r\n}\r\n"}]